/Users/nataliechin/GitHub/audits-2023/hyper/contracts/Assembly.sol
   1 | *r  | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     |   
   8 |     |   Using yul to handle low-level coversions
   9 |     |   can easily be a foot shotgun.
  10 |     | 
  11 |     |   We like the gas reductions.
  12 |     | 
  13 |     |   -------------
  14 |     | 
  15 |     |   Primitive™
  16 |     | 
  17 |     |  */
  18 |     | 
  19 |     | error CastOverflow(uint);
  20 |     | error InvalidLiquidity();
  21 |     | 
  22 |     | uint constant SECONDS_PER_DAY = 86_400 seconds;
  23 | *r  | uint8 constant MIN_DECIMALS = 6;
  24 | *r  | uint8 constant MAX_DECIMALS = 18;
  25 | *r  | 
  26 | *r  | function isBetween(uint256 value, uint256 lower, uint256 upper) pure returns (bool valid) {
  27 | *r  |     return __between(int256(value), int256(lower), int256(upper));
  28 |     | }
  29 | *r  | 
  30 | *r  | function __between(int256 value, int256 lower, int256 upper) pure returns (bool valid) {
  31 |     |     assembly {
  32 |     |         // Is `val` btwn lo and hi, inclusive?
  33 | *r  |         function isValid(val, lo, hi) -> btwn {
  34 | *r  |             btwn := iszero(sgt(mul(sub(val, lo), sub(val, hi)), 0)) // iszero(x > amount ? 1 : 0) ? true : false, (n - a) * (n - b) <= 0, n = amount, a = lower, b = upper
  35 |     |         }
  36 |     | 
  37 | *r  |         valid := isValid(value, lower, upper)
  38 |     |     }
  39 |     | }
  40 |     | 
  41 |     | /** 
  42 |     | 
  43 |     |     @dev Reference:
  44 |     |     
  45 |     |     if (delta < 0) {
  46 |     |         output = input - uint128(-delta);
  47 |     |         if (output >= input) revert InvalidLiquidity();
  48 |     |     } else {
  49 |     |         output = input + uint128(delta);
  50 |     |         if (output < input) revert InvalidLiquidity();
  51 |     |     }
  52 | *r  | */
  53 | *   | function addSignedDelta(uint128 input, int128 delta) pure returns (uint128 output) {
  54 | *   |     bytes memory revertData = abi.encodeWithSelector(InvalidLiquidity.selector);
  55 | *r  |     assembly {
  56 | *r  |         switch slt(delta, 0) // delta < 0 ? 1 : 0
  57 |     |         // negative delta
  58 | *   |         case 1 {
  59 | *   |             output := sub(input, add(not(delta), 1))
  60 | *   |             switch slt(output, input) // output < input ? 1 : 0
  61 | *   |             case 0 {
  62 |     |                 // not less than
  63 |     |                 revert(add(32, revertData), mload(revertData)) // 0x1fff9681
  64 |     |             }
  65 |     |         }
  66 |     |         // position delta
  67 | *   |         case 0 {
  68 | *   |             output := add(input, delta)
  69 | *   |             switch slt(output, input) // (output < input ? 1 : 0) == 0 ? 1 : 0
  70 | *   |             case 1 {
  71 |     |                 // less than
  72 |     |                 revert(add(32, revertData), mload(revertData)) // 0x1fff9681
  73 |     |             }
  74 |     |         }
  75 |     |     }
  76 |     | }
  77 |     | 
  78 |     | function computeCheckpoint(uint256 present, uint256 delta) pure returns (uint256 checkpoint) {
  79 |     |     checkpoint = present;
  80 |     | 
  81 |     |     if (delta != 0) {
  82 |     |         // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.
  83 |     |         assembly {
  84 |     |             checkpoint := add(present, delta)
  85 |     |         }
  86 |     |     }
  87 |     | }
  88 | *   | 
  89 |     | function computeCheckpointDistance(uint256 present, uint256 past) pure returns (uint256 distance) {
  90 |     |     // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.
  91 |     |     assembly {
  92 | *   |         distance := sub(present, past)
  93 |     |     }
  94 |     | }
  95 | *r  | 
  96 |     | function convertDaysToSeconds(uint amountDays) pure returns (uint amountSeconds) {
  97 |     |     assembly {
  98 | *r  |         amountSeconds := mul(amountDays, SECONDS_PER_DAY)
  99 |     |     }
 100 |     | }
 101 |     | 
 102 |     | function toBytes32(bytes memory raw) pure returns (bytes32 data) {
 103 |     |     assembly {
 104 |     |         data := mload(add(raw, 32))
 105 |     |         let shift := mul(sub(32, mload(raw)), 8)
 106 |     |         data := shr(shift, data)
 107 |     |     }
 108 |     | }
 109 |     | 
 110 |     | function toBytes16(bytes memory raw) pure returns (bytes16 data) {
 111 |     |     assembly {
 112 |     |         data := mload(add(raw, 32))
 113 |     |         let shift := mul(sub(16, mload(raw)), 8)
 114 |     |         data := shr(shift, data)
 115 |     |     }
 116 |     | }
 117 | *r  | 
 118 |     | function separate(bytes1 data) pure returns (bytes1 upper, bytes1 lower) {
 119 | *r  |     upper = data >> 4;
 120 | *r  |     lower = data & 0x0f;
 121 |     | }
 122 |     | 
 123 |     | function pack(bytes1 upper, bytes1 lower) pure returns (bytes1 data) {
 124 |     |     data = (upper << 4) | lower;
 125 |     | }
 126 |     | 
 127 |     | /**
 128 |     |  * @dev             Converts an array of bytes into an uint128, the array must adhere
 129 |     |  *                  to the the following format:
 130 |     |  *                  - First byte: Amount of trailing zeros.
 131 |     |  *                  - Rest of the array: A hexadecimal number.
 132 | *r  |  */
 133 | *r  | function toAmount(bytes calldata raw) pure returns (uint128 amount) {
 134 |     |     uint8 power = uint8(raw[0]);
 135 |     |     amount = uint128(toBytes16(raw[1:raw.length]));
 136 | *r  |     if (power != 0) amount = amount * uint128(10 ** power);
 137 |     | }
 138 | *r  | 
 139 | *r  | function computeScalar(uint decimals) pure returns (uint scalar) {
 140 | *r  |     return 10 ** (MAX_DECIMALS - decimals); // can revert on underflow
 141 |     | }
 142 | r   | 
 143 | r   | function scaleToWad(uint amountDec, uint decimals) pure returns (uint outputWad) {
 144 | r   |     uint factor = computeScalar(decimals);
 145 |     |     assembly {
 146 | r   |         outputWad := mul(amountDec, factor)
 147 |     |     }
 148 |     | }
 149 |     | 
 150 |     | function scaleFromWadUp(uint amountWad, uint decimals) pure returns (uint outputDec) {
 151 |     |     uint factor = computeScalar(decimals);
 152 |     |     assembly {
 153 |     |         outputDec := add(div(amountWad, factor), 1)
 154 |     |     }
 155 |     | }
 156 | *r  | 
 157 | *r  | function scaleFromWadDown(uint amountWad, uint decimals) pure returns (uint outputDec) {
 158 | *r  |     uint factor = computeScalar(decimals);
 159 |     |     assembly {
 160 | *r  |         outputDec := div(amountWad, factor)
 161 |     |     }
 162 |     | }
 163 |     | 
 164 |     | function scaleFromWadUpSigned(int amountWad, uint decimals) pure returns (int outputDec) {
 165 |     |     uint factor = computeScalar(decimals);
 166 |     |     assembly {
 167 |     |         outputDec := add(sdiv(amountWad, factor), 1)
 168 |     |     }
 169 |     | }
 170 |     | 
 171 |     | function scaleFromWadDownSigned(int amountWad, uint decimals) pure returns (int outputDec) {
 172 |     |     uint factor = computeScalar(decimals);
 173 |     |     assembly {
 174 |     |         outputDec := sdiv(amountWad, factor)
 175 |     |     }
 176 |     | }
 177 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/Enigma.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     |   
   8 |     |   This is called the Enigma, it's an alternative ABI.
   9 |     |   Originally, it was designed to compress calldata and therefore
  10 |     |   save gas on optimistic rollup networks.
  11 |     | 
  12 |     |   There are levels to the optimizations that can be made for it,
  13 |     |   but this one focuses on the alternative multicall: jump process.
  14 |     | 
  15 |     |   Multicalls will pad all calls to a full bytes32.
  16 |     |   This means two calls are at least 64 bytes.
  17 |     |   This alternative multicall can process over 10 calls in the same 64 bytes.
  18 |     |   The smallest bytes provided by a call is for allocate and unallocate, at 11 bytes.
  19 |     | 
  20 |     |   Multicalls also process transactions sequentially.
  21 |     |   State cannot be carried over transiently between transactions.
  22 |     |   With Enigma, we can transiently set state (only specific state),
  23 |     |   and use it across "instructions".
  24 |     | 
  25 |     |   Without jump instruction, this alternative encoding is overkill.
  26 |     | 
  27 |     |   Be aware of function selector hash collisions.
  28 |     |   Data is delivered via the `fallback` function.
  29 |     | 
  30 |     |   -------------
  31 |     | 
  32 |     |   Primitive™
  33 |     | 
  34 |     |  */
  35 |     | 
  36 |     | import "./Assembly.sol" as Assembly;
  37 |     | 
  38 |     | uint8 constant JUMP_PROCESS_START_POINTER = 2;
  39 |     | bytes1 constant UNKNOWN = 0x00;
  40 |     | bytes1 constant ALLOCATE = 0x01;
  41 |     | bytes1 constant UNSET00 = 0x02;
  42 |     | bytes1 constant UNALLOCATE = 0x03;
  43 |     | bytes1 constant UNSET01 = 0x04;
  44 |     | bytes1 constant SWAP = 0x05;
  45 |     | bytes1 constant STAKE_POSITION = 0x06;
  46 |     | bytes1 constant UNSTAKE_POSITION = 0x07;
  47 |     | bytes1 constant UNSET02 = 0x08;
  48 |     | bytes1 constant UNSET03 = 0x09;
  49 |     | bytes1 constant CREATE_POOL = 0x0B;
  50 |     | bytes1 constant CREATE_PAIR = 0x0C;
  51 |     | bytes1 constant UNSET04 = 0x0D;
  52 |     | bytes1 constant INSTRUCTION_JUMP = 0xAA;
  53 |     | 
  54 |     | error InvalidJump(uint256 pointer); // 0x80f63bd1
  55 |     | error InvalidBytesLength(uint256 expected, uint256 length); // 0xe19dc95e
  56 | *r  | 
  57 |     | function __startProcess__(function(bytes calldata) _process) {
  58 | *r  |     if (msg.data[0] != INSTRUCTION_JUMP) _process(msg.data);
  59 |     |     else _jumpProcess(msg.data, _process);
  60 |     | }
  61 |     | 
  62 |     | /** @dev  [jump instruction, instructions.length, pointer, ...instruction, pointer, ...etc] */
  63 |     | function _jumpProcess(bytes calldata data, function(bytes calldata) _process) {
  64 |     |     uint8 length = uint8(data[1]);
  65 |     |     uint8 pointer = JUMP_PROCESS_START_POINTER;
  66 |     |     uint256 start;
  67 |     |     // For each instruction set...
  68 |     |     for (uint256 i; i != length; ++i) {
  69 |     |         // Start at the index of the first byte of the next instruction.
  70 |     |         start = pointer;
  71 |     |         // Set the new pointer to the next instruction, located at the pointer.
  72 |     |         pointer = uint8(data[pointer]);
  73 |     |         // The `start:` includes the pointer byte, while the `:end` `pointer` is excluded.
  74 |     |         if (pointer > data.length) revert InvalidJump(pointer);
  75 |     |         bytes calldata instruction = data[start:pointer];
  76 |     |         // Process the instruction.
  77 |     |         _process(instruction[1:]); // note: Removes the pointer to the next instruction.
  78 |     |     }
  79 |     | }
  80 |     | 
  81 |     | function encodeJumpInstruction(bytes[] memory instructions) pure returns (bytes memory) {
  82 |     |     uint8 nextPointer;
  83 |     |     uint8 len = uint8(instructions.length);
  84 |     |     bytes memory payload = bytes.concat(INSTRUCTION_JUMP, bytes1(len));
  85 |     | 
  86 |     |     // for each instruction set...
  87 |     |     for (uint i; i != len; ++i) {
  88 |     |         bytes memory instruction = instructions[i];
  89 |     |         uint8 size = uint8(instruction.length);
  90 |     | 
  91 |     |         // Using instruction and index of instruction in list, we create a new array with a pointer to the next instruction in front of the instruction payload.
  92 |     |         if (i == 0) {
  93 |     |             nextPointer = size + 3; // [added0, instruction, added1, nextPointer]
  94 |     |         } else {
  95 |     |             nextPointer = nextPointer + size + 1; // [currentPointer, instruction, nextPointer]
  96 |     |         }
  97 |     | 
  98 |     |         bytes memory edited = bytes.concat(bytes1(nextPointer), instruction);
  99 |     |         payload = bytes.concat(payload, edited);
 100 |     |     }
 101 |     | 
 102 |     |     return payload;
 103 |     | }
 104 |     | 
 105 |     | function decodePairIdFromPoolId(uint64 poolId) pure returns (uint24) {
 106 | r   |     return uint24(poolId >> 40);
 107 |     | }
 108 | *   | 
 109 | *   | function encodePoolId(uint24 pairId, bool isMutable, uint32 poolNonce) pure returns (uint64) {
 110 | *   |     return uint64(bytes8(abi.encodePacked(pairId, isMutable ? uint8(1) : uint8(0), poolNonce)));
 111 |     | }
 112 |     | 
 113 |     | function decodePoolId(
 114 |     |     bytes calldata data
 115 |     | ) pure returns (uint64 poolId, uint24 pairId, uint8 isMutable, uint32 poolNonce) {
 116 |     |     if (data.length != 8) revert InvalidBytesLength(8, data.length);
 117 |     |     poolId = uint64(bytes8(data));
 118 |     |     pairId = uint16(bytes2(data[:3]));
 119 |     |     isMutable = uint8(bytes1(data[3:4]));
 120 |     |     poolNonce = uint32(bytes4(data[4:]));
 121 |     | }
 122 | *r  | 
 123 | *r  | function encodeCreatePair(address token0, address token1) pure returns (bytes memory data) {
 124 | *r  |     data = abi.encodePacked(CREATE_PAIR, token0, token1);
 125 |     | }
 126 | *r  | 
 127 | *r  | function decodeCreatePair(bytes calldata data) pure returns (address tokenAsset, address tokenQuote) {
 128 | *r  |     if (data.length != 41) revert InvalidBytesLength(41, data.length);
 129 | *r  |     tokenAsset = address(bytes20(data[1:21]));
 130 | *r  |     tokenQuote = address(bytes20(data[21:]));
 131 |     | }
 132 | *   | 
 133 |     | function encodeCreatePool(
 134 |     |     uint24 pairId,
 135 |     |     address controller,
 136 |     |     uint16 priorityFee,
 137 |     |     uint16 fee,
 138 |     |     uint16 vol,
 139 |     |     uint16 dur,
 140 |     |     uint16 jit,
 141 |     |     int24 max,
 142 |     |     uint128 price
 143 | *   | ) pure returns (bytes memory data) {
 144 | *   |     data = abi.encodePacked(CREATE_POOL, pairId, controller, priorityFee, fee, vol, dur, jit, max, price);
 145 |     | }
 146 | *   | 
 147 |     | function decodeCreatePool(
 148 |     |     bytes calldata data
 149 |     | )
 150 |     |     pure
 151 |     |     returns (
 152 | *   |         uint24 pairId,
 153 |     |         address controller,
 154 |     |         uint16 priorityFee,
 155 |     |         uint16 fee,
 156 |     |         uint16 vol,
 157 |     |         uint16 dur,
 158 |     |         uint16 jit,
 159 |     |         int24 max,
 160 |     |         uint128 price
 161 |     |     )
 162 |     | {
 163 | *   |     if (data.length != 53) revert InvalidBytesLength(53, data.length);
 164 | *   |     pairId = uint24(bytes3(data[1:4]));
 165 | *   |     controller = address(bytes20(data[4:24]));
 166 | *   |     priorityFee = uint16(bytes2(data[24:26]));
 167 | *   |     fee = uint16(bytes2(data[26:28]));
 168 | *   |     vol = uint16(bytes2(data[28:30]));
 169 | *   |     dur = uint16(bytes2(data[30:32]));
 170 | *   |     jit = uint16(bytes2(data[32:34]));
 171 | *   |     max = int24(uint24(bytes3(data[34:37])));
 172 | *   |     price = uint128(bytes16(data[37:]));
 173 |     | }
 174 |     | 
 175 |     | function encodeAllocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {
 176 |     |     data = abi.encodePacked(Assembly.pack(bytes1(useMax), ALLOCATE), poolId, power, amount);
 177 |     | }
 178 |     | 
 179 |     | function decodeAllocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {
 180 |     |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 181 |     |     (bytes1 maxFlag, ) = Assembly.separate(data[0]);
 182 |     |     useMax = uint8(maxFlag);
 183 |     |     poolId = uint64(bytes8(data[1:9]));
 184 |     |     deltaLiquidity = Assembly.toAmount(data[9:]);
 185 |     | }
 186 |     | 
 187 |     | function encodeUnallocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {
 188 |     |     data = abi.encodePacked(Assembly.pack(bytes1(useMax), UNALLOCATE), poolId, power, amount);
 189 |     | }
 190 | *r  | 
 191 |     | function decodeUnallocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {
 192 |     |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 193 |     |     useMax = uint8(data[0] >> 4);
 194 |     |     poolId = uint64(bytes8(data[1:9]));
 195 | *r  |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
 196 |     | }
 197 |     | 
 198 |     | function encodeSwap(
 199 |     |     uint8 useMax,
 200 |     |     uint64 poolId,
 201 |     |     uint8 power0,
 202 |     |     uint128 amount0,
 203 |     |     uint8 power1,
 204 |     |     uint128 amount1,
 205 |     |     uint8 direction
 206 |     | ) pure returns (bytes memory data) {
 207 |     |     //    pointerToAmount1 = instruction, poolId, pointer, power0, amount0, power1 {pointer}->
 208 |     |     uint8 pointerToAmount1 = 0x01 + 0x08 + 0x01 + 0x10 + 0x01;
 209 |     |     data = abi.encodePacked(
 210 |     |         Assembly.pack(bytes1(useMax), SWAP),
 211 |     |         poolId,
 212 |     |         pointerToAmount1,
 213 |     |         power0,
 214 |     |         amount0,
 215 |     |         power1,
 216 |     |         amount1,
 217 |     |         direction
 218 |     |     );
 219 |     | }
 220 |     | 
 221 |     | function decodeSwap(
 222 |     |     bytes calldata data
 223 |     | ) pure returns (uint8 useMax, uint64 poolId, uint128 input, uint128 limit, uint8 direction) {
 224 |     |     useMax = uint8(data[0] >> 4);
 225 |     |     poolId = uint64(bytes8(data[1:9]));
 226 |     |     uint8 pointer = uint8(data[9]);
 227 |     |     input = uint128(Assembly.toAmount(data[10:pointer]));
 228 |     |     limit = uint128(Assembly.toAmount(data[pointer:data.length - 1]));
 229 |     |     direction = uint8(data[data.length - 1]);
 230 |     | }
 231 |     | 
 232 |     | function encodeStakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {
 233 |     |     data = abi.encodePacked(STAKE_POSITION, poolId, deltaLiquidity);
 234 |     | }
 235 | *r  | 
 236 | r   | function decodeStakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {
 237 | r   |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 238 |     |     poolId = uint64(bytes8(data[1:9]));
 239 | *r  |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
 240 |     | }
 241 |     | 
 242 |     | function encodeUnstakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {
 243 |     |     data = abi.encodePacked(UNSTAKE_POSITION, poolId, deltaLiquidity);
 244 |     | }
 245 |     | 
 246 |     | function decodeUnstakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {
 247 |     |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 248 |     |     poolId = uint64(bytes8(data[1:9]));
 249 |     |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
 250 |     | }
 251 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/Hyper.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   ------------------------------------
   7 |     | 
   8 |     |   Hyper is a replicating market maker.
   9 |     | 
  10 |     |   ------------------------------------
  11 |     | 
  12 |     |   Primitive™
  13 |     | 
  14 |     |  */
  15 |     | 
  16 |     | import "./HyperLib.sol";
  17 |     | import "./interfaces/IWETH.sol";
  18 |     | import "./interfaces/IHyper.sol";
  19 |     | import "./interfaces/IERC20.sol";
  20 | *r  | 
  21 |     | contract Hyper is IHyper {
  22 |     |     using Price for Price.RMM;
  23 |     |     using SafeCastLib for uint;
  24 |     |     using FixedPointMathLib for int256;
  25 |     |     using FixedPointMathLib for uint256;
  26 |     |     using {Assembly.isBetween} for uint8;
  27 |     |     using {Assembly.scaleFromWadDownSigned} for int;
  28 |     |     using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;
  29 |     | 
  30 | *r  |     function VERSION() public pure returns (string memory) {
  31 |     |         assembly {
  32 |     |             // Load 0x20 (32) in memory at slot 0x00, this corresponds to the
  33 |     |             // offset location of the next data.
  34 | *   |             mstore(0x00, 0x20)
  35 |     | 
  36 |     |             // Then we load both the length of our string (11 bytes, 0x0b in hex) and its
  37 |     |             // actual hex value (0x626574612d76302e302e31) using the offset 0x2b. Using this
  38 |     |             // particular offset value will right pad the length at the end of the slot
  39 |     |             // and left pad the string at the beginning of the next slot, assuring the
  40 |     |             // right ABI format to return a string.
  41 | *   |             mstore(0x2b, 0x0b626574612d76302e302e31) // "beta-v0.0.1"
  42 |     | 
  43 |     |             // Return all the 96 bytes (0x60) of data that was loaded into the memory.
  44 | *   |             return(0x00, 0x60)
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 | *r  |     OS.AccountSystem public __account__;
  49 |     | 
  50 | *r  |     address public immutable WETH;
  51 | *r  |     uint256 public getPairNonce;
  52 | *r  |     uint256 public getPoolNonce;
  53 |     | 
  54 | *r  |     mapping(uint24 => HyperPair) public pairs;
  55 | *r  |     mapping(uint64 => HyperPool) public pools;
  56 | *r  |     mapping(address => mapping(address => uint24)) public getPairId;
  57 | *r  |     mapping(address => mapping(uint64 => HyperPosition)) public positions;
  58 |     | 
  59 | *r  |     uint256 public locked = 1;
  60 |     |     Payment[] private _payments;
  61 |     |     SwapState private _state;
  62 |     | 
  63 |     |     modifier lock() {
  64 | *r  |         if (locked != 1) revert InvalidReentrancy();
  65 |     | 
  66 | *r  |         locked = 2;
  67 |     |         _;
  68 | *r  |         locked = 1;
  69 |     |     }
  70 |     | 
  71 |     |     /** @dev Used on every external operation that touches tokens. */
  72 |     |     modifier interactions() {
  73 | *r  |         if (__account__.prepared) revert InvalidReentrancy();
  74 | *r  |         __account__.__wrapEther__(WETH); // Deposits msg.value ether, this contract receives WETH.
  75 | *r  |         __account__.prepared = false;
  76 |     |         _;
  77 | *r  |         __account__.prepared = true;
  78 |     | 
  79 | *r  |         _settlement();
  80 |     | 
  81 | *r  |         if (!__account__.settled) revert InvalidSettlement();
  82 |     |     }
  83 |     | 
  84 |     |     constructor(address weth) {
  85 |     |         WETH = weth;
  86 |     |         __account__.settled = true;
  87 |     |     }
  88 |     | 
  89 |     |     receive() external payable {
  90 | *r  |         if (msg.sender != WETH) revert();
  91 |     |     }
  92 |     | 
  93 |     |     /**  @dev Alternative entrypoint to process operations using encoded calldata transferred directly as `msg.data`. */
  94 |     |     fallback() external payable lock interactions {
  95 | *r  |         Enigma.__startProcess__(_process);
  96 |     |     }
  97 |     | 
  98 |     |     /** @dev balanceOf(token) - getReserve(token). If negative, you win. */
  99 | *r  |     function getNetBalance(address token) public view returns (int256) {
 100 | *r  |         return __account__.getNetBalance(token, address(this));
 101 |     |     }
 102 |     | 
 103 |     |     /** @dev Virtual balance of `token`. */
 104 | *r  |     function getReserve(address token) public view returns (uint) {
 105 | *r  |         return __account__.reserves[token];
 106 |     |     }
 107 |     | 
 108 |     |     /** @dev Internal balance of `owner` of `token`. */
 109 | *r  |     function getBalance(address owner, address token) public view returns (uint) {
 110 | *r  |         return __account__.balances[owner][token];
 111 |     |     }
 112 |     |     
 113 |     |     /** @dev Transient stored tokens */
 114 | *r  |     function getWarm() public view returns (address[] memory warm) {
 115 | *   |         return __account__.warm;
 116 |     |     }
 117 |     | 
 118 |     | 
 119 |     |     // ===== Actions ===== //
 120 |     | 
 121 |     |     /// @inheritdoc IHyperActions
 122 | *r  |     function allocate(
 123 |     |         uint64 poolId,
 124 |     |         uint amount
 125 | *r  |     ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {
 126 | *r  |         bool useMax = amount == type(uint).max;
 127 | *r  |         (deltaAsset, deltaQuote) = _allocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());
 128 |     |     }
 129 |     | 
 130 |     |     /// @inheritdoc IHyperActions
 131 | *r  |     function unallocate(
 132 |     |         uint64 poolId,
 133 |     |         uint amount
 134 | *r  |     ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {
 135 | *r  |         bool useMax = amount == type(uint).max;
 136 | *r  |         (deltaAsset, deltaQuote) = _unallocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());
 137 |     |     }
 138 |     | 
 139 |     |     /// @inheritdoc IHyperActions
 140 | *r  |     function stake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {
 141 | *r  |         _stake(poolId, deltaLiquidity);
 142 |     |     }
 143 |     | 
 144 |     |     /// @inheritdoc IHyperActions
 145 | r   |     function unstake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {
 146 | r   |         _unstake(poolId, deltaLiquidity);
 147 |     |     }
 148 |     | 
 149 |     |     /// @inheritdoc IHyperActions
 150 | r   |     function swap(
 151 |     |         uint64 poolId,
 152 |     |         bool sellAsset,
 153 |     |         uint amount,
 154 |     |         uint limit
 155 | r   |     ) external lock interactions returns (uint output, uint remainder) {
 156 | r   |         if (limit == type(uint256).max) limit = type(uint128).max;
 157 | r   |         bool useMax = amount == type(uint256).max; // magic variable.
 158 | r   |         uint128 input = useMax ? type(uint128).max : amount.safeCastTo128();
 159 | r   |         (, remainder, , output) = _swapExactIn(
 160 | r   |             Order({
 161 | r   |                 useMax: useMax ? 1 : 0,
 162 | r   |                 poolId: poolId,
 163 | r   |                 input: input,
 164 | r   |                 limit: limit.safeCastTo128(),
 165 | r   |                 direction: sellAsset ? 0 : 1
 166 |     |             })
 167 |     |         );
 168 |     |     }
 169 |     | 
 170 |     |     /// @inheritdoc IHyperActions
 171 | *r  |     function draw(address token, uint256 amount, address to) external lock interactions {
 172 | *r  |         if (to == address(this)) revert InvalidTransfer(); // todo: Investigate attack vectors if this was not here.
 173 | *r  |         if (amount > getBalance(msg.sender, token)) revert DrawBalance();
 174 |     | 
 175 | *r  |         _applyDebit(token, amount);
 176 | *r  |         _decreaseReserves(token, amount);
 177 |     | 
 178 | *r  |         if (token == WETH) OS.__dangerousUnwrapEther__(WETH, to, amount);
 179 | *r  |         else OS.SafeTransferLib.safeTransfer(OS.ERC20(token), to, amount);
 180 |     |     }
 181 |     | 
 182 |     |     /// @inheritdoc IHyperActions
 183 | *r  |     function fund(address token, uint256 amount) external override lock interactions {
 184 | *r  |         __account__.dangerousFund(token, address(this), amount); // transferFrom(msg.sender)
 185 |     |     }
 186 |     | 
 187 |     |     /// @inheritdoc IHyperActions
 188 | *r  |     function deposit() external payable override lock interactions {
 189 | *r  |         if (msg.value == 0) revert ZeroValue();
 190 | *   |         emit Deposit(msg.sender, msg.value);
 191 |     |         // interactions modifier does the work.
 192 |     |     }
 193 |     | 
 194 |     |     // todo: test
 195 | *r  |     function claim(uint64 poolId, uint deltaAsset, uint deltaQuote) external lock interactions {
 196 | r   |         HyperPool memory pool = pools[poolId];
 197 | r   |         HyperPosition storage pos = positions[msg.sender][poolId];
 198 | *r  |         if (pos.lastTimestamp == 0) revert NonExistentPosition(msg.sender, poolId);
 199 |     | 
 200 |     |         pos.syncPositionFees(pool.liquidity, pool.feeGrowthGlobalAsset, pool.feeGrowthGlobalQuote);
 201 |     |         pos.tokensOwedAsset -= deltaAsset.safeCastTo128();
 202 |     |         pos.tokensOwedQuote -= deltaQuote.safeCastTo128();
 203 |     | 
 204 |     |         if (deltaAsset > 0) _applyCredit(pool.pair.tokenAsset, deltaAsset); // todo: problem, what balance do fees accrue to?
 205 |     |         if (deltaQuote > 0) _applyCredit(pool.pair.tokenQuote, deltaQuote); // todo: add debit to this contract?
 206 |     | 
 207 |     |         pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward);
 208 |     |         uint128 deltaReward = pos.tokensOwedReward;
 209 |     |         pos.tokensOwedReward -= deltaReward;
 210 |     | 
 211 |     |         // todo: a hack that utilizes Hyper contract as a fee bucket for priority swaps.
 212 |     |         // Currently uses WETH as the reward token. However, these priority fees
 213 |     |         // are paid based on liquidity.
 214 |     |         // If 1 WAD of liquidity is worth a small amount, the priority fee cost
 215 |     |         // a lot relative to the liquidity's value.
 216 |     |         // A better change is making this reward token configurable.
 217 |     |         if (deltaReward > 0) {
 218 |     |             _applyCredit(WETH, deltaReward); // gift to `msg.sender`.
 219 |     |             if (getBalance(address(this), WETH) < deltaReward) revert InvalidReward();
 220 |     |             __account__.debit(address(this), WETH, deltaReward); // only place hyper's balance is used
 221 |     |         }
 222 |     | 
 223 |     |         emit Collect(
 224 |     |             poolId,
 225 |     |             msg.sender,
 226 |     |             deltaAsset,
 227 |     |             pool.pair.tokenAsset,
 228 |     |             deltaQuote,
 229 |     |             pool.pair.tokenQuote,
 230 |     |             deltaReward,
 231 |     |             WETH
 232 |     |         );
 233 |     |     }
 234 |     | 
 235 |     |     // ===== Effects ===== //
 236 |     | 
 237 |     |     /** @dev Increases virtal reserves and liquidity. Debits `msg.sender`. */
 238 | *r  |     function _allocate(
 239 |     |         bool useMax,
 240 |     |         uint64 poolId,
 241 |     |         uint128 deltaLiquidity
 242 | *r  |     ) internal returns (uint256 deltaAsset, uint256 deltaQuote) {
 243 | *r  |         HyperPool memory pool = pools[poolId];
 244 | *r  |         if (!pool.exists()) revert NonExistentPool(poolId);
 245 |     | 
 246 | *r  |         if (useMax) {
 247 |     |             deltaLiquidity = pool.getMaxLiquidity({
 248 |     |                 deltaAsset: getBalance(msg.sender, pool.pair.tokenAsset),
 249 |     |                 deltaQuote: getBalance(msg.sender, pool.pair.tokenQuote)
 250 |     |             });
 251 |     |         }
 252 |     | 
 253 | *r  |         if (deltaLiquidity == 0) revert ZeroLiquidity();
 254 | *r  |         (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(toInt128(deltaLiquidity)); // note: rounds up.
 255 |     | 
 256 | *   |         ChangeLiquidityParams memory args = ChangeLiquidityParams({
 257 | *   |             owner: msg.sender,
 258 |     |             poolId: poolId,
 259 |     |             timestamp: _blockTimestamp(),
 260 | *   |             deltaAsset: deltaAsset,
 261 | *   |             deltaQuote: deltaQuote,
 262 | *   |             tokenAsset: pool.pair.tokenAsset,
 263 | *   |             tokenQuote: pool.pair.tokenQuote,
 264 | *   |             deltaLiquidity: toInt128(deltaLiquidity)
 265 |     |         });
 266 |     | 
 267 | *   |         _changeLiquidity(args);
 268 | *   |         emit Allocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);
 269 |     |     }
 270 |     | 
 271 |     |     /** @dev Reduces virtual reserves and liquidity. Credits `msg.sender`. */
 272 | *r  |     function _unallocate(
 273 |     |         bool useMax,
 274 |     |         uint64 poolId,
 275 |     |         uint128 deltaLiquidity
 276 | *r  |     ) internal returns (uint deltaAsset, uint deltaQuote) {
 277 | *r  |         if (useMax) deltaLiquidity = positions[msg.sender][poolId].freeLiquidity;
 278 | *r  |         if (deltaLiquidity == 0) revert ZeroLiquidity();
 279 |     | 
 280 | *r  |         HyperPool memory pool = pools[poolId];
 281 | *r  |         if (!pool.exists()) revert NonExistentPool(poolId);
 282 |     | 
 283 | *r  |         (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(-toInt128(deltaLiquidity)); // rounds down
 284 |     | 
 285 | *   |         ChangeLiquidityParams memory args = ChangeLiquidityParams({
 286 | *   |             owner: msg.sender,
 287 |     |             poolId: poolId,
 288 |     |             timestamp: _blockTimestamp(),
 289 | *   |             deltaAsset: deltaAsset,
 290 | *   |             deltaQuote: deltaQuote,
 291 | *   |             tokenAsset: pool.pair.tokenAsset,
 292 | *   |             tokenQuote: pool.pair.tokenQuote,
 293 | *   |             deltaLiquidity: -toInt128(deltaLiquidity)
 294 |     |         });
 295 |     | 
 296 | *   |         _changeLiquidity(args);
 297 | *   |         emit Unallocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);
 298 |     |     }
 299 |     | 
 300 | *   |     function _changeLiquidity(ChangeLiquidityParams memory args) internal returns (uint feeAsset, uint feeQuote) {
 301 | *   |         (HyperPool storage pool, HyperPosition storage pos) = (pools[args.poolId], positions[args.owner][args.poolId]);
 302 |     | 
 303 | *   |         (feeAsset, feeQuote) = pos.syncPositionFees(
 304 | *   |             pool.liquidity,
 305 | *   |             pool.feeGrowthGlobalAsset,
 306 | *   |             pool.feeGrowthGlobalQuote
 307 |     |         );
 308 |     | 
 309 | *   |         _changePosition(args);
 310 |     |     }
 311 |     | 
 312 |     |     /** @dev Changes position liquidity and timestamp. */
 313 | *   |     function _changePosition(ChangeLiquidityParams memory args) internal {
 314 | *   |         HyperPosition storage position = positions[args.owner][args.poolId];
 315 |     | 
 316 | *   |         if (args.deltaLiquidity < 0) {
 317 | *   |             uint distance = position.getTimeSinceChanged(_blockTimestamp());
 318 | *   |             if (pools[args.poolId].params.jit > distance) revert JitLiquidity(distance);
 319 |     |         }
 320 |     | 
 321 | *   |         position.changePositionLiquidity(args.timestamp, args.deltaLiquidity);
 322 |     | 
 323 | *   |         _changePool(args);
 324 |     |     }
 325 |     | 
 326 |     |     /** @dev Changes virtual reserves and pool liquidity. Does not update timestamp of pool. */
 327 | *   |     function _changePool(ChangeLiquidityParams memory args) internal {
 328 | *   |         (address asset, address quote) = (args.tokenAsset, args.tokenQuote);
 329 |     | 
 330 | *   |         pools[args.poolId].changePoolLiquidity(args.deltaLiquidity);
 331 |     | 
 332 | *   |         if (args.deltaLiquidity < 0) {
 333 | *   |             _decreaseReserves(asset, args.deltaAsset);
 334 | *   |             _decreaseReserves(quote, args.deltaQuote);
 335 |     |         } else {
 336 |     |             // note: Reserves are used at the end of instruction processing to interactions transactions.
 337 | *   |             _increaseReserves(asset, args.deltaAsset);
 338 | *   |             _increaseReserves(quote, args.deltaQuote);
 339 |     |         }
 340 |     |     }
 341 |     | 
 342 | r   |     function _stake(uint64 poolId, uint128 deltaLiquidity) internal {
 343 | r   |         HyperPool storage pool = pools[poolId];
 344 | r   |         if (!pool.exists()) revert NonExistentPool(poolId);
 345 |     | 
 346 | r   |         HyperPosition memory pos = positions[msg.sender][poolId];
 347 | r   |         if (deltaLiquidity == 0) revert ZeroLiquidity();
 348 | r   |         if (pos.freeLiquidity < deltaLiquidity) revert InsufficientPosition(poolId);
 349 |     | 
 350 |     |         uint feeEarned = _changeStake(poolId, toInt128(deltaLiquidity));
 351 |     |         pool.stakedLiquidityDelta += toInt128(deltaLiquidity);
 352 |     |         emit Stake(poolId, msg.sender, deltaLiquidity);
 353 |     |     }
 354 |     | 
 355 | r   |     function _unstake(uint64 poolId, uint128 deltaLiquidity) internal returns (uint feeEarned) {
 356 | r   |         HyperPool storage pool = pools[poolId];
 357 | r   |         if (!pool.exists()) revert NonExistentPool(poolId);
 358 |     | 
 359 | r   |         uint timestamp = _blockTimestamp();
 360 | r   |         HyperPosition memory pos = positions[msg.sender][poolId];
 361 | r   |         if (pos.stakeTimestamp == 0) revert PositionNotStaked(poolId);
 362 |     |         if (pos.unstakeTimestamp > timestamp) revert StakeNotMature(poolId); // todo: Investigate if its okay to unstake whenever.
 363 |     | 
 364 |     |         feeEarned = _changeStake(poolId, -toInt128(deltaLiquidity));
 365 |     |         pool.stakedLiquidityDelta -= toInt128(deltaLiquidity);
 366 |     |         emit Unstake(poolId, msg.sender, deltaLiquidity);
 367 |     |     }
 368 |     | 
 369 |     |     function _changeStake(uint64 poolId, int128 deltaLiquidity) internal returns (uint feeEarned) {
 370 |     |         uint timestamp = _blockTimestamp();
 371 |     |         HyperPool memory pool = pools[poolId];
 372 |     |         HyperPosition storage pos = positions[msg.sender][poolId];
 373 |     |         if (pos.stakeTimestamp == 0) pos.stakeTimestamp = timestamp.safeCastTo32();
 374 |     |         if (pos.unstakeTimestamp == 0) pos.unstakeTimestamp = pool.params.maturity();
 375 |     | 
 376 |     |         feeEarned = pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward); // must apply before liquidity changes.
 377 |     |         pos.changePositionLiquidity(timestamp, -deltaLiquidity);
 378 |     |         pos.stakedLiquidity = Assembly.addSignedDelta(pos.stakedLiquidity, deltaLiquidity);
 379 |     |     }
 380 |     | 
 381 |     |     // ===== Swaps ===== //
 382 |     | 
 383 |     |     /** * @dev Swaps in direction (0 or 1) exact input of tokens (0 = asset, 1 = quote) for output of tokens (0 = quote, 1 = asset) up to limit price. */
 384 | r   |     function _swapExactIn(
 385 |     |         Order memory args
 386 | r   |     ) internal returns (uint64 poolId, uint256 remainder, uint256 input, uint256 output) {
 387 | r   |         if (args.input == 0) revert ZeroInput();
 388 |     | 
 389 | r   |         HyperPool storage pool = pools[args.poolId];
 390 | r   |         if (!pool.exists()) revert NonExistentPool(args.poolId);
 391 |     | 
 392 | r   |         _state.sell = args.direction == 0; // 0: asset -> quote, 1: quote -> asset
 393 | r   |         _state.fee = msg.sender == pool.controller ? pool.params.priorityFee : uint(pool.params.fee);
 394 | r   |         _state.feeGrowthGlobal = _state.sell ? pool.feeGrowthGlobalAsset : pool.feeGrowthGlobalQuote;
 395 | r   |         _state.tokenInput = _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote;
 396 | r   |         _state.tokenOutput = _state.sell ? pool.pair.tokenQuote : pool.pair.tokenAsset;
 397 |     | 
 398 | r   |         Price.RMM memory rmm = Price.RMM({strike: pool.params.strike(), sigma: pool.params.volatility, tau: 0});
 399 | r   |         Iteration memory _swap;
 400 | r   |         {
 401 | r   |             (uint256 price, int24 tick, uint updatedTau) = _computeSyncedPrice(args.poolId);
 402 | r   |             rmm.tau = updatedTau;
 403 |     | 
 404 | r   |             uint internalBalance = getBalance(msg.sender, _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote);
 405 | r   |             remainder = args.useMax == 1 ? internalBalance : args.input;
 406 | r   |             remainder = remainder.scaleToWad(_state.sell ? pool.pair.decimalsAsset : pool.pair.decimalsQuote); // WAD
 407 | r   |             _swap = Iteration({
 408 | r   |                 price: price,
 409 | r   |                 tick: tick,
 410 | r   |                 feeAmount: 0,
 411 | r   |                 remainder: remainder,
 412 | r   |                 liquidity: pool.liquidity,
 413 | r   |                 input: 0,
 414 | r   |                 output: 0
 415 |     |             });
 416 |     |         }
 417 | r   |         if (rmm.tau == 0) revert PoolExpired();
 418 |     | 
 419 |     |         // =---= Effects =---= //
 420 |     | 
 421 |     |         // These are WAD values.
 422 | r   |         uint256 liveIndependent;
 423 |     |         uint256 nextIndependent;
 424 |     |         uint256 liveDependent;
 425 |     |         uint256 nextDependent;
 426 |     |         uint priorityFeeAmount;
 427 |     | 
 428 |     |         {
 429 |     |             uint256 maxInput;
 430 |     |             uint256 deltaInput;
 431 |     | 
 432 |     |             // Virtual reserves
 433 | r   |             if (_state.sell) {
 434 | r   |                 (liveDependent, liveIndependent) = rmm.computeReserves(_swap.price);
 435 | *r  |                 maxInput = (FixedPointMathLib.WAD - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.
 436 |     |             } else {
 437 | r   |                 (liveIndependent, liveDependent) = rmm.computeReserves(_swap.price);
 438 | r   |                 maxInput = (rmm.strike - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.
 439 |     |             }
 440 |     | 
 441 | r   |             priorityFeeAmount = msg.sender == pool.controller ? (pool.liquidity * _state.fee) / 10_000 : 0;
 442 | r   |             _swap.feeAmount = priorityFeeAmount != 0
 443 |     |                 ? 0
 444 | r   |                 : ((_swap.remainder > maxInput ? maxInput : _swap.remainder) * _state.fee) / 10_000;
 445 | r   |             _state.feeGrowthGlobal = FixedPointMathLib.divWadDown(_swap.feeAmount, _swap.liquidity);
 446 |     |             if (priorityFeeAmount != 0) _state.priorityFeeGrowthGlobal = priorityFeeAmount.divWadDown(_swap.liquidity); // todo: change to staked liquidity
 447 |     | 
 448 |     |             if (_swap.remainder > maxInput) {
 449 |     |                 deltaInput = maxInput - _swap.feeAmount;
 450 |     |                 nextIndependent = liveIndependent + deltaInput.divWadDown(_swap.liquidity);
 451 |     |                 _swap.remainder -= (deltaInput + _swap.feeAmount);
 452 |     |             } else {
 453 |     |                 deltaInput = _swap.remainder - _swap.feeAmount;
 454 |     |                 nextIndependent = liveIndependent + deltaInput.divWadDown(_swap.liquidity);
 455 |     |                 deltaInput = _swap.remainder; // Swap input amount including the fee payment.
 456 |     |                 _swap.remainder = 0; // Clear the remainder to zero, as the order has been filled.
 457 |     |             }
 458 |     | 
 459 |     |             // Compute the output of the swap by computing the difference between the dependent reserves.
 460 |     |             if (_state.sell) nextDependent = rmm.getYWithX(nextIndependent);
 461 |     |             else nextDependent = rmm.getXWithY(nextIndependent);
 462 |     | 
 463 |     |             _swap.input += deltaInput;
 464 |     |             _swap.output += (liveDependent - nextDependent);
 465 |     |         }
 466 |     | 
 467 |     |         {
 468 |     |             uint256 nextPrice;
 469 |     |             uint256 limitPrice = args.limit;
 470 |     |             int256 liveInvariantWad;
 471 |     |             int256 nextInvariantWad;
 472 |     | 
 473 |     |             if (_state.sell) {
 474 |     |                 liveInvariantWad = rmm.invariantOf(liveDependent, liveIndependent);
 475 |     |                 nextInvariantWad = rmm.invariantOf(nextDependent, nextIndependent);
 476 |     |                 nextPrice = rmm.getPriceWithX(nextIndependent);
 477 |     |             } else {
 478 |     |                 liveInvariantWad = rmm.invariantOf(liveIndependent, liveDependent);
 479 |     |                 nextInvariantWad = rmm.invariantOf(nextIndependent, nextDependent);
 480 |     |                 nextPrice = rmm.getPriceWithX(nextDependent);
 481 |     |             }
 482 |     | 
 483 |     |             if (!_state.sell && nextPrice > limitPrice) revert SwapLimitReached();
 484 |     |             if (_state.sell && limitPrice > nextPrice) revert SwapLimitReached();
 485 |     | 
 486 |     |             liveInvariantWad = liveInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote); // invariant is denominated in quote token.
 487 |     |             nextInvariantWad = nextInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote);
 488 |     |             if (nextInvariantWad < liveInvariantWad) revert InvalidInvariant(liveInvariantWad, nextInvariantWad);
 489 |     | 
 490 |     |             _swap.price = (nextPrice * 10_000_001) / 10_000_000; // todo: this prevents failure in fuzz tests, investigate further. Related to precision.
 491 |     |         }
 492 |     | 
 493 |     |         {
 494 |     |             uint inputDec;
 495 |     |             uint outputDec;
 496 |     |             if (_state.sell) {
 497 |     |                 inputDec = pool.pair.decimalsAsset;
 498 |     |                 outputDec = pool.pair.decimalsQuote;
 499 |     |             } else {
 500 |     |                 inputDec = pool.pair.decimalsQuote;
 501 |     |                 outputDec = pool.pair.decimalsAsset;
 502 |     |             }
 503 |     | 
 504 |     |             _swap.input = _swap.input.scaleFromWadUp(inputDec);
 505 |     |             _swap.output = _swap.output.scaleFromWadDown(outputDec);
 506 |     |         }
 507 |     | 
 508 |     |         // Apply pool effects.
 509 |     |         _syncPool(
 510 |     |             args.poolId,
 511 |     |             Price.computeTickWithPrice(_swap.price),
 512 |     |             _swap.price,
 513 |     |             _swap.liquidity,
 514 |     |             _state.sell ? _state.feeGrowthGlobal : 0,
 515 |     |             _state.sell ? 0 : _state.feeGrowthGlobal,
 516 |     |             _state.priorityFeeGrowthGlobal
 517 |     |         );
 518 |     | 
 519 |     |         _increaseReserves(_state.tokenInput, _swap.input);
 520 |     |         _decreaseReserves(_state.tokenOutput, _swap.output);
 521 |     | 
 522 |     |         // Apply reserve effects.
 523 |     |         if (priorityFeeAmount != 0) {
 524 |     |             // Uses hyper's internal balance as a fee bucket for priority swaps.
 525 |     |             // todo: investigate two different pools accruing priority rewards in the same bucket,
 526 |     |             // and if it's possible to "steal" another pool's accrued priority rewards.
 527 |     |             _increaseReserves(WETH, priorityFeeAmount);
 528 |     |             emit IncreaseUserBalance(address(this), WETH, priorityFeeAmount);
 529 |     |             __account__.credit(address(this), WETH, priorityFeeAmount);
 530 |     |         }
 531 |     | 
 532 |     |         emit Swap(args.poolId, _swap.price, _state.tokenInput, _swap.input, _state.tokenOutput, _swap.output);
 533 |     | 
 534 |     |         delete _state;
 535 |     |         return (args.poolId, _swap.remainder, _swap.input, _swap.output);
 536 |     |     }
 537 |     | 
 538 |     |     /**
 539 |     |      * @dev Computes the price of the pool, which changes over time.
 540 |     |      *
 541 |     |      * @custom:reverts Underflows if the reserve of the input token is lower than the next one, after the next price movement.
 542 |     |      * @custom:reverts Underflows if current reserves of output token is less then next reserves.
 543 |     |      */
 544 | *r  |     function _computeSyncedPrice(uint64 poolId) internal view returns (uint256 price, int24 tick, uint updatedTau) {
 545 | *r  |         HyperPool memory pool = pools[poolId];
 546 | *r  |         if (!pool.exists()) revert NonExistentPool(poolId);
 547 |     | 
 548 | *r  |         (price, tick, updatedTau) = (pool.lastPrice, pool.lastTick, pool.tau(_blockTimestamp()));
 549 |     | 
 550 | *r  |         uint passed = getTimePassed(poolId);
 551 | *r  |         if (passed > 0) {
 552 | *r  |             uint256 lastTau = pool.lastTau(); // pool.params.maturity() - pool.lastTimestamp.
 553 | *r  |             (price, tick) = pool.computePriceChangeWithTime(lastTau, passed);
 554 |     |         }
 555 |     |     }
 556 |     | 
 557 |     |     /**
 558 |     |      * @dev Effects on a Pool after a successful swap order condition has been met.
 559 |     |      */
 560 |     |     function _syncPool(
 561 |     |         uint64 poolId,
 562 |     |         int24 tick,
 563 |     |         uint256 price,
 564 |     |         uint256 liquidity,
 565 |     |         uint256 feeGrowthGlobalAsset,
 566 |     |         uint256 feeGrowthGlobalQuote,
 567 |     |         uint256 feeGrowthGlobalReward
 568 |     |     ) internal returns (uint256 timeDelta) {
 569 |     |         HyperPool storage pool = pools[poolId];
 570 |     | 
 571 |     |         uint256 timestamp = _blockTimestamp();
 572 |     |         timeDelta = getTimePassed(poolId);
 573 |     | 
 574 |     |         // todo: better configuration of this value?
 575 |     |         uint requiredTimePassedForStake = 1;
 576 |     |         if (timeDelta >= requiredTimePassedForStake) {
 577 |     |             pool.stakedLiquidity = Assembly.addSignedDelta(pool.stakedLiquidity, pool.stakedLiquidityDelta);
 578 |     |             pool.stakedLiquidityDelta = 0;
 579 |     |         }
 580 |     | 
 581 |     |         if (pool.lastTick != tick) pool.lastTick = tick;
 582 |     |         if (pool.lastPrice != price) pool.lastPrice = price.safeCastTo128();
 583 |     |         if (pool.liquidity != liquidity) pool.liquidity = liquidity.safeCastTo128();
 584 |     |         if (pool.lastTimestamp != timestamp) pool.syncPoolTimestamp(timestamp);
 585 |     | 
 586 |     |         pool.feeGrowthGlobalAsset = Assembly.computeCheckpoint(pool.feeGrowthGlobalAsset, feeGrowthGlobalAsset);
 587 |     |         pool.feeGrowthGlobalQuote = Assembly.computeCheckpoint(pool.feeGrowthGlobalQuote, feeGrowthGlobalQuote);
 588 |     |         pool.feeGrowthGlobalReward = Assembly.computeCheckpoint(pool.feeGrowthGlobalReward, feeGrowthGlobalReward);
 589 |     |     }
 590 |     | 
 591 |     |     // ===== Initializing Pools ===== //
 592 |     | 
 593 | *r  |     function _createPair(address asset, address quote) internal returns (uint24 pairId) {
 594 | *r  |         if (asset == quote) revert SameTokenError();
 595 |     | 
 596 | *r  |         pairId = getPairId[asset][quote];
 597 | *r  |         if (pairId != 0) revert PairExists(pairId);
 598 |     | 
 599 | *r  |         (uint8 decimalsAsset, uint8 decimalsQuote) = (IERC20(asset).decimals(), IERC20(quote).decimals());
 600 | *r  |         if (!decimalsAsset.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))
 601 |     |             revert InvalidDecimals(decimalsAsset);
 602 | *r  |         if (!decimalsQuote.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))
 603 |     |             revert InvalidDecimals(decimalsQuote);
 604 |     | 
 605 |     |         unchecked {
 606 | *r  |             pairId = uint24(++getPairNonce);
 607 |     |         }
 608 |     | 
 609 | *r  |         getPairId[asset][quote] = pairId; // note: order of tokens matters!
 610 | *r  |         pairs[pairId] = HyperPair({
 611 |     |             tokenAsset: asset,
 612 |     |             decimalsAsset: decimalsAsset,
 613 |     |             tokenQuote: quote,
 614 |     |             decimalsQuote: decimalsQuote
 615 |     |         });
 616 |     | 
 617 | *r  |         emit CreatePair(pairId, asset, quote, decimalsAsset, decimalsQuote);
 618 |     |     }
 619 |     | 
 620 |     |     /** @dev If pairId == 0, its a magic variable that uses current pair nonce. */
 621 | *   |     function _createPool(
 622 |     |         uint24 pairId,
 623 |     |         address controller,
 624 |     |         uint16 priorityFee,
 625 |     |         uint16 fee,
 626 |     |         uint16 vol,
 627 |     |         uint16 dur,
 628 |     |         uint16 jit,
 629 |     |         int24 max,
 630 |     |         uint128 price
 631 | *   |     ) internal returns (uint64 poolId) {
 632 | *   |         if (price == 0) revert ZeroPrice();
 633 |     | 
 634 | *   |         uint32 timestamp = uint(_blockTimestamp()).safeCastTo32();
 635 | *   |         HyperPool memory pool;
 636 | *   |         pool.controller = controller;
 637 | *   |         pool.lastTimestamp = timestamp;
 638 | *   |         pool.lastPrice = price;
 639 | *   |         pool.lastTick = Price.computeTickWithPrice(pool.lastPrice);
 640 | *   |         bool hasController = pool.controller != address(0);
 641 | *   |         if (hasController && priorityFee == 0) revert InvalidFee(priorityFee); // Cannot set priority to 0.
 642 |     | 
 643 | *   |         uint24 pairNonce = pairId == 0 ? uint24(getPairNonce) : pairId; // magic variable todo: fix, possible to set 0 pairId if getPairNonce is 0
 644 | *   |         pool.pair = pairs[pairNonce];
 645 |     | 
 646 | *   |         HyperCurve memory params = HyperCurve({
 647 |     |             maxTick: max,
 648 | *   |             jit: hasController ? jit : uint8(_liquidityPolicy()),
 649 | *   |             fee: fee,
 650 | *   |             duration: dur,
 651 | *   |             volatility: vol,
 652 | *   |             priorityFee: hasController ? priorityFee : 0, // min fee
 653 | *   |             createdAt: timestamp
 654 |     |         });
 655 | *   |         params.validateParameters();
 656 | *   |         pool.params = params;
 657 |     | 
 658 |     |         uint32 poolNonce;
 659 |     |         unchecked {
 660 | *   |             poolNonce = uint32(++getPoolNonce);
 661 |     |         }
 662 |     | 
 663 | *   |         poolId = Enigma.encodePoolId(pairNonce, hasController, poolNonce);
 664 | *   |         if (pools[poolId].exists()) revert PoolExists(); // todo: poolNonce always increments, so this never gets hit, remove
 665 |     | 
 666 | *   |         pools[poolId] = pool; // effect
 667 |     | 
 668 | *   |         emit CreatePool(poolId, hasController, pool.pair.tokenAsset, pool.pair.tokenQuote, price);
 669 |     |     }
 670 |     | 
 671 | *r  |     function changeParameters(
 672 |     |         uint64 poolId,
 673 |     |         uint16 priorityFee,
 674 |     |         uint16 fee,
 675 |     |         uint16 volatility,
 676 |     |         uint16 duration,
 677 |     |         uint16 jit,
 678 |     |         int24 maxTick
 679 |     |     ) external lock interactions {
 680 | *r  |         HyperPool storage pool = pools[poolId];
 681 | *r  |         if (pool.controller != msg.sender) revert NotController();
 682 |     | 
 683 | *   |         HyperCurve memory modified = pool.params;
 684 | *   |         if (jit != 0) modified.jit = jit;
 685 | *   |         if (maxTick != 0) modified.maxTick = maxTick;
 686 | *   |         if (fee != 0) modified.fee = fee;
 687 | *   |         if (volatility != 0) modified.volatility = volatility;
 688 | *   |         if (duration != 0) modified.duration = duration;
 689 | *   |         if (priorityFee != 0) modified.priorityFee = priorityFee;
 690 |     | 
 691 | *   |         pool.changePoolParameters(modified);
 692 |     | 
 693 | *   |         emit ChangeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
 694 |     |     }
 695 |     | 
 696 |     |     /** @dev Overridable in tests.  */
 697 | r   |     function _blockTimestamp() internal view virtual returns (uint128) {
 698 | *r  |         return uint128(block.timestamp);
 699 |     |     }
 700 |     | 
 701 |     |     /** @dev Overridable in tests.  */
 702 |     |     function _liquidityPolicy() internal view virtual returns (uint256) {
 703 |     |         return JUST_IN_TIME_LIQUIDITY_POLICY;
 704 |     |     }
 705 |     | 
 706 |     |     // ===== Accounting System ===== //
 707 |     |     /**
 708 |     |      * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.
 709 |     |      *
 710 |     |      * @custom:security Directly manipulates reserves.
 711 |     |      */
 712 | *   |     function _increaseReserves(address token, uint256 amount) internal {
 713 | *   |         __account__.increase(token, amount);
 714 | *   |         emit IncreaseReserveBalance(token, amount);
 715 |     |     }
 716 |     | 
 717 |     |     /**
 718 |     |      * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.
 719 |     |      *
 720 |     |      * @custom:security Directly manipulates reserves.
 721 |     |      * @custom:reverts With `InsufficientReserve` if current reserve balance for `token` iss less than `amount`.
 722 |     |      */
 723 | *r  |     function _decreaseReserves(address token, uint256 amount) internal {
 724 | *r  |         __account__.decrease(token, amount);
 725 | *r  |         emit DecreaseReserveBalance(token, amount);
 726 |     |     }
 727 |     | 
 728 |     |     /**
 729 |     |      * @dev A positive credit is a receivable paid to the `msg.sender` internal balance.
 730 |     |      *      Positive credits are only applied to the internal balance of the account.
 731 |     |      *      Therefore, it does not require a state change for the global reserves.
 732 |     |      *
 733 |     |      * @custom:security Directly manipulates intrernal balances.
 734 |     |      */
 735 | *r  |     function _applyCredit(address token, uint256 amount) internal {
 736 |     |         __account__.credit(msg.sender, token, amount);
 737 | *r  |         emit IncreaseUserBalance(msg.sender, token, amount);
 738 |     |     }
 739 |     | 
 740 |     |     /**
 741 |     |      * @dev A positive debit is a cost that must be paid for a transaction to be processed.
 742 |     |      *      If a balance exists for the token for the internal balance of `msg.sender`,
 743 |     |      *      it will be used to pay the debit. Else, the contract expects tokens to be transferred in.
 744 |     |      *
 745 |     |      * @custom:security Directly manipulates intrernal balances.
 746 |     |      */
 747 | *r  |     function _applyDebit(address token, uint256 amount) internal {
 748 | *r  |         __account__.debit(msg.sender, token, amount);
 749 | *r  |         emit DecreaseUserBalance(msg.sender, token, amount);
 750 |     |     }
 751 |     | 
 752 |     |     /**
 753 |     |      * @dev Alternative entrypoint to execute functions.
 754 |     |      * @param data Encoded Enigma data. First byte must be an Enigma instruction.
 755 |     |      */
 756 | *r  |     function _process(bytes calldata data) internal {
 757 | *r  |         (, bytes1 instruction) = Assembly.separate(data[0]); // Upper byte is useMax, lower byte is instruction.
 758 |     | 
 759 | *r  |         if (instruction == Enigma.ALLOCATE) {
 760 |     |             (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeAllocate(data);
 761 |     |             _allocate(useMax == 1, poolId, deltaLiquidity);
 762 | *r  |         } else if (instruction == Enigma.UNALLOCATE) {
 763 |     |             (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnallocate(data);
 764 |     |             _unallocate(useMax == 1, poolId, deltaLiquidity);
 765 | *r  |         } else if (instruction == Enigma.SWAP) {
 766 |     |             Order memory args;
 767 |     |             (args.useMax, args.poolId, args.input, args.limit, args.direction) = Enigma.decodeSwap(data);
 768 |     |             _swapExactIn(args);
 769 | *r  |         } else if (instruction == Enigma.STAKE_POSITION) {
 770 | r   |             (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeStakePosition(data);
 771 | *r  |             _stake(poolId, deltaLiquidity);
 772 | *r  |         } else if (instruction == Enigma.UNSTAKE_POSITION) {
 773 |     |             (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnstakePosition(data);
 774 | *r  |             _unstake(poolId, deltaLiquidity);
 775 | *r  |         } else if (instruction == Enigma.CREATE_POOL) {
 776 | *   |             (
 777 | *   |                 uint24 pairId,
 778 | *   |                 address controller,
 779 | *   |                 uint16 priorityFee,
 780 | *   |                 uint16 fee,
 781 | *   |                 uint16 vol,
 782 | *   |                 uint16 dur,
 783 | *   |                 uint16 jit,
 784 | *   |                 int24 max,
 785 | *   |                 uint128 price
 786 | *   |             ) = Enigma.decodeCreatePool(data);
 787 | *   |             _createPool(pairId, controller, priorityFee, fee, vol, dur, jit, max, price);
 788 | *r  |         } else if (instruction == Enigma.CREATE_PAIR) {
 789 | *r  |             (address asset, address quote) = Enigma.decodeCreatePair(data);
 790 | *r  |             _createPair(asset, quote);
 791 |     |         } else {
 792 |     |             revert InvalidInstruction();
 793 |     |         }
 794 |     |     }
 795 |     | 
 796 |     |     /**
 797 |     | 
 798 |     |         Be aware of these settlement invariants:
 799 |     | 
 800 |     |         Invariant 1. Every token that is interacted with is cached and exists.
 801 |     |         Invariant 2. Tokens are removed from cache, and cache is empty by end of settlement.
 802 |     |         Invariant 3. Cached tokens cannot be carried over from previous transactions.
 803 |     |         Invariant 4. Execution does not exit during the loops prematurely.
 804 |     |         Invariant 5. Account `settled` bool is set to true at end of `settlement`.
 805 |     |         Invariant 6. Debits reduce `reserves` of `token`.
 806 |     | 
 807 |     |      */
 808 | *r  |     function _settlement() internal {
 809 | *r  |         if (!__account__.prepared) revert OS.NotPreparedToSettle();
 810 |     | 
 811 | *r  |         address[] memory tokens = __account__.warm;
 812 | *r  |         uint256 loops = tokens.length;
 813 | *r  |         if (loops == 0) return __account__.reset(); // exit early.
 814 |     | 
 815 | *r  |         uint x;
 816 | *r  |         uint i = loops;
 817 | *r  |         do {
 818 |     |             // Loop backwards to pop tokens off.
 819 | *r  |             address token = tokens[i - 1];
 820 |     |             // Apply credits or debits to net balance.
 821 | *r  |             (uint credited, uint debited, uint remainder) = __account__.settle(token, address(this));
 822 |     |             // Reserves were increased, we paid a debit, therefore need to decrease reserves by `debited` amount.
 823 | *r  |             if (debited > 0) {
 824 | r   |                 emit DecreaseUserBalance(msg.sender, token, debited);
 825 | r   |                 emit DecreaseReserveBalance(token, debited);
 826 |     |             }
 827 |     |             // Reserves were not tracking some tokens, increase the reserves to account for them.
 828 | *r  |             if (credited > 0) {
 829 | *r  |                 emit IncreaseUserBalance(msg.sender, token, credited);
 830 | *r  |                 emit IncreaseReserveBalance(token, credited);
 831 |     |             }
 832 |     |             // Outstanding amount must be transferred in.
 833 | *r  |             if (remainder > 0) _payments.push(Payment({token: token, amount: remainder}));
 834 |     |             // Token accounted for.
 835 | *r  |             __account__.warm.pop();
 836 |     |             unchecked {
 837 | *r  |                 --i;
 838 | *r  |                 ++x;
 839 |     |             }
 840 | *r  |         } while (i != 0);
 841 |     | 
 842 | *r  |         Payment[] memory payments = _payments;
 843 |     | 
 844 | *r  |         uint px = payments.length;
 845 | *r  |         while (px != 0) {
 846 | r   |             uint index = px - 1;
 847 | r   |             OS.__dangerousTransferFrom__(payments[index].token, address(this), payments[index].amount);
 848 |     |             unchecked {
 849 |     |                 --px;
 850 |     |             }
 851 |     |         }
 852 |     | 
 853 | *r  |         __account__.reset();
 854 | *r  |         delete _payments;
 855 |     |     }
 856 |     | 
 857 |     |     // ===== View ===== //
 858 |     | 
 859 |     |     /** @dev Can be manipulated. */
 860 | *r  |     function getLatestPrice(uint64 poolId) public view returns (uint price) {
 861 | *r  |         (price, , ) = _computeSyncedPrice(poolId);
 862 |     |     }
 863 |     | 
 864 | *r  |     function getTimePassed(uint64 poolId) public view returns (uint) {
 865 | *r  |         return _blockTimestamp() - pools[poolId].lastTimestamp;
 866 |     |     }
 867 |     | 
 868 | *r  |     function getVirtualReserves(uint64 poolId) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {
 869 | *   |         return pools[poolId].getVirtualReserves();
 870 |     |     }
 871 |     | 
 872 | *r  |     function getMaxLiquidity(
 873 |     |         uint64 poolId,
 874 |     |         uint deltaAsset,
 875 |     |         uint deltaQuote
 876 | r   |     ) public view override returns (uint128 deltaLiquidity) {
 877 | *r  |         return pools[poolId].getMaxLiquidity(deltaAsset, deltaQuote);
 878 |     |     }
 879 |     | 
 880 | *r  |     function getLiquidityDeltas(
 881 |     |         uint64 poolId,
 882 |     |         int128 deltaLiquidity
 883 | *r  |     ) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {
 884 | *r  |         return pools[poolId].getLiquidityDeltas(deltaLiquidity);
 885 |     |     }
 886 |     | 
 887 | *r  |     function getAmounts(uint64 poolId) public view override returns (uint256 deltaAsset, uint256 deltaQuote) {
 888 | *r  |         return pools[poolId].getAmounts();
 889 |     |     }
 890 |     | 
 891 | r   |     function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) public view returns (uint output) {
 892 | r   |         uint24 pairId = Enigma.decodePairIdFromPoolId(poolId);
 893 | r   |         HyperPool memory pool = pools[poolId];
 894 | r   |         (output, ) = pool.getAmountOut({
 895 | r   |             pair: pairs[pairId],
 896 | r   |             sellAsset: sellAsset,
 897 | r   |             amountIn: amountIn,
 898 | r   |             timeSinceUpdate: _blockTimestamp() - pool.lastTimestamp // invariant: should not underflow.
 899 |     |         });
 900 |     |     }
 901 |     | }
 902 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/HyperLib.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     | 
   8 |     |   Comprehensive library with all structs, errors,
   9 |     |   constants, and utils for Hyper.
  10 |     | 
  11 |     |   -------------
  12 |     | 
  13 |     |   Primitive™
  14 |     | 
  15 |     |  */
  16 |     | 
  17 |     | import "solmate/utils/SafeCastLib.sol";
  18 |     | import "./libraries/Price.sol";
  19 |     | import "./Assembly.sol" as Assembly;
  20 |     | import "./Enigma.sol" as Enigma;
  21 |     | import "./OS.sol" as OS;
  22 |     | 
  23 |     | using Price for Price.RMM;
  24 |     | using SafeCastLib for uint;
  25 |     | using FixedPointMathLib for uint;
  26 |     | using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;
  27 |     | using {checkParameters, maturity, strike, validateParameters} for HyperCurve global;
  28 |     | using {changePositionLiquidity, syncPositionFees, getTimeSinceChanged, syncPositionStakedFees} for HyperPosition global;
  29 |     | using {
  30 |     |     changePoolLiquidity,
  31 |     |     changePoolParameters,
  32 |     |     computePriceChangeWithTime,
  33 |     |     exists,
  34 |     |     getAmounts,
  35 |     |     getAmountOut,
  36 |     |     getAmountsWad,
  37 |     |     getLiquidityDeltas,
  38 |     |     getMaxLiquidity,
  39 |     |     getMaxSwapAssetInWad,
  40 |     |     getMaxSwapQuoteInWad,
  41 |     |     getRMM,
  42 |     |     getVirtualReserves,
  43 |     |     isMutable,
  44 |     |     syncPoolTimestamp,
  45 |     |     lastTau,
  46 |     |     tau
  47 |     | } for HyperPool global;
  48 |     | 
  49 | *   | int24 constant MAX_TICK = 887272;
  50 |     | uint256 constant BUFFER = 300 seconds;
  51 | *   | uint256 constant MIN_FEE = 1; // 0.01%
  52 | *   | uint256 constant MAX_FEE = 1000; // 10%
  53 | *   | uint256 constant MIN_VOLATILITY = 100; // 1%
  54 | *   | uint256 constant MAX_VOLATILITY = 25_000; // 250%
  55 | *   | uint256 constant MIN_DURATION = 1; // days, but without units
  56 | *   | uint256 constant MAX_DURATION = 500; // days, but without units
  57 | *   | uint256 constant JUST_IN_TIME_MAX = 600 seconds;
  58 | *   | uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;
  59 |     | 
  60 |     | // todo: add selectors for debugging?
  61 |     | error DrawBalance();
  62 |     | error InsufficientPosition(uint64 poolId);
  63 |     | error InvalidDecimals(uint8 decimals);
  64 |     | error InvalidDuration(uint16);
  65 |     | error InvalidFee(uint16 fee);
  66 |     | error InvalidInstruction();
  67 |     | error InvalidInvariant(int256 prev, int256 next);
  68 |     | error InvalidJit(uint16);
  69 |     | error InvalidReentrancy();
  70 |     | error InvalidReward();
  71 |     | error InvalidSettlement();
  72 |     | error InvalidStrike(uint128 strike);
  73 |     | error InvalidTick(int24);
  74 |     | error InvalidTransfer();
  75 |     | error InvalidVolatility(uint24 sigma); // todo: fix, use uint16 type.
  76 |     | error JitLiquidity(uint256 distance);
  77 |     | error MaxFee(uint16 fee);
  78 |     | error NotController();
  79 |     | error NonExistentPool(uint64 poolId);
  80 |     | error NonExistentPosition(address owner, uint64 poolId);
  81 |     | error PairExists(uint24 pairId);
  82 |     | error PerLiquidityError(uint256 deltaAsset);
  83 |     | error PoolExists();
  84 |     | error PoolExpired();
  85 |     | error PositionStaked(uint96 positionId);
  86 |     | error PositionZeroLiquidity(uint96 positionId);
  87 |     | error PositionNotStaked(uint96 positionId);
  88 |     | error SameTokenError();
  89 |     | error StakeNotMature(uint64 poolId);
  90 |     | error SwapLimitReached();
  91 |     | error ZeroInput();
  92 |     | error ZeroLiquidity();
  93 |     | error ZeroPrice();
  94 |     | error ZeroValue();
  95 |     | 
  96 |     | struct HyperPair {
  97 |     |     address tokenAsset;
  98 |     |     uint8 decimalsAsset;
  99 |     |     address tokenQuote;
 100 |     |     uint8 decimalsQuote;
 101 |     | }
 102 |     | 
 103 |     | struct HyperCurve {
 104 |     |     // single slot
 105 |     |     int24 maxTick;
 106 |     |     uint16 jit;
 107 |     |     uint16 fee;
 108 |     |     uint16 duration;
 109 |     |     uint16 volatility;
 110 |     |     uint16 priorityFee;
 111 |     |     uint32 createdAt;
 112 |     | }
 113 |     | 
 114 |     | struct HyperPool {
 115 |     |     int24 lastTick;
 116 |     |     uint32 lastTimestamp; // updated on swaps.
 117 |     |     address controller;
 118 |     |     uint256 feeGrowthGlobalReward;
 119 |     |     uint256 feeGrowthGlobalAsset;
 120 |     |     uint256 feeGrowthGlobalQuote;
 121 |     |     uint128 lastPrice;
 122 |     |     uint128 liquidity; // available liquidity to remove
 123 |     |     uint128 stakedLiquidity; // locked liquidity
 124 |     |     int128 stakedLiquidityDelta; // liquidity to be added or removed
 125 |     |     HyperCurve params;
 126 |     |     HyperPair pair;
 127 |     | }
 128 |     | 
 129 |     | // todo: optimize slot
 130 |     | struct HyperPosition {
 131 |     |     uint128 freeLiquidity;
 132 |     |     uint128 stakedLiquidity;
 133 |     |     uint256 lastTimestamp;
 134 |     |     uint256 stakeTimestamp;
 135 |     |     uint256 unstakeTimestamp;
 136 |     |     uint256 feeGrowthRewardLast;
 137 |     |     uint256 feeGrowthAssetLast;
 138 |     |     uint256 feeGrowthQuoteLast;
 139 |     |     uint128 tokensOwedAsset;
 140 |     |     uint128 tokensOwedQuote;
 141 |     |     uint128 tokensOwedReward;
 142 |     | }
 143 |     | 
 144 |     | struct ChangeLiquidityParams {
 145 |     |     address owner;
 146 |     |     uint64 poolId;
 147 |     |     uint256 timestamp;
 148 |     |     uint256 deltaAsset;
 149 |     |     uint256 deltaQuote;
 150 |     |     address tokenAsset;
 151 |     |     address tokenQuote;
 152 |     |     int128 deltaLiquidity;
 153 |     | }
 154 |     | 
 155 |     | struct Order {
 156 |     |     uint8 useMax;
 157 |     |     uint64 poolId;
 158 |     |     uint128 input;
 159 |     |     uint128 limit;
 160 |     |     uint8 direction;
 161 |     | }
 162 |     | 
 163 |     | struct Iteration {
 164 |     |     int24 tick;
 165 |     |     uint256 price;
 166 |     |     uint256 remainder;
 167 |     |     uint256 feeAmount;
 168 |     |     uint256 liquidity;
 169 |     |     uint256 input;
 170 |     |     uint256 output;
 171 |     | }
 172 |     | 
 173 |     | struct SwapState {
 174 |     |     bool sell;
 175 |     |     address tokenInput;
 176 |     |     address tokenOutput;
 177 |     |     uint256 fee;
 178 |     |     uint256 feeGrowthGlobal;
 179 |     |     uint256 priorityFeeGrowthGlobal;
 180 |     | }
 181 |     | 
 182 |     | struct Payment {
 183 |     |     address token;
 184 |     |     uint amount;
 185 |     | }
 186 | *   | 
 187 |     | function changePoolLiquidity(HyperPool storage self, int128 liquidityDelta) {
 188 | *   |     self.liquidity = Assembly.addSignedDelta(self.liquidity, liquidityDelta);
 189 |     | }
 190 |     | 
 191 |     | function syncPoolTimestamp(HyperPool storage self, uint timestamp) {
 192 |     |     self.lastTimestamp = SafeCastLib.safeCastTo32(timestamp);
 193 |     | }
 194 | *   | 
 195 |     | function changePoolParameters(HyperPool storage self, HyperCurve memory updated) {
 196 | *   |     (bool success, ) = updated.validateParameters();
 197 | *   |     self.params = updated;
 198 | *   |     assert(success);
 199 |     | }
 200 | *   | 
 201 |     | function changePositionLiquidity(HyperPosition storage self, uint256 timestamp, int128 liquidityDelta) {
 202 | *   |     self.lastTimestamp = timestamp;
 203 | *   |     self.freeLiquidity = Assembly.addSignedDelta(self.freeLiquidity, liquidityDelta);
 204 |     | }
 205 |     | 
 206 | *   | /** @dev Liquidity must be altered after syncing positions and not before. */
 207 |     | function syncPositionFees(
 208 |     |     HyperPosition storage self,
 209 |     |     uint liquidity,
 210 |     |     uint feeGrowthAsset,
 211 |     |     uint feeGrowthQuote
 212 | *   | ) returns (uint feeAssetEarned, uint feeQuoteEarned) {
 213 | *   |     uint checkpointAsset = Assembly.computeCheckpointDistance(feeGrowthAsset, self.feeGrowthAssetLast);
 214 | *   |     uint checkpointQuote = Assembly.computeCheckpointDistance(feeGrowthQuote, self.feeGrowthQuoteLast);
 215 |     | 
 216 | *   |     feeAssetEarned = FixedPointMathLib.mulWadDown(checkpointAsset, liquidity);
 217 | *   |     feeQuoteEarned = FixedPointMathLib.mulWadDown(checkpointQuote, liquidity);
 218 |     | 
 219 | *   |     self.feeGrowthAssetLast = feeGrowthAsset;
 220 | *   |     self.feeGrowthQuoteLast = feeGrowthQuote;
 221 |     | 
 222 | *   |     self.tokensOwedAsset += SafeCastLib.safeCastTo128(feeAssetEarned);
 223 | *   |     self.tokensOwedQuote += SafeCastLib.safeCastTo128(feeQuoteEarned);
 224 |     | }
 225 |     | 
 226 |     | function syncPositionStakedFees(HyperPosition storage self, uint liquidity, uint feeGrowth) returns (uint feeEarned) {
 227 |     |     uint checkpoint = Assembly.computeCheckpointDistance(feeGrowth, self.feeGrowthRewardLast);
 228 |     |     feeEarned = FixedPointMathLib.mulWadDown(checkpoint, liquidity);
 229 |     |     self.feeGrowthRewardLast = feeEarned;
 230 |     |     self.tokensOwedReward += SafeCastLib.safeCastTo128(feeEarned);
 231 |     | }
 232 |     | 
 233 |     | // ===== View ===== //
 234 | *   | 
 235 | *   | function getVirtualReserves(HyperPool memory self) view returns (uint128 reserveAsset, uint128 reserveQuote) {
 236 | *   |     return self.getLiquidityDeltas(-int128(self.liquidity)); // rounds down
 237 |     | }
 238 | r   | 
 239 |     | function getMaxLiquidity(
 240 |     |     HyperPool memory self,
 241 |     |     uint deltaAsset,
 242 |     |     uint deltaQuote
 243 | r   | ) view returns (uint128 deltaLiquidity) {
 244 | r   |     (uint amountAsset, uint amountQuote) = self.getAmounts();
 245 | r   |     uint liquidity0 = deltaAsset.divWadDown(amountAsset);
 246 |     |     uint liquidity1 = deltaQuote.divWadDown(amountQuote);
 247 |     |     deltaLiquidity = (liquidity0 < liquidity1 ? liquidity0 : liquidity1).safeCastTo128();
 248 |     | }
 249 |     | 
 250 | *r  | /** @dev Rounds positive deltas up. Rounds negative deltas down. */
 251 |     | function getLiquidityDeltas(
 252 |     |     HyperPool memory self,
 253 |     |     int128 deltaLiquidity
 254 | *r  | ) view returns (uint128 deltaAsset, uint128 deltaQuote) {
 255 | *r  |     if (deltaLiquidity == 0) return (deltaAsset, deltaQuote);
 256 | *r  |     (uint amountAsset, uint amountQuote) = self.getAmounts();
 257 |     | 
 258 | *r  |     uint delta;
 259 | *r  |     if (deltaLiquidity > 0) {
 260 | *   |         delta = uint128(deltaLiquidity);
 261 | *   |         deltaAsset = amountAsset.mulWadUp(delta).safeCastTo128();
 262 | *   |         deltaQuote = amountQuote.mulWadUp(delta).safeCastTo128();
 263 |     |     } else {
 264 | *r  |         delta = uint128(-deltaLiquidity);
 265 | *   |         deltaAsset = amountAsset.mulWadDown(delta).safeCastTo128();
 266 | *   |         deltaQuote = amountQuote.mulWadDown(delta).safeCastTo128();
 267 |     |     }
 268 |     | }
 269 |     | 
 270 | *r  | /** @dev Decimal amounts per WAD of liquidity, rounded down... */
 271 | *r  | function getAmounts(HyperPool memory self) view returns (uint amountAssetDec, uint amountQuoteDec) {
 272 | *r  |     (uint amountAssetWad, uint amountQuoteWad) = self.getAmountsWad();
 273 | *r  |     amountAssetDec = amountAssetWad.scaleFromWadDown(self.pair.decimalsAsset);
 274 | *r  |     amountQuoteDec = amountQuoteWad.scaleFromWadDown(self.pair.decimalsQuote);
 275 |     | }
 276 |     | 
 277 | *r  | /** @dev WAD Amounts per WAD of liquidity. */
 278 | *r  | function getAmountsWad(HyperPool memory self) view returns (uint amountAssetWad, uint amountQuoteWad) {
 279 | *r  |     Price.RMM memory rmm = self.getRMM();
 280 | *r  |     amountAssetWad = rmm.getXWithPrice(self.lastPrice);
 281 | *r  |     amountQuoteWad = rmm.getYWithX(amountAssetWad);
 282 |     | }
 283 |     | 
 284 |     | // ===== Derived ===== //
 285 | *r  | 
 286 |     | function computePriceChangeWithTime(
 287 |     |     HyperPool memory self,
 288 |     |     uint timeRemaining,
 289 |     |     uint epsilon
 290 | *r  | ) pure returns (uint price, int24 tick) {
 291 | *r  |     uint maxPrice = Price.computePriceWithTick(self.params.maxTick);
 292 | *r  |     price = Price.computePriceWithChangeInTau(maxPrice, self.params.volatility, self.lastPrice, timeRemaining, epsilon);
 293 | *r  |     tick = Price.computeTickWithPrice(price);
 294 |     | }
 295 | *   | 
 296 | *   | function getTimeSinceChanged(HyperPosition memory self, uint timestamp) view returns (uint distance) {
 297 | *   |     return timestamp - self.lastTimestamp;
 298 |     | }
 299 | *r  | 
 300 |     | function exists(HyperPool memory self) view returns (bool) {
 301 | *r  |     return self.lastTimestamp != 0;
 302 |     | }
 303 | *   | 
 304 |     | function isMutable(HyperPool memory self) view returns (bool) {
 305 | *r  |     return self.controller != address(0);
 306 |     | }
 307 | *r  | 
 308 | *r  | function getRMM(HyperPool memory self) view returns (Price.RMM memory) {
 309 | *r  |     return Price.RMM({strike: self.params.strike(), sigma: self.params.volatility, tau: self.lastTau()});
 310 |     | }
 311 | *r  | 
 312 | *r  | function lastTau(HyperPool memory self) view returns (uint) {
 313 | *r  |     return self.tau(self.lastTimestamp);
 314 |     | }
 315 | *r  | 
 316 | *r  | function tau(HyperPool memory self, uint timestamp) view returns (uint) {
 317 | *r  |     uint end = self.params.maturity();
 318 | *r  |     if (timestamp > end) return 0;
 319 | *r  |     return end - timestamp;
 320 |     | }
 321 | *r  | 
 322 | *r  | function strike(HyperCurve memory self) view returns (uint) {
 323 | *r  |     return Price.computePriceWithTick(self.maxTick);
 324 |     | }
 325 | *r  | 
 326 | *r  | function maturity(HyperCurve memory self) view returns (uint32 endTimestamp) {
 327 | *r  |     return (Assembly.convertDaysToSeconds(self.duration) + self.createdAt).safeCastTo32();
 328 |     | }
 329 | *   | 
 330 | *   | function validateParameters(HyperCurve memory self) view returns (bool, bytes memory) {
 331 | *   |     (bool success, bytes memory reason) = self.checkParameters();
 332 | *   |     if (!success) {
 333 |     |         assembly {
 334 |     |             revert(add(32, reason), mload(reason))
 335 |     |         }
 336 |     |     }
 337 |     | 
 338 | *   |     return (success, reason);
 339 |     | }
 340 |     | 
 341 | *   | /** @dev Invalid parameters should revert. */
 342 | *   | function checkParameters(HyperCurve memory self) view returns (bool, bytes memory) {
 343 | *   |     if (!Assembly.isBetween(self.volatility, MIN_VOLATILITY, MAX_VOLATILITY))
 344 |     |         return (false, abi.encodeWithSelector(InvalidVolatility.selector, self.volatility));
 345 | *   |     if (!Assembly.isBetween(self.duration, MIN_DURATION, MAX_DURATION))
 346 |     |         return (false, abi.encodeWithSelector(InvalidDuration.selector, self.duration));
 347 | *   |     if (self.maxTick >= MAX_TICK) return (false, abi.encodeWithSelector(InvalidTick.selector, self.maxTick)); //  todo: fix, min tick check?
 348 | *   |     if (self.jit > JUST_IN_TIME_MAX) return (false, abi.encodeWithSelector(InvalidJit.selector, self.jit));
 349 | *   |     if (!Assembly.isBetween(self.fee, MIN_FEE, MAX_FEE))
 350 |     |         return (false, abi.encodeWithSelector(InvalidFee.selector, self.fee));
 351 |     |     // 0 priority fee == no controller, impossible to set to zero unless default from non controlled pools.
 352 | *   |     if (!Assembly.isBetween(self.priorityFee, 0, self.fee))
 353 |     |         return (false, abi.encodeWithSelector(InvalidFee.selector, self.priorityFee));
 354 |     | 
 355 | *   |     return (true, "");
 356 |     | }
 357 |     | 
 358 |     | // ===== Swaps ===== //
 359 |     | 
 360 |     | function getMaxSwapAssetInWad(HyperPool memory self) view returns (uint) {
 361 |     |     Price.RMM memory rmm = self.getRMM();
 362 |     |     (, uint res1) = rmm.computeReserves(self.lastPrice);
 363 |     |     uint maxInput = FixedPointMathLib.WAD - res1;
 364 |     |     maxInput = maxInput.mulWadDown(self.liquidity);
 365 |     |     return maxInput.scaleFromWadDown(self.pair.decimalsAsset);
 366 |     | }
 367 |     | 
 368 |     | function getMaxSwapQuoteInWad(HyperPool memory self) view returns (uint) {
 369 |     |     Price.RMM memory rmm = self.getRMM();
 370 |     |     (uint res0, ) = rmm.computeReserves(self.lastPrice);
 371 |     |     uint maxInput = rmm.strike - res0;
 372 |     |     maxInput = maxInput.mulWadDown(self.liquidity);
 373 |     |     return maxInput.scaleFromWadDown(self.pair.decimalsQuote);
 374 |     | }
 375 | r   | 
 376 |     | function getAmountOut(
 377 |     |     HyperPool memory self,
 378 |     |     HyperPair memory pair,
 379 |     |     bool sellAsset,
 380 |     |     uint amountIn,
 381 |     |     uint timeSinceUpdate
 382 | r   | ) view returns (uint, uint) {
 383 | r   |     Iteration memory data;
 384 | r   |     Price.RMM memory rmm = self.getRMM();
 385 | r   |     (data.price, data.tick) = self.computePriceChangeWithTime(self.lastTau(), timeSinceUpdate);
 386 | r   |     data.remainder = amountIn.scaleToWad(sellAsset ? pair.decimalsAsset : pair.decimalsQuote);
 387 | r   |     data.liquidity = self.liquidity;
 388 |     | 
 389 |     |     uint prevInd;
 390 |     |     uint prevDep;
 391 |     |     uint nextInd;
 392 |     |     uint nextDep;
 393 |     | 
 394 |     |     {
 395 |     |         uint maxInput;
 396 |     |         uint delInput;
 397 |     | 
 398 | r   |         if (sellAsset) {
 399 | r   |             (prevDep, prevInd) = rmm.computeReserves(data.price);
 400 | r   |             maxInput = (FixedPointMathLib.WAD - prevInd).mulWadDown(self.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.
 401 |     |         } else {
 402 | r   |             (prevInd, prevDep) = rmm.computeReserves(data.price);
 403 | r   |             maxInput = (rmm.strike - prevInd).mulWadDown(self.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.
 404 |     |         }
 405 |     | 
 406 | r   |         data.feeAmount = ((data.remainder > maxInput ? maxInput : data.remainder) * self.params.fee) / 10_000;
 407 |     | 
 408 | r   |         if (data.remainder > maxInput) {
 409 | r   |             delInput = maxInput - data.feeAmount;
 410 | r   |             nextInd = prevInd + delInput.divWadDown(data.liquidity);
 411 |     |             data.remainder -= (delInput + data.feeAmount);
 412 |     |         } else {
 413 |     |             delInput = data.remainder - data.feeAmount;
 414 |     |             nextInd = prevInd + delInput.divWadDown(data.liquidity);
 415 |     |             delInput = data.remainder; // Swap input amount including the fee payment.
 416 |     |             data.remainder = 0; // Clear the remainder to zero, as the order has been filled.
 417 |     |         }
 418 |     | 
 419 |     |         // Compute the output of the swap by computing the difference between the dependent reserves.
 420 |     |         if (sellAsset) nextDep = rmm.getYWithX(nextInd);
 421 |     |         else nextDep = rmm.getXWithY(nextInd);
 422 |     | 
 423 |     |         data.input += delInput;
 424 |     |         data.output += (prevDep - nextDep);
 425 |     |     }
 426 |     | 
 427 |     |     {
 428 |     |         // Scale down amounts from WAD.
 429 |     |         uint inputDec;
 430 |     |         uint outputDec;
 431 |     |         if (sellAsset) {
 432 |     |             inputDec = pair.decimalsAsset;
 433 |     |             outputDec = pair.decimalsQuote;
 434 |     |         } else {
 435 |     |             inputDec = pair.decimalsQuote;
 436 |     |             outputDec = pair.decimalsAsset;
 437 |     |         }
 438 |     | 
 439 |     |         data.input = data.input.scaleFromWadUp(inputDec);
 440 |     |         data.output = data.output.scaleFromWadDown(outputDec);
 441 |     |     }
 442 |     | 
 443 |     |     return (data.output, data.remainder);
 444 |     | }
 445 | *r  | 
 446 | *r  | function toInt128(uint128 a) pure returns (int128 b) {
 447 |     |     assembly {
 448 | *r  |         if gt(a, 0x7fffffffffffffffffffffffffffffff) {
 449 |     |             revert(0, 0)
 450 |     |         }
 451 |     | 
 452 |     |         b := a
 453 |     |     }
 454 |     | }
 455 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/OS.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     |   
   8 |     |   This is a custom account system to support Enigma's
   9 |     |   jump processing. Without jump processing, the benefits 
  10 |     |   are marginal at best. Combining the two reduces the 
  11 |     |   marginal cost of aditional operations to only ~20% of a single operation. 
  12 |     |   This is by design, in order to support a system that interacts with a lot
  13 |     |   of different parameters, tokens, actors, and pools.
  14 |     | 
  15 |     |   -------------
  16 |     | 
  17 |     |   Glossary:
  18 |     | 
  19 |     |   Virtual Reserves  - Expected balance of tokens.
  20 |     |   Physical Reserves - Actual balance of tokens.
  21 |     |   Net Balance       - Difference of physical reserve and virtual reserve.
  22 |     |   Credit            - Increase (+) spendable tokens.
  23 |     |   Debit             - Decrease (-) spendable tokens.
  24 |     |   Settle            - Apply net balance (+/-) as credit (+) or debit (-) to user.
  25 |     | 
  26 |     |   -------------
  27 |     | 
  28 |     |   Primitive™
  29 |     | 
  30 |     |  */
  31 |     | 
  32 |     | import "solmate/utils/SafeTransferLib.sol";
  33 |     | import "./interfaces/IWETH.sol";
  34 |     | import "./interfaces/IERC20.sol";
  35 |     | import "./Assembly.sol" as Assembly;
  36 |     | 
  37 |     | using {
  38 |     |     __wrapEther__,
  39 |     |     dangerousFund,
  40 |     |     cache,
  41 |     |     credit,
  42 |     |     debit,
  43 |     |     decrease,
  44 |     |     increase,
  45 |     |     reset,
  46 |     |     settle,
  47 |     |     touch,
  48 |     |     getNetBalance
  49 |     | } for AccountSystem global;
  50 |     | 
  51 |     | error EtherTransferFail(); // 0x75f42683
  52 |     | error InsufficientReserve(uint amount, uint delta); // 0x315276c9
  53 |     | error InvalidBalance(); // 0xc52e3eff
  54 |     | error NotPreparedToSettle(); // 0xf7cede50
  55 |     | 
  56 |     | struct AccountSystem {
  57 |     |     // user -> token -> internal balance.
  58 |     |     mapping(address => mapping(address => uint)) balances;
  59 |     |     // token -> virtual reserve.
  60 |     |     mapping(address => uint) reserves;
  61 |     |     // token -> cached status. todo: make this a bitmap
  62 |     |     mapping(address => bool) cached;
  63 |     |     // Transiently stored cached tokens, must be length zero outside of execution.
  64 |     |     address[] warm;
  65 |     |     // Must be `false` outside of execution.
  66 |     |     bool prepared;
  67 |     |     // Must be `true` outside of execution.
  68 |     |     bool settled;
  69 |     | }
  70 |     | 
  71 | *r  | /** @dev Gas optimized. */
  72 | *r  | function __balanceOf__(address token, address account) view returns (uint256) {
  73 | *r  |     (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, account));
  74 | *r  |     if (!success || data.length != 32) revert InvalidBalance();
  75 | *r  |     return abi.decode(data, (uint256));
  76 |     | }
  77 |     | 
  78 | *r  | /** @dev Must validate `weth` is real weth. */
  79 |     | function __wrapEther__(AccountSystem storage self, address weth) {
  80 | *r  |     if (msg.value > 0) {
  81 | *r  |         self.touch(weth);
  82 | *r  |         IWETH(weth).deposit{value: msg.value}();
  83 |     |     }
  84 |     | }
  85 |     | 
  86 | *r  | /** @dev Dangerously sends ether to `to` in a low-level call. */
  87 |     | function __dangerousUnwrapEther__(address weth, address to, uint256 amount) {
  88 | *r  |     IWETH(weth).withdraw(amount);
  89 | *r  |     __dangerousTransferEther__(to, amount);
  90 |     | }
  91 |     | 
  92 | *r  | /** @dev Dangerously sends ether to `to` in a low-level call. */
  93 |     | function __dangerousTransferEther__(address to, uint256 value) {
  94 | *r  |     (bool success, ) = to.call{value: value}(new bytes(0));
  95 | *r  |     if (!success) revert EtherTransferFail();
  96 |     | }
  97 |     | 
  98 | *r  | /** @dev External call to the `to` address is dangerous. */
  99 |     | function __dangerousTransferFrom__(address token, address to, uint amount) {
 100 | *r  |     SafeTransferLib.safeTransferFrom(ERC20(token), msg.sender, to, amount);
 101 |     | }
 102 |     | 
 103 | *r  | /** @dev External call to the `to` address is dangerous. */
 104 |     | function dangerousFund(AccountSystem storage self, address token, address to, uint amount) {
 105 | *r  |     self.touch(token);
 106 | *r  |     __dangerousTransferFrom__(token, to, amount); // Settlement gifts tokens to msg.sender.
 107 |     | }
 108 |     | 
 109 | *r  | /** @dev Increases an `owner`'s spendable balance. */
 110 |     | function credit(AccountSystem storage self, address owner, address token, uint amount) {
 111 | *r  |     self.touch(token);
 112 | *r  |     self.balances[owner][token] += amount;
 113 |     | }
 114 |     | 
 115 | *r  | /** @dev Decreases an `owner`'s spendable balance. */
 116 |     | function debit(
 117 |     |     AccountSystem storage self,
 118 |     |     address owner,
 119 |     |     address token,
 120 |     |     uint256 owed
 121 | *r  | ) returns (uint paid, uint remainder) {
 122 | *r  |     self.touch(token);
 123 | *r  |     uint balance = self.balances[owner][token];
 124 | *r  |     if (balance >= owed) {
 125 | *r  |         paid = owed;
 126 | *r  |         self.balances[owner][token] -= paid;
 127 | *r  |         remainder = 0;
 128 |     |     } else {
 129 | r   |         paid = balance;
 130 | r   |         self.balances[owner][token] -= paid;
 131 | r   |         remainder = owed - paid;
 132 |     |     }
 133 |     | }
 134 |     | 
 135 | *   | /** @dev Actives a token and increases the reserves. Settlement will pick up this activated token. */
 136 |     | function increase(AccountSystem storage self, address token, uint amount) {
 137 | *   |     self.touch(token);
 138 | *   |     self.reserves[token] += amount;
 139 |     | }
 140 |     | 
 141 | *r  | /** @dev Actives a token and decreases the reserves. Settlement will pick up this activated token. */
 142 |     | function decrease(AccountSystem storage self, address token, uint amount) {
 143 | *r  |     uint balance = self.reserves[token];
 144 | *r  |     if (amount > balance) revert InsufficientReserve(balance, amount);
 145 |     | 
 146 | *r  |     self.touch(token);
 147 | *r  |     self.reserves[token] -= amount;
 148 |     | }
 149 |     | 
 150 | *r  | /** @notice Settles the difference in balance between virtual tokens and physically held tokens. */
 151 |     | function settle(
 152 |     |     AccountSystem storage self,
 153 |     |     address token,
 154 |     |     address account
 155 | *r  | ) returns (uint credited, uint debited, uint remainder) {
 156 | *r  |     int net = self.getNetBalance(token, account);
 157 | *r  |     if (net > 0) {
 158 | *r  |         credited = uint(net);
 159 |     |         // unaccounted for tokens, e.g. transferred directly into Hyper.
 160 | *r  |         self.credit(msg.sender, token, uint(net)); // gift to `msg.sender`.
 161 | *r  |         self.reserves[token] += uint(net); // add the difference back to reserves, so net is zero.
 162 | *r  |     } else if (net < 0) {
 163 |     |         // missing tokens that must be paid for or transferred in.
 164 | r   |         remainder = uint(-net);
 165 | r   |         (debited, remainder) = self.debit(msg.sender, token, remainder);
 166 | *r  |         if (debited > 0) self.reserves[token] -= debited; // using a balance means tokens are in contract already.
 167 |     |     }
 168 |     | 
 169 | *r  |     delete self.cached[token]; // Note: Assumes this token is completely paid for by the end of the transaction.
 170 |     | }
 171 |     | 
 172 | *r  | /** @dev Interacting with a token will activate it, adding it to an array of interacted tokens for settlement to loop through. */
 173 |     | function touch(AccountSystem storage self, address token) {
 174 | *r  |     if (self.settled) self.settled = false; // If tokens are warm, they are not settled.
 175 | *r  |     if (!self.cached[token]) {
 176 | *r  |         self.warm.push(token);
 177 |     |         self.cache(token, true);
 178 |     |     }
 179 |     |     // do nothing if already cached.
 180 |     | }
 181 |     | 
 182 | *r  | /** @dev Account system is reset after settlement is successful. */
 183 |     | function reset(AccountSystem storage self) {
 184 | *r  |     assert(self.warm.length == 0); // todo: this is a valid assertion, but should we use assert?
 185 | *r  |     self.settled = true;
 186 | *r  |     delete self.warm;
 187 | *r  |     delete self.prepared;
 188 |     | }
 189 |     | 
 190 |     | /** @dev Used to check if a token was already activated after being interacted with again. */
 191 |     | function cache(AccountSystem storage self, address token, bool status) {
 192 | *r  |     self.cached[token] = status;
 193 |     | }
 194 |     | 
 195 | *r  | /** @dev Computes surplus (positive) or deficit (negative) in actual tokens compared to tracked amounts. */
 196 | *r  | function getNetBalance(AccountSystem storage self, address token, address account) view returns (int256 net) {
 197 | *r  |     uint256 internalBalance = self.reserves[token]; // 0
 198 | *r  |     uint256 physicalBalance = __balanceOf__(token, account); // 
 199 | *r  |     net = int256(physicalBalance) - int256(internalBalance); // >0
 200 |     | }
 201 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/echidna/EchidnaE2E.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | import "solmate/tokens/WETH.sol";
   3 |     | import "../test/TestERC20.sol";
   4 |     | import "../Hyper.sol";
   5 |     | import "../Enigma.sol" as ProcessingLib;
   6 |     | import "../../test/helpers/HelperHyperProfiles.sol" as DefaultValues;
   7 |     | import "../../test/helpers/HelperHyperView.sol";
   8 |     | 
   9 | *r  | 
  10 |     | contract EchidnaE2E is HelperHyperView
  11 |     | {
  12 |     | 	WETH _weth;
  13 |     | 	TestERC20 _quote;
  14 |     | 	TestERC20 _asset;
  15 |     | 	Hyper _hyper;
  16 |     | 	uint24 pairId;
  17 |     | 	TestERC20[] hyperTokens;
  18 |     | 	uint64 [] poolIds;
  19 |     | 	bool isPairCreated;
  20 |     | 
  21 |     | 	event AssertionFailed(string msg);
  22 |     | 	event LogUint256(string msg, uint256 value);
  23 |     | 	event LogBytes(string msg, bytes value);
  24 |     | 	event LogAddress(string msg, address tkn);
  25 |     | 	constructor() public {
  26 |     | 		_weth = new WETH();
  27 |     | 		_quote = new TestERC20("6 Decimals","6DEC",6);
  28 |     | 		_asset = new TestERC20("18 Decimals", "18DEC", 18);
  29 |     | 
  30 |     | 		_hyper = new Hyper(address(_weth));
  31 |     | 		
  32 |     | 	}
  33 |     | 	OS.AccountSystem hyperAccount;
  34 |     | 	// ******************** Check Proper System Deployment ********************
  35 | *   | 	function check_proper_deployment() public { 
  36 | *   | 		assert(address(_weth) != address(0));
  37 | *   | 		assert(address(_quote) != address(0));
  38 | *   | 		assert(address(_asset) != address(0));
  39 | *   | 		assert(address(_hyper) != address(0));
  40 |     | 
  41 |     | 		// Note: This invariant may break with tokens on hooks. 
  42 | *   | 		assert(_hyper.locked() == 1);
  43 |     | 
  44 |     | 		// Retrieve the OS.__account__
  45 | *   | 		(bool prepared, bool settled) = _hyper.__account__();
  46 | *   | 		assert(!prepared);
  47 | *   | 		assert(settled);
  48 |     | 
  49 | *   | 		address[] memory warmTokens = _hyper.getWarm();
  50 | *   | 		assert(warmTokens.length == 0);
  51 |     | 	}
  52 |     | 	// ******************** System wide Invariants ********************
  53 | *r  | 	function non_zero_priority_fee_if_controlled(uint64 id) public {
  54 | *r  | 		(HyperPool memory pool,) = retrieve_created_pool(id);
  55 |     | 		// if the pool has a controller, the priority fee should never be zero
  56 | *   | 		if (pool.controller != address(0)) { 
  57 | *   | 			assert(pool.params.priorityFee != 0);
  58 |     | 		}
  59 |     | 	}
  60 |     | 	// The token balance of Hyper should be greater or equal to the reserve for all tokens 
  61 |     | 	// Note: assumption that pairs are created through create_pair invariant test 
  62 |     | 	// which will add the token to the hyperTokens list 
  63 |     | 	// this function is built so that extending the creation of new pairs should not require code changes here
  64 | *   | 	function token_balance_greater_or_equal_reserves() public {
  65 | *   | 		uint256 reserveBalance = 0;
  66 | *   | 		uint256 tokenBalance = 0;
  67 | *   | 		for (uint8 i=0; i<hyperTokens.length; i++){
  68 | *   | 			TestERC20 token = hyperTokens[i];
  69 |     | 			// retrieve reserves of the token and add to tracked reserve balance
  70 | *   | 			reserveBalance = getReserve(address(_hyper),address(token));
  71 |     | 			// get token balance and add to tracked token balance
  72 | *   | 			tokenBalance += token.balanceOf(address(_hyper));
  73 |     | 		}
  74 | *   | 		assert(tokenBalance >= reserveBalance);
  75 |     | 	}		
  76 | *r  | 	function pool_last_price_not_greater_than_strike() public {
  77 | *r  | 		for (uint8 i = 0; i<poolIds.length; i++) {
  78 | r   | 			uint64 poolId = poolIds[i];
  79 | r   | 			HyperPool memory pool = getPool(address(_hyper),poolId);
  80 | r   | 			Price.RMM memory rmm = pool.getRMM();
  81 |     | 
  82 | r   | 			assert(pool.lastPrice <= rmm.strike);
  83 |     | 		}
  84 |     | 	}
  85 |     | 
  86 |     | 	// ******************** Create Pairs ********************
  87 |     | 	/** Future Invariant: This assumes that there is a single pair of _asset and _quote token 
  88 |     | 	        - In the future, can be extended to deploy tokens from here and save the address in a list 
  89 |     | 			which allows echidna to test against different pairs. 
  90 |     | 			- Assumption: 1 pair for now. 
  91 |     | 	 */
  92 | *   | 	function create_token(uint8 decimals) public returns (TestERC20 token){
  93 | *   | 		TestERC20 token = new TestERC20("Token", "TKN", decimals);
  94 | *   | 		assert(token.decimals() == decimals);
  95 |     | 	}
  96 |     | 	/* Future Invariant: This could be extended to create arbitrary pairs. 
  97 |     |     For now for complexity, I am leaving as is. 
  98 |     | 	Test overlapping token pairs
  99 |     | 	*/
 100 | *r  | 	function create_pair_with_default() public { 
 101 |     | 		// require that this specific pair ID does not exist (i.e: this function has not been invoked yet)
 102 | *r  | 		require(!isPairCreated);
 103 |     | 		// without this, Echidna may decide to call the TestERC20.setDecimals 
 104 | *r  | 		require(_quote.decimals() == 6); 
 105 | *r  | 		require(_asset.decimals() == 18);
 106 | *r  | 		uint256 preCreationNonce = _hyper.getPairNonce();
 107 |     | 		
 108 |     | 		// encode createPair arguments and call hyper contract
 109 | *r  | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(_asset), address(_quote));
 110 | *r  |         (bool success, ) = address(_hyper).call(createPairData);
 111 | *r  | 		assert(success);
 112 | *r  | 		pair_id_saved_properly(address(_asset), address(_quote));
 113 |     | 
 114 | *r  | 		uint256 pairNonce = _hyper.getPairNonce();
 115 | *r  | 		assert(pairNonce == preCreationNonce + 1);
 116 |     | 	}
 117 |     | 	/** Future Invariant: This can likely be extended to ensure that pairID's must always match backwards to the tokens saved
 118 |     | 	 */
 119 | *r  | 	function pair_id_saved_properly(address asset, address quote) private {
 120 |     | 		// retrieve recently created pair ID 
 121 | *r  | 		pairId = _hyper.getPairId(address(asset),address(quote));
 122 | *r  | 		if (pairId == 0) {
 123 |     | 			emit LogUint256("PairId Exists", uint256(pairId));
 124 | *r  | 			assert(false);
 125 |     | 		}
 126 |     | 		
 127 |     | 		// retrieve pair information and ensure pair was saved 
 128 | *r  | 		HyperPair memory pair  = getPair(address(_hyper),pairId);
 129 | *r  | 		assert(pair.tokenAsset == address(asset));
 130 | *r  | 		assert(pair.decimalsAsset == TestERC20(asset).decimals());
 131 | *r  | 		assert(pair.tokenQuote == address(quote));
 132 | *r  | 		assert(pair.decimalsQuote == TestERC20(quote).decimals());
 133 |     | 
 134 |     | 		// save internal Echidna state to test against
 135 | *r  | 		isPairCreated = true;
 136 | *r  | 		hyperTokens.push(TestERC20(asset));
 137 | *r  | 		hyperTokens.push(TestERC20(quote));
 138 |     | 	}
 139 | *   | 	function create_same_pair_should_fail() public {
 140 | *   | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(_quote), address(_quote));
 141 | *   |         (bool success, ) = address(_hyper).call(createPairData);
 142 | *   | 		assert(!success);
 143 |     | 	}
 144 | *   | 	function create_pair_with_less_than_min_decimals_should_fail(uint256 decimals) public {
 145 | *   | 		decimals = uint8(between(decimals,0,5));
 146 |     | 		TestERC20 testToken = create_token(uint8(decimals));
 147 |     | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(_quote));
 148 |     |         (bool success, ) = address(_hyper).call(createPairData);
 149 |     | 		assert(!success);
 150 |     | 	}	
 151 | *r  | 	function create_pair_with_more_than_max_decimals_should_fail(uint256 decimals) public {
 152 | *   | 		decimals = uint8(between(decimals,19,type(uint64).max));
 153 | *   | 		TestERC20 testToken = create_token(uint8(decimals));
 154 | *   | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(_quote));
 155 | *   |         (bool success, ) = address(_hyper).call(createPairData);
 156 | *r  | 		assert(!success);
 157 |     | 	}	
 158 |     | 	// ******************** Create Pool ********************
 159 | *   | 	int24 constant MAX_TICK = 887272;
 160 |     | 	uint256 constant BUFFER = 300 seconds;
 161 | *r  | 	uint256 constant MIN_FEE = 1; // 0.01%
 162 | *r  | 	uint256 constant MAX_FEE = 1000; // 10%
 163 | *   | 	uint256 constant MIN_VOLATILITY = 100; // 1%
 164 | *   | 	uint256 constant MAX_VOLATILITY = 25_000; // 250%
 165 | *   | 	uint256 constant MIN_DURATION = 1; // days, but without units
 166 | *   | 	uint256 constant MAX_DURATION = 500; // days, but without units
 167 | *   | 	uint256 constant JUST_IN_TIME_MAX = 600 seconds;
 168 | *   | 	uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;	
 169 |     | 
 170 |     | 	// Create a non controlled pool (controller address is 0) with default pair
 171 |     | 	// Note: This function can be extended to choose from any created pair and create a pool on top of it
 172 | *r  | 	function create_non_controlled_pool(
 173 |     | 		uint16 fee, 
 174 |     | 		int24 maxTick,
 175 |     | 		uint16 volatility, 
 176 |     | 		uint16 duration, 
 177 |     | 		uint128 price
 178 |     | 	) public {
 179 | *r  | 		if(!isPairCreated) { create_pair_with_default(); }
 180 |     | 		{ 
 181 |     | 			// scaling remaining pool creation values
 182 | *   | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
 183 | *   | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
 184 | *   | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
 185 | *   | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
 186 | *   | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
 187 |     | 		}
 188 | *   | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
 189 | *   | 			pairId,
 190 | *   | 			address(0), // no controller 
 191 | *   | 			0, // no priority fee 
 192 | *   | 			fee,
 193 | *   | 			volatility,
 194 | *   | 			duration,
 195 | *   | 			0, // no jit 
 196 | *   | 			maxTick,
 197 | *   | 			price
 198 |     | 		);		
 199 |     | 		{ 
 200 | *   | 			(HyperPool memory pool,uint64 poolId) = execute_create_pool(createPoolData, false);
 201 | *   | 			assert(!pool.isMutable());	
 202 | *   | 			HyperCurve memory curve = pool.params;
 203 | *   | 			assert(pool.lastTimestamp == block.timestamp);
 204 | *   | 			assert(curve.createdAt == block.timestamp);
 205 | *   | 			assert(pool.controller == address(0));
 206 | *   | 			assert(curve.priorityFee == 0);
 207 | *   | 			assert(curve.fee == fee);
 208 | *   | 			assert(curve.volatility == volatility);
 209 | *   | 			assert(curve.duration == duration);
 210 | *   | 			assert(curve.jit == JUST_IN_TIME_LIQUIDITY_POLICY);
 211 | *   | 			assert(curve.maxTick == maxTick);				
 212 |     | 		}
 213 |     | 	}
 214 | *r  | 	function create_controlled_pool(
 215 |     | 		uint16 priorityFee,
 216 |     | 		uint16 fee, 
 217 |     | 		int24 maxTick,
 218 |     | 		uint16 volatility, 
 219 |     | 		uint16 duration, 
 220 |     | 		uint16 jit,
 221 |     | 		uint128 price
 222 | *r  | 	) public {
 223 | *r  | 		if(!isPairCreated) { create_pair_with_default(); }
 224 |     | 		{ 
 225 |     | 			// scaling remaining pool creation values
 226 | *r  | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
 227 | *r  | 			priorityFee = uint16(between(priorityFee, 1, fee));
 228 | *   | 			emit LogUint256("priority fee", uint256(priorityFee));
 229 | *   | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
 230 | *   | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
 231 | *   | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
 232 | *   | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
 233 | *   | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
 234 |     | 		}
 235 | *   | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
 236 | *   | 			pairId,
 237 | *   | 			address(this), //controller
 238 | *   | 			priorityFee, // no priority fee 
 239 | *   | 			fee,
 240 | *   | 			volatility,
 241 | *   | 			duration,
 242 | *   | 			jit, // no jit 
 243 | *   | 			maxTick,
 244 | *   | 			price
 245 |     | 		);		
 246 | *r  | 		{ 
 247 | *   | 			(HyperPool memory pool,uint64 poolId) = execute_create_pool(createPoolData, true);		
 248 | *   | 			assert(pool.isMutable());
 249 | *   | 			HyperCurve memory curve = pool.params;
 250 | *   | 			assert(pool.lastTimestamp == block.timestamp);
 251 | *   | 			assert(curve.createdAt == block.timestamp);
 252 | *   | 			assert(pool.controller == address(this));
 253 | *   | 			assert(curve.priorityFee == priorityFee);
 254 | *   | 			assert(curve.fee == fee);
 255 | *   | 			assert(curve.volatility == volatility);
 256 | *   | 			assert(curve.duration == duration);
 257 | *   | 			assert(curve.jit == jit);
 258 | *r  | 			assert(curve.maxTick == maxTick);
 259 |     | 		}
 260 |     | 	}
 261 | *r  | 	function create_controlled_pool_with_zero_priority_fee_should_fail(
 262 |     | 		uint16 fee, 
 263 |     | 		int24 maxTick,
 264 |     | 		uint16 volatility, 
 265 |     | 		uint16 duration, 
 266 |     | 		uint16 jit,
 267 |     | 		uint128 price
 268 | *   | 	) public {
 269 | *r  | 		if(!isPairCreated) { create_pair_with_default(); }
 270 | *   | 		uint16 priorityFee = 0;
 271 |     | 		{ 
 272 |     | 			// scaling remaining pool creation values
 273 | *   | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
 274 | *   | 			emit LogUint256("priority fee", uint256(priorityFee));
 275 | *   | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
 276 | *   | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
 277 | *   | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
 278 | *   | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
 279 | *   | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
 280 |     | 		}
 281 | *   | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
 282 | *   | 			pairId,
 283 | *   | 			address(this), //controller
 284 | *   | 			priorityFee, // no priority fee 
 285 | *   | 			fee,
 286 | *   | 			volatility,
 287 | *   | 			duration,
 288 | *   | 			jit, // no jit 
 289 | *   | 			maxTick,
 290 | *   | 			price
 291 |     | 		);		
 292 | *   | 		(bool success, ) = address(_hyper).call(createPoolData);
 293 | *   | 		assert(!success);
 294 |     | 	}
 295 | *   | 	function execute_create_pool(
 296 |     | 		bytes memory createPoolData, 
 297 |     | 		bool hasController
 298 | *   | 	) private returns (HyperPool memory pool,uint64 poolId){
 299 | *   | 		uint256 preCreationPoolNonce = _hyper.getPoolNonce();
 300 | *   | 		(bool success, ) = address(_hyper).call(createPoolData);
 301 |     | 
 302 |     | 		// pool nonce should increase by 1 each time a pool is created
 303 | *   | 		uint256 poolNonce = _hyper.getPoolNonce();
 304 | *   | 		assert(poolNonce == preCreationPoolNonce + 1);
 305 |     | 		
 306 |     | 		// pool should be created and exist 
 307 | *   | 		poolId = ProcessingLib.encodePoolId(pairId, hasController, uint32(poolNonce));
 308 | *   | 		pool = getPool(address(_hyper),poolId);
 309 | *   | 		assert(pool.exists());
 310 |     | 
 311 |     | 		// save pools in Echidna
 312 | *   | 		poolIds.push(poolId);
 313 |     | 	}
 314 |     | 	// ******************** Change Pool Parameters ********************	
 315 | *r  | 	function change_parameters(
 316 |     | 		uint256 id,
 317 |     | 		uint16 priorityFee,
 318 |     | 		uint16 fee, 
 319 |     | 		int24 maxTick,
 320 |     | 		uint16 volatility, 
 321 |     | 		uint16 duration, 
 322 |     | 		uint16 jit,
 323 |     | 		uint128 price
 324 | *   | 	) public {
 325 | *r  | 		(HyperPool memory preChangeState,uint64 poolId) = retrieve_created_pool(id);
 326 | *r  | 		emit LogUint256("created pools",poolIds.length);
 327 | *r  | 		emit LogUint256("pool ID",uint256(poolId));
 328 | *r  | 		require(preChangeState.isMutable());
 329 | *   | 		require(preChangeState.controller == address(this));
 330 |     | 		{ 
 331 |     | 			// scaling remaining pool creation values
 332 | *   | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
 333 | *   | 			priorityFee = uint16(between(priorityFee, 1, fee));
 334 | *   | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
 335 | *   | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
 336 | *   | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
 337 | *   | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
 338 | *   | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
 339 |     | 		}
 340 |     | 
 341 | *   | 		_hyper.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
 342 | *   | 		{ 
 343 | *   | 			(HyperPool memory postChangeState,) = retrieve_created_pool(id);
 344 | *   | 			HyperCurve memory preChangeCurve = preChangeState.params;
 345 | *   | 			HyperCurve memory postChangeCurve = postChangeState.params;
 346 | *   | 			assert(postChangeState.lastTimestamp == preChangeState.lastTimestamp); 
 347 | *   | 			assert(postChangeState.controller == address(this));
 348 | *   | 			assert(postChangeCurve.createdAt == preChangeCurve.createdAt);
 349 | *   | 			assert(postChangeCurve.priorityFee == priorityFee);
 350 | *   | 			assert(postChangeCurve.fee == fee);
 351 | *   | 			assert(postChangeCurve.volatility == volatility);
 352 | *   | 			assert(postChangeCurve.duration == duration);
 353 | *   | 			assert(postChangeCurve.jit == jit);
 354 | *   | 			assert(postChangeCurve.maxTick == maxTick);		
 355 |     | 		}
 356 |     | 	}
 357 |     | 	// ******************** Funding ********************	
 358 | *r  | 	function fund_with_correct_preconditions_should_succeed(
 359 |     | 		uint256 assetAmount,
 360 |     | 		uint256 quoteAmount
 361 |     | 	) public {
 362 |     | 		// asset and quote amount > 1
 363 | *r  | 		assetAmount = between(assetAmount,1,type(uint64).max);
 364 | *r  | 		quoteAmount = between(quoteAmount,1,type(uint64).max);
 365 |     | 
 366 | *r  | 		emit LogUint256("assetAmount",assetAmount);
 367 | *r  | 		emit LogUint256("quoteAmount",quoteAmount);
 368 | *r  | 		setup_fund(assetAmount, quoteAmount);
 369 |     | 
 370 | *r  | 		if(_asset.balanceOf(address(this)) < assetAmount) {
 371 |     | 			emit LogUint256("asset balance",_asset.balanceOf(address(this)));
 372 |     | 		}
 373 | *r  | 		if (_quote.balanceOf(address(this)) < quoteAmount) {
 374 |     | 			emit LogUint256("quote balance",_quote.balanceOf(address(this)));			
 375 |     | 		}
 376 |     | 
 377 | *r  | 		fund_token(address(_asset), assetAmount);
 378 | *r  | 		fund_token(address(_quote), quoteAmount);
 379 |     | 	}		
 380 | *r  | 	function fund_with_insufficient_funds_should_fail(uint256 assetAmount, uint256 quoteAmount) public {
 381 | *   | 		assetAmount = between(assetAmount,1,type(uint256).max);
 382 | *   | 		quoteAmount = between(quoteAmount,1,type(uint256).max);
 383 |     | 
 384 | *   | 		try _hyper.fund(address(_asset),assetAmount) {
 385 |     | 			emit AssertionFailed("funding with insufficient funds should fail");
 386 |     | 		} 
 387 |     | 		catch {}
 388 |     | 
 389 |     | 
 390 | *   | 		try _hyper.fund(address(_quote),quoteAmount) {
 391 |     | 			emit AssertionFailed("funding with insufficient quote should fail");
 392 |     | 		}
 393 |     | 		catch {}
 394 |     | 	}
 395 | *r  | 	function fund_with_insufficient_allowance_should_fail(uint256 fundAmount) public {
 396 | *r  | 		uint256 smallAssetAllowance = between(fundAmount,1,fundAmount-1);
 397 |     | 
 398 |     | 		// mint the asset to address(this) and approve some amount < fund
 399 | *r  | 		_asset.mint(address(this),fundAmount);
 400 | *r  | 		_asset.approve(address(_hyper),smallAssetAllowance);
 401 | *r  | 		try _hyper.fund(address(_asset),fundAmount) {
 402 |     | 			emit LogUint256("small asset allowance", smallAssetAllowance);
 403 |     | 			emit AssertionFailed("insufficient allowance should fail.");
 404 |     | 		}
 405 |     | 		catch {} 
 406 |     | 
 407 |     | 		// mint the quote token to address(this), approve some amount < fund
 408 | *r  | 		_quote.mint(address(this),fundAmount);
 409 | *   | 		_quote.approve(address(_hyper),smallAssetAllowance);
 410 | *   | 		try _hyper.fund(address(_quote),fundAmount) {
 411 |     | 			emit LogUint256("small asset allowance", smallAssetAllowance);			
 412 |     | 			emit AssertionFailed("insufficient allownce should fail.");
 413 |     | 		}
 414 |     | 		catch {} 
 415 |     | 	}
 416 | *r  | 	function fund_with_zero() public {
 417 | *r  | 		setup_fund(0,0);
 418 | *r  | 		_hyper.fund(address(_asset),0);
 419 | *r  | 		_hyper.fund(address(_quote),0);		
 420 |     | 	}
 421 |     | 
 422 | *r  | 	function fund_token(address token, uint256 amount) private returns(bool) {
 423 | *r  | 		uint256 senderBalancePreFund = TestERC20(token).balanceOf(address(this));	
 424 | *r  | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(token));
 425 | *r  | 		uint256 reservePreFund = getReserve(address(_hyper),address(token));
 426 | *r  | 		uint256 hyperBalancePreFund = TestERC20(token).balanceOf(address(_hyper));
 427 |     | 
 428 | *r  | 		try _hyper.fund(address(token),amount) {
 429 |     | 		} catch (bytes memory error) {
 430 | r   | 			emit LogBytes("error", error);
 431 | r   | 			assert(false);
 432 |     | 		}
 433 |     | 
 434 |     | 		// sender's token balance should decrease 
 435 |     | 		// usdc sender pre token balance = 100 ; usdc sender post token = 100 - 1
 436 | *r  | 		uint256 senderBalancePostFund = TestERC20(token).balanceOf(address(this));			
 437 | *r  | 		if(senderBalancePostFund != senderBalancePreFund - amount) {
 438 |     | 			emit LogUint256("postTransfer sender balance", senderBalancePostFund);
 439 |     | 			emit LogUint256("preTransfer:", senderBalancePreFund);
 440 |     | 			emit AssertionFailed("Sender balance did not decrease by amount after funding");
 441 |     | 		}
 442 |     | 		// hyper balance of the sender should increase 
 443 |     | 		// pre hyper balance = a; post hyperbalance + 100
 444 | *r  | 		uint256 virtualBalancePostFund = getBalance(address(_hyper),address(this),address(token));
 445 | *r  | 		if(virtualBalancePostFund != virtualBalancePreFund + amount){
 446 | *r  | 			emit LogUint256("virtual balance after funding", virtualBalancePostFund);
 447 | *r  | 			emit LogUint256("virtual balance before funding:", virtualBalancePreFund);
 448 | *r  | 			emit AssertionFailed("Virtual balance did not increase after funding");
 449 |     | 		}
 450 |     | 		// hyper reserves for token should increase
 451 |     | 		// reserve balance = b; post reserves + 100
 452 | *r  | 		uint256 reservePostFund = getReserve(address(_hyper),address(token));
 453 | *r  | 		if(reservePostFund != reservePreFund + amount){
 454 | *r  | 			emit LogUint256("reserve after funding", reservePostFund);
 455 | *r  | 			emit LogUint256("reserve balance before funding:", reservePreFund);
 456 | *r  | 			emit AssertionFailed("Reserve did not increase after funding");			
 457 |     | 		}
 458 |     | 		// hyper's token balance should increase
 459 |     | 		// pre balance of usdc = y; post balance = y + 100
 460 | *r  | 		uint256 hyperBalancePostFund = TestERC20(token).balanceOf(address(_hyper));
 461 | *r  | 		if(hyperBalancePostFund  != hyperBalancePreFund + amount){
 462 |     | 			emit LogUint256("hyper token balance after funding", hyperBalancePostFund);
 463 |     | 			emit LogUint256("hyper balance before funding:", hyperBalancePreFund);
 464 |     | 			emit AssertionFailed("hyper token balance did not increase after funding");			
 465 |     | 		}
 466 | *r  | 		return true;
 467 |     | 	}
 468 | *r  | 	function setup_fund(uint256 assetAmount, uint256 quoteAmount) private {
 469 | *r  | 		_asset.mint(address(this),assetAmount);
 470 | *r  | 		_quote.mint(address(this),quoteAmount);
 471 | *r  | 		_asset.approve(address(_hyper),type(uint256).max);
 472 | *r  | 		_quote.approve(address(_hyper),type(uint256).max);
 473 |     | 	}
 474 |     | 	// ******************** Draw ********************	
 475 | r   | 	function draw_should_succeed(uint256 assetAmount,uint256 quoteAmount, address recipient) public {	
 476 | r   | 		assetAmount = between(assetAmount,1,type(uint64).max);
 477 | r   | 		quoteAmount = between(quoteAmount,1,type(uint64).max);
 478 | r   | 		emit LogUint256("asset amount: ", assetAmount);
 479 | r   | 		emit LogUint256("quote amount:", quoteAmount);
 480 |     | 
 481 | r   | 		require(recipient != address(_hyper));
 482 | r   | 		require(recipient != address(0));
 483 |     | 
 484 | r   | 		draw_token(address(_asset),assetAmount, recipient);
 485 | r   | 		draw_token(address(_quote),quoteAmount, recipient);
 486 |     | 	}
 487 | r   | 	function draw_token(address token, uint256 amount, address recipient) private {
 488 |     | 		// make sure a user has funded already 
 489 | r   | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(token));
 490 | r   | 		require (virtualBalancePreFund>0);
 491 | r   | 		amount = between(amount,1,virtualBalancePreFund);
 492 |     | 
 493 | r   | 		uint256 recipientBalancePreFund = TestERC20(token).balanceOf(address(recipient));	
 494 | r   | 		uint256 reservePreFund = getReserve(address(_hyper),address(token));
 495 | r   | 		uint256 hyperBalancePreFund = TestERC20(token).balanceOf(address(_hyper));		
 496 |     | 
 497 | r   | 		_hyper.draw(token,amount,recipient);
 498 |     | 		
 499 |     | 		//-- Postconditions 
 500 |     | 		// caller balance should decrease 
 501 |     | 		// pre caller balance = a; post caller balance = a - 100
 502 | r   | 		uint256 virtualBalancePostFund = getBalance(address(_hyper),address(this),address(token));
 503 | r   | 		if(virtualBalancePostFund != virtualBalancePreFund - amount){
 504 |     | 			emit LogUint256("virtual balance post draw",virtualBalancePostFund);
 505 |     | 			emit LogUint256("virtual balance pre draw", virtualBalancePreFund);
 506 |     | 			emit AssertionFailed("virtual balance should decrease after drawing tokens");
 507 |     | 		}
 508 |     | 		// reserves should decrease 
 509 | r   | 		uint256 reservePostFund = getReserve(address(_hyper),address(token));
 510 | r   | 		if(reservePostFund != reservePreFund - amount){
 511 |     | 			emit LogUint256("reserve post draw",reservePostFund);
 512 |     | 			emit LogUint256("reserve pre draw", reservePreFund);
 513 |     | 			emit AssertionFailed("reserve balance should decrease after drawing tokens");
 514 |     | 		}
 515 |     | 		// to address should increase 
 516 |     | 		// pre-token balance = a; post-token = a + 100
 517 | r   | 		uint256 recipientBalancePostFund = TestERC20(token).balanceOf(address(recipient));			
 518 | r   | 		if(recipientBalancePostFund  != recipientBalancePreFund + amount){
 519 |     | 			emit LogUint256("recipient balance post draw",recipientBalancePostFund);
 520 |     | 			emit LogUint256("recipient balance pre draw", recipientBalancePreFund);
 521 |     | 			emit AssertionFailed("recipient balance should increase after drawing tokens");			
 522 |     | 		}
 523 |     | 		// hyper token's balance should decrease
 524 | r   | 		uint256 tokenPostFund = TestERC20(token).balanceOf(address(_hyper));
 525 | r   | 		if(tokenPostFund != hyperBalancePreFund - amount){
 526 |     | 			emit LogUint256("token post draw",tokenPostFund);
 527 |     | 			emit LogUint256("token pre draw", hyperBalancePreFund);
 528 |     | 			emit AssertionFailed("hyper token balance should increase after drawing tokens");						
 529 |     | 		}
 530 |     | 	}	
 531 | *r  | 	function draw_to_zero_should_fail(uint256 assetAmount) public {
 532 |     | 		// make sure a user has funded already 
 533 | r   | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(_asset));
 534 | r   | 		emit LogUint256("virtual balance pre fund",virtualBalancePreFund);
 535 |     | 		require (virtualBalancePreFund >= 0);
 536 | r   | 		assetAmount = between(assetAmount,1,virtualBalancePreFund);
 537 |     | 
 538 | *   | 		try _hyper.draw(address(_asset),assetAmount,address(0)) { 
 539 |     | 			emit AssertionFailed("draw should fail attempting to transfer to zero");
 540 |     | 		} catch { } 
 541 |     | 	}
 542 | *r  | 	function fund_then_draw(uint256 whichToken, uint256 amount) public {
 543 |     | 		// this can be extended to use the token list in `hyperTokens`
 544 | *r  | 		address token; 
 545 | *r  | 		if (whichToken%2==0) token = address(_asset);
 546 | *r  | 		else token = address(_quote);
 547 |     | 
 548 | *r  | 		setup_fund(amount,amount);
 549 |     | 
 550 | *r  | 		uint256 hyperBalancePreFund = TestERC20(token).balanceOf(address(_hyper));		
 551 | *r  | 		require(hyperBalancePreFund == 0);
 552 |     | 		
 553 | *r  | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(token));
 554 | *r  | 		uint256 recipientBalancePreFund = TestERC20(token).balanceOf(address(this));	
 555 | *r  | 		uint256 reservePreFund = getReserve(address(_hyper),address(token));
 556 |     | 
 557 |     | 		// Call fund and draw
 558 | *r  | 		_hyper.fund(token,amount);
 559 | *   | 		_hyper.draw(token,amount,address(this));
 560 |     | 
 561 |     | 		//-- Postconditions 
 562 |     | 		// caller balance should be equal 
 563 | *   | 		uint256 virtualBalancePostFund = getBalance(address(_hyper),address(this),address(token));
 564 | *   | 		if(virtualBalancePostFund != virtualBalancePreFund){
 565 |     | 			emit LogUint256("virtual balance post fund-draw",virtualBalancePostFund);
 566 |     | 			emit LogUint256("virtual balance pre fund-draw", virtualBalancePreFund);
 567 |     | 			emit AssertionFailed("virtual balance should be equal after fund-draw");
 568 |     | 		}
 569 |     | 		// reserves should be equal
 570 | *   | 		uint256 reservePostFund = getReserve(address(_hyper),address(token));
 571 | *   | 		if(reservePostFund != reservePreFund){
 572 |     | 			emit LogUint256("reserve post fund-draw",reservePostFund);
 573 |     | 			emit LogUint256("reserve pre fund-draw", reservePreFund);
 574 |     | 			emit AssertionFailed("reserve balance should be equal after fund-draw");
 575 |     | 		}
 576 |     | 		// recipient = sender balance should be equal
 577 | *   | 		uint256 recipientBalancePostFund = TestERC20(token).balanceOf(address(this));			
 578 | *   | 		if(recipientBalancePostFund  != recipientBalancePreFund){
 579 |     | 			emit LogUint256("recipient balance post fund-draw",recipientBalancePostFund);
 580 |     | 			emit LogUint256("recipient balance pre fund-draw", recipientBalancePreFund);
 581 |     | 			emit AssertionFailed("recipient balance should be equal after fund-draw");			
 582 |     | 		}
 583 |     | 		// hyper token's balance should be equal
 584 | *   | 		uint256 tokenPostFund = TestERC20(token).balanceOf(address(_hyper));
 585 | *   | 		if(tokenPostFund != hyperBalancePreFund){
 586 |     | 			emit LogUint256("token post fund-draw",tokenPostFund);
 587 |     | 			emit LogUint256("token pre fund-draw", hyperBalancePreFund);
 588 |     | 			emit AssertionFailed("hyper token balance should be equal after fund-draw");						
 589 |     | 		}		
 590 |     | 	}
 591 |     | 	// ******************** Depositing ********************	
 592 | *r  | 	function deposit_with_correct_preconditions_should_succeed() public payable {
 593 | *r  | 		require(msg.value>0);
 594 | *   | 		emit LogUint256("msg.value",msg.value);
 595 |     | 
 596 | *   | 		uint256 ethBalancePreTransfer = address(this).balance;
 597 | *   | 		uint256 wethPreTransfer = _weth.balanceOf(address(_hyper));
 598 |     | 
 599 | *   | 		try _hyper.deposit{value:msg.value}() {
 600 | *   | 			uint256 ethBalancePostTransfer = address(this).balance;		
 601 | *   | 			uint256 wethPostTransfer = _weth.balanceOf(address(_hyper));
 602 |     | 
 603 |     | 			// sender's eth balance should decrease 
 604 | *   | 			assert(ethBalancePostTransfer == ethBalancePreTransfer - msg.value);
 605 |     | 			// weth balance of contract should increase
 606 |     | 			// pretransfer = b; post-transfer = b+msg.value
 607 | *r  | 			assert(wethPostTransfer == wethPreTransfer+msg.value);
 608 |     | 			
 609 |     | 		} catch (bytes memory err) {
 610 |     | 			emit LogBytes("error",err);
 611 |     | 			emit AssertionFailed("deposit should not have failed.");
 612 |     | 		}
 613 |     | 	}	
 614 |     | 	// Future invariant: Funding with WETH and then depositing with ETH should have the same impact on the pool 
 615 |     | 	// ******************** Helper ********************	
 616 |     |     // function allocate_should_succeed_with_correct_preconditions(uint256 id, uint256 amount) {
 617 |     | 	// 	(HyperPool memory pool,uint64 poolId) = retrieve_created_pool(id);
 618 |     | 	// 	require(pool.lastPrice !=0);
 619 |     | 	// 	require(pool.lastTimestamp !=0);
 620 |     | 
 621 |     | 	// 	_hyper.allocate(poolId,amount);
 622 |     | 
 623 |     | 
 624 |     | 	// }
 625 |     | 	// allocate should fail on a nonexistent pool 
 626 |     | 	// allocate shoudl fail if deltaLiquidity = 0
 627 |     | 	// ******************** Helper ********************	
 628 | *r  |     function between(uint256 random,uint256 low, uint256 high) private returns (uint256) {
 629 | *r  |         return low + (random % (high - low));
 630 |     |     }
 631 | *r  | 	function retrieve_created_pool(uint256 id) private returns (HyperPool memory pool, uint64 poolId) {
 632 | *r  | 		require(poolIds.length > 0);
 633 | *r  | 		id = between(id,0,poolIds.length);
 634 | *r  | 		return (getPool(address(_hyper),poolIds[id]),poolIds[id]);
 635 |     | 	}
 636 |     | }

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | interface IERC20 {
  5 |     |     function totalSupply() external view returns (uint256);
  6 |     | 
  7 |     |     function balanceOf(address account) external view returns (uint256);
  8 |     | 
  9 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 10 |     | 
 11 |     |     function allowance(address owner, address spender) external view returns (uint256);
 12 |     | 
 13 |     |     function approve(address spender, uint256 amount) external returns (bool);
 14 |     | 
 15 |     |     function transferFrom(
 16 |     |         address sender,
 17 |     |         address recipient,
 18 |     |         uint256 amount
 19 |     |     ) external returns (bool);
 20 |     | 
 21 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 22 |     | 
 23 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 24 |     | 
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/interfaces/IHyper.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import {HyperCurve, HyperPair} from "../HyperLib.sol";
   5 |     | 
   6 |     | interface IHyperEvents {
   7 |     |     event Deposit(address indexed account, uint amount);
   8 |     |     event DecreaseUserBalance(address indexed account, address indexed token, uint256 amount);
   9 |     |     event DecreaseReserveBalance(address indexed token, uint256 amount);
  10 |     |     event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);
  11 |     |     event IncreaseReserveBalance(address indexed token, uint256 amount);
  12 |     |     event Swap(
  13 |     |         uint64 indexed poolId,
  14 |     |         uint256 price,
  15 |     |         address indexed tokenIn,
  16 |     |         uint256 input,
  17 |     |         address indexed tokenOut,
  18 |     |         uint256 output
  19 |     |     );
  20 |     |     event Stake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);
  21 |     |     event Unstake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);
  22 |     |     event Allocate(
  23 |     |         uint64 indexed poolId,
  24 |     |         address indexed asset,
  25 |     |         address indexed quote,
  26 |     |         uint256 deltaAsset,
  27 |     |         uint256 deltaQuote,
  28 |     |         uint256 deltaLiquidity
  29 |     |     );
  30 |     |     event Unallocate(
  31 |     |         uint64 indexed poolId,
  32 |     |         address indexed asset,
  33 |     |         address indexed quote,
  34 |     |         uint256 deltaAsset,
  35 |     |         uint256 deltaQuote,
  36 |     |         uint256 deltaLiquidity
  37 |     |     );
  38 |     | 
  39 |     |     event ChangeParameters(
  40 |     |         uint64 indexed poolId,
  41 |     |         uint16 priorityFee,
  42 |     |         uint16 indexed fee,
  43 |     |         uint16 volatility,
  44 |     |         uint16 duration,
  45 |     |         uint16 jit,
  46 |     |         int24 indexed maxTick
  47 |     |     );
  48 |     |     event Collect(
  49 |     |         uint64 poolId,
  50 |     |         address account,
  51 |     |         uint feeAsset,
  52 |     |         address indexed asset,
  53 |     |         uint feeQuote,
  54 |     |         address indexed quote,
  55 |     |         uint feeReward,
  56 |     |         address indexed reward
  57 |     |     );
  58 |     |     event CreatePair(
  59 |     |         uint24 indexed pairId,
  60 |     |         address indexed asset,
  61 |     |         address indexed quote,
  62 |     |         uint8 decimalsAsset,
  63 |     |         uint8 decimalsQuote
  64 |     |     );
  65 |     |     event CreatePool(
  66 |     |         uint64 indexed poolId,
  67 |     |         bool isMutable,
  68 |     |         address indexed asset,
  69 |     |         address indexed quote,
  70 |     |         uint256 price
  71 |     |     );
  72 |     | }
  73 |     | 
  74 |     | interface IHyperGetters {
  75 |     |     function getNetBalance(address token) external view returns (int);
  76 |     | 
  77 |     |     function getReserve(address token) external view returns (uint);
  78 |     | 
  79 |     |     function getBalance(address owner, address token) external view returns (uint);
  80 |     | 
  81 |     |     function pairs(
  82 |     |         uint24 pairId
  83 |     |     ) external view returns (address tokenAsset, uint8 decimalsAsset, address tokenQuote, uint8 decimalsQuote);
  84 |     | 
  85 |     |     function pools(
  86 |     |         uint64 poolId
  87 |     |     )
  88 |     |         external
  89 |     |         view
  90 |     |         returns (
  91 |     |             int24 lastTick,
  92 |     |             uint32 lastTimestamp,
  93 |     |             address controller,
  94 |     |             uint256 feeGrowthGlobalReward,
  95 |     |             uint256 feeGrowthGlobalAsset,
  96 |     |             uint256 feeGrowthGlobalQuote,
  97 |     |             uint128 lastPrice,
  98 |     |             uint128 liquidity,
  99 |     |             uint128 stakedLiquidity,
 100 |     |             int128 stakedLiquidityDelta,
 101 |     |             HyperCurve memory,
 102 |     |             HyperPair memory
 103 |     |         );
 104 |     | 
 105 |     |     function positions(
 106 |     |         address owner,
 107 |     |         uint64 poolId
 108 |     |     )
 109 |     |         external
 110 |     |         view
 111 |     |         returns (
 112 |     |             uint128 freeLiquidity,
 113 |     |             uint128 stakedLiquidity,
 114 |     |             uint256 lastTimestamp,
 115 |     |             uint256 stakeTimestamp,
 116 |     |             uint256 unstakeTimestamp,
 117 |     |             uint256 feeGrowthRewardLast,
 118 |     |             uint256 feeGrowthAssetLast,
 119 |     |             uint256 feeGrowthQuoteLast,
 120 |     |             uint128 tokensOwedAsset,
 121 |     |             uint128 tokensOwedQuote,
 122 |     |             uint128 tokensOwedReward
 123 |     |         );
 124 |     | 
 125 |     |     function getPairNonce() external view returns (uint256);
 126 |     | 
 127 |     |     function getAmounts(uint64 poolId) external view returns (uint256 deltaAsset, uint256 deltaQuote);
 128 |     | 
 129 |     |     function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) external view returns (uint);
 130 |     | 
 131 |     |     function getVirtualReserves(uint64 poolId) external view returns (uint128 deltaAsset, uint128 deltaQuote);
 132 |     | 
 133 |     |     function getMaxLiquidity(
 134 |     |         uint64 poolId,
 135 |     |         uint deltaAsset,
 136 |     |         uint deltaQuote
 137 |     |     ) external view returns (uint128 deltaLiquidity);
 138 |     | 
 139 |     |     function getLiquidityDeltas(
 140 |     |         uint64 poolId,
 141 |     |         int128 deltaLiquidity
 142 |     |     ) external view returns (uint128 deltaAsset, uint128 deltaQuote);
 143 |     | 
 144 |     |     function getLatestPrice(uint64 poolId) external view returns (uint price);
 145 |     | }
 146 |     | 
 147 |     | interface IHyperActions {
 148 |     |     function allocate(uint64 poolId, uint deltaLiquidity) external returns (uint deltaAsset, uint deltaQuote);
 149 |     | 
 150 |     |     function unallocate(uint64 poolId, uint amount) external returns (uint deltaAsset, uint deltaQuote);
 151 |     | 
 152 |     |     function stake(uint64 poolId, uint128 deltaLiquidity) external;
 153 |     | 
 154 |     |     function unstake(uint64 poolId, uint128 deltaLiquidity) external;
 155 |     | 
 156 |     |     function swap(
 157 |     |         uint64 poolId,
 158 |     |         bool sellAsset,
 159 |     |         uint amount,
 160 |     |         uint limit
 161 |     |     ) external returns (uint output, uint remainder);
 162 |     | 
 163 |     |     function fund(address token, uint256 amount) external;
 164 |     | 
 165 |     |     function draw(address token, uint256 amount, address to) external;
 166 |     | 
 167 |     |     function deposit() external payable;
 168 |     | 
 169 |     |     function changeParameters(
 170 |     |         uint64 poolId,
 171 |     |         uint16 priorityFee,
 172 |     |         uint16 fee,
 173 |     |         uint16 volatility,
 174 |     |         uint16 duration,
 175 |     |         uint16 jit,
 176 |     |         int24 maxTick
 177 |     |     ) external;
 178 |     | }
 179 |     | 
 180 |     | interface IHyper is IHyperActions, IHyperEvents, IHyperGetters {}
 181 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/interfaces/IWETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IWETH {
  5 |     |     function deposit() external payable;
  6 |     | 
  7 |     |     function withdraw(uint256 wad) external;
  8 |     | }
  9 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/libraries/Price.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "solstat/Invariant.sol";
   5 |     | 
   6 |     | using Price for Price.RMM global;
   7 |     | 
   8 |     | /**
   9 |     |  * @dev     Library for RMM to compute reserves, prices, and changes in reserves over time.
  10 |     |  * @notice  Units Glossary:
  11 |     |  *
  12 |     |  *          wad - `1 ether` == 1e18
  13 |     |  *          seconds - `1 seconds` == 1
  14 |     |  *          percentage - 10_000 == 100%
  15 |     |  *
  16 |     |  */
  17 |     | library Price {
  18 |     |     using FixedPointMathLib for uint256;
  19 |     |     using FixedPointMathLib for int256;
  20 |     | 
  21 |     |     struct RMM {
  22 |     |         uint256 strike; // wad
  23 |     |         uint256 sigma; // 10_000 = 100%;
  24 |     |         uint256 tau; // seconds
  25 |     |     }
  26 |     | 
  27 |     |     error OverflowWad(int256 wad);
  28 |     | 
  29 | *r  |     int256 internal constant TICK_BASE = 1_0001e14;
  30 | *r  |     uint256 internal constant DOUBLE_WAD = 2 ether;
  31 |     |     uint256 internal constant PERCENTAGE = 10_000;
  32 | *r  |     uint256 internal constant SQRT_WAD = 1e9;
  33 | *r  |     uint256 internal constant WAD = 1 ether;
  34 |     |     uint256 internal constant YEAR = 31556953 seconds;
  35 |     | 
  36 |     |     // ===== Class Methods ===== //
  37 |     | 
  38 |     |     function invariantOf(RMM memory args, uint R_y, uint R_x) internal pure returns (int256) {
  39 |     |         return Invariant.invariant(R_y, R_x, args.strike, convertPercentageToWad(args.sigma), args.tau);
  40 |     |     }
  41 |     | 
  42 | *r  |     function getXWithPrice(RMM memory args, uint256 prc) internal pure returns (uint256 R_x) {
  43 | *r  |         R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);
  44 |     |     }
  45 |     | 
  46 |     |     function getPriceWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 prc) {
  47 |     |         prc = getPriceWithX(R_x, args.strike, args.sigma, args.tau);
  48 |     |     }
  49 |     | 
  50 | *r  |     function getYWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 R_y) {
  51 | *r  |         R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);
  52 |     |     }
  53 |     | 
  54 |     |     function getXWithY(RMM memory args, uint256 R_y) internal pure returns (uint256 R_x) {
  55 |     |         R_x = getXWithY(R_y, args.strike, args.sigma, args.tau, 0);
  56 |     |     }
  57 |     | 
  58 |     |     function computePriceWithChangeInTau(RMM memory args, uint256 prc, uint256 eps) internal pure returns (uint256) {
  59 |     |         return computePriceWithChangeInTau(args.strike, args.sigma, prc, args.tau, eps);
  60 |     |     }
  61 |     | 
  62 | r   |     function computeReserves(RMM memory args, uint prc) internal pure returns (uint R_y, uint R_x) {
  63 | r   |         R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);
  64 | r   |         R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);
  65 |     |     }
  66 |     | 
  67 |     |     // ===== Raw Functions ===== //
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Computes change in price given a change in time in seconds.
  71 |     |      * @param stk WAD
  72 |     |      * @param vol percentage
  73 |     |      * @param prc WAD
  74 |     |      * @param tau seconds
  75 |     |      * @param epsilon seconds
  76 |     |      * @custom:math P(τ - ε) = ( P(τ)^(√(1 - ε/τ)) / K^2 )e^((1/2)(t^2)(√(τ)√(τ- ε) - (τ - ε)))
  77 |     |      */
  78 | *r  |     function computePriceWithChangeInTau(
  79 |     |         uint256 stk,
  80 |     |         uint256 vol,
  81 |     |         uint256 prc,
  82 |     |         uint256 tau,
  83 |     |         uint256 epsilon
  84 | *r  |     ) internal pure returns (uint256) {
  85 | *r  |         if (epsilon == 0) return prc;
  86 | *r  |         if (epsilon > tau) return stk;
  87 |     | 
  88 | *r  |         RMM memory params = RMM(stk, vol, tau);
  89 |     | 
  90 |     |         uint256 tauYears;
  91 |     |         assembly {
  92 | *r  |             tauYears := sdiv(mul(tau, WAD), YEAR) // tau * WAD / year = time in years scaled to WAD
  93 |     |         }
  94 |     | 
  95 |     |         uint256 epsilonYears;
  96 |     |         assembly {
  97 | *r  |             epsilonYears := sdiv(mul(epsilon, WAD), YEAR) // epsilon * WAD / year = epsilon in years scaled to WAD
  98 |     |         }
  99 |     | 
 100 | *r  |         uint256 term_0 = WAD - (epsilonYears.divWadUp(tauYears)); // WAD - ((epsilon * WAD) / tau rounded down), units are WAD - WAD, time units cancel out
 101 | *r  |         uint256 term_1 = term_0.sqrt(); // this sqrts WAD, so we end up with SQRT_WAD units
 102 |     | 
 103 | *r  |         uint256 term_2 = prc.divWadUp(params.strike); // p(t) / K, both units are already WAD
 104 | *r  |         uint256 term_3 = uint256(int256(term_2).powWad(int256(term_1 * SQRT_WAD)));
 105 |     | 
 106 | *r  |         uint256 term_7;
 107 | *r  |         {
 108 | *r  |             uint256 currentTau = tauYears - epsilonYears; // WAD - WAD = WAD
 109 | *r  |             uint256 tausSqrt = tauYears.sqrt() * (currentTau).sqrt(); // sqrt(1e18) = 1e9, so 1e9 * 1e9 = 1e18
 110 | *r  |             uint256 term_4 = tausSqrt - currentTau; // WAD - WAD = WAD
 111 |     | 
 112 | *r  |             uint256 sigmaWad = convertPercentageToWad(uint256(params.sigma));
 113 |     | 
 114 | *r  |             uint256 term_5 = (sigmaWad * sigmaWad) / DOUBLE_WAD; // 1e4 * 1e4 * 1e17 / 1e4 = 1e17, which is half WAD
 115 | *r  |             uint256 term_6 = uint256((int256(term_5.mulWadDown(term_4))).expWad()); // exp(WAD * WAD / WAD)
 116 | *r  |             term_7 = uint256(params.strike).mulWadDown(term_6); // WAD * WAD / WAD
 117 |     |         }
 118 |     | 
 119 | *r  |         uint256 price = term_3.mulWadDown(term_7); // WAD * WAD / WAD = WAD
 120 |     |         return price;
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev R_y = tradingFunction(R_x, ...)
 125 |     |      * @param R_x WAD
 126 |     |      * @param stk WAD
 127 |     |      * @param vol percentage
 128 |     |      * @param tau seconds
 129 |     |      * @param inv WAD
 130 |     |      * @return R_y WAD
 131 |     |      */
 132 | *r  |     function getYWithX(
 133 |     |         uint256 R_x,
 134 |     |         uint256 stk,
 135 |     |         uint256 vol,
 136 |     |         uint256 tau,
 137 |     |         int256 inv
 138 | *r  |     ) internal pure returns (uint256 R_y) {
 139 | *r  |         R_y = Invariant.getY(R_x, stk, convertPercentageToWad(vol), tau, inv);
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev R_x = tradingFunction(R_y, ...)
 144 |     |      * @param R_y WAD
 145 |     |      * @param stk WAD
 146 |     |      * @param vol percentage
 147 |     |      * @param tau seconds
 148 |     |      * @param inv WAD
 149 |     |      * @return R_x WAD
 150 |     |      */
 151 |     |     function getXWithY(
 152 |     |         uint256 R_y,
 153 |     |         uint256 stk,
 154 |     |         uint256 vol,
 155 |     |         uint256 tau,
 156 |     |         int256 inv
 157 |     |     ) internal pure returns (uint256 R_x) {
 158 |     |         R_x = Invariant.getX(R_y, stk, convertPercentageToWad(vol), tau, inv);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Used in `getAmounts` to compute the virtual amount of assets at the pool's price.
 163 |     |      * @param prc WAD
 164 |     |      * @param stk WAD
 165 |     |      * @param vol percentage
 166 |     |      * @param tau seconds
 167 |     |      * @return R_x WAD
 168 |     |      * @custom:math R_x = 1 - Φ(( ln(S/K) + (σ²/2)τ ) / σ√τ)
 169 |     |      */
 170 | *r  |     function getXWithPrice(uint256 prc, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 R_x) {
 171 | *r  |         if (prc != 0) {
 172 | *r  |             int256 ln = FixedPointMathLib.lnWad(int256(FixedPointMathLib.divWadDown(prc, stk)));
 173 | *r  |             uint256 tauYears = convertSecondsToWadYears(tau);
 174 |     | 
 175 |     |             uint256 sigmaWad = convertPercentageToWad(vol);
 176 | *r  |             uint256 doubleSigma = (sigmaWad * sigmaWad) / uint256(Gaussian.TWO);
 177 | *r  |             uint256 halfSigmaTau = doubleSigma * tauYears;
 178 | *r  |             uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(sigmaWad);
 179 |     | 
 180 | *r  |             int256 lnOverVol = (ln * Gaussian.ONE + int256(halfSigmaTau)) / int256(sqrtTauSigma);
 181 | *r  |             int256 cdf = Gaussian.cdf(lnOverVol);
 182 | *r  |             if (cdf > Gaussian.ONE) revert OverflowWad(cdf);
 183 | *r  |             R_x = uint256(Gaussian.ONE - cdf);
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev price(R_x) = Ke^(Φ^-1(1 - R_x)σ√τ - 1/2σ^2τ)
 189 |     |      * @param R_x WAD
 190 |     |      * @param stk WAD
 191 |     |      * @param vol percentage
 192 |     |      * @param tau seconds
 193 |     |      * @return prc WAD
 194 |     |      */
 195 | *r  |     function getPriceWithX(uint256 R_x, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 prc) {
 196 |     |         uint256 tauYears = convertSecondsToWadYears(tau);
 197 |     |         uint256 volWad = convertPercentageToWad(vol);
 198 |     | 
 199 |     |         if (uint256(Gaussian.ONE) < R_x) revert OverflowWad(int256(R_x));
 200 |     |         int256 input = Gaussian.ONE - int256(R_x);
 201 |     |         int256 ppf = Gaussian.ppf(input);
 202 |     |         uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(volWad);
 203 |     |         int256 first = (ppf * int256(sqrtTauSigma)) / Gaussian.ONE; // Φ^-1(1 - R_x)σ√τ
 204 |     |         uint256 doubleSigma = (volWad * volWad) / uint256(Gaussian.TWO);
 205 |     |         int256 halfSigmaTau = int256(doubleSigma * tauYears) / Gaussian.ONE; // 1/2σ^2τ
 206 |     | 
 207 |     |         int256 exponent = first - halfSigmaTau;
 208 |     |         int256 exp = exponent.expWad();
 209 | *r  |         prc = uint256(exp).mulWadDown(stk);
 210 |     |     }
 211 |     | 
 212 |     |     // ===== Tick Math ===== //
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Computes a price value from a tick key.
 216 |     |      *
 217 |     |      * @custom:math price = e^(ln(1.0001) * tick)
 218 |     |      *
 219 |     |      * @param tick Key of a slot in a price/liquidity grid.
 220 |     |      * @return price WAD Value on a key (tick) value pair of a price grid.
 221 |     |      */
 222 | *r  |     function computePriceWithTick(int24 tick) internal pure returns (uint256 price) {
 223 | *r  |         int256 tickWad = int256(tick) * int256(FixedPointMathLib.WAD);
 224 | *r  |         price = uint256(FixedPointMathLib.powWad(TICK_BASE, tickWad));
 225 |     |     }
 226 |     | 
 227 |     |     /**
 228 |     |      * @dev Computes a tick value from the price.
 229 |     |      *
 230 |     |      * @custom:math tick = ln(price) / ln(1.0001)
 231 |     |      *
 232 |     |      * @param price WAD Value on a key (tick) value pair of a price grid.
 233 |     |      * @return tick Key of a slot in a price/liquidity grid.
 234 |     |      */
 235 | *r  |     function computeTickWithPrice(uint256 price) internal pure returns (int24 tick) {
 236 | *r  |         uint256 numerator = uint256(int256(price).lnWad());
 237 | *r  |         uint256 denominator = uint256(TICK_BASE.lnWad());
 238 | *r  |         tick = int24(int256((numerator)) / int256(denominator) + 1);
 239 |     |     }
 240 |     | 
 241 |     |     // ===== Utils ===== //
 242 |     | 
 243 |     |     function convertSecondsToWadYears(uint256 sec) internal pure returns (uint256 yrsWad) {
 244 |     |         assembly {
 245 | *r  |             yrsWad := div(mul(sec, WAD), YEAR)
 246 |     |         }
 247 |     |     }
 248 |     | 
 249 | *r  |     function convertPercentageToWad(uint256 pct) internal pure returns (uint256 pctWad) {
 250 |     |         assembly {
 251 | *r  |             pctWad := div(mul(pct, WAD), PERCENTAGE)
 252 |     |         }
 253 |     |     }
 254 |     | }
 255 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/test/HyperForwarderHelper.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IERC20 {
  5 |     |     function approve(address spender, uint256 amount) external;
  6 |     | }
  7 |     | 
  8 |     | contract HyperForwarderHelper {
  9 |     |     Caller public caller;
 10 |     | 
 11 |     |     event Success();
 12 |     |     event Fail(bytes reason);
 13 |     | 
 14 |     |     constructor() {
 15 |     |         caller = new Caller();
 16 |     |     }
 17 |     | 
 18 |     |     function approve(address token, address target) external {
 19 |     |         caller.approve(token, target, type(uint256).max);
 20 |     |     }
 21 |     | 
 22 |     |     // Assumes Hyper calls this, for testing only.
 23 |     |     function pass(address target, bytes calldata data) external payable returns (bool) {
 24 |     |         try caller.forward{value: msg.value}(target, data) {
 25 |     |             emit Success();
 26 |     |             return true;
 27 |     |         } catch (bytes memory reason) {
 28 |     |             emit Fail(reason);
 29 |     |             assembly {
 30 |     |                 revert(add(32, reason), mload(reason))
 31 |     |             }
 32 |     |         }
 33 |     |     }
 34 |     | 
 35 |     |     function getPoolId(uint24 pairId, bool isMutable, uint32 poolNonce) public pure returns (uint64) {
 36 |     |         return uint64(bytes8(abi.encodePacked(pairId, isMutable ? 1 : 0, poolNonce)));
 37 |     |     }
 38 |     | }
 39 |     | 
 40 |     | /// @dev msg.sender in Hyper calls.
 41 |     | contract Caller {
 42 |     |     function approve(address token, address to, uint256 amount) external {
 43 |     |         IERC20(token).approve(to, amount);
 44 |     |     }
 45 |     | 
 46 |     |     function forward(address target, bytes calldata data) external payable returns (bool) {
 47 |     |         (bool success, bytes memory returnData) = target.call{value: msg.value}(data);
 48 |     |         if (!success) {
 49 |     |             assembly {
 50 |     |                 revert(add(32, returnData), mload(returnData))
 51 |     |             }
 52 |     |         }
 53 |     | 
 54 |     |         return success;
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/test/TestERC20.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "../interfaces/IERC20.sol";
   5 | *r  | 
   6 |     | contract TestERC20 is IERC20 {
   7 |     |     mapping(address => uint256) private _balances;
   8 |     | 
   9 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  10 |     | 
  11 |     |     uint256 private _totalSupply;
  12 |     | 
  13 | *r  |     string public name;
  14 | *   |     string public symbol;
  15 | *r  |     uint8 public override decimals;
  16 |     | 
  17 |     |     constructor(
  18 |     |         string memory name_,
  19 |     |         string memory symbol_,
  20 |     |         uint8 decimals_
  21 |     |     ) {
  22 |     |         name = name_;
  23 |     |         symbol = symbol_;
  24 |     |         decimals = decimals_;
  25 |     |     }
  26 |     | 
  27 |     |     /// @notice Used for testing pairs with decimals that are not 18
  28 | *   |     function setDecimals(uint8 decimals_) public {
  29 | *   |         decimals = decimals_;
  30 |     |     }
  31 |     | 
  32 | *r  |     function totalSupply() public view virtual override returns (uint256) {
  33 | *   |         return _totalSupply;
  34 |     |     }
  35 |     | 
  36 | *r  |     function balanceOf(address account) public view virtual override returns (uint256) {
  37 | *r  |         return _balances[account];
  38 |     |     }
  39 |     | 
  40 | *r  |     function mint(address to, uint256 wad) public {
  41 | *r  |         _mint(to, wad);
  42 |     |     }
  43 |     | 
  44 | *r  |     function burn(address to, uint256 wad) public {
  45 | *r  |         _burn(to, wad);
  46 |     |     }
  47 |     | 
  48 | *r  |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
  49 | *r  |         _transfer(msg.sender, recipient, amount);
  50 |     |         return true;
  51 |     |     }
  52 |     | 
  53 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
  54 | *   |         return _allowances[owner][spender];
  55 |     |     }
  56 |     | 
  57 | *r  |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  58 | *r  |         _approve(msg.sender, spender, amount);
  59 | *r  |         return true;
  60 |     |     }
  61 |     | 
  62 | *r  |     function transferFrom(
  63 |     |         address sender,
  64 |     |         address recipient,
  65 |     |         uint256 amount
  66 | *r  |     ) public virtual override returns (bool) {
  67 | *r  |         _transfer(sender, recipient, amount);
  68 |     | 
  69 | *r  |         uint256 currentAllowance = _allowances[sender][msg.sender];
  70 | *r  |         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
  71 |     |         unchecked {
  72 | *r  |             _approve(sender, msg.sender, currentAllowance - amount);
  73 |     |         }
  74 |     | 
  75 | *r  |         return true;
  76 |     |     }
  77 |     | 
  78 | *r  |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
  79 | *r  |         _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
  80 |     |         return true;
  81 |     |     }
  82 |     | 
  83 | *r  |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
  84 | *r  |         uint256 currentAllowance = _allowances[msg.sender][spender];
  85 | *r  |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
  86 |     |         unchecked {
  87 | *r  |             _approve(msg.sender, spender, currentAllowance - subtractedValue);
  88 |     |         }
  89 |     | 
  90 | *   |         return true;
  91 |     |     }
  92 |     | 
  93 | *r  |     function _transfer(
  94 |     |         address sender,
  95 |     |         address recipient,
  96 |     |         uint256 amount
  97 | *r  |     ) internal virtual {
  98 | *r  |         require(sender != address(0), "ERC20: transfer from the zero address");
  99 | *r  |         require(recipient != address(0), "ERC20: transfer to the zero address");
 100 |     | 
 101 |     |         _beforeTokenTransfer(sender, recipient, amount);
 102 |     | 
 103 | *r  |         uint256 senderBalance = _balances[sender];
 104 | *r  |         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
 105 |     |         unchecked {
 106 | *r  |             _balances[sender] = senderBalance - amount;
 107 |     |         }
 108 | *r  |         _balances[recipient] += amount;
 109 |     | 
 110 | *r  |         emit Transfer(sender, recipient, amount);
 111 |     |     }
 112 |     | 
 113 | *r  |     function _mint(address account, uint256 amount) internal virtual {
 114 | *r  |         require(account != address(0), "ERC20: mint to the zero address");
 115 |     | 
 116 |     |         _beforeTokenTransfer(address(0), account, amount);
 117 |     | 
 118 | *r  |         _totalSupply += amount;
 119 | *r  |         _balances[account] += amount;
 120 | *r  |         emit Transfer(address(0), account, amount);
 121 |     |     }
 122 |     | 
 123 | *r  |     function _burn(address account, uint256 amount) internal virtual {
 124 | *r  |         require(account != address(0), "ERC20: burn from the zero address");
 125 |     | 
 126 |     |         _beforeTokenTransfer(account, address(0), amount);
 127 |     | 
 128 | *r  |         uint256 accountBalance = _balances[account];
 129 | *r  |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 130 |     |         unchecked {
 131 | *   |             _balances[account] = accountBalance - amount;
 132 |     |         }
 133 | *   |         _totalSupply -= amount;
 134 |     | 
 135 | *   |         emit Transfer(account, address(0), amount);
 136 |     |     }
 137 |     | 
 138 | *r  |     function _approve(
 139 |     |         address owner,
 140 |     |         address spender,
 141 |     |         uint256 amount
 142 |     |     ) internal virtual {
 143 | *r  |         require(owner != address(0), "ERC20: approve from the zero address");
 144 | *r  |         require(spender != address(0), "ERC20: approve to the zero address");
 145 |     | 
 146 | *r  |         _allowances[owner][spender] = amount;
 147 | *r  |         emit Approval(owner, spender, amount);
 148 |     |     }
 149 |     | 
 150 |     |     function _beforeTokenTransfer(
 151 |     |         address from,
 152 |     |         address to,
 153 |     |         uint256 amount
 154 |     |     ) internal virtual {}
 155 |     | }
 156 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/contracts/test/TestHyperTime.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import "../Hyper.sol";
  5 |     | 
  6 |     | contract TestHyperTime is Hyper {
  7 |     |     uint256 public timestamp;
  8 |     | 
  9 |     |     function set(uint256 x) public {
 10 |     |         timestamp = x;
 11 |     |     }
 12 |     | 
 13 |     |     constructor(address weth) Hyper(weth) {}
 14 |     | 
 15 |     |     function _blockTimestamp() internal view override returns (uint128) {
 16 |     |         return uint128(timestamp);
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
  9 |     |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
 10 |     |     // console.sol and console2.sol work by executing a staticcall to this address.
 11 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 12 |     |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
 13 |     |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
 14 |     |     // Address of the test contract, deployed by the DEFAULT_SENDER.
 15 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 16 |     | 
 17 |     |     uint256 internal constant UINT256_MAX =
 18 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 19 |     | 
 20 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 21 |     |     StdStorage internal stdstore;
 22 |     | }
 23 |     | 
 24 |     | abstract contract TestBase is CommonBase {}
 25 |     | 
 26 |     | abstract contract ScriptBase is CommonBase {
 27 |     |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
 28 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 29 |     | 
 30 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 31 |     | }
 32 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {DSTest} from "ds-test/test.sol";
   5 |     | import {stdMath} from "./StdMath.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions is DSTest {
   8 |     |     event log_array(uint256[] val);
   9 |     |     event log_array(int256[] val);
  10 |     |     event log_array(address[] val);
  11 |     |     event log_named_array(string key, uint256[] val);
  12 |     |     event log_named_array(string key, int256[] val);
  13 |     |     event log_named_array(string key, address[] val);
  14 |     | 
  15 |     |     function fail(string memory err) internal virtual {
  16 |     |         emit log_named_string("Error", err);
  17 |     |         fail();
  18 |     |     }
  19 |     | 
  20 |     |     function assertFalse(bool data) internal virtual {
  21 |     |         assertTrue(!data);
  22 |     |     }
  23 |     | 
  24 |     |     function assertFalse(bool data, string memory err) internal virtual {
  25 |     |         assertTrue(!data, err);
  26 |     |     }
  27 |     | 
  28 |     |     function assertEq(bool a, bool b) internal virtual {
  29 |     |         if (a != b) {
  30 |     |             emit log("Error: a == b not satisfied [bool]");
  31 |     |             emit log_named_string("  Expected", b ? "true" : "false");
  32 |     |             emit log_named_string("    Actual", a ? "true" : "false");
  33 |     |             fail();
  34 |     |         }
  35 |     |     }
  36 |     | 
  37 |     |     function assertEq(bool a, bool b, string memory err) internal virtual {
  38 |     |         if (a != b) {
  39 |     |             emit log_named_string("Error", err);
  40 |     |             assertEq(a, b);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     function assertEq(bytes memory a, bytes memory b) internal virtual {
  45 |     |         assertEq0(a, b);
  46 |     |     }
  47 |     | 
  48 |     |     function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {
  49 |     |         assertEq0(a, b, err);
  50 |     |     }
  51 |     | 
  52 |     |     function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {
  53 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  54 |     |             emit log("Error: a == b not satisfied [uint[]]");
  55 |     |             emit log_named_array("  Expected", b);
  56 |     |             emit log_named_array("    Actual", a);
  57 |     |             fail();
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     function assertEq(int256[] memory a, int256[] memory b) internal virtual {
  62 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  63 |     |             emit log("Error: a == b not satisfied [int[]]");
  64 |     |             emit log_named_array("  Expected", b);
  65 |     |             emit log_named_array("    Actual", a);
  66 |     |             fail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     function assertEq(address[] memory a, address[] memory b) internal virtual {
  71 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  72 |     |             emit log("Error: a == b not satisfied [address[]]");
  73 |     |             emit log_named_array("  Expected", b);
  74 |     |             emit log_named_array("    Actual", a);
  75 |     |             fail();
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {
  80 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  81 |     |             emit log_named_string("Error", err);
  82 |     |             assertEq(a, b);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {
  87 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  88 |     |             emit log_named_string("Error", err);
  89 |     |             assertEq(a, b);
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {
  94 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  95 |     |             emit log_named_string("Error", err);
  96 |     |             assertEq(a, b);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     // Legacy helper
 101 |     |     function assertEqUint(uint256 a, uint256 b) internal virtual {
 102 |     |         assertEq(uint256(a), uint256(b));
 103 |     |     }
 104 |     | 
 105 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {
 106 |     |         uint256 delta = stdMath.delta(a, b);
 107 |     | 
 108 |     |         if (delta > maxDelta) {
 109 |     |             emit log("Error: a ~= b not satisfied [uint]");
 110 |     |             emit log_named_uint("  Expected", b);
 111 |     |             emit log_named_uint("    Actual", a);
 112 |     |             emit log_named_uint(" Max Delta", maxDelta);
 113 |     |             emit log_named_uint("     Delta", delta);
 114 |     |             fail();
 115 |     |         }
 116 |     |     }
 117 |     | 
 118 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {
 119 |     |         uint256 delta = stdMath.delta(a, b);
 120 |     | 
 121 |     |         if (delta > maxDelta) {
 122 |     |             emit log_named_string("Error", err);
 123 |     |             assertApproxEqAbs(a, b, maxDelta);
 124 |     |         }
 125 |     |     }
 126 |     | 
 127 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {
 128 |     |         uint256 delta = stdMath.delta(a, b);
 129 |     | 
 130 |     |         if (delta > maxDelta) {
 131 |     |             emit log("Error: a ~= b not satisfied [int]");
 132 |     |             emit log_named_int("  Expected", b);
 133 |     |             emit log_named_int("    Actual", a);
 134 |     |             emit log_named_uint(" Max Delta", maxDelta);
 135 |     |             emit log_named_uint("     Delta", delta);
 136 |     |             fail();
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {
 141 |     |         uint256 delta = stdMath.delta(a, b);
 142 |     | 
 143 |     |         if (delta > maxDelta) {
 144 |     |             emit log_named_string("Error", err);
 145 |     |             assertApproxEqAbs(a, b, maxDelta);
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     function assertApproxEqRel(
 150 |     |         uint256 a,
 151 |     |         uint256 b,
 152 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 153 |     |     ) internal virtual {
 154 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 155 |     | 
 156 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 157 |     | 
 158 |     |         if (percentDelta > maxPercentDelta) {
 159 |     |             emit log("Error: a ~= b not satisfied [uint]");
 160 |     |             emit log_named_uint("    Expected", b);
 161 |     |             emit log_named_uint("      Actual", a);
 162 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 163 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 164 |     |             fail();
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     function assertApproxEqRel(
 169 |     |         uint256 a,
 170 |     |         uint256 b,
 171 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 172 |     |         string memory err
 173 |     |     ) internal virtual {
 174 |     |         if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.
 175 |     | 
 176 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 177 |     | 
 178 |     |         if (percentDelta > maxPercentDelta) {
 179 |     |             emit log_named_string("Error", err);
 180 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {
 185 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 186 |     | 
 187 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 188 |     | 
 189 |     |         if (percentDelta > maxPercentDelta) {
 190 |     |             emit log("Error: a ~= b not satisfied [int]");
 191 |     |             emit log_named_int("    Expected", b);
 192 |     |             emit log_named_int("      Actual", a);
 193 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 194 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 195 |     |             fail();
 196 |     |         }
 197 |     |     }
 198 |     | 
 199 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {
 200 |     |         if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.
 201 |     | 
 202 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 203 |     | 
 204 |     |         if (percentDelta > maxPercentDelta) {
 205 |     |             emit log_named_string("Error", err);
 206 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 207 |     |         }
 208 |     |     }
 209 |     | }
 210 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
  10 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
  11 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  12 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  13 |     |  * alias used in this contract, which can be found as the first argument to the
  14 |     |  * `setChainWithDefaultRpcUrl` call in the `initialize` function.
  15 |     |  *
  16 |     |  * There are two main ways to use this contract:
  17 |     |  *   1. Set a chain with `setChain(string memory chainAlias, Chain memory chain)`
  18 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  19 |     |  *
  20 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  21 |     |  * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  22 |     |  * `defaultRpcUrls`.
  23 |     |  *
  24 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  25 |     |  *
  26 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  27 |     |  * we want to retrieve `mainnet`'s RPC URL:
  28 |     |  *   - If you haven't set any mainnet chain info with `setChain` and you haven't specified that
  29 |     |  *     chain in `foundry.toml`, the default data and RPC URL will be returned.
  30 |     |  *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if
  31 |     |  *     a URL is given or if an environment variable is given and that environment variable exists).
  32 |     |  *     Otherwise, the default data is returned.
  33 |     |  *   - If you specified data with `setChain` it will return that.
  34 |     |  *
  35 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> defaults.
  36 |     |  */
  37 |     | abstract contract StdChains {
  38 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  39 |     | 
  40 |     |     bool private initialized;
  41 |     | 
  42 |     |     struct Chain {
  43 |     |         // The chain name.
  44 |     |         string name;
  45 |     |         // The chain's Chain ID.
  46 |     |         uint256 chainId;
  47 |     |         // A default RPC endpoint for this chain.
  48 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  49 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  50 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  51 |     |         string rpcUrl;
  52 |     |     }
  53 |     | 
  54 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  55 |     |     mapping(string => Chain) private chains;
  56 |     |     // Maps from the chain's alias to it's default RPC URL.
  57 |     |     mapping(string => string) private defaultRpcUrls;
  58 |     |     // Maps from a chain ID to it's alias.
  59 |     |     mapping(uint256 => string) private idToAlias;
  60 |     | 
  61 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  62 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  63 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  64 |     | 
  65 |     |         initialize();
  66 |     |         chain = chains[chainAlias];
  67 |     |         require(
  68 |     |             chain.chainId != 0,
  69 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  70 |     |         );
  71 |     | 
  72 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  73 |     |     }
  74 |     | 
  75 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  76 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  77 |     |         initialize();
  78 |     |         string memory chainAlias = idToAlias[chainId];
  79 |     | 
  80 |     |         chain = chains[chainAlias];
  81 |     | 
  82 |     |         require(
  83 |     |             chain.chainId != 0,
  84 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  85 |     |         );
  86 |     | 
  87 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  88 |     |     }
  89 |     | 
  90 |     |     // set chain info, with priority to argument's rpcUrl field.
  91 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
  92 |     |         require(
  93 |     |             bytes(chainAlias).length != 0, "StdChains setChain(string,Chain): Chain alias cannot be the empty string."
  94 |     |         );
  95 |     | 
  96 |     |         require(chain.chainId != 0, "StdChains setChain(string,Chain): Chain ID cannot be 0.");
  97 |     | 
  98 |     |         initialize();
  99 |     |         string memory foundAlias = idToAlias[chain.chainId];
 100 |     | 
 101 |     |         require(
 102 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 103 |     |             string(
 104 |     |                 abi.encodePacked(
 105 |     |                     "StdChains setChain(string,Chain): Chain ID ",
 106 |     |                     vm.toString(chain.chainId),
 107 |     |                     " already used by \"",
 108 |     |                     foundAlias,
 109 |     |                     "\"."
 110 |     |                 )
 111 |     |             )
 112 |     |         );
 113 |     | 
 114 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 115 |     |         delete idToAlias[oldChainId];
 116 |     | 
 117 |     |         chains[chainAlias] = chain;
 118 |     |         idToAlias[chain.chainId] = chainAlias;
 119 |     |     }
 120 |     | 
 121 |     |     // lookup rpcUrl, in descending order of priority:
 122 |     |     // current -> config (foundry.toml) -> default
 123 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 124 |     |         private
 125 |     |         view
 126 |     |         returns (Chain memory)
 127 |     |     {
 128 |     |         if (bytes(chain.rpcUrl).length == 0) {
 129 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 130 |     |                 chain.rpcUrl = configRpcUrl;
 131 |     |             } catch (bytes memory err) {
 132 |     |                 chain.rpcUrl = defaultRpcUrls[chainAlias];
 133 |     |                 // distinguish 'not found' from 'cannot read'
 134 |     |                 bytes memory notFoundError =
 135 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 136 |     |                 if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {
 137 |     |                     /// @solidity memory-safe-assembly
 138 |     |                     assembly {
 139 |     |                         revert(add(32, err), mload(err))
 140 |     |                     }
 141 |     |                 }
 142 |     |             }
 143 |     |         }
 144 |     |         return chain;
 145 |     |     }
 146 |     | 
 147 |     |     function initialize() private {
 148 |     |         if (initialized) return;
 149 |     | 
 150 |     |         initialized = true;
 151 |     | 
 152 |     |         // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`
 153 |     |         setChainWithDefaultRpcUrl("anvil", Chain("Anvil", 31337, "http://127.0.0.1:8545"));
 154 |     |         setChainWithDefaultRpcUrl(
 155 |     |             "mainnet", Chain("Mainnet", 1, "https://mainnet.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
 156 |     |         );
 157 |     |         setChainWithDefaultRpcUrl(
 158 |     |             "goerli", Chain("Goerli", 5, "https://goerli.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
 159 |     |         );
 160 |     |         setChainWithDefaultRpcUrl(
 161 |     |             "sepolia", Chain("Sepolia", 11155111, "https://sepolia.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
 162 |     |         );
 163 |     |         setChainWithDefaultRpcUrl("optimism", Chain("Optimism", 10, "https://mainnet.optimism.io"));
 164 |     |         setChainWithDefaultRpcUrl("optimism_goerli", Chain("Optimism Goerli", 420, "https://goerli.optimism.io"));
 165 |     |         setChainWithDefaultRpcUrl("arbitrum_one", Chain("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 166 |     |         setChainWithDefaultRpcUrl(
 167 |     |             "arbitrum_one_goerli", Chain("Arbitrum One Goerli", 421613, "https://goerli-rollup.arbitrum.io/rpc")
 168 |     |         );
 169 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", Chain("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 170 |     |         setChainWithDefaultRpcUrl("polygon", Chain("Polygon", 137, "https://polygon-rpc.com"));
 171 |     |         setChainWithDefaultRpcUrl("polygon_mumbai", Chain("Polygon Mumbai", 80001, "https://rpc-mumbai.maticvigil.com"));
 172 |     |         setChainWithDefaultRpcUrl("avalanche", Chain("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 173 |     |         setChainWithDefaultRpcUrl(
 174 |     |             "avalanche_fuji", Chain("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 175 |     |         );
 176 |     |         setChainWithDefaultRpcUrl("bnb_smart_chain", Chain("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org"));
 177 |     |         setChainWithDefaultRpcUrl("bnb_smart_chain_testnet", Chain("BNB Smart Chain Testnet", 97, "https://data-seed-prebsc-1-s1.binance.org:8545"));// forgefmt: disable-line
 178 |     |         setChainWithDefaultRpcUrl("gnosis_chain", Chain("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 179 |     |     }
 180 |     | 
 181 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 182 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, Chain memory chain) private {
 183 |     |         string memory rpcUrl = chain.rpcUrl;
 184 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 185 |     |         chain.rpcUrl = "";
 186 |     |         setChain(chainAlias, chain);
 187 |     |         chain.rpcUrl = rpcUrl; // restore argument
 188 |     |     }
 189 |     | }
 190 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {Vm} from "./Vm.sol";
   8 |     | 
   9 |     | abstract contract StdCheatsSafe {
  10 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  11 |     | 
  12 |     |     bool private gasMeteringOff;
  13 |     | 
  14 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  15 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  16 |     |     // and then converted to the one that is used by the user for better UX.
  17 |     | 
  18 |     |     struct RawTx1559 {
  19 |     |         string[] arguments;
  20 |     |         address contractAddress;
  21 |     |         string contractName;
  22 |     |         // json value name = function
  23 |     |         string functionSig;
  24 |     |         bytes32 hash;
  25 |     |         // json value name = tx
  26 |     |         RawTx1559Detail txDetail;
  27 |     |         // json value name = type
  28 |     |         string opcode;
  29 |     |     }
  30 |     | 
  31 |     |     struct RawTx1559Detail {
  32 |     |         AccessList[] accessList;
  33 |     |         bytes data;
  34 |     |         address from;
  35 |     |         bytes gas;
  36 |     |         bytes nonce;
  37 |     |         address to;
  38 |     |         bytes txType;
  39 |     |         bytes value;
  40 |     |     }
  41 |     | 
  42 |     |     struct Tx1559 {
  43 |     |         string[] arguments;
  44 |     |         address contractAddress;
  45 |     |         string contractName;
  46 |     |         string functionSig;
  47 |     |         bytes32 hash;
  48 |     |         Tx1559Detail txDetail;
  49 |     |         string opcode;
  50 |     |     }
  51 |     | 
  52 |     |     struct Tx1559Detail {
  53 |     |         AccessList[] accessList;
  54 |     |         bytes data;
  55 |     |         address from;
  56 |     |         uint256 gas;
  57 |     |         uint256 nonce;
  58 |     |         address to;
  59 |     |         uint256 txType;
  60 |     |         uint256 value;
  61 |     |     }
  62 |     | 
  63 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  64 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  65 |     |     // and then converted to the one that is used by the user for better UX.
  66 |     | 
  67 |     |     struct TxLegacy {
  68 |     |         string[] arguments;
  69 |     |         address contractAddress;
  70 |     |         string contractName;
  71 |     |         string functionSig;
  72 |     |         string hash;
  73 |     |         string opcode;
  74 |     |         TxDetailLegacy transaction;
  75 |     |     }
  76 |     | 
  77 |     |     struct TxDetailLegacy {
  78 |     |         AccessList[] accessList;
  79 |     |         uint256 chainId;
  80 |     |         bytes data;
  81 |     |         address from;
  82 |     |         uint256 gas;
  83 |     |         uint256 gasPrice;
  84 |     |         bytes32 hash;
  85 |     |         uint256 nonce;
  86 |     |         bytes1 opcode;
  87 |     |         bytes32 r;
  88 |     |         bytes32 s;
  89 |     |         uint256 txType;
  90 |     |         address to;
  91 |     |         uint8 v;
  92 |     |         uint256 value;
  93 |     |     }
  94 |     | 
  95 |     |     struct AccessList {
  96 |     |         address accessAddress;
  97 |     |         bytes32[] storageKeys;
  98 |     |     }
  99 |     | 
 100 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 101 |     |     // The Raw structs is what is parsed from the JSON
 102 |     |     // and then converted to the one that is used by the user for better UX.
 103 |     | 
 104 |     |     struct RawReceipt {
 105 |     |         bytes32 blockHash;
 106 |     |         bytes blockNumber;
 107 |     |         address contractAddress;
 108 |     |         bytes cumulativeGasUsed;
 109 |     |         bytes effectiveGasPrice;
 110 |     |         address from;
 111 |     |         bytes gasUsed;
 112 |     |         RawReceiptLog[] logs;
 113 |     |         bytes logsBloom;
 114 |     |         bytes status;
 115 |     |         address to;
 116 |     |         bytes32 transactionHash;
 117 |     |         bytes transactionIndex;
 118 |     |     }
 119 |     | 
 120 |     |     struct Receipt {
 121 |     |         bytes32 blockHash;
 122 |     |         uint256 blockNumber;
 123 |     |         address contractAddress;
 124 |     |         uint256 cumulativeGasUsed;
 125 |     |         uint256 effectiveGasPrice;
 126 |     |         address from;
 127 |     |         uint256 gasUsed;
 128 |     |         ReceiptLog[] logs;
 129 |     |         bytes logsBloom;
 130 |     |         uint256 status;
 131 |     |         address to;
 132 |     |         bytes32 transactionHash;
 133 |     |         uint256 transactionIndex;
 134 |     |     }
 135 |     | 
 136 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 137 |     |     // transactions conform to EIP1559.
 138 |     | 
 139 |     |     struct EIP1559ScriptArtifact {
 140 |     |         string[] libraries;
 141 |     |         string path;
 142 |     |         string[] pending;
 143 |     |         Receipt[] receipts;
 144 |     |         uint256 timestamp;
 145 |     |         Tx1559[] transactions;
 146 |     |         TxReturn[] txReturns;
 147 |     |     }
 148 |     | 
 149 |     |     struct RawEIP1559ScriptArtifact {
 150 |     |         string[] libraries;
 151 |     |         string path;
 152 |     |         string[] pending;
 153 |     |         RawReceipt[] receipts;
 154 |     |         TxReturn[] txReturns;
 155 |     |         uint256 timestamp;
 156 |     |         RawTx1559[] transactions;
 157 |     |     }
 158 |     | 
 159 |     |     struct RawReceiptLog {
 160 |     |         // json value = address
 161 |     |         address logAddress;
 162 |     |         bytes32 blockHash;
 163 |     |         bytes blockNumber;
 164 |     |         bytes data;
 165 |     |         bytes logIndex;
 166 |     |         bool removed;
 167 |     |         bytes32[] topics;
 168 |     |         bytes32 transactionHash;
 169 |     |         bytes transactionIndex;
 170 |     |         bytes transactionLogIndex;
 171 |     |     }
 172 |     | 
 173 |     |     struct ReceiptLog {
 174 |     |         // json value = address
 175 |     |         address logAddress;
 176 |     |         bytes32 blockHash;
 177 |     |         uint256 blockNumber;
 178 |     |         bytes data;
 179 |     |         uint256 logIndex;
 180 |     |         bytes32[] topics;
 181 |     |         uint256 transactionIndex;
 182 |     |         uint256 transactionLogIndex;
 183 |     |         bool removed;
 184 |     |     }
 185 |     | 
 186 |     |     struct TxReturn {
 187 |     |         string internalType;
 188 |     |         string value;
 189 |     |     }
 190 |     | 
 191 |     |     function assumeNoPrecompiles(address addr) internal virtual {
 192 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 193 |     |         uint256 chainId;
 194 |     |         assembly {
 195 |     |             chainId := chainid()
 196 |     |         }
 197 |     |         assumeNoPrecompiles(addr, chainId);
 198 |     |     }
 199 |     | 
 200 |     |     function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {
 201 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 202 |     |         // address), but the same rationale for excluding them applies so we include those too.
 203 |     | 
 204 |     |         // These should be present on all EVM-compatible chains.
 205 |     |         vm.assume(addr < address(0x1) || addr > address(0x9));
 206 |     | 
 207 |     |         // forgefmt: disable-start
 208 |     |         if (chainId == 10 || chainId == 420) {
 209 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 210 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 211 |     |         } else if (chainId == 42161 || chainId == 421613) {
 212 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 213 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 214 |     |         } else if (chainId == 43114 || chainId == 43113) {
 215 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 216 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 217 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 218 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 219 |     |         }
 220 |     |         // forgefmt: disable-end
 221 |     |     }
 222 |     | 
 223 |     |     function readEIP1559ScriptArtifact(string memory path)
 224 |     |         internal
 225 |     |         view
 226 |     |         virtual
 227 |     |         returns (EIP1559ScriptArtifact memory)
 228 |     |     {
 229 |     |         string memory data = vm.readFile(path);
 230 |     |         bytes memory parsedData = vm.parseJson(data);
 231 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 232 |     |         EIP1559ScriptArtifact memory artifact;
 233 |     |         artifact.libraries = rawArtifact.libraries;
 234 |     |         artifact.path = rawArtifact.path;
 235 |     |         artifact.timestamp = rawArtifact.timestamp;
 236 |     |         artifact.pending = rawArtifact.pending;
 237 |     |         artifact.txReturns = rawArtifact.txReturns;
 238 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 239 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 240 |     |         return artifact;
 241 |     |     }
 242 |     | 
 243 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 244 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 245 |     |         for (uint256 i; i < rawTxs.length; i++) {
 246 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 247 |     |         }
 248 |     |         return txs;
 249 |     |     }
 250 |     | 
 251 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 252 |     |         Tx1559 memory transaction;
 253 |     |         transaction.arguments = rawTx.arguments;
 254 |     |         transaction.contractName = rawTx.contractName;
 255 |     |         transaction.functionSig = rawTx.functionSig;
 256 |     |         transaction.hash = rawTx.hash;
 257 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 258 |     |         transaction.opcode = rawTx.opcode;
 259 |     |         return transaction;
 260 |     |     }
 261 |     | 
 262 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 263 |     |         internal
 264 |     |         pure
 265 |     |         virtual
 266 |     |         returns (Tx1559Detail memory)
 267 |     |     {
 268 |     |         Tx1559Detail memory txDetail;
 269 |     |         txDetail.data = rawDetail.data;
 270 |     |         txDetail.from = rawDetail.from;
 271 |     |         txDetail.to = rawDetail.to;
 272 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 273 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 274 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 275 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 276 |     |         txDetail.accessList = rawDetail.accessList;
 277 |     |         return txDetail;
 278 |     |     }
 279 |     | 
 280 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 281 |     |         string memory deployData = vm.readFile(path);
 282 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 283 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 284 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 285 |     |     }
 286 |     | 
 287 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 288 |     |         string memory deployData = vm.readFile(path);
 289 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 290 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 291 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 292 |     |         return rawToConvertedEIPTx1559(rawTx);
 293 |     |     }
 294 |     | 
 295 |     |     // Analogous to readTransactions, but for receipts.
 296 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 297 |     |         string memory deployData = vm.readFile(path);
 298 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 299 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 300 |     |         return rawToConvertedReceipts(rawReceipts);
 301 |     |     }
 302 |     | 
 303 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 304 |     |         string memory deployData = vm.readFile(path);
 305 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 306 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 307 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 308 |     |         return rawToConvertedReceipt(rawReceipt);
 309 |     |     }
 310 |     | 
 311 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 312 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 313 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 314 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 315 |     |         }
 316 |     |         return receipts;
 317 |     |     }
 318 |     | 
 319 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 320 |     |         Receipt memory receipt;
 321 |     |         receipt.blockHash = rawReceipt.blockHash;
 322 |     |         receipt.to = rawReceipt.to;
 323 |     |         receipt.from = rawReceipt.from;
 324 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 325 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 326 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 327 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 328 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 329 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 330 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 331 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 332 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 333 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 334 |     |         return receipt;
 335 |     |     }
 336 |     | 
 337 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 338 |     |         internal
 339 |     |         pure
 340 |     |         virtual
 341 |     |         returns (ReceiptLog[] memory)
 342 |     |     {
 343 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 344 |     |         for (uint256 i; i < rawLogs.length; i++) {
 345 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 346 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 347 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 348 |     |             logs[i].data = rawLogs[i].data;
 349 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 350 |     |             logs[i].topics = rawLogs[i].topics;
 351 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 352 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 353 |     |             logs[i].removed = rawLogs[i].removed;
 354 |     |         }
 355 |     |         return logs;
 356 |     |     }
 357 |     | 
 358 |     |     // Deploy a contract by fetching the contract bytecode from
 359 |     |     // the artifacts directory
 360 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 361 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 362 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 363 |     |         /// @solidity memory-safe-assembly
 364 |     |         assembly {
 365 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 366 |     |         }
 367 |     | 
 368 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 369 |     |     }
 370 |     | 
 371 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 372 |     |         bytes memory bytecode = vm.getCode(what);
 373 |     |         /// @solidity memory-safe-assembly
 374 |     |         assembly {
 375 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 376 |     |         }
 377 |     | 
 378 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 379 |     |     }
 380 |     | 
 381 |     |     /// @dev deploy contract with value on construction
 382 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 383 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 384 |     |         /// @solidity memory-safe-assembly
 385 |     |         assembly {
 386 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 387 |     |         }
 388 |     | 
 389 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 390 |     |     }
 391 |     | 
 392 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 393 |     |         bytes memory bytecode = vm.getCode(what);
 394 |     |         /// @solidity memory-safe-assembly
 395 |     |         assembly {
 396 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 397 |     |         }
 398 |     | 
 399 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 400 |     |     }
 401 |     | 
 402 |     |     // creates a labeled address and the corresponding private key
 403 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 404 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 405 |     |         addr = vm.addr(privateKey);
 406 |     |         vm.label(addr, name);
 407 |     |     }
 408 |     | 
 409 |     |     // creates a labeled address
 410 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 411 |     |         (addr,) = makeAddrAndKey(name);
 412 |     |     }
 413 |     | 
 414 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 415 |     |         internal
 416 |     |         virtual
 417 |     |         returns (address who, uint256 privateKey)
 418 |     |     {
 419 |     |         privateKey = vm.deriveKey(mnemonic, index);
 420 |     |         who = vm.rememberKey(privateKey);
 421 |     |     }
 422 |     | 
 423 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 424 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 425 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 426 |     |     }
 427 |     | 
 428 |     |     function isFork() internal view virtual returns (bool status) {
 429 |     |         try vm.activeFork() {
 430 |     |             status = true;
 431 |     |         } catch (bytes memory) {}
 432 |     |     }
 433 |     | 
 434 |     |     modifier skipWhenForking() {
 435 |     |         if (!isFork()) {
 436 |     |             _;
 437 |     |         }
 438 |     |     }
 439 |     | 
 440 |     |     modifier skipWhenNotForking() {
 441 |     |         if (isFork()) {
 442 |     |             _;
 443 |     |         }
 444 |     |     }
 445 |     | 
 446 |     |     modifier noGasMetering() {
 447 |     |         vm.pauseGasMetering();
 448 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 449 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 450 |     |         // it back on until we exit the top level function that used the modifier
 451 |     |         //
 452 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 453 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 454 |     |         // so we only turn metering back on at the end of the funcA
 455 |     |         bool gasStartedOff = gasMeteringOff;
 456 |     |         gasMeteringOff = true;
 457 |     | 
 458 |     |         _;
 459 |     | 
 460 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 461 |     |         if (!gasStartedOff) {
 462 |     |             gasMeteringOff = false;
 463 |     |             vm.resumeGasMetering();
 464 |     |         }
 465 |     |     }
 466 |     | }
 467 |     | 
 468 |     | // Wrappers around cheatcodes to avoid footguns
 469 |     | abstract contract StdCheats is StdCheatsSafe {
 470 |     |     using stdStorage for StdStorage;
 471 |     | 
 472 |     |     StdStorage private stdstore;
 473 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 474 |     | 
 475 |     |     // Skip forward or rewind time by the specified number of seconds
 476 |     |     function skip(uint256 time) internal virtual {
 477 |     |         vm.warp(block.timestamp + time);
 478 |     |     }
 479 |     | 
 480 |     |     function rewind(uint256 time) internal virtual {
 481 |     |         vm.warp(block.timestamp - time);
 482 |     |     }
 483 |     | 
 484 |     |     // Setup a prank from an address that has some ether
 485 |     |     function hoax(address who) internal virtual {
 486 |     |         vm.deal(who, 1 << 128);
 487 |     |         vm.prank(who);
 488 |     |     }
 489 |     | 
 490 |     |     function hoax(address who, uint256 give) internal virtual {
 491 |     |         vm.deal(who, give);
 492 |     |         vm.prank(who);
 493 |     |     }
 494 |     | 
 495 |     |     function hoax(address who, address origin) internal virtual {
 496 |     |         vm.deal(who, 1 << 128);
 497 |     |         vm.prank(who, origin);
 498 |     |     }
 499 |     | 
 500 |     |     function hoax(address who, address origin, uint256 give) internal virtual {
 501 |     |         vm.deal(who, give);
 502 |     |         vm.prank(who, origin);
 503 |     |     }
 504 |     | 
 505 |     |     // Start perpetual prank from an address that has some ether
 506 |     |     function startHoax(address who) internal virtual {
 507 |     |         vm.deal(who, 1 << 128);
 508 |     |         vm.startPrank(who);
 509 |     |     }
 510 |     | 
 511 |     |     function startHoax(address who, uint256 give) internal virtual {
 512 |     |         vm.deal(who, give);
 513 |     |         vm.startPrank(who);
 514 |     |     }
 515 |     | 
 516 |     |     // Start perpetual prank from an address that has some ether
 517 |     |     // tx.origin is set to the origin parameter
 518 |     |     function startHoax(address who, address origin) internal virtual {
 519 |     |         vm.deal(who, 1 << 128);
 520 |     |         vm.startPrank(who, origin);
 521 |     |     }
 522 |     | 
 523 |     |     function startHoax(address who, address origin, uint256 give) internal virtual {
 524 |     |         vm.deal(who, give);
 525 |     |         vm.startPrank(who, origin);
 526 |     |     }
 527 |     | 
 528 |     |     function changePrank(address who) internal virtual {
 529 |     |         vm.stopPrank();
 530 |     |         vm.startPrank(who);
 531 |     |     }
 532 |     | 
 533 |     |     // The same as Vm's `deal`
 534 |     |     // Use the alternative signature for ERC20 tokens
 535 |     |     function deal(address to, uint256 give) internal virtual {
 536 |     |         vm.deal(to, give);
 537 |     |     }
 538 |     | 
 539 |     |     // Set the balance of an account for any ERC20 token
 540 |     |     // Use the alternative signature to update `totalSupply`
 541 |     |     function deal(address token, address to, uint256 give) internal virtual {
 542 |     |         deal(token, to, give, false);
 543 |     |     }
 544 |     | 
 545 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 546 |     |         // get current balance
 547 |     |         (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));
 548 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 549 |     | 
 550 |     |         // update balance
 551 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 552 |     | 
 553 |     |         // update total supply
 554 |     |         if (adjust) {
 555 |     |             (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));
 556 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 557 |     |             if (give < prevBal) {
 558 |     |                 totSup -= (prevBal - give);
 559 |     |             } else {
 560 |     |                 totSup += (give - prevBal);
 561 |     |             }
 562 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 563 |     |         }
 564 |     |     }
 565 |     | }
 566 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("some_peth");
  13 |     | // json.parseUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "deploymentArtifact";
  19 |     | // Contract contract = new Contract();
  20 |     | // json.serialize("contractAddress", address(contract));
  21 |     | // json = json.serialize("deploymentTimes", uint(1));
  22 |     | // // store the stringified JSON to the 'json' variable we have been using as a key
  23 |     | // // as we won't need it any longer
  24 |     | // string memory json2 = "finalArtifact";
  25 |     | // string memory final = json2.serialize("depArtifact", json);
  26 |     | // final.write("<some_path>");
  27 |     | // ```
  28 |     | 
  29 |     | library stdJson {
  30 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  37 |     |         return abi.decode(vm.parseJson(json, key), (uint256));
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return abi.decode(vm.parseJson(json, key), (uint256[]));
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  45 |     |         return abi.decode(vm.parseJson(json, key), (int256));
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return abi.decode(vm.parseJson(json, key), (int256[]));
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  53 |     |         return abi.decode(vm.parseJson(json, key), (bytes32));
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return abi.decode(vm.parseJson(json, key), (bytes32[]));
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  61 |     |         return abi.decode(vm.parseJson(json, key), (string));
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  65 |     |         return abi.decode(vm.parseJson(json, key), (string[]));
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  69 |     |         return abi.decode(vm.parseJson(json, key), (address));
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  73 |     |         return abi.decode(vm.parseJson(json, key), (address[]));
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  77 |     |         return abi.decode(vm.parseJson(json, key), (bool));
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return abi.decode(vm.parseJson(json, key), (bool[]));
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  85 |     |         return abi.decode(vm.parseJson(json, key), (bytes));
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return abi.decode(vm.parseJson(json, key), (bytes[]));
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeJson(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeJson(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct StdStorage {
   7 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
   8 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
   9 |     |     bytes32[] _keys;
  10 |     |     bytes4 _sig;
  11 |     |     uint256 _depth;
  12 |     |     address _target;
  13 |     |     bytes32 _set;
  14 |     | }
  15 |     | 
  16 |     | library stdStorageSafe {
  17 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  18 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  19 |     | 
  20 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  21 |     | 
  22 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  23 |     |         return bytes4(keccak256(bytes(sigStr)));
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
  27 |     |     // slot complexity:
  28 |     |     //  if flat, will be bytes32(uint256(uint));
  29 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
  30 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
  31 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
  32 |     |     function find(StdStorage storage self) internal returns (uint256) {
  33 |     |         address who = self._target;
  34 |     |         bytes4 fsig = self._sig;
  35 |     |         uint256 field_depth = self._depth;
  36 |     |         bytes32[] memory ins = self._keys;
  37 |     | 
  38 |     |         // calldata to test against
  39 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
  40 |     |             return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
  41 |     |         }
  42 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
  43 |     |         vm.record();
  44 |     |         bytes32 fdat;
  45 |     |         {
  46 |     |             (, bytes memory rdat) = who.staticcall(cald);
  47 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
  48 |     |         }
  49 |     | 
  50 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
  51 |     |         if (reads.length == 1) {
  52 |     |             bytes32 curr = vm.load(who, reads[0]);
  53 |     |             if (curr == bytes32(0)) {
  54 |     |                 emit WARNING_UninitedSlot(who, uint256(reads[0]));
  55 |     |             }
  56 |     |             if (fdat != curr) {
  57 |     |                 require(
  58 |     |                     false,
  59 |     |                     "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
  60 |     |                 );
  61 |     |             }
  62 |     |             emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
  63 |     |             self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
  64 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  65 |     |         } else if (reads.length > 1) {
  66 |     |             for (uint256 i = 0; i < reads.length; i++) {
  67 |     |                 bytes32 prev = vm.load(who, reads[i]);
  68 |     |                 if (prev == bytes32(0)) {
  69 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
  70 |     |                 }
  71 |     |                 // store
  72 |     |                 vm.store(who, reads[i], bytes32(hex"1337"));
  73 |     |                 bool success;
  74 |     |                 bytes memory rdat;
  75 |     |                 {
  76 |     |                     (success, rdat) = who.staticcall(cald);
  77 |     |                     fdat = bytesToBytes32(rdat, 32 * field_depth);
  78 |     |                 }
  79 |     | 
  80 |     |                 if (success && fdat == bytes32(hex"1337")) {
  81 |     |                     // we found which of the slots is the actual one
  82 |     |                     emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
  83 |     |                     self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
  84 |     |                     self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  85 |     |                     vm.store(who, reads[i], prev);
  86 |     |                     break;
  87 |     |                 }
  88 |     |                 vm.store(who, reads[i], prev);
  89 |     |             }
  90 |     |         } else {
  91 |     |             require(false, "stdStorage find(StdStorage): No storage use detected for target.");
  92 |     |         }
  93 |     | 
  94 |     |         require(
  95 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],
  96 |     |             "stdStorage find(StdStorage): Slot(s) not found."
  97 |     |         );
  98 |     | 
  99 |     |         delete self._target;
 100 |     |         delete self._sig;
 101 |     |         delete self._keys;
 102 |     |         delete self._depth;
 103 |     | 
 104 |     |         return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
 105 |     |     }
 106 |     | 
 107 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 108 |     |         self._target = _target;
 109 |     |         return self;
 110 |     |     }
 111 |     | 
 112 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 113 |     |         self._sig = _sig;
 114 |     |         return self;
 115 |     |     }
 116 |     | 
 117 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 118 |     |         self._sig = sigs(_sig);
 119 |     |         return self;
 120 |     |     }
 121 |     | 
 122 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 123 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 124 |     |         return self;
 125 |     |     }
 126 |     | 
 127 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 128 |     |         self._keys.push(bytes32(amt));
 129 |     |         return self;
 130 |     |     }
 131 |     | 
 132 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 133 |     |         self._keys.push(key);
 134 |     |         return self;
 135 |     |     }
 136 |     | 
 137 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 138 |     |         self._depth = _depth;
 139 |     |         return self;
 140 |     |     }
 141 |     | 
 142 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 143 |     |         address t = self._target;
 144 |     |         uint256 s = find(self);
 145 |     |         return abi.encode(vm.load(t, bytes32(s)));
 146 |     |     }
 147 |     | 
 148 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 149 |     |         return abi.decode(read(self), (bytes32));
 150 |     |     }
 151 |     | 
 152 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 153 |     |         int256 v = read_int(self);
 154 |     |         if (v == 0) return false;
 155 |     |         if (v == 1) return true;
 156 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 157 |     |     }
 158 |     | 
 159 |     |     function read_address(StdStorage storage self) internal returns (address) {
 160 |     |         return abi.decode(read(self), (address));
 161 |     |     }
 162 |     | 
 163 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 164 |     |         return abi.decode(read(self), (uint256));
 165 |     |     }
 166 |     | 
 167 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 168 |     |         return abi.decode(read(self), (int256));
 169 |     |     }
 170 |     | 
 171 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 172 |     |         bytes32 out;
 173 |     | 
 174 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 175 |     |         for (uint256 i = 0; i < max; i++) {
 176 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 177 |     |         }
 178 |     |         return out;
 179 |     |     }
 180 |     | 
 181 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 182 |     |         bytes memory result = new bytes(b.length * 32);
 183 |     |         for (uint256 i = 0; i < b.length; i++) {
 184 |     |             bytes32 k = b[i];
 185 |     |             /// @solidity memory-safe-assembly
 186 |     |             assembly {
 187 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 |     |         return result;
 192 |     |     }
 193 |     | }
 194 |     | 
 195 |     | library stdStorage {
 196 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 197 |     | 
 198 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 199 |     |         return stdStorageSafe.sigs(sigStr);
 200 |     |     }
 201 |     | 
 202 |     |     function find(StdStorage storage self) internal returns (uint256) {
 203 |     |         return stdStorageSafe.find(self);
 204 |     |     }
 205 |     | 
 206 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 207 |     |         return stdStorageSafe.target(self, _target);
 208 |     |     }
 209 |     | 
 210 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 211 |     |         return stdStorageSafe.sig(self, _sig);
 212 |     |     }
 213 |     | 
 214 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 215 |     |         return stdStorageSafe.sig(self, _sig);
 216 |     |     }
 217 |     | 
 218 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 219 |     |         return stdStorageSafe.with_key(self, who);
 220 |     |     }
 221 |     | 
 222 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 223 |     |         return stdStorageSafe.with_key(self, amt);
 224 |     |     }
 225 |     | 
 226 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 227 |     |         return stdStorageSafe.with_key(self, key);
 228 |     |     }
 229 |     | 
 230 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 231 |     |         return stdStorageSafe.depth(self, _depth);
 232 |     |     }
 233 |     | 
 234 |     |     function checked_write(StdStorage storage self, address who) internal {
 235 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 236 |     |     }
 237 |     | 
 238 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 239 |     |         checked_write(self, bytes32(amt));
 240 |     |     }
 241 |     | 
 242 |     |     function checked_write(StdStorage storage self, bool write) internal {
 243 |     |         bytes32 t;
 244 |     |         /// @solidity memory-safe-assembly
 245 |     |         assembly {
 246 |     |             t := write
 247 |     |         }
 248 |     |         checked_write(self, t);
 249 |     |     }
 250 |     | 
 251 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 252 |     |         address who = self._target;
 253 |     |         bytes4 fsig = self._sig;
 254 |     |         uint256 field_depth = self._depth;
 255 |     |         bytes32[] memory ins = self._keys;
 256 |     | 
 257 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
 258 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
 259 |     |             find(self);
 260 |     |         }
 261 |     |         bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);
 262 |     | 
 263 |     |         bytes32 fdat;
 264 |     |         {
 265 |     |             (, bytes memory rdat) = who.staticcall(cald);
 266 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
 267 |     |         }
 268 |     |         bytes32 curr = vm.load(who, slot);
 269 |     | 
 270 |     |         if (fdat != curr) {
 271 |     |             require(
 272 |     |                 false,
 273 |     |                 "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
 274 |     |             );
 275 |     |         }
 276 |     |         vm.store(who, slot, set);
 277 |     |         delete self._target;
 278 |     |         delete self._sig;
 279 |     |         delete self._keys;
 280 |     |         delete self._depth;
 281 |     |     }
 282 |     | 
 283 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 284 |     |         return stdStorageSafe.read_bytes32(self);
 285 |     |     }
 286 |     | 
 287 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 288 |     |         return stdStorageSafe.read_bool(self);
 289 |     |     }
 290 |     | 
 291 |     |     function read_address(StdStorage storage self) internal returns (address) {
 292 |     |         return stdStorageSafe.read_address(self);
 293 |     |     }
 294 |     | 
 295 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 296 |     |         return stdStorageSafe.read_uint(self);
 297 |     |     }
 298 |     | 
 299 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 300 |     |         return stdStorageSafe.read_int(self);
 301 |     |     }
 302 |     | 
 303 |     |     // Private function so needs to be copied over
 304 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 305 |     |         bytes32 out;
 306 |     | 
 307 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 308 |     |         for (uint256 i = 0; i < max; i++) {
 309 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 310 |     |         }
 311 |     |         return out;
 312 |     |     }
 313 |     | 
 314 |     |     // Private function so needs to be copied over
 315 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 316 |     |         bytes memory result = new bytes(b.length * 32);
 317 |     |         for (uint256 i = 0; i < b.length; i++) {
 318 |     |             bytes32 k = b[i];
 319 |     |             /// @solidity memory-safe-assembly
 320 |     |             assembly {
 321 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 322 |     |             }
 323 |     |         }
 324 |     | 
 325 |     |         return result;
 326 |     |     }
 327 |     | }
 328 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | // TODO Remove import.
   5 |     | import {VmSafe} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdUtils {
   8 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  10 |     | 
  11 |     |     uint256 private constant INT256_MIN_ABS =
  12 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  17 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  18 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  19 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  20 |     |         if (x >= min && x <= max) return x;
  21 |     | 
  22 |     |         uint256 size = max - min + 1;
  23 |     | 
  24 |     |         // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  25 |     |         // This helps ensure coverage of the min/max values.
  26 |     |         if (x <= 3 && size > x) return min + x;
  27 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  28 |     | 
  29 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  30 |     |         if (x > max) {
  31 |     |             uint256 diff = x - max;
  32 |     |             uint256 rem = diff % size;
  33 |     |             if (rem == 0) return max;
  34 |     |             result = min + rem - 1;
  35 |     |         } else if (x < min) {
  36 |     |             uint256 diff = min - x;
  37 |     |             uint256 rem = diff % size;
  38 |     |             if (rem == 0) return min;
  39 |     |             result = max - rem + 1;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {
  44 |     |         result = _bound(x, min, max);
  45 |     |         console2_log("Bound Result", result);
  46 |     |     }
  47 |     | 
  48 |     |     function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {
  49 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  50 |     | 
  51 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  52 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  53 |     |         // uint256:     0     ~ (2**256 - 1)
  54 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  55 |     |         //
  56 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  57 |     |         // So, use `~uint256(x) + 1` instead.
  58 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  59 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  60 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  61 |     | 
  62 |     |         uint256 y = _bound(_x, _min, _max);
  63 |     | 
  64 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  65 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  66 |     |         console2_log("Bound result", vm.toString(result));
  67 |     |     }
  68 |     | 
  69 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
  70 |     |     /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
  71 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
  72 |     |         // forgefmt: disable-start
  73 |     |         // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
  74 |     |         // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
  75 |     |         if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));
  76 |     |         if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));
  77 |     | 
  78 |     |         // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
  79 |     |         if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));
  80 |     |         if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));
  81 |     |         if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));
  82 |     |         // forgefmt: disable-end
  83 |     | 
  84 |     |         // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
  85 |     |         // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
  86 |     |         // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
  87 |     |         // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
  88 |     |         // We assume nobody can have a nonce large enough to require more than 32 bytes.
  89 |     |         return addressFromLast20Bytes(
  90 |     |             keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))
  91 |     |         );
  92 |     |     }
  93 |     | 
  94 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
  95 |     |         internal
  96 |     |         pure
  97 |     |         virtual
  98 |     |         returns (address)
  99 |     |     {
 100 |     |         return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));
 101 |     |     }
 102 |     | 
 103 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
 104 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
 105 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 106 |     |     }
 107 |     | 
 108 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 109 |     |         return address(uint160(uint256(bytesValue)));
 110 |     |     }
 111 |     | 
 112 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 113 |     | 
 114 |     |     function console2_log(string memory p0, uint256 p1) private view {
 115 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 116 |     |         status;
 117 |     |     }
 118 |     | 
 119 |     |     function console2_log(string memory p0, string memory p1) private view {
 120 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,string)", p0, p1));
 121 |     |         status;
 122 |     |     }
 123 |     | }
 124 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | // 💬 ABOUT
  5 |     | // Standard Library's default Test
  6 |     | 
  7 |     | // 🧩 MODULES
  8 |     | import {console} from "./console.sol";
  9 |     | import {console2} from "./console2.sol";
 10 |     | import {StdAssertions} from "./StdAssertions.sol";
 11 |     | import {StdChains} from "./StdChains.sol";
 12 |     | import {StdCheats} from "./StdCheats.sol";
 13 |     | import {stdError} from "./StdError.sol";
 14 |     | import {stdJson} from "./StdJson.sol";
 15 |     | import {stdMath} from "./StdMath.sol";
 16 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 17 |     | import {StdUtils} from "./StdUtils.sol";
 18 |     | import {Vm} from "./Vm.sol";
 19 |     | 
 20 |     | // 📦 BOILERPLATE
 21 |     | import {TestBase} from "./Base.sol";
 22 |     | import {DSTest} from "ds-test/test.sol";
 23 |     | 
 24 |     | // ⭐️ TEST
 25 |     | abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdUtils, TestBase {
 26 |     | // Note: IS_TEST() must return true.
 27 |     | // Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.
 28 |     | }
 29 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/Vm.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | // Cheatcodes are marked as view/pure/none using the following rules:
   7 |     | // 0. A call's observable behaviour includes its return value, logs, reverts and state writes,
   8 |     | // 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),
   9 |     | // 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,
  10 |     | // 3. Otherwise you're `pure`.
  11 |     | 
  12 |     | interface VmSafe {
  13 |     |     struct Log {
  14 |     |         bytes32[] topics;
  15 |     |         bytes data;
  16 |     |         address emitter;
  17 |     |     }
  18 |     | 
  19 |     |     struct Rpc {
  20 |     |         string key;
  21 |     |         string url;
  22 |     |     }
  23 |     | 
  24 |     |     struct FsMetadata {
  25 |     |         bool isDir;
  26 |     |         bool isSymlink;
  27 |     |         uint256 length;
  28 |     |         bool readOnly;
  29 |     |         uint256 modified;
  30 |     |         uint256 accessed;
  31 |     |         uint256 created;
  32 |     |     }
  33 |     | 
  34 |     |     // Loads a storage slot from an address
  35 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  36 |     |     // Signs data
  37 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  38 |     |     // Gets the address for a given private key
  39 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  40 |     |     // Gets the nonce of an account
  41 |     |     function getNonce(address account) external view returns (uint64 nonce);
  42 |     |     // Performs a foreign function call via the terminal
  43 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  44 |     |     // Sets environment variables
  45 |     |     function setEnv(string calldata name, string calldata value) external;
  46 |     |     // Reads environment variables, (name) => (value)
  47 |     |     function envBool(string calldata name) external view returns (bool value);
  48 |     |     function envUint(string calldata name) external view returns (uint256 value);
  49 |     |     function envInt(string calldata name) external view returns (int256 value);
  50 |     |     function envAddress(string calldata name) external view returns (address value);
  51 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  52 |     |     function envString(string calldata name) external view returns (string memory value);
  53 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  54 |     |     // Reads environment variables as arrays
  55 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  56 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  57 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  58 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  59 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  60 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  61 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  62 |     |     // Read environment variables with default value
  63 |     |     function envOr(string calldata name, bool defaultValue) external returns (bool value);
  64 |     |     function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);
  65 |     |     function envOr(string calldata name, int256 defaultValue) external returns (int256 value);
  66 |     |     function envOr(string calldata name, address defaultValue) external returns (address value);
  67 |     |     function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);
  68 |     |     function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);
  69 |     |     function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);
  70 |     |     // Read environment variables as arrays with default value
  71 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  72 |     |         external
  73 |     |         returns (bool[] memory value);
  74 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  75 |     |         external
  76 |     |         returns (uint256[] memory value);
  77 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  78 |     |         external
  79 |     |         returns (int256[] memory value);
  80 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  81 |     |         external
  82 |     |         returns (address[] memory value);
  83 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  84 |     |         external
  85 |     |         returns (bytes32[] memory value);
  86 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  87 |     |         external
  88 |     |         returns (string[] memory value);
  89 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  90 |     |         external
  91 |     |         returns (bytes[] memory value);
  92 |     |     // Records all storage reads and writes
  93 |     |     function record() external;
  94 |     |     // Gets all accessed reads and write slot from a recording session, for a given address
  95 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  96 |     |     // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file
  97 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  98 |     |     // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file
  99 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
 100 |     |     // Labels an address in call traces
 101 |     |     function label(address account, string calldata newLabel) external;
 102 |     |     // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain
 103 |     |     function broadcast() external;
 104 |     |     // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain
 105 |     |     function broadcast(address signer) external;
 106 |     |     // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain
 107 |     |     function broadcast(uint256 privateKey) external;
 108 |     |     // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain
 109 |     |     function startBroadcast() external;
 110 |     |     // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain
 111 |     |     function startBroadcast(address signer) external;
 112 |     |     // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain
 113 |     |     function startBroadcast(uint256 privateKey) external;
 114 |     |     // Stops collecting onchain transactions
 115 |     |     function stopBroadcast() external;
 116 |     |     // Reads the entire content of file to string
 117 |     |     function readFile(string calldata path) external view returns (string memory data);
 118 |     |     // Reads the entire content of file as binary. Path is relative to the project root.
 119 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
 120 |     |     // Get the path of the current project root
 121 |     |     function projectRoot() external view returns (string memory path);
 122 |     |     // Get the metadata for a file/directory
 123 |     |     function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);
 124 |     |     // Reads next line of file to string
 125 |     |     function readLine(string calldata path) external view returns (string memory line);
 126 |     |     // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
 127 |     |     function writeFile(string calldata path, string calldata data) external;
 128 |     |     // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
 129 |     |     // Path is relative to the project root.
 130 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
 131 |     |     // Writes line to file, creating a file if it does not exist.
 132 |     |     function writeLine(string calldata path, string calldata data) external;
 133 |     |     // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
 134 |     |     function closeFile(string calldata path) external;
 135 |     |     // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:
 136 |     |     // - Path points to a directory.
 137 |     |     // - The file doesn't exist.
 138 |     |     // - The user lacks permissions to remove the file.
 139 |     |     function removeFile(string calldata path) external;
 140 |     |     // Convert values to a string
 141 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
 142 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
 143 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
 144 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
 145 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
 146 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
 147 |     |     // Convert values from a string
 148 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
 149 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
 150 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
 151 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
 152 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
 153 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
 154 |     |     // Record all the transaction logs
 155 |     |     function recordLogs() external;
 156 |     |     // Gets all the recorded logs
 157 |     |     function getRecordedLogs() external returns (Log[] memory logs);
 158 |     |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}
 159 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
 160 |     |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}
 161 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
 162 |     |         external
 163 |     |         pure
 164 |     |         returns (uint256 privateKey);
 165 |     |     // Adds a private key to the local forge wallet and returns the address
 166 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
 167 |     |     //
 168 |     |     // parseJson
 169 |     |     //
 170 |     |     // ----
 171 |     |     // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects
 172 |     |     // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in
 173 |     |     // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that
 174 |     |     // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded
 175 |     |     // as tuples, with the attributes in the order in which they are defined.
 176 |     |     // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}
 177 |     |     // a: uint256
 178 |     |     // b: address
 179 |     |     // To decode that json, we need to define a struct or a tuple as follows:
 180 |     |     // struct json = { uint256 a; address b; }
 181 |     |     // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to
 182 |     |     // decode the tuple in that order, and thus fail.
 183 |     |     // ----
 184 |     |     // Given a string of JSON, return it as ABI-encoded
 185 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
 186 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
 187 |     | 
 188 |     |     // Serialize a key and value to a JSON object stored in-memory that can be later written to a file
 189 |     |     // It returns the stringified version of the specific JSON file up to that moment.
 190 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
 191 |     |         external
 192 |     |         returns (string memory json);
 193 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
 194 |     |         external
 195 |     |         returns (string memory json);
 196 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
 197 |     |         external
 198 |     |         returns (string memory json);
 199 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
 200 |     |         external
 201 |     |         returns (string memory json);
 202 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
 203 |     |         external
 204 |     |         returns (string memory json);
 205 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
 206 |     |         external
 207 |     |         returns (string memory json);
 208 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
 209 |     |         external
 210 |     |         returns (string memory json);
 211 |     | 
 212 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
 213 |     |         external
 214 |     |         returns (string memory json);
 215 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
 216 |     |         external
 217 |     |         returns (string memory json);
 218 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
 219 |     |         external
 220 |     |         returns (string memory json);
 221 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
 222 |     |         external
 223 |     |         returns (string memory json);
 224 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
 225 |     |         external
 226 |     |         returns (string memory json);
 227 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
 228 |     |         external
 229 |     |         returns (string memory json);
 230 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
 231 |     |         external
 232 |     |         returns (string memory json);
 233 |     | 
 234 |     |     //
 235 |     |     // writeJson
 236 |     |     //
 237 |     |     // ----
 238 |     |     // Write a serialized JSON object to a file. If the file exists, it will be overwritten.
 239 |     |     // Let's assume we want to write the following JSON to a file:
 240 |     |     //
 241 |     |     // { "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
 242 |     |     //
 243 |     |     // ```
 244 |     |     //  string memory json1 = "some key";
 245 |     |     //  vm.serializeBool(json1, "boolean", true);
 246 |     |     //  vm.serializeBool(json1, "number", uint256(342));
 247 |     |     //  json2 = "some other key";
 248 |     |     //  string memory output = vm.serializeString(json2, "title", "finally json serialization");
 249 |     |     //  string memory finalJson = vm.serialize(json1, "object", output);
 250 |     |     //  vm.writeJson(finalJson, "./output/example.json");
 251 |     |     // ```
 252 |     |     // The critical insight is that every invocation of serialization will return the stringified version of the JSON
 253 |     |     // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version
 254 |     |     // to serialize them as values to another JSON object.
 255 |     |     //
 256 |     |     // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)
 257 |     |     // will find the object in-memory that is keyed by "some key".
 258 |     |     function writeJson(string calldata json, string calldata path) external;
 259 |     |     // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>
 260 |     |     // This is useful to replace a specific value of a JSON file, without having to parse the entire thing
 261 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
 262 |     |     // Returns the RPC url for the given alias
 263 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 264 |     |     // Returns all rpc urls and their aliases `[alias, url][]`
 265 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 266 |     |     // Returns all rpc urls and their aliases as structs.
 267 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 268 |     |     // If the condition is false, discard this run's fuzz inputs and generate new ones.
 269 |     |     function assume(bool condition) external pure;
 270 |     |     // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
 271 |     |     function pauseGasMetering() external;
 272 |     |     // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
 273 |     |     function resumeGasMetering() external;
 274 |     | }
 275 |     | 
 276 |     | interface Vm is VmSafe {
 277 |     |     // Sets block.timestamp
 278 |     |     function warp(uint256 newTimestamp) external;
 279 |     |     // Sets block.height
 280 |     |     function roll(uint256 newHeight) external;
 281 |     |     // Sets block.basefee
 282 |     |     function fee(uint256 newBasefee) external;
 283 |     |     // Sets block.difficulty
 284 |     |     function difficulty(uint256 newDifficulty) external;
 285 |     |     // Sets block.chainid
 286 |     |     function chainId(uint256 newChainId) external;
 287 |     |     // Stores a value to an address' storage slot.
 288 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 289 |     |     // Sets the nonce of an account; must be higher than the current nonce of the account
 290 |     |     function setNonce(address account, uint64 newNonce) external;
 291 |     |     // Sets the *next* call's msg.sender to be the input address
 292 |     |     function prank(address msgSender) external;
 293 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
 294 |     |     function startPrank(address msgSender) external;
 295 |     |     // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
 296 |     |     function prank(address msgSender, address txOrigin) external;
 297 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
 298 |     |     function startPrank(address msgSender, address txOrigin) external;
 299 |     |     // Resets subsequent calls' msg.sender to be `address(this)`
 300 |     |     function stopPrank() external;
 301 |     |     // Sets an address' balance
 302 |     |     function deal(address account, uint256 newBalance) external;
 303 |     |     // Sets an address' code
 304 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 305 |     |     // Expects an error on next call
 306 |     |     function expectRevert(bytes calldata revertData) external;
 307 |     |     function expectRevert(bytes4 revertData) external;
 308 |     |     function expectRevert() external;
 309 |     |     // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
 310 |     |     // Call this function, then emit an event, then call a function. Internally after the call, we check if
 311 |     |     // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
 312 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 313 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 314 |     |         external;
 315 |     |     // Mocks a call to an address, returning specified data.
 316 |     |     // Calldata can either be strict or a partial match, e.g. if you only
 317 |     |     // pass a Solidity selector to the expected calldata, then the entire Solidity
 318 |     |     // function will be mocked.
 319 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 320 |     |     // Mocks a call to an address with a specific msg.value, returning specified data.
 321 |     |     // Calldata match takes precedence over msg.value in case of ambiguity.
 322 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 323 |     |     // Clears all mocked calls
 324 |     |     function clearMockedCalls() external;
 325 |     |     // Expects a call to an address with the specified calldata.
 326 |     |     // Calldata can either be a strict or a partial match
 327 |     |     function expectCall(address callee, bytes calldata data) external;
 328 |     |     // Expects a call to an address with the specified msg.value and calldata
 329 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 330 |     |     // Sets block.coinbase
 331 |     |     function coinbase(address newCoinbase) external;
 332 |     |     // Snapshot the current state of the evm.
 333 |     |     // Returns the id of the snapshot that was created.
 334 |     |     // To revert a snapshot use `revertTo`
 335 |     |     function snapshot() external returns (uint256 snapshotId);
 336 |     |     // Revert the state of the EVM to a previous snapshot
 337 |     |     // Takes the snapshot id to revert to.
 338 |     |     // This deletes the snapshot and all snapshots taken after the given snapshot id.
 339 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 340 |     |     // Creates a new fork with the given endpoint and block and returns the identifier of the fork
 341 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 342 |     |     // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork
 343 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 344 |     |     // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,
 345 |     |     // and returns the identifier of the fork
 346 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 347 |     |     // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork
 348 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 349 |     |     // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before
 350 |     |     // the transaction, returns the identifier of the fork
 351 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 352 |     |     // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork
 353 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 354 |     |     // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 355 |     |     function selectFork(uint256 forkId) external;
 356 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 357 |     |     function activeFork() external view returns (uint256 forkId);
 358 |     |     // Updates the currently active fork to given block number
 359 |     |     // This is similar to `roll` but for the currently active fork
 360 |     |     function rollFork(uint256 blockNumber) external;
 361 |     |     // Updates the currently active fork to given transaction
 362 |     |     // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block
 363 |     |     function rollFork(bytes32 txHash) external;
 364 |     |     // Updates the given fork to given block number
 365 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 366 |     |     // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block
 367 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 368 |     |     // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 369 |     |     // Meaning, changes made to the state of this account will be kept when switching forks
 370 |     |     function makePersistent(address account) external;
 371 |     |     function makePersistent(address account0, address account1) external;
 372 |     |     function makePersistent(address account0, address account1, address account2) external;
 373 |     |     function makePersistent(address[] calldata accounts) external;
 374 |     |     // Revokes persistent status from the address, previously added via `makePersistent`
 375 |     |     function revokePersistent(address account) external;
 376 |     |     function revokePersistent(address[] calldata accounts) external;
 377 |     |     // Returns true if the account is marked as persistent
 378 |     |     function isPersistent(address account) external view returns (bool persistent);
 379 |     |     // In forking mode, explicitly grant the given address cheatcode access
 380 |     |     function allowCheatcodes(address account) external;
 381 |     |     // Fetches the given transaction from the active fork and executes it on the current state
 382 |     |     function transact(bytes32 txHash) external;
 383 |     |     // Fetches the given transaction from the given fork and executes it on the current state
 384 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 385 |     | }
 386 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _sendLogPayload(bytes memory payload) private view {
    8 |     |         uint256 payloadLength = payload.length;
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             let payloadStart := add(payload, 32)
   13 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   14 |     |         }
   15 |     |     }
   16 |     | 
   17 |     |     function log() internal view {
   18 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   19 |     |     }
   20 |     | 
   21 |     |     function logInt(int p0) internal view {
   22 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   23 |     |     }
   24 |     | 
   25 |     |     function logUint(uint p0) internal view {
   26 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   27 |     |     }
   28 |     | 
   29 |     |     function logString(string memory p0) internal view {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   31 |     |     }
   32 |     | 
   33 |     |     function logBool(bool p0) internal view {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logAddress(address p0) internal view {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logBytes(bytes memory p0) internal view {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBytes1(bytes1 p0) internal view {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logBytes2(bytes2 p0) internal view {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes3(bytes3 p0) internal view {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes4(bytes4 p0) internal view {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes5(bytes5 p0) internal view {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes6(bytes6 p0) internal view {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes7(bytes7 p0) internal view {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes8(bytes8 p0) internal view {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes9(bytes9 p0) internal view {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes10(bytes10 p0) internal view {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes11(bytes11 p0) internal view {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes12(bytes12 p0) internal view {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes13(bytes13 p0) internal view {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes14(bytes14 p0) internal view {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes15(bytes15 p0) internal view {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes16(bytes16 p0) internal view {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes17(bytes17 p0) internal view {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes18(bytes18 p0) internal view {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes19(bytes19 p0) internal view {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes20(bytes20 p0) internal view {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes21(bytes21 p0) internal view {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes22(bytes22 p0) internal view {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes23(bytes23 p0) internal view {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes24(bytes24 p0) internal view {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes25(bytes25 p0) internal view {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes26(bytes26 p0) internal view {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes27(bytes27 p0) internal view {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes28(bytes28 p0) internal view {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes29(bytes29 p0) internal view {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes30(bytes30 p0) internal view {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes31(bytes31 p0) internal view {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes32(bytes32 p0) internal view {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function log(uint p0) internal view {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function log(string memory p0) internal view {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function log(bool p0) internal view {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(address p0) internal view {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(uint p0, uint p1) internal view {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint p0, string memory p1) internal view {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  195 |     |     }
  196 |     | 
  197 |     |     function log(uint p0, bool p1) internal view {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, address p1) internal view {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(string memory p0, uint p1) internal view {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(string memory p0, string memory p1) internal view {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(string memory p0, bool p1) internal view {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, address p1) internal view {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(bool p0, uint p1) internal view {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(bool p0, string memory p1) internal view {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(bool p0, bool p1) internal view {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, address p1) internal view {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(address p0, uint p1) internal view {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(address p0, string memory p1) internal view {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(address p0, bool p1) internal view {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, address p1) internal view {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(uint p0, uint p1, uint p2) internal view {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  255 |     |     }
  256 |     | 
  257 |     |     function log(uint p0, uint p1, string memory p2) internal view {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  259 |     |     }
  260 |     | 
  261 |     |     function log(uint p0, uint p1, bool p2) internal view {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, address p2) internal view {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, string memory p1, uint p2) internal view {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, string memory p1, string memory p2) internal view {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, string memory p1, bool p2) internal view {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, address p2) internal view {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, bool p1, uint p2) internal view {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, bool p1, string memory p2) internal view {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, bool p1, bool p2) internal view {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, address p2) internal view {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, address p1, uint p2) internal view {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, address p1, string memory p2) internal view {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, address p1, bool p2) internal view {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, address p2) internal view {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(string memory p0, uint p1, uint p2) internal view {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(string memory p0, uint p1, string memory p2) internal view {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(string memory p0, uint p1, bool p2) internal view {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, address p2) internal view {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, string memory p1, uint p2) internal view {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, bool p1, uint p2) internal view {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, address p2) internal view {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, address p1, uint p2) internal view {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, address p1, bool p2) internal view {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, address p2) internal view {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(bool p0, uint p1, uint p2) internal view {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(bool p0, uint p1, string memory p2) internal view {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(bool p0, uint p1, bool p2) internal view {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, address p2) internal view {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, string memory p1, uint p2) internal view {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, address p2) internal view {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, bool p1, uint p2) internal view {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, bool p1, bool p2) internal view {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, address p2) internal view {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, address p1, uint p2) internal view {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, address p1, string memory p2) internal view {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, address p1, bool p2) internal view {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, address p2) internal view {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(address p0, uint p1, uint p2) internal view {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(address p0, uint p1, string memory p2) internal view {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(address p0, uint p1, bool p2) internal view {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, address p2) internal view {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, string memory p1, uint p2) internal view {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, string memory p1, bool p2) internal view {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, address p2) internal view {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, bool p1, uint p2) internal view {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, bool p1, string memory p2) internal view {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, bool p1, bool p2) internal view {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, address p2) internal view {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, address p1, uint p2) internal view {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, address p1, string memory p2) internal view {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, address p1, bool p2) internal view {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, address p2) internal view {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  511 |     |     }
  512 |     | 
  513 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  515 |     |     }
  516 |     | 
  517 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, address p3) internal view {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, address p3) internal view {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, address p2, uint p3) internal view {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, address p2, bool p3) internal view {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, address p3) internal view {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, address p3) internal view {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, address p3) internal view {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, address p3) internal view {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, address p2, uint p3) internal view {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, address p2, bool p3) internal view {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, address p3) internal view {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, address p1, uint p2, uint p3) internal view {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, address p1, uint p2, bool p3) internal view {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, address p3) internal view {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, address p3) internal view {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, bool p2, uint p3) internal view {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, bool p2, bool p3) internal view {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, address p3) internal view {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, address p2, uint p3) internal view {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, address p2, string memory p3) internal view {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, address p2, bool p3) internal view {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, address p3) internal view {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, address p3) internal view {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, address p3) internal view {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, address p2, uint p3) internal view {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, address p3) internal view {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, address p3) internal view {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, address p2, uint p3) internal view {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, address p2, bool p3) internal view {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, address p3) internal view {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, address p3) internal view {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, address p2, uint p3) internal view {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, address p1, uint p2, uint p3) internal view {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, address p1, uint p2, bool p3) internal view {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, address p3) internal view {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, bool p2, uint p3) internal view {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, address p2, uint p3) internal view {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(address p0, uint p1, uint p2, uint p3) internal view {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(address p0, uint p1, uint p2, bool p3) internal view {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, address p3) internal view {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, address p3) internal view {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, bool p2, uint p3) internal view {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, bool p2, bool p3) internal view {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, address p3) internal view {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, address p2, uint p3) internal view {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, address p2, string memory p3) internal view {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, address p2, bool p3) internal view {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, address p3) internal view {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, address p3) internal view {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, address p2, uint p3) internal view {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, bool p1, uint p2, uint p3) internal view {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, bool p1, uint p2, bool p3) internal view {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, address p3) internal view {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, bool p2, uint p3) internal view {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, address p2, uint p3) internal view {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, address p1, uint p2, uint p3) internal view {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, address p1, uint p2, string memory p3) internal view {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, address p1, uint p2, bool p3) internal view {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, address p3) internal view {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, string memory p2, uint p3) internal view {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, bool p2, uint p3) internal view {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, address p2, uint p3) internal view {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     | }

/Users/nataliechin/GitHub/audits-2023/hyper/lib/forge-std/src/console2.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | /// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should
    5 |     | /// use `int256` and `uint256`. This modified version fixes that. This version is recommended
    6 |     | /// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
    7 |     | /// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
    8 |     | /// Reference: https://github.com/NomicFoundation/hardhat/issues/2178
    9 |     | library console2 {
   10 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
   11 |     | 
   12 |     |     function _sendLogPayload(bytes memory payload) private view {
   13 |     |         uint256 payloadLength = payload.length;
   14 |     |         address consoleAddress = CONSOLE_ADDRESS;
   15 |     |         /// @solidity memory-safe-assembly
   16 |     |         assembly {
   17 |     |             let payloadStart := add(payload, 32)
   18 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   19 |     |         }
   20 |     |     }
   21 |     | 
   22 |     |     function log() internal view {
   23 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   24 |     |     }
   25 |     | 
   26 |     |     function logInt(int256 p0) internal view {
   27 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   28 |     |     }
   29 |     | 
   30 |     |     function logUint(uint256 p0) internal view {
   31 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   32 |     |     }
   33 |     | 
   34 |     |     function logString(string memory p0) internal view {
   35 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   36 |     |     }
   37 |     | 
   38 |     |     function logBool(bool p0) internal view {
   39 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   40 |     |     }
   41 |     | 
   42 |     |     function logAddress(address p0) internal view {
   43 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   44 |     |     }
   45 |     | 
   46 |     |     function logBytes(bytes memory p0) internal view {
   47 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   48 |     |     }
   49 |     | 
   50 |     |     function logBytes1(bytes1 p0) internal view {
   51 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   52 |     |     }
   53 |     | 
   54 |     |     function logBytes2(bytes2 p0) internal view {
   55 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   56 |     |     }
   57 |     | 
   58 |     |     function logBytes3(bytes3 p0) internal view {
   59 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   60 |     |     }
   61 |     | 
   62 |     |     function logBytes4(bytes4 p0) internal view {
   63 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   64 |     |     }
   65 |     | 
   66 |     |     function logBytes5(bytes5 p0) internal view {
   67 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   68 |     |     }
   69 |     | 
   70 |     |     function logBytes6(bytes6 p0) internal view {
   71 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   72 |     |     }
   73 |     | 
   74 |     |     function logBytes7(bytes7 p0) internal view {
   75 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   76 |     |     }
   77 |     | 
   78 |     |     function logBytes8(bytes8 p0) internal view {
   79 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   80 |     |     }
   81 |     | 
   82 |     |     function logBytes9(bytes9 p0) internal view {
   83 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   84 |     |     }
   85 |     | 
   86 |     |     function logBytes10(bytes10 p0) internal view {
   87 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   88 |     |     }
   89 |     | 
   90 |     |     function logBytes11(bytes11 p0) internal view {
   91 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   92 |     |     }
   93 |     | 
   94 |     |     function logBytes12(bytes12 p0) internal view {
   95 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   96 |     |     }
   97 |     | 
   98 |     |     function logBytes13(bytes13 p0) internal view {
   99 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  100 |     |     }
  101 |     | 
  102 |     |     function logBytes14(bytes14 p0) internal view {
  103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  104 |     |     }
  105 |     | 
  106 |     |     function logBytes15(bytes15 p0) internal view {
  107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  108 |     |     }
  109 |     | 
  110 |     |     function logBytes16(bytes16 p0) internal view {
  111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  112 |     |     }
  113 |     | 
  114 |     |     function logBytes17(bytes17 p0) internal view {
  115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  116 |     |     }
  117 |     | 
  118 |     |     function logBytes18(bytes18 p0) internal view {
  119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  120 |     |     }
  121 |     | 
  122 |     |     function logBytes19(bytes19 p0) internal view {
  123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  124 |     |     }
  125 |     | 
  126 |     |     function logBytes20(bytes20 p0) internal view {
  127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  128 |     |     }
  129 |     | 
  130 |     |     function logBytes21(bytes21 p0) internal view {
  131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  132 |     |     }
  133 |     | 
  134 |     |     function logBytes22(bytes22 p0) internal view {
  135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  136 |     |     }
  137 |     | 
  138 |     |     function logBytes23(bytes23 p0) internal view {
  139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  140 |     |     }
  141 |     | 
  142 |     |     function logBytes24(bytes24 p0) internal view {
  143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  144 |     |     }
  145 |     | 
  146 |     |     function logBytes25(bytes25 p0) internal view {
  147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  148 |     |     }
  149 |     | 
  150 |     |     function logBytes26(bytes26 p0) internal view {
  151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  152 |     |     }
  153 |     | 
  154 |     |     function logBytes27(bytes27 p0) internal view {
  155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  156 |     |     }
  157 |     | 
  158 |     |     function logBytes28(bytes28 p0) internal view {
  159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  160 |     |     }
  161 |     | 
  162 |     |     function logBytes29(bytes29 p0) internal view {
  163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  164 |     |     }
  165 |     | 
  166 |     |     function logBytes30(bytes30 p0) internal view {
  167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  168 |     |     }
  169 |     | 
  170 |     |     function logBytes31(bytes31 p0) internal view {
  171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  172 |     |     }
  173 |     | 
  174 |     |     function logBytes32(bytes32 p0) internal view {
  175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  176 |     |     }
  177 |     | 
  178 |     |     function log(uint256 p0) internal view {
  179 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  180 |     |     }
  181 |     | 
  182 |     |     function log(int256 p0) internal view {
  183 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  184 |     |     }
  185 |     | 
  186 |     |     function log(string memory p0) internal view {
  187 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  188 |     |     }
  189 |     | 
  190 |     |     function log(bool p0) internal view {
  191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  192 |     |     }
  193 |     | 
  194 |     |     function log(address p0) internal view {
  195 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  196 |     |     }
  197 |     | 
  198 |     |     function log(uint256 p0, uint256 p1) internal view {
  199 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  200 |     |     }
  201 |     | 
  202 |     |     function log(uint256 p0, string memory p1) internal view {
  203 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  204 |     |     }
  205 |     | 
  206 |     |     function log(uint256 p0, bool p1) internal view {
  207 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  208 |     |     }
  209 |     | 
  210 |     |     function log(uint256 p0, address p1) internal view {
  211 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  212 |     |     }
  213 |     | 
  214 |     |     function log(string memory p0, uint256 p1) internal view {
  215 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  216 |     |     }
  217 |     | 
  218 |     |     function log(string memory p0, int256 p1) internal view {
  219 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  220 |     |     }
  221 |     | 
  222 |     |     function log(string memory p0, string memory p1) internal view {
  223 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  224 |     |     }
  225 |     | 
  226 |     |     function log(string memory p0, bool p1) internal view {
  227 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  228 |     |     }
  229 |     | 
  230 |     |     function log(string memory p0, address p1) internal view {
  231 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  232 |     |     }
  233 |     | 
  234 |     |     function log(bool p0, uint256 p1) internal view {
  235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  236 |     |     }
  237 |     | 
  238 |     |     function log(bool p0, string memory p1) internal view {
  239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  240 |     |     }
  241 |     | 
  242 |     |     function log(bool p0, bool p1) internal view {
  243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  244 |     |     }
  245 |     | 
  246 |     |     function log(bool p0, address p1) internal view {
  247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  248 |     |     }
  249 |     | 
  250 |     |     function log(address p0, uint256 p1) internal view {
  251 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  252 |     |     }
  253 |     | 
  254 |     |     function log(address p0, string memory p1) internal view {
  255 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  256 |     |     }
  257 |     | 
  258 |     |     function log(address p0, bool p1) internal view {
  259 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  260 |     |     }
  261 |     | 
  262 |     |     function log(address p0, address p1) internal view {
  263 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  264 |     |     }
  265 |     | 
  266 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal view {
  267 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  268 |     |     }
  269 |     | 
  270 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal view {
  271 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  272 |     |     }
  273 |     | 
  274 |     |     function log(uint256 p0, uint256 p1, bool p2) internal view {
  275 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  276 |     |     }
  277 |     | 
  278 |     |     function log(uint256 p0, uint256 p1, address p2) internal view {
  279 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  280 |     |     }
  281 |     | 
  282 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal view {
  283 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  284 |     |     }
  285 |     | 
  286 |     |     function log(uint256 p0, string memory p1, string memory p2) internal view {
  287 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  288 |     |     }
  289 |     | 
  290 |     |     function log(uint256 p0, string memory p1, bool p2) internal view {
  291 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  292 |     |     }
  293 |     | 
  294 |     |     function log(uint256 p0, string memory p1, address p2) internal view {
  295 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  296 |     |     }
  297 |     | 
  298 |     |     function log(uint256 p0, bool p1, uint256 p2) internal view {
  299 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  300 |     |     }
  301 |     | 
  302 |     |     function log(uint256 p0, bool p1, string memory p2) internal view {
  303 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  304 |     |     }
  305 |     | 
  306 |     |     function log(uint256 p0, bool p1, bool p2) internal view {
  307 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  308 |     |     }
  309 |     | 
  310 |     |     function log(uint256 p0, bool p1, address p2) internal view {
  311 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  312 |     |     }
  313 |     | 
  314 |     |     function log(uint256 p0, address p1, uint256 p2) internal view {
  315 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  316 |     |     }
  317 |     | 
  318 |     |     function log(uint256 p0, address p1, string memory p2) internal view {
  319 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  320 |     |     }
  321 |     | 
  322 |     |     function log(uint256 p0, address p1, bool p2) internal view {
  323 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  324 |     |     }
  325 |     | 
  326 |     |     function log(uint256 p0, address p1, address p2) internal view {
  327 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  328 |     |     }
  329 |     | 
  330 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal view {
  331 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  332 |     |     }
  333 |     | 
  334 |     |     function log(string memory p0, uint256 p1, string memory p2) internal view {
  335 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  336 |     |     }
  337 |     | 
  338 |     |     function log(string memory p0, uint256 p1, bool p2) internal view {
  339 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  340 |     |     }
  341 |     | 
  342 |     |     function log(string memory p0, uint256 p1, address p2) internal view {
  343 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  344 |     |     }
  345 |     | 
  346 |     |     function log(string memory p0, string memory p1, uint256 p2) internal view {
  347 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  348 |     |     }
  349 |     | 
  350 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  351 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  352 |     |     }
  353 |     | 
  354 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  355 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  356 |     |     }
  357 |     | 
  358 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  359 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  360 |     |     }
  361 |     | 
  362 |     |     function log(string memory p0, bool p1, uint256 p2) internal view {
  363 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  364 |     |     }
  365 |     | 
  366 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  367 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  368 |     |     }
  369 |     | 
  370 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  371 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  372 |     |     }
  373 |     | 
  374 |     |     function log(string memory p0, bool p1, address p2) internal view {
  375 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  376 |     |     }
  377 |     | 
  378 |     |     function log(string memory p0, address p1, uint256 p2) internal view {
  379 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  380 |     |     }
  381 |     | 
  382 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  383 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  384 |     |     }
  385 |     | 
  386 |     |     function log(string memory p0, address p1, bool p2) internal view {
  387 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  388 |     |     }
  389 |     | 
  390 |     |     function log(string memory p0, address p1, address p2) internal view {
  391 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  392 |     |     }
  393 |     | 
  394 |     |     function log(bool p0, uint256 p1, uint256 p2) internal view {
  395 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  396 |     |     }
  397 |     | 
  398 |     |     function log(bool p0, uint256 p1, string memory p2) internal view {
  399 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  400 |     |     }
  401 |     | 
  402 |     |     function log(bool p0, uint256 p1, bool p2) internal view {
  403 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  404 |     |     }
  405 |     | 
  406 |     |     function log(bool p0, uint256 p1, address p2) internal view {
  407 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  408 |     |     }
  409 |     | 
  410 |     |     function log(bool p0, string memory p1, uint256 p2) internal view {
  411 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  412 |     |     }
  413 |     | 
  414 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  415 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  416 |     |     }
  417 |     | 
  418 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  419 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  420 |     |     }
  421 |     | 
  422 |     |     function log(bool p0, string memory p1, address p2) internal view {
  423 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  424 |     |     }
  425 |     | 
  426 |     |     function log(bool p0, bool p1, uint256 p2) internal view {
  427 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  428 |     |     }
  429 |     | 
  430 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  431 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  432 |     |     }
  433 |     | 
  434 |     |     function log(bool p0, bool p1, bool p2) internal view {
  435 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  436 |     |     }
  437 |     | 
  438 |     |     function log(bool p0, bool p1, address p2) internal view {
  439 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  440 |     |     }
  441 |     | 
  442 |     |     function log(bool p0, address p1, uint256 p2) internal view {
  443 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  444 |     |     }
  445 |     | 
  446 |     |     function log(bool p0, address p1, string memory p2) internal view {
  447 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  448 |     |     }
  449 |     | 
  450 |     |     function log(bool p0, address p1, bool p2) internal view {
  451 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  452 |     |     }
  453 |     | 
  454 |     |     function log(bool p0, address p1, address p2) internal view {
  455 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  456 |     |     }
  457 |     | 
  458 |     |     function log(address p0, uint256 p1, uint256 p2) internal view {
  459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  460 |     |     }
  461 |     | 
  462 |     |     function log(address p0, uint256 p1, string memory p2) internal view {
  463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  464 |     |     }
  465 |     | 
  466 |     |     function log(address p0, uint256 p1, bool p2) internal view {
  467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  468 |     |     }
  469 |     | 
  470 |     |     function log(address p0, uint256 p1, address p2) internal view {
  471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  472 |     |     }
  473 |     | 
  474 |     |     function log(address p0, string memory p1, uint256 p2) internal view {
  475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  476 |     |     }
  477 |     | 
  478 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  480 |     |     }
  481 |     | 
  482 |     |     function log(address p0, string memory p1, bool p2) internal view {
  483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  484 |     |     }
  485 |     | 
  486 |     |     function log(address p0, string memory p1, address p2) internal view {
  487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  488 |     |     }
  489 |     | 
  490 |     |     function log(address p0, bool p1, uint256 p2) internal view {
  491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  492 |     |     }
  493 |     | 
  494 |     |     function log(address p0, bool p1, string memory p2) internal view {
  495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  496 |     |     }
  497 |     | 
  498 |     |     function log(address p0, bool p1, bool p2) internal view {
  499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  500 |     |     }
  501 |     | 
  502 |     |     function log(address p0, bool p1, address p2) internal view {
  503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  504 |     |     }
  505 |     | 
  506 |     |     function log(address p0, address p1, uint256 p2) internal view {
  507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  508 |     |     }
  509 |     | 
  510 |     |     function log(address p0, address p1, string memory p2) internal view {
  511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  512 |     |     }
  513 |     | 
  514 |     |     function log(address p0, address p1, bool p2) internal view {
  515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  516 |     |     }
  517 |     | 
  518 |     |     function log(address p0, address p1, address p2) internal view {
  519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  520 |     |     }
  521 |     | 
  522 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  523 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  524 |     |     }
  525 |     | 
  526 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
  527 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  528 |     |     }
  529 |     | 
  530 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
  531 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  532 |     |     }
  533 |     | 
  534 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
  535 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  536 |     |     }
  537 |     | 
  538 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
  539 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  540 |     |     }
  541 |     | 
  542 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
  543 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  544 |     |     }
  545 |     | 
  546 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
  547 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  548 |     |     }
  549 |     | 
  550 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
  551 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  552 |     |     }
  553 |     | 
  554 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
  555 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  556 |     |     }
  557 |     | 
  558 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
  559 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  560 |     |     }
  561 |     | 
  562 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
  563 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  564 |     |     }
  565 |     | 
  566 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
  567 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  568 |     |     }
  569 |     | 
  570 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
  571 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  572 |     |     }
  573 |     | 
  574 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
  575 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  576 |     |     }
  577 |     | 
  578 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
  579 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  580 |     |     }
  581 |     | 
  582 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
  583 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  584 |     |     }
  585 |     | 
  586 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
  587 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  588 |     |     }
  589 |     | 
  590 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
  591 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  592 |     |     }
  593 |     | 
  594 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
  595 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  596 |     |     }
  597 |     | 
  598 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
  599 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  600 |     |     }
  601 |     | 
  602 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
  603 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  604 |     |     }
  605 |     | 
  606 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
  607 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  608 |     |     }
  609 |     | 
  610 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
  611 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  612 |     |     }
  613 |     | 
  614 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
  615 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  616 |     |     }
  617 |     | 
  618 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
  619 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  620 |     |     }
  621 |     | 
  622 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
  623 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  624 |     |     }
  625 |     | 
  626 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
  627 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  628 |     |     }
  629 |     | 
  630 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
  631 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  632 |     |     }
  633 |     | 
  634 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
  635 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  636 |     |     }
  637 |     | 
  638 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
  639 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  640 |     |     }
  641 |     | 
  642 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
  643 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  644 |     |     }
  645 |     | 
  646 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal view {
  647 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  648 |     |     }
  649 |     | 
  650 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
  651 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  652 |     |     }
  653 |     | 
  654 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
  655 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  656 |     |     }
  657 |     | 
  658 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
  659 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  660 |     |     }
  661 |     | 
  662 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
  663 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  664 |     |     }
  665 |     | 
  666 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
  667 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  668 |     |     }
  669 |     | 
  670 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
  671 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  672 |     |     }
  673 |     | 
  674 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
  675 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  676 |     |     }
  677 |     | 
  678 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
  679 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  680 |     |     }
  681 |     | 
  682 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
  683 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  684 |     |     }
  685 |     | 
  686 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
  687 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  688 |     |     }
  689 |     | 
  690 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
  691 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  692 |     |     }
  693 |     | 
  694 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal view {
  695 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  696 |     |     }
  697 |     | 
  698 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
  699 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  700 |     |     }
  701 |     | 
  702 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
  703 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  704 |     |     }
  705 |     | 
  706 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal view {
  707 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  708 |     |     }
  709 |     | 
  710 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal view {
  711 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  712 |     |     }
  713 |     | 
  714 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
  715 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  716 |     |     }
  717 |     | 
  718 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
  719 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  720 |     |     }
  721 |     | 
  722 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
  723 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  724 |     |     }
  725 |     | 
  726 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
  727 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  728 |     |     }
  729 |     | 
  730 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
  731 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  732 |     |     }
  733 |     | 
  734 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
  735 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  736 |     |     }
  737 |     | 
  738 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
  739 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  740 |     |     }
  741 |     | 
  742 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal view {
  743 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  744 |     |     }
  745 |     | 
  746 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
  747 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  748 |     |     }
  749 |     | 
  750 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
  751 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  752 |     |     }
  753 |     | 
  754 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal view {
  755 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  756 |     |     }
  757 |     | 
  758 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal view {
  759 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  760 |     |     }
  761 |     | 
  762 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
  763 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  764 |     |     }
  765 |     | 
  766 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal view {
  767 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  768 |     |     }
  769 |     | 
  770 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal view {
  771 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  772 |     |     }
  773 |     | 
  774 |     |     function log(uint256 p0, address p1, address p2, address p3) internal view {
  775 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  776 |     |     }
  777 |     | 
  778 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  779 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  780 |     |     }
  781 |     | 
  782 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
  783 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  784 |     |     }
  785 |     | 
  786 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
  787 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  788 |     |     }
  789 |     | 
  790 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
  791 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  792 |     |     }
  793 |     | 
  794 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
  795 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  796 |     |     }
  797 |     | 
  798 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
  799 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  800 |     |     }
  801 |     | 
  802 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
  803 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  804 |     |     }
  805 |     | 
  806 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
  807 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  808 |     |     }
  809 |     | 
  810 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
  811 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  812 |     |     }
  813 |     | 
  814 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
  815 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  816 |     |     }
  817 |     | 
  818 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
  819 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  820 |     |     }
  821 |     | 
  822 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
  823 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  824 |     |     }
  825 |     | 
  826 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
  827 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  828 |     |     }
  829 |     | 
  830 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
  831 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  832 |     |     }
  833 |     | 
  834 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
  835 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  836 |     |     }
  837 |     | 
  838 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal view {
  839 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  840 |     |     }
  841 |     | 
  842 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
  843 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  844 |     |     }
  845 |     | 
  846 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
  847 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  848 |     |     }
  849 |     | 
  850 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
  851 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  852 |     |     }
  853 |     | 
  854 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
  855 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  856 |     |     }
  857 |     | 
  858 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
  859 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  860 |     |     }
  861 |     | 
  862 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  863 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  864 |     |     }
  865 |     | 
  866 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  867 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  868 |     |     }
  869 |     | 
  870 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  871 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  872 |     |     }
  873 |     | 
  874 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
  875 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  876 |     |     }
  877 |     | 
  878 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  879 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  880 |     |     }
  881 |     | 
  882 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  883 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  884 |     |     }
  885 |     | 
  886 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  887 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  888 |     |     }
  889 |     | 
  890 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
  891 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  892 |     |     }
  893 |     | 
  894 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  895 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  896 |     |     }
  897 |     | 
  898 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  899 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  900 |     |     }
  901 |     | 
  902 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  903 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  904 |     |     }
  905 |     | 
  906 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
  907 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  908 |     |     }
  909 |     | 
  910 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
  911 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  912 |     |     }
  913 |     | 
  914 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
  915 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  916 |     |     }
  917 |     | 
  918 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
  919 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  920 |     |     }
  921 |     | 
  922 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
  923 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  924 |     |     }
  925 |     | 
  926 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  927 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  928 |     |     }
  929 |     | 
  930 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  931 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  932 |     |     }
  933 |     | 
  934 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  935 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  936 |     |     }
  937 |     | 
  938 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
  939 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  940 |     |     }
  941 |     | 
  942 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  943 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  944 |     |     }
  945 |     | 
  946 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  947 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  948 |     |     }
  949 |     | 
  950 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  951 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  952 |     |     }
  953 |     | 
  954 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
  955 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  956 |     |     }
  957 |     | 
  958 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  959 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  960 |     |     }
  961 |     | 
  962 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  963 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  964 |     |     }
  965 |     | 
  966 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  967 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  968 |     |     }
  969 |     | 
  970 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
  971 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  972 |     |     }
  973 |     | 
  974 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
  975 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  976 |     |     }
  977 |     | 
  978 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
  979 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  980 |     |     }
  981 |     | 
  982 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal view {
  983 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  984 |     |     }
  985 |     | 
  986 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
  987 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  988 |     |     }
  989 |     | 
  990 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  991 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  992 |     |     }
  993 |     | 
  994 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  995 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  996 |     |     }
  997 |     | 
  998 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  999 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1000 |     |     }
 1001 |     | 
 1002 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
 1003 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1004 |     |     }
 1005 |     | 
 1006 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
 1007 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1008 |     |     }
 1009 |     | 
 1010 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
 1011 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1012 |     |     }
 1013 |     | 
 1014 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1015 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1016 |     |     }
 1017 |     | 
 1018 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal view {
 1019 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1020 |     |     }
 1021 |     | 
 1022 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1023 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1024 |     |     }
 1025 |     | 
 1026 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1027 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1028 |     |     }
 1029 |     | 
 1030 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1031 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1032 |     |     }
 1033 |     | 
 1034 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1035 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1036 |     |     }
 1037 |     | 
 1038 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1039 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1040 |     |     }
 1041 |     | 
 1042 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
 1043 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1044 |     |     }
 1045 |     | 
 1046 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
 1047 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1048 |     |     }
 1049 |     | 
 1050 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1051 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1052 |     |     }
 1053 |     | 
 1054 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
 1055 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1056 |     |     }
 1057 |     | 
 1058 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
 1059 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1060 |     |     }
 1061 |     | 
 1062 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
 1063 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1064 |     |     }
 1065 |     | 
 1066 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
 1067 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1068 |     |     }
 1069 |     | 
 1070 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
 1071 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1072 |     |     }
 1073 |     | 
 1074 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
 1075 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1076 |     |     }
 1077 |     | 
 1078 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal view {
 1079 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1080 |     |     }
 1081 |     | 
 1082 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
 1083 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1084 |     |     }
 1085 |     | 
 1086 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
 1087 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1088 |     |     }
 1089 |     | 
 1090 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal view {
 1091 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1092 |     |     }
 1093 |     | 
 1094 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal view {
 1095 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1096 |     |     }
 1097 |     | 
 1098 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1099 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1100 |     |     }
 1101 |     | 
 1102 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
 1103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1104 |     |     }
 1105 |     | 
 1106 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
 1107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1108 |     |     }
 1109 |     | 
 1110 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
 1111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1112 |     |     }
 1113 |     | 
 1114 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
 1115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1116 |     |     }
 1117 |     | 
 1118 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1120 |     |     }
 1121 |     | 
 1122 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1124 |     |     }
 1125 |     | 
 1126 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1128 |     |     }
 1129 |     | 
 1130 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
 1131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1132 |     |     }
 1133 |     | 
 1134 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1136 |     |     }
 1137 |     | 
 1138 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1140 |     |     }
 1141 |     | 
 1142 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1144 |     |     }
 1145 |     | 
 1146 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
 1147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1148 |     |     }
 1149 |     | 
 1150 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1152 |     |     }
 1153 |     | 
 1154 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1156 |     |     }
 1157 |     | 
 1158 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1160 |     |     }
 1161 |     | 
 1162 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
 1163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1164 |     |     }
 1165 |     | 
 1166 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
 1167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1168 |     |     }
 1169 |     | 
 1170 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
 1171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1172 |     |     }
 1173 |     | 
 1174 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal view {
 1175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1176 |     |     }
 1177 |     | 
 1178 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
 1179 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1180 |     |     }
 1181 |     | 
 1182 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1183 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1184 |     |     }
 1185 |     | 
 1186 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1188 |     |     }
 1189 |     | 
 1190 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1192 |     |     }
 1193 |     | 
 1194 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
 1195 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1196 |     |     }
 1197 |     | 
 1198 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1199 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1200 |     |     }
 1201 |     | 
 1202 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1203 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1204 |     |     }
 1205 |     | 
 1206 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1207 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1208 |     |     }
 1209 |     | 
 1210 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal view {
 1211 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1212 |     |     }
 1213 |     | 
 1214 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1215 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1216 |     |     }
 1217 |     | 
 1218 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1219 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1220 |     |     }
 1221 |     | 
 1222 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1223 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1224 |     |     }
 1225 |     | 
 1226 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
 1227 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1228 |     |     }
 1229 |     | 
 1230 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
 1231 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1232 |     |     }
 1233 |     | 
 1234 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal view {
 1235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1236 |     |     }
 1237 |     | 
 1238 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal view {
 1239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1240 |     |     }
 1241 |     | 
 1242 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
 1243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1244 |     |     }
 1245 |     | 
 1246 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1248 |     |     }
 1249 |     | 
 1250 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1251 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1252 |     |     }
 1253 |     | 
 1254 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1255 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1256 |     |     }
 1257 |     | 
 1258 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal view {
 1259 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1260 |     |     }
 1261 |     | 
 1262 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1263 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1264 |     |     }
 1265 |     | 
 1266 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1267 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1268 |     |     }
 1269 |     | 
 1270 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1271 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1272 |     |     }
 1273 |     | 
 1274 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal view {
 1275 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1276 |     |     }
 1277 |     | 
 1278 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1279 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1280 |     |     }
 1281 |     | 
 1282 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1283 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1284 |     |     }
 1285 |     | 
 1286 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1287 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1288 |     |     }
 1289 |     | 
 1290 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1291 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1292 |     |     }
 1293 |     | 
 1294 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1295 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1296 |     |     }
 1297 |     | 
 1298 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
 1299 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1300 |     |     }
 1301 |     | 
 1302 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
 1303 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1304 |     |     }
 1305 |     | 
 1306 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1307 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1308 |     |     }
 1309 |     | 
 1310 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
 1311 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1312 |     |     }
 1313 |     | 
 1314 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
 1315 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1316 |     |     }
 1317 |     | 
 1318 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal view {
 1319 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1320 |     |     }
 1321 |     | 
 1322 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
 1323 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1324 |     |     }
 1325 |     | 
 1326 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
 1327 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1328 |     |     }
 1329 |     | 
 1330 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal view {
 1331 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1332 |     |     }
 1333 |     | 
 1334 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal view {
 1335 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1336 |     |     }
 1337 |     | 
 1338 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
 1339 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1340 |     |     }
 1341 |     | 
 1342 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal view {
 1343 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1344 |     |     }
 1345 |     | 
 1346 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal view {
 1347 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1348 |     |     }
 1349 |     | 
 1350 |     |     function log(address p0, uint256 p1, address p2, address p3) internal view {
 1351 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1352 |     |     }
 1353 |     | 
 1354 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1355 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1356 |     |     }
 1357 |     | 
 1358 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
 1359 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1360 |     |     }
 1361 |     | 
 1362 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
 1363 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1364 |     |     }
 1365 |     | 
 1366 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal view {
 1367 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1368 |     |     }
 1369 |     | 
 1370 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
 1371 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1372 |     |     }
 1373 |     | 
 1374 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1375 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1376 |     |     }
 1377 |     | 
 1378 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1379 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1380 |     |     }
 1381 |     | 
 1382 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1383 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1384 |     |     }
 1385 |     | 
 1386 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
 1387 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1388 |     |     }
 1389 |     | 
 1390 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1391 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1392 |     |     }
 1393 |     | 
 1394 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1395 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1396 |     |     }
 1397 |     | 
 1398 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1399 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1400 |     |     }
 1401 |     | 
 1402 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal view {
 1403 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1404 |     |     }
 1405 |     | 
 1406 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1407 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1408 |     |     }
 1409 |     | 
 1410 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1411 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1412 |     |     }
 1413 |     | 
 1414 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1415 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1416 |     |     }
 1417 |     | 
 1418 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
 1419 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1420 |     |     }
 1421 |     | 
 1422 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
 1423 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1424 |     |     }
 1425 |     | 
 1426 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal view {
 1427 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1428 |     |     }
 1429 |     | 
 1430 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal view {
 1431 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1432 |     |     }
 1433 |     | 
 1434 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
 1435 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1436 |     |     }
 1437 |     | 
 1438 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1439 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1440 |     |     }
 1441 |     | 
 1442 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1443 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1444 |     |     }
 1445 |     | 
 1446 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1447 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1448 |     |     }
 1449 |     | 
 1450 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal view {
 1451 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1452 |     |     }
 1453 |     | 
 1454 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1455 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1456 |     |     }
 1457 |     | 
 1458 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1460 |     |     }
 1461 |     | 
 1462 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1464 |     |     }
 1465 |     | 
 1466 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal view {
 1467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1468 |     |     }
 1469 |     | 
 1470 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1472 |     |     }
 1473 |     | 
 1474 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1476 |     |     }
 1477 |     | 
 1478 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1480 |     |     }
 1481 |     | 
 1482 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
 1483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1484 |     |     }
 1485 |     | 
 1486 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal view {
 1487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1488 |     |     }
 1489 |     | 
 1490 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal view {
 1491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1492 |     |     }
 1493 |     | 
 1494 |     |     function log(address p0, address p1, uint256 p2, address p3) internal view {
 1495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1496 |     |     }
 1497 |     | 
 1498 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal view {
 1499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1500 |     |     }
 1501 |     | 
 1502 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1504 |     |     }
 1505 |     | 
 1506 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1508 |     |     }
 1509 |     | 
 1510 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1512 |     |     }
 1513 |     | 
 1514 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal view {
 1515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1516 |     |     }
 1517 |     | 
 1518 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1520 |     |     }
 1521 |     | 
 1522 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1523 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1524 |     |     }
 1525 |     | 
 1526 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1527 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1528 |     |     }
 1529 |     | 
 1530 |     |     function log(address p0, address p1, address p2, uint256 p3) internal view {
 1531 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1532 |     |     }
 1533 |     | 
 1534 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1535 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1536 |     |     }
 1537 |     | 
 1538 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1539 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1540 |     |     }
 1541 |     | 
 1542 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1543 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1544 |     |     }
 1545 |     | 
 1546 |     | }

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solmate/lib/ds-test/src/test.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | 
   3 |     | // This program is free software: you can redistribute it and/or modify
   4 |     | // it under the terms of the GNU General Public License as published by
   5 |     | // the Free Software Foundation, either version 3 of the License, or
   6 |     | // (at your option) any later version.
   7 |     | 
   8 |     | // This program is distributed in the hope that it will be useful,
   9 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  10 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11 |     | // GNU General Public License for more details.
  12 |     | 
  13 |     | // You should have received a copy of the GNU General Public License
  14 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15 |     | 
  16 |     | pragma solidity >=0.5.0;
  17 |     | 
  18 |     | contract DSTest {
  19 |     |     event log                    (string);
  20 |     |     event logs                   (bytes);
  21 |     | 
  22 |     |     event log_address            (address);
  23 |     |     event log_bytes32            (bytes32);
  24 |     |     event log_int                (int);
  25 |     |     event log_uint               (uint);
  26 |     |     event log_bytes              (bytes);
  27 |     |     event log_string             (string);
  28 |     | 
  29 |     |     event log_named_address      (string key, address val);
  30 |     |     event log_named_bytes32      (string key, bytes32 val);
  31 |     |     event log_named_decimal_int  (string key, int val, uint decimals);
  32 |     |     event log_named_decimal_uint (string key, uint val, uint decimals);
  33 |     |     event log_named_int          (string key, int val);
  34 |     |     event log_named_uint         (string key, uint val);
  35 |     |     event log_named_bytes        (string key, bytes val);
  36 |     |     event log_named_string       (string key, string val);
  37 |     | 
  38 |     |     bool public IS_TEST = true;
  39 |     |     bool private _failed;
  40 |     | 
  41 |     |     address constant HEVM_ADDRESS =
  42 |     |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
  43 |     | 
  44 |     |     modifier mayRevert() { _; }
  45 |     |     modifier testopts(string memory) { _; }
  46 |     | 
  47 |     |     function failed() public returns (bool) {
  48 |     |         if (_failed) {
  49 |     |             return _failed;
  50 |     |         } else {
  51 |     |             bool globalFailed = false;
  52 |     |             if (hasHEVMContext()) {
  53 |     |                 (, bytes memory retdata) = HEVM_ADDRESS.call(
  54 |     |                     abi.encodePacked(
  55 |     |                         bytes4(keccak256("load(address,bytes32)")),
  56 |     |                         abi.encode(HEVM_ADDRESS, bytes32("failed"))
  57 |     |                     )
  58 |     |                 );
  59 |     |                 globalFailed = abi.decode(retdata, (bool));
  60 |     |             }
  61 |     |             return globalFailed;
  62 |     |         }
  63 |     |     } 
  64 |     | 
  65 |     |     function fail() internal {
  66 |     |         if (hasHEVMContext()) {
  67 |     |             (bool status, ) = HEVM_ADDRESS.call(
  68 |     |                 abi.encodePacked(
  69 |     |                     bytes4(keccak256("store(address,bytes32,bytes32)")),
  70 |     |                     abi.encode(HEVM_ADDRESS, bytes32("failed"), bytes32(uint256(0x01)))
  71 |     |                 )
  72 |     |             );
  73 |     |             status; // Silence compiler warnings
  74 |     |         }
  75 |     |         _failed = true;
  76 |     |     }
  77 |     | 
  78 |     |     function hasHEVMContext() internal view returns (bool) {
  79 |     |         uint256 hevmCodeSize = 0;
  80 |     |         assembly {
  81 |     |             hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
  82 |     |         }
  83 |     |         return hevmCodeSize > 0;
  84 |     |     }
  85 |     | 
  86 |     |     modifier logs_gas() {
  87 |     |         uint startGas = gasleft();
  88 |     |         _;
  89 |     |         uint endGas = gasleft();
  90 |     |         emit log_named_uint("gas", startGas - endGas);
  91 |     |     }
  92 |     | 
  93 |     |     function assertTrue(bool condition) internal {
  94 |     |         if (!condition) {
  95 |     |             emit log("Error: Assertion Failed");
  96 |     |             fail();
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     function assertTrue(bool condition, string memory err) internal {
 101 |     |         if (!condition) {
 102 |     |             emit log_named_string("Error", err);
 103 |     |             assertTrue(condition);
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address a, address b) internal {
 108 |     |         if (a != b) {
 109 |     |             emit log("Error: a == b not satisfied [address]");
 110 |     |             emit log_named_address("  Expected", b);
 111 |     |             emit log_named_address("    Actual", a);
 112 |     |             fail();
 113 |     |         }
 114 |     |     }
 115 |     |     function assertEq(address a, address b, string memory err) internal {
 116 |     |         if (a != b) {
 117 |     |             emit log_named_string ("Error", err);
 118 |     |             assertEq(a, b);
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     function assertEq(bytes32 a, bytes32 b) internal {
 123 |     |         if (a != b) {
 124 |     |             emit log("Error: a == b not satisfied [bytes32]");
 125 |     |             emit log_named_bytes32("  Expected", b);
 126 |     |             emit log_named_bytes32("    Actual", a);
 127 |     |             fail();
 128 |     |         }
 129 |     |     }
 130 |     |     function assertEq(bytes32 a, bytes32 b, string memory err) internal {
 131 |     |         if (a != b) {
 132 |     |             emit log_named_string ("Error", err);
 133 |     |             assertEq(a, b);
 134 |     |         }
 135 |     |     }
 136 |     |     function assertEq32(bytes32 a, bytes32 b) internal {
 137 |     |         assertEq(a, b);
 138 |     |     }
 139 |     |     function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
 140 |     |         assertEq(a, b, err);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(int a, int b) internal {
 144 |     |         if (a != b) {
 145 |     |             emit log("Error: a == b not satisfied [int]");
 146 |     |             emit log_named_int("  Expected", b);
 147 |     |             emit log_named_int("    Actual", a);
 148 |     |             fail();
 149 |     |         }
 150 |     |     }
 151 |     |     function assertEq(int a, int b, string memory err) internal {
 152 |     |         if (a != b) {
 153 |     |             emit log_named_string("Error", err);
 154 |     |             assertEq(a, b);
 155 |     |         }
 156 |     |     }
 157 |     |     function assertEq(uint a, uint b) internal {
 158 |     |         if (a != b) {
 159 |     |             emit log("Error: a == b not satisfied [uint]");
 160 |     |             emit log_named_uint("  Expected", b);
 161 |     |             emit log_named_uint("    Actual", a);
 162 |     |             fail();
 163 |     |         }
 164 |     |     }
 165 |     |     function assertEq(uint a, uint b, string memory err) internal {
 166 |     |         if (a != b) {
 167 |     |             emit log_named_string("Error", err);
 168 |     |             assertEq(a, b);
 169 |     |         }
 170 |     |     }
 171 |     |     function assertEqDecimal(int a, int b, uint decimals) internal {
 172 |     |         if (a != b) {
 173 |     |             emit log("Error: a == b not satisfied [decimal int]");
 174 |     |             emit log_named_decimal_int("  Expected", b, decimals);
 175 |     |             emit log_named_decimal_int("    Actual", a, decimals);
 176 |     |             fail();
 177 |     |         }
 178 |     |     }
 179 |     |     function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
 180 |     |         if (a != b) {
 181 |     |             emit log_named_string("Error", err);
 182 |     |             assertEqDecimal(a, b, decimals);
 183 |     |         }
 184 |     |     }
 185 |     |     function assertEqDecimal(uint a, uint b, uint decimals) internal {
 186 |     |         if (a != b) {
 187 |     |             emit log("Error: a == b not satisfied [decimal uint]");
 188 |     |             emit log_named_decimal_uint("  Expected", b, decimals);
 189 |     |             emit log_named_decimal_uint("    Actual", a, decimals);
 190 |     |             fail();
 191 |     |         }
 192 |     |     }
 193 |     |     function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
 194 |     |         if (a != b) {
 195 |     |             emit log_named_string("Error", err);
 196 |     |             assertEqDecimal(a, b, decimals);
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     function assertGt(uint a, uint b) internal {
 201 |     |         if (a <= b) {
 202 |     |             emit log("Error: a > b not satisfied [uint]");
 203 |     |             emit log_named_uint("  Value a", a);
 204 |     |             emit log_named_uint("  Value b", b);
 205 |     |             fail();
 206 |     |         }
 207 |     |     }
 208 |     |     function assertGt(uint a, uint b, string memory err) internal {
 209 |     |         if (a <= b) {
 210 |     |             emit log_named_string("Error", err);
 211 |     |             assertGt(a, b);
 212 |     |         }
 213 |     |     }
 214 |     |     function assertGt(int a, int b) internal {
 215 |     |         if (a <= b) {
 216 |     |             emit log("Error: a > b not satisfied [int]");
 217 |     |             emit log_named_int("  Value a", a);
 218 |     |             emit log_named_int("  Value b", b);
 219 |     |             fail();
 220 |     |         }
 221 |     |     }
 222 |     |     function assertGt(int a, int b, string memory err) internal {
 223 |     |         if (a <= b) {
 224 |     |             emit log_named_string("Error", err);
 225 |     |             assertGt(a, b);
 226 |     |         }
 227 |     |     }
 228 |     |     function assertGtDecimal(int a, int b, uint decimals) internal {
 229 |     |         if (a <= b) {
 230 |     |             emit log("Error: a > b not satisfied [decimal int]");
 231 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 232 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 233 |     |             fail();
 234 |     |         }
 235 |     |     }
 236 |     |     function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
 237 |     |         if (a <= b) {
 238 |     |             emit log_named_string("Error", err);
 239 |     |             assertGtDecimal(a, b, decimals);
 240 |     |         }
 241 |     |     }
 242 |     |     function assertGtDecimal(uint a, uint b, uint decimals) internal {
 243 |     |         if (a <= b) {
 244 |     |             emit log("Error: a > b not satisfied [decimal uint]");
 245 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 246 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 247 |     |             fail();
 248 |     |         }
 249 |     |     }
 250 |     |     function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 251 |     |         if (a <= b) {
 252 |     |             emit log_named_string("Error", err);
 253 |     |             assertGtDecimal(a, b, decimals);
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     function assertGe(uint a, uint b) internal {
 258 |     |         if (a < b) {
 259 |     |             emit log("Error: a >= b not satisfied [uint]");
 260 |     |             emit log_named_uint("  Value a", a);
 261 |     |             emit log_named_uint("  Value b", b);
 262 |     |             fail();
 263 |     |         }
 264 |     |     }
 265 |     |     function assertGe(uint a, uint b, string memory err) internal {
 266 |     |         if (a < b) {
 267 |     |             emit log_named_string("Error", err);
 268 |     |             assertGe(a, b);
 269 |     |         }
 270 |     |     }
 271 |     |     function assertGe(int a, int b) internal {
 272 |     |         if (a < b) {
 273 |     |             emit log("Error: a >= b not satisfied [int]");
 274 |     |             emit log_named_int("  Value a", a);
 275 |     |             emit log_named_int("  Value b", b);
 276 |     |             fail();
 277 |     |         }
 278 |     |     }
 279 |     |     function assertGe(int a, int b, string memory err) internal {
 280 |     |         if (a < b) {
 281 |     |             emit log_named_string("Error", err);
 282 |     |             assertGe(a, b);
 283 |     |         }
 284 |     |     }
 285 |     |     function assertGeDecimal(int a, int b, uint decimals) internal {
 286 |     |         if (a < b) {
 287 |     |             emit log("Error: a >= b not satisfied [decimal int]");
 288 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 289 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 290 |     |             fail();
 291 |     |         }
 292 |     |     }
 293 |     |     function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
 294 |     |         if (a < b) {
 295 |     |             emit log_named_string("Error", err);
 296 |     |             assertGeDecimal(a, b, decimals);
 297 |     |         }
 298 |     |     }
 299 |     |     function assertGeDecimal(uint a, uint b, uint decimals) internal {
 300 |     |         if (a < b) {
 301 |     |             emit log("Error: a >= b not satisfied [decimal uint]");
 302 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 303 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 304 |     |             fail();
 305 |     |         }
 306 |     |     }
 307 |     |     function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 308 |     |         if (a < b) {
 309 |     |             emit log_named_string("Error", err);
 310 |     |             assertGeDecimal(a, b, decimals);
 311 |     |         }
 312 |     |     }
 313 |     | 
 314 |     |     function assertLt(uint a, uint b) internal {
 315 |     |         if (a >= b) {
 316 |     |             emit log("Error: a < b not satisfied [uint]");
 317 |     |             emit log_named_uint("  Value a", a);
 318 |     |             emit log_named_uint("  Value b", b);
 319 |     |             fail();
 320 |     |         }
 321 |     |     }
 322 |     |     function assertLt(uint a, uint b, string memory err) internal {
 323 |     |         if (a >= b) {
 324 |     |             emit log_named_string("Error", err);
 325 |     |             assertLt(a, b);
 326 |     |         }
 327 |     |     }
 328 |     |     function assertLt(int a, int b) internal {
 329 |     |         if (a >= b) {
 330 |     |             emit log("Error: a < b not satisfied [int]");
 331 |     |             emit log_named_int("  Value a", a);
 332 |     |             emit log_named_int("  Value b", b);
 333 |     |             fail();
 334 |     |         }
 335 |     |     }
 336 |     |     function assertLt(int a, int b, string memory err) internal {
 337 |     |         if (a >= b) {
 338 |     |             emit log_named_string("Error", err);
 339 |     |             assertLt(a, b);
 340 |     |         }
 341 |     |     }
 342 |     |     function assertLtDecimal(int a, int b, uint decimals) internal {
 343 |     |         if (a >= b) {
 344 |     |             emit log("Error: a < b not satisfied [decimal int]");
 345 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 346 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 347 |     |             fail();
 348 |     |         }
 349 |     |     }
 350 |     |     function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
 351 |     |         if (a >= b) {
 352 |     |             emit log_named_string("Error", err);
 353 |     |             assertLtDecimal(a, b, decimals);
 354 |     |         }
 355 |     |     }
 356 |     |     function assertLtDecimal(uint a, uint b, uint decimals) internal {
 357 |     |         if (a >= b) {
 358 |     |             emit log("Error: a < b not satisfied [decimal uint]");
 359 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 360 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 361 |     |             fail();
 362 |     |         }
 363 |     |     }
 364 |     |     function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 365 |     |         if (a >= b) {
 366 |     |             emit log_named_string("Error", err);
 367 |     |             assertLtDecimal(a, b, decimals);
 368 |     |         }
 369 |     |     }
 370 |     | 
 371 |     |     function assertLe(uint a, uint b) internal {
 372 |     |         if (a > b) {
 373 |     |             emit log("Error: a <= b not satisfied [uint]");
 374 |     |             emit log_named_uint("  Value a", a);
 375 |     |             emit log_named_uint("  Value b", b);
 376 |     |             fail();
 377 |     |         }
 378 |     |     }
 379 |     |     function assertLe(uint a, uint b, string memory err) internal {
 380 |     |         if (a > b) {
 381 |     |             emit log_named_string("Error", err);
 382 |     |             assertLe(a, b);
 383 |     |         }
 384 |     |     }
 385 |     |     function assertLe(int a, int b) internal {
 386 |     |         if (a > b) {
 387 |     |             emit log("Error: a <= b not satisfied [int]");
 388 |     |             emit log_named_int("  Value a", a);
 389 |     |             emit log_named_int("  Value b", b);
 390 |     |             fail();
 391 |     |         }
 392 |     |     }
 393 |     |     function assertLe(int a, int b, string memory err) internal {
 394 |     |         if (a > b) {
 395 |     |             emit log_named_string("Error", err);
 396 |     |             assertLe(a, b);
 397 |     |         }
 398 |     |     }
 399 |     |     function assertLeDecimal(int a, int b, uint decimals) internal {
 400 |     |         if (a > b) {
 401 |     |             emit log("Error: a <= b not satisfied [decimal int]");
 402 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 403 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 404 |     |             fail();
 405 |     |         }
 406 |     |     }
 407 |     |     function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
 408 |     |         if (a > b) {
 409 |     |             emit log_named_string("Error", err);
 410 |     |             assertLeDecimal(a, b, decimals);
 411 |     |         }
 412 |     |     }
 413 |     |     function assertLeDecimal(uint a, uint b, uint decimals) internal {
 414 |     |         if (a > b) {
 415 |     |             emit log("Error: a <= b not satisfied [decimal uint]");
 416 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 417 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 418 |     |             fail();
 419 |     |         }
 420 |     |     }
 421 |     |     function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 422 |     |         if (a > b) {
 423 |     |             emit log_named_string("Error", err);
 424 |     |             assertGeDecimal(a, b, decimals);
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     function assertEq(string memory a, string memory b) internal {
 429 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 430 |     |             emit log("Error: a == b not satisfied [string]");
 431 |     |             emit log_named_string("  Expected", b);
 432 |     |             emit log_named_string("    Actual", a);
 433 |     |             fail();
 434 |     |         }
 435 |     |     }
 436 |     |     function assertEq(string memory a, string memory b, string memory err) internal {
 437 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 438 |     |             emit log_named_string("Error", err);
 439 |     |             assertEq(a, b);
 440 |     |         }
 441 |     |     }
 442 |     | 
 443 |     |     function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
 444 |     |         ok = true;
 445 |     |         if (a.length == b.length) {
 446 |     |             for (uint i = 0; i < a.length; i++) {
 447 |     |                 if (a[i] != b[i]) {
 448 |     |                     ok = false;
 449 |     |                 }
 450 |     |             }
 451 |     |         } else {
 452 |     |             ok = false;
 453 |     |         }
 454 |     |     }
 455 |     |     function assertEq0(bytes memory a, bytes memory b) internal {
 456 |     |         if (!checkEq0(a, b)) {
 457 |     |             emit log("Error: a == b not satisfied [bytes]");
 458 |     |             emit log_named_bytes("  Expected", b);
 459 |     |             emit log_named_bytes("    Actual", a);
 460 |     |             fail();
 461 |     |         }
 462 |     |     }
 463 |     |     function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
 464 |     |         if (!checkEq0(a, b)) {
 465 |     |             emit log_named_string("Error", err);
 466 |     |             assertEq0(a, b);
 467 |     |         }
 468 |     |     }
 469 |     | }
 470 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solmate/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
   7 |     | /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
   8 |     | abstract contract ERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                                  EVENTS
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  14 |     | 
  15 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  16 |     | 
  17 |     |     /*//////////////////////////////////////////////////////////////
  18 |     |                             METADATA STORAGE
  19 |     |     //////////////////////////////////////////////////////////////*/
  20 |     | 
  21 | *r  |     string public name;
  22 |     | 
  23 | *r  |     string public symbol;
  24 |     | 
  25 | *r  |     uint8 public immutable decimals;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                               ERC20 STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 | *r  |     uint256 public totalSupply;
  32 |     | 
  33 | *r  |     mapping(address => uint256) public balanceOf;
  34 |     | 
  35 | *r  |     mapping(address => mapping(address => uint256)) public allowance;
  36 |     | 
  37 |     |     /*//////////////////////////////////////////////////////////////
  38 |     |                             EIP-2612 STORAGE
  39 |     |     //////////////////////////////////////////////////////////////*/
  40 |     | 
  41 |     |     uint256 internal immutable INITIAL_CHAIN_ID;
  42 |     | 
  43 |     |     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
  44 |     | 
  45 | *r  |     mapping(address => uint256) public nonces;
  46 |     | 
  47 |     |     /*//////////////////////////////////////////////////////////////
  48 |     |                                CONSTRUCTOR
  49 |     |     //////////////////////////////////////////////////////////////*/
  50 |     | 
  51 |     |     constructor(
  52 |     |         string memory _name,
  53 |     |         string memory _symbol,
  54 |     |         uint8 _decimals
  55 |     |     ) {
  56 |     |         name = _name;
  57 |     |         symbol = _symbol;
  58 |     |         decimals = _decimals;
  59 |     | 
  60 |     |         INITIAL_CHAIN_ID = block.chainid;
  61 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  62 |     |     }
  63 |     | 
  64 |     |     /*//////////////////////////////////////////////////////////////
  65 |     |                                ERC20 LOGIC
  66 |     |     //////////////////////////////////////////////////////////////*/
  67 |     | 
  68 | *r  |     function approve(address spender, uint256 amount) public virtual returns (bool) {
  69 | *   |         allowance[msg.sender][spender] = amount;
  70 |     | 
  71 | *   |         emit Approval(msg.sender, spender, amount);
  72 |     | 
  73 | *   |         return true;
  74 |     |     }
  75 |     | 
  76 | *r  |     function transfer(address to, uint256 amount) public virtual returns (bool) {
  77 | *r  |         balanceOf[msg.sender] -= amount;
  78 |     | 
  79 |     |         // Cannot overflow because the sum of all user
  80 |     |         // balances can't exceed the max uint256 value.
  81 |     |         unchecked {
  82 | *   |             balanceOf[to] += amount;
  83 |     |         }
  84 |     | 
  85 | *   |         emit Transfer(msg.sender, to, amount);
  86 |     | 
  87 |     |         return true;
  88 |     |     }
  89 |     | 
  90 | *r  |     function transferFrom(
  91 |     |         address from,
  92 |     |         address to,
  93 |     |         uint256 amount
  94 | *r  |     ) public virtual returns (bool) {
  95 | *r  |         uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
  96 |     | 
  97 | *r  |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
  98 |     | 
  99 | *r  |         balanceOf[from] -= amount;
 100 |     | 
 101 |     |         // Cannot overflow because the sum of all user
 102 |     |         // balances can't exceed the max uint256 value.
 103 |     |         unchecked {
 104 | *   |             balanceOf[to] += amount;
 105 |     |         }
 106 |     | 
 107 | *   |         emit Transfer(from, to, amount);
 108 |     | 
 109 | *   |         return true;
 110 |     |     }
 111 |     | 
 112 |     |     /*//////////////////////////////////////////////////////////////
 113 |     |                              EIP-2612 LOGIC
 114 |     |     //////////////////////////////////////////////////////////////*/
 115 |     | 
 116 | r   |     function permit(
 117 |     |         address owner,
 118 |     |         address spender,
 119 |     |         uint256 value,
 120 |     |         uint256 deadline,
 121 |     |         uint8 v,
 122 |     |         bytes32 r,
 123 |     |         bytes32 s
 124 |     |     ) public virtual {
 125 | r   |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 126 |     | 
 127 |     |         // Unchecked because the only math done is incrementing
 128 |     |         // the owner's nonce which cannot realistically overflow.
 129 |     |         unchecked {
 130 | r   |             address recoveredAddress = ecrecover(
 131 | r   |                 keccak256(
 132 | r   |                     abi.encodePacked(
 133 |     |                         "\x19\x01",
 134 | r   |                         DOMAIN_SEPARATOR(),
 135 | r   |                         keccak256(
 136 | r   |                             abi.encode(
 137 | r   |                                 keccak256(
 138 |     |                                     "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 139 |     |                                 ),
 140 |     |                                 owner,
 141 |     |                                 spender,
 142 |     |                                 value,
 143 | r   |                                 nonces[owner]++,
 144 |     |                                 deadline
 145 |     |                             )
 146 |     |                         )
 147 |     |                     )
 148 |     |                 ),
 149 |     |                 v,
 150 |     |                 r,
 151 |     |                 s
 152 |     |             );
 153 |     | 
 154 | r   |             require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 155 |     | 
 156 |     |             allowance[recoveredAddress][spender] = value;
 157 |     |         }
 158 |     | 
 159 |     |         emit Approval(owner, spender, value);
 160 |     |     }
 161 |     | 
 162 | *r  |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 163 | *r  |         return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 164 |     |     }
 165 |     | 
 166 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 167 |     |         return
 168 |     |             keccak256(
 169 |     |                 abi.encode(
 170 |     |                     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 171 |     |                     keccak256(bytes(name)),
 172 |     |                     keccak256("1"),
 173 |     |                     block.chainid,
 174 |     |                     address(this)
 175 |     |                 )
 176 |     |             );
 177 |     |     }
 178 |     | 
 179 |     |     /*//////////////////////////////////////////////////////////////
 180 |     |                         INTERNAL MINT/BURN LOGIC
 181 |     |     //////////////////////////////////////////////////////////////*/
 182 |     | 
 183 | *r  |     function _mint(address to, uint256 amount) internal virtual {
 184 | *r  |         totalSupply += amount;
 185 |     | 
 186 |     |         // Cannot overflow because the sum of all user
 187 |     |         // balances can't exceed the max uint256 value.
 188 |     |         unchecked {
 189 | *r  |             balanceOf[to] += amount;
 190 |     |         }
 191 |     | 
 192 | *r  |         emit Transfer(address(0), to, amount);
 193 |     |     }
 194 |     | 
 195 | *r  |     function _burn(address from, uint256 amount) internal virtual {
 196 | *r  |         balanceOf[from] -= amount;
 197 |     | 
 198 |     |         // Cannot underflow because a user's balance
 199 |     |         // will never be larger than the total supply.
 200 |     |         unchecked {
 201 | *r  |             totalSupply -= amount;
 202 |     |         }
 203 |     | 
 204 | *r  |         emit Transfer(from, address(0), amount);
 205 |     |     }
 206 |     | }
 207 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solmate/src/tokens/WETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "./ERC20.sol";
  5 |     | 
  6 |     | import {SafeTransferLib} from "../utils/SafeTransferLib.sol";
  7 |     | 
  8 |     | /// @notice Minimalist and modern Wrapped Ether implementation.
  9 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)
 10 | *r  | /// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)
 11 |     | contract WETH is ERC20("Wrapped Ether", "WETH", 18) {
 12 |     |     using SafeTransferLib for address;
 13 |     | 
 14 |     |     event Deposit(address indexed from, uint256 amount);
 15 |     | 
 16 |     |     event Withdrawal(address indexed to, uint256 amount);
 17 |     | 
 18 | *r  |     function deposit() public payable virtual {
 19 | *r  |         _mint(msg.sender, msg.value);
 20 |     | 
 21 | *r  |         emit Deposit(msg.sender, msg.value);
 22 |     |     }
 23 |     | 
 24 | *r  |     function withdraw(uint256 amount) public virtual {
 25 | *r  |         _burn(msg.sender, amount);
 26 |     | 
 27 | *r  |         emit Withdrawal(msg.sender, amount);
 28 |     | 
 29 | *r  |         msg.sender.safeTransferETH(amount);
 30 |     |     }
 31 |     | 
 32 |     |     receive() external payable virtual {
 33 | *r  |         deposit();
 34 |     |     }
 35 |     | }
 36 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solmate/src/utils/FixedPointMathLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Arithmetic library with operations for fixed-point numbers.
   5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)
   6 |     | library FixedPointMathLib {
   7 |     |     /*//////////////////////////////////////////////////////////////
   8 |     |                     SIMPLIFIED FIXED POINT OPERATIONS
   9 |     |     //////////////////////////////////////////////////////////////*/
  10 |     | 
  11 | *r  |     uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.
  12 |     | 
  13 | *r  |     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  14 | *r  |         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
  15 |     |     }
  16 |     | 
  17 | *   |     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  18 | *   |         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
  19 |     |     }
  20 |     | 
  21 | *r  |     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  22 | *r  |         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
  23 |     |     }
  24 |     | 
  25 | *r  |     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  26 | *r  |         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
  27 |     |     }
  28 |     | 
  29 | *r  |     function powWad(int256 x, int256 y) internal pure returns (int256) {
  30 |     |         // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)
  31 | *r  |         return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.
  32 |     |     }
  33 |     | 
  34 | *r  |     function expWad(int256 x) internal pure returns (int256 r) {
  35 |     |         unchecked {
  36 |     |             // When the result is < 0.5 we return zero. This happens when
  37 |     |             // x <= floor(log(0.5e18) * 1e18) ~ -42e18
  38 | *r  |             if (x <= -42139678854452767551) return 0;
  39 |     | 
  40 |     |             // When the result is > (2**255 - 1) / 1e18 we can not represent it as an
  41 |     |             // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.
  42 | *r  |             if (x >= 135305999368893231589) revert("EXP_OVERFLOW");
  43 |     | 
  44 |     |             // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96
  45 |     |             // for more intermediate precision and a binary basis. This base conversion
  46 |     |             // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
  47 | *r  |             x = (x << 78) / 5**18;
  48 |     | 
  49 |     |             // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers
  50 |     |             // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
  51 |     |             // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
  52 | *r  |             int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;
  53 | *r  |             x = x - k * 54916777467707473351141471128;
  54 |     | 
  55 |     |             // k is in the range [-61, 195].
  56 |     | 
  57 |     |             // Evaluate using a (6, 7)-term rational approximation.
  58 |     |             // p is made monic, we'll multiply by a scale factor later.
  59 | *r  |             int256 y = x + 1346386616545796478920950773328;
  60 | *r  |             y = ((y * x) >> 96) + 57155421227552351082224309758442;
  61 | *r  |             int256 p = y + x - 94201549194550492254356042504812;
  62 | *r  |             p = ((p * y) >> 96) + 28719021644029726153956944680412240;
  63 | *r  |             p = p * x + (4385272521454847904659076985693276 << 96);
  64 |     | 
  65 |     |             // We leave p in 2**192 basis so we don't need to scale it back up for the division.
  66 | *r  |             int256 q = x - 2855989394907223263936484059900;
  67 | *r  |             q = ((q * x) >> 96) + 50020603652535783019961831881945;
  68 | *r  |             q = ((q * x) >> 96) - 533845033583426703283633433725380;
  69 | *r  |             q = ((q * x) >> 96) + 3604857256930695427073651918091429;
  70 | *r  |             q = ((q * x) >> 96) - 14423608567350463180887372962807573;
  71 | *r  |             q = ((q * x) >> 96) + 26449188498355588339934803723976023;
  72 |     | 
  73 |     |             assembly {
  74 |     |                 // Div in assembly because solidity adds a zero check despite the unchecked.
  75 |     |                 // The q polynomial won't have zeros in the domain as all its roots are complex.
  76 |     |                 // No scaling is necessary because p is already 2**96 too large.
  77 | *r  |                 r := sdiv(p, q)
  78 |     |             }
  79 |     | 
  80 |     |             // r should be in the range (0.09, 0.25) * 2**96.
  81 |     | 
  82 |     |             // We now need to multiply r by:
  83 |     |             // * the scale factor s = ~6.031367120.
  84 |     |             // * the 2**k factor from the range reduction.
  85 |     |             // * the 1e18 / 2**96 factor for base conversion.
  86 |     |             // We do this all at once, with an intermediate result in 2**213
  87 |     |             // basis, so the final right shift is always by a positive amount.
  88 | *r  |             r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 | *r  |     function lnWad(int256 x) internal pure returns (int256 r) {
  93 |     |         unchecked {
  94 | *r  |             require(x > 0, "UNDEFINED");
  95 |     | 
  96 |     |             // We want to convert x from 10**18 fixed point to 2**96 fixed point.
  97 |     |             // We do this by multiplying by 2**96 / 10**18. But since
  98 |     |             // ln(x * C) = ln(x) + ln(C), we can simply do nothing here
  99 |     |             // and add ln(2**96 / 10**18) at the end.
 100 |     | 
 101 |     |             // Reduce range of x to (1, 2) * 2**96
 102 |     |             // ln(2^k * x) = k * ln(2) + ln(x)
 103 | *r  |             int256 k = int256(log2(uint256(x))) - 96;
 104 | *r  |             x <<= uint256(159 - k);
 105 | *r  |             x = int256(uint256(x) >> 159);
 106 |     | 
 107 |     |             // Evaluate using a (8, 8)-term rational approximation.
 108 |     |             // p is made monic, we will multiply by a scale factor later.
 109 | *r  |             int256 p = x + 3273285459638523848632254066296;
 110 | *r  |             p = ((p * x) >> 96) + 24828157081833163892658089445524;
 111 | *r  |             p = ((p * x) >> 96) + 43456485725739037958740375743393;
 112 | *r  |             p = ((p * x) >> 96) - 11111509109440967052023855526967;
 113 | *r  |             p = ((p * x) >> 96) - 45023709667254063763336534515857;
 114 | *r  |             p = ((p * x) >> 96) - 14706773417378608786704636184526;
 115 | *r  |             p = p * x - (795164235651350426258249787498 << 96);
 116 |     | 
 117 |     |             // We leave p in 2**192 basis so we don't need to scale it back up for the division.
 118 |     |             // q is monic by convention.
 119 | *r  |             int256 q = x + 5573035233440673466300451813936;
 120 | *r  |             q = ((q * x) >> 96) + 71694874799317883764090561454958;
 121 | *r  |             q = ((q * x) >> 96) + 283447036172924575727196451306956;
 122 | *r  |             q = ((q * x) >> 96) + 401686690394027663651624208769553;
 123 | *r  |             q = ((q * x) >> 96) + 204048457590392012362485061816622;
 124 | *r  |             q = ((q * x) >> 96) + 31853899698501571402653359427138;
 125 | *r  |             q = ((q * x) >> 96) + 909429971244387300277376558375;
 126 |     |             assembly {
 127 |     |                 // Div in assembly because solidity adds a zero check despite the unchecked.
 128 |     |                 // The q polynomial is known not to have zeros in the domain.
 129 |     |                 // No scaling required because p is already 2**96 too large.
 130 | *r  |                 r := sdiv(p, q)
 131 |     |             }
 132 |     | 
 133 |     |             // r is in the range (0, 0.125) * 2**96
 134 |     | 
 135 |     |             // Finalization, we need to:
 136 |     |             // * multiply by the scale factor s = 5.549…
 137 |     |             // * add ln(2**96 / 10**18)
 138 |     |             // * add k * ln(2)
 139 |     |             // * multiply by 10**18 / 2**96 = 5**18 >> 78
 140 |     | 
 141 |     |             // mul s * 5e18 * 2**96, base is now 5**18 * 2**192
 142 | *r  |             r *= 1677202110996718588342820967067443963516166;
 143 |     |             // add ln(2) * k * 5e18 * 2**192
 144 | *r  |             r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;
 145 |     |             // add ln(2**96 / 10**18) * 5e18 * 2**192
 146 | *r  |             r += 600920179829731861736702779321621459595472258049074101567377883020018308;
 147 |     |             // base conversion: mul 2**18 / 2**192
 148 | *r  |             r >>= 174;
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /*//////////////////////////////////////////////////////////////
 153 |     |                     LOW LEVEL FIXED POINT OPERATIONS
 154 |     |     //////////////////////////////////////////////////////////////*/
 155 |     | 
 156 | *r  |     function mulDivDown(
 157 |     |         uint256 x,
 158 |     |         uint256 y,
 159 |     |         uint256 denominator
 160 |     |     ) internal pure returns (uint256 z) {
 161 |     |         assembly {
 162 |     |             // Store x * y in z for now.
 163 | *r  |             z := mul(x, y)
 164 |     | 
 165 |     |             // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
 166 | *r  |             if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {
 167 | r   |                 revert(0, 0)
 168 |     |             }
 169 |     | 
 170 |     |             // Divide z by the denominator.
 171 | *r  |             z := div(z, denominator)
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 | *r  |     function mulDivUp(
 176 |     |         uint256 x,
 177 |     |         uint256 y,
 178 |     |         uint256 denominator
 179 |     |     ) internal pure returns (uint256 z) {
 180 |     |         assembly {
 181 |     |             // Store x * y in z for now.
 182 | *r  |             z := mul(x, y)
 183 |     | 
 184 |     |             // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
 185 | *r  |             if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {
 186 | r   |                 revert(0, 0)
 187 |     |             }
 188 |     | 
 189 |     |             // First, divide z - 1 by the denominator and add 1.
 190 |     |             // We allow z - 1 to underflow if z is 0, because we multiply the
 191 |     |             // end result by 0 if z is zero, ensuring we return 0 if z is zero.
 192 | *r  |             z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))
 193 |     |         }
 194 |     |     }
 195 |     | 
 196 |     |     function rpow(
 197 |     |         uint256 x,
 198 |     |         uint256 n,
 199 |     |         uint256 scalar
 200 |     |     ) internal pure returns (uint256 z) {
 201 |     |         assembly {
 202 |     |             switch x
 203 |     |             case 0 {
 204 |     |                 switch n
 205 |     |                 case 0 {
 206 |     |                     // 0 ** 0 = 1
 207 |     |                     z := scalar
 208 |     |                 }
 209 |     |                 default {
 210 |     |                     // 0 ** n = 0
 211 |     |                     z := 0
 212 |     |                 }
 213 |     |             }
 214 |     |             default {
 215 |     |                 switch mod(n, 2)
 216 |     |                 case 0 {
 217 |     |                     // If n is even, store scalar in z for now.
 218 |     |                     z := scalar
 219 |     |                 }
 220 |     |                 default {
 221 |     |                     // If n is odd, store x in z for now.
 222 |     |                     z := x
 223 |     |                 }
 224 |     | 
 225 |     |                 // Shifting right by 1 is like dividing by 2.
 226 |     |                 let half := shr(1, scalar)
 227 |     | 
 228 |     |                 for {
 229 |     |                     // Shift n right by 1 before looping to halve it.
 230 |     |                     n := shr(1, n)
 231 |     |                 } n {
 232 |     |                     // Shift n right by 1 each iteration to halve it.
 233 |     |                     n := shr(1, n)
 234 |     |                 } {
 235 |     |                     // Revert immediately if x ** 2 would overflow.
 236 |     |                     // Equivalent to iszero(eq(div(xx, x), x)) here.
 237 |     |                     if shr(128, x) {
 238 |     |                         revert(0, 0)
 239 |     |                     }
 240 |     | 
 241 |     |                     // Store x squared.
 242 |     |                     let xx := mul(x, x)
 243 |     | 
 244 |     |                     // Round to the nearest number.
 245 |     |                     let xxRound := add(xx, half)
 246 |     | 
 247 |     |                     // Revert if xx + half overflowed.
 248 |     |                     if lt(xxRound, xx) {
 249 |     |                         revert(0, 0)
 250 |     |                     }
 251 |     | 
 252 |     |                     // Set x to scaled xxRound.
 253 |     |                     x := div(xxRound, scalar)
 254 |     | 
 255 |     |                     // If n is even:
 256 |     |                     if mod(n, 2) {
 257 |     |                         // Compute z * x.
 258 |     |                         let zx := mul(z, x)
 259 |     | 
 260 |     |                         // If z * x overflowed:
 261 |     |                         if iszero(eq(div(zx, x), z)) {
 262 |     |                             // Revert if x is non-zero.
 263 |     |                             if iszero(iszero(x)) {
 264 |     |                                 revert(0, 0)
 265 |     |                             }
 266 |     |                         }
 267 |     | 
 268 |     |                         // Round to the nearest number.
 269 |     |                         let zxRound := add(zx, half)
 270 |     | 
 271 |     |                         // Revert if zx + half overflowed.
 272 |     |                         if lt(zxRound, zx) {
 273 |     |                             revert(0, 0)
 274 |     |                         }
 275 |     | 
 276 |     |                         // Return properly scaled zxRound.
 277 |     |                         z := div(zxRound, scalar)
 278 |     |                     }
 279 |     |                 }
 280 |     |             }
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     /*//////////////////////////////////////////////////////////////
 285 |     |                         GENERAL NUMBER UTILITIES
 286 |     |     //////////////////////////////////////////////////////////////*/
 287 |     | 
 288 | *r  |     function sqrt(uint256 x) internal pure returns (uint256 z) {
 289 |     |         assembly {
 290 | *r  |             let y := x // We start y at x, which will help us make our initial estimate.
 291 |     | 
 292 | *r  |             z := 181 // The "correct" value is 1, but this saves a multiplication later.
 293 |     | 
 294 |     |             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
 295 |     |             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
 296 |     | 
 297 |     |             // We check y >= 2^(k + 8) but shift right by k bits
 298 |     |             // each branch to ensure that if x >= 256, then y >= 256.
 299 | *r  |             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
 300 |     |                 y := shr(128, y)
 301 |     |                 z := shl(64, z)
 302 |     |             }
 303 | *r  |             if iszero(lt(y, 0x1000000000000000000)) {
 304 |     |                 y := shr(64, y)
 305 |     |                 z := shl(32, z)
 306 |     |             }
 307 | *r  |             if iszero(lt(y, 0x10000000000)) {
 308 | *r  |                 y := shr(32, y)
 309 | *r  |                 z := shl(16, z)
 310 |     |             }
 311 | *r  |             if iszero(lt(y, 0x1000000)) {
 312 | *r  |                 y := shr(16, y)
 313 | *r  |                 z := shl(8, z)
 314 |     |             }
 315 |     | 
 316 |     |             // Goal was to get z*z*y within a small factor of x. More iterations could
 317 |     |             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
 318 |     |             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
 319 |     |             // That's not possible if x < 256 but we can just verify those cases exhaustively.
 320 |     | 
 321 |     |             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
 322 |     |             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
 323 |     |             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
 324 |     | 
 325 |     |             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
 326 |     |             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
 327 |     | 
 328 |     |             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
 329 |     |             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
 330 |     | 
 331 |     |             // There is no overflow risk here since y < 2^136 after the first branch above.
 332 | *r  |             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
 333 |     | 
 334 |     |             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
 335 | *r  |             z := shr(1, add(z, div(x, z)))
 336 | *r  |             z := shr(1, add(z, div(x, z)))
 337 | *r  |             z := shr(1, add(z, div(x, z)))
 338 | *r  |             z := shr(1, add(z, div(x, z)))
 339 | *r  |             z := shr(1, add(z, div(x, z)))
 340 | *r  |             z := shr(1, add(z, div(x, z)))
 341 | *r  |             z := shr(1, add(z, div(x, z)))
 342 |     | 
 343 |     |             // If x+1 is a perfect square, the Babylonian method cycles between
 344 |     |             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
 345 |     |             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
 346 |     |             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
 347 |     |             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
 348 | *r  |             z := sub(z, lt(div(x, z), z))
 349 |     |         }
 350 |     |     }
 351 |     | 
 352 | *r  |     function log2(uint256 x) internal pure returns (uint256 r) {
 353 | *r  |         require(x > 0, "UNDEFINED");
 354 |     | 
 355 |     |         assembly {
 356 | *r  |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
 357 | *r  |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
 358 | *r  |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
 359 | *r  |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
 360 | *r  |             r := or(r, shl(3, lt(0xff, shr(r, x))))
 361 | *r  |             r := or(r, shl(2, lt(0xf, shr(r, x))))
 362 | *r  |             r := or(r, shl(1, lt(0x3, shr(r, x))))
 363 | *r  |             r := or(r, lt(0x1, shr(r, x)))
 364 |     |         }
 365 |     |     }
 366 |     | 
 367 |     |     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
 368 |     |         assembly {
 369 |     |             // z will equal 0 if y is 0, unlike in Solidity where it will revert.
 370 |     |             z := mod(x, y)
 371 |     |         }
 372 |     |     }
 373 |     | 
 374 |     |     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
 375 |     |         assembly {
 376 |     |             // z will equal 0 if y is 0, unlike in Solidity where it will revert.
 377 |     |             z := div(x, y)
 378 |     |         }
 379 |     |     }
 380 |     | 
 381 |     |     /// @dev Will return 0 instead of reverting if y is zero.
 382 |     |     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 383 |     |         assembly {
 384 |     |             // Add 1 to x * y if x % y > 0.
 385 |     |             z := add(gt(mod(x, y), 0), div(x, y))
 386 |     |         }
 387 |     |     }
 388 |     | }
 389 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solmate/src/utils/SafeCastLib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Safe unsigned integer casting library that reverts on overflow.
  5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)
  6 |     | library SafeCastLib {
  7 |     |     function safeCastTo248(uint256 x) internal pure returns (uint248 y) {
  8 |     |         require(x < 1 << 248);
  9 |     | 
 10 |     |         y = uint248(x);
 11 |     |     }
 12 |     | 
 13 |     |     function safeCastTo224(uint256 x) internal pure returns (uint224 y) {
 14 |     |         require(x < 1 << 224);
 15 |     | 
 16 |     |         y = uint224(x);
 17 |     |     }
 18 |     | 
 19 |     |     function safeCastTo192(uint256 x) internal pure returns (uint192 y) {
 20 |     |         require(x < 1 << 192);
 21 |     | 
 22 |     |         y = uint192(x);
 23 |     |     }
 24 |     | 
 25 |     |     function safeCastTo160(uint256 x) internal pure returns (uint160 y) {
 26 |     |         require(x < 1 << 160);
 27 |     | 
 28 |     |         y = uint160(x);
 29 |     |     }
 30 |     | 
 31 | *r  |     function safeCastTo128(uint256 x) internal pure returns (uint128 y) {
 32 | *r  |         require(x < 1 << 128);
 33 |     | 
 34 | *r  |         y = uint128(x);
 35 |     |     }
 36 |     | 
 37 |     |     function safeCastTo96(uint256 x) internal pure returns (uint96 y) {
 38 |     |         require(x < 1 << 96);
 39 |     | 
 40 |     |         y = uint96(x);
 41 |     |     }
 42 |     | 
 43 |     |     function safeCastTo64(uint256 x) internal pure returns (uint64 y) {
 44 |     |         require(x < 1 << 64);
 45 |     | 
 46 |     |         y = uint64(x);
 47 |     |     }
 48 |     | 
 49 | *r  |     function safeCastTo32(uint256 x) internal pure returns (uint32 y) {
 50 | *r  |         require(x < 1 << 32);
 51 |     | 
 52 | r   |         y = uint32(x);
 53 |     |     }
 54 |     | 
 55 |     |     function safeCastTo8(uint256 x) internal pure returns (uint8 y) {
 56 |     |         require(x < 1 << 8);
 57 |     | 
 58 |     |         y = uint8(x);
 59 |     |     }
 60 |     | }
 61 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solmate/src/utils/SafeTransferLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ERC20} from "../tokens/ERC20.sol";
   5 |     | 
   6 |     | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
   7 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)
   8 |     | /// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.
   9 |     | library SafeTransferLib {
  10 |     |     /*//////////////////////////////////////////////////////////////
  11 |     |                              ETH OPERATIONS
  12 |     |     //////////////////////////////////////////////////////////////*/
  13 |     | 
  14 | *r  |     function safeTransferETH(address to, uint256 amount) internal {
  15 | *r  |         bool success;
  16 |     | 
  17 |     |         assembly {
  18 |     |             // Transfer the ETH and store if it succeeded or not.
  19 | *r  |             success := call(gas(), to, amount, 0, 0, 0, 0)
  20 |     |         }
  21 |     | 
  22 | *r  |         require(success, "ETH_TRANSFER_FAILED");
  23 |     |     }
  24 |     | 
  25 |     |     /*//////////////////////////////////////////////////////////////
  26 |     |                             ERC20 OPERATIONS
  27 |     |     //////////////////////////////////////////////////////////////*/
  28 |     | 
  29 | *r  |     function safeTransferFrom(
  30 |     |         ERC20 token,
  31 |     |         address from,
  32 |     |         address to,
  33 |     |         uint256 amount
  34 |     |     ) internal {
  35 | *r  |         bool success;
  36 |     | 
  37 |     |         assembly {
  38 |     |             // We'll write our calldata to this slot below, but restore it later.
  39 | *r  |             let memPointer := mload(0x40)
  40 |     | 
  41 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  42 | *r  |             mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)
  43 | *r  |             mstore(4, from) // Append the "from" argument.
  44 | *r  |             mstore(36, to) // Append the "to" argument.
  45 | *r  |             mstore(68, amount) // Append the "amount" argument.
  46 |     | 
  47 | *r  |             success := and(
  48 |     |                 // Set success to whether the call reverted, if not we check it either
  49 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
  50 | *r  |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
  51 |     |                 // We use 100 because that's the total length of our calldata (4 + 32 * 3)
  52 |     |                 // Counterintuitively, this call() must be positioned after the or() in the
  53 |     |                 // surrounding and() because and() evaluates its arguments from right to left.
  54 | *r  |                 call(gas(), token, 0, 0, 100, 0, 32)
  55 |     |             )
  56 |     | 
  57 | *r  |             mstore(0x60, 0) // Restore the zero slot to zero.
  58 | *r  |             mstore(0x40, memPointer) // Restore the memPointer.
  59 |     |         }
  60 |     | 
  61 | *r  |         require(success, "TRANSFER_FROM_FAILED");
  62 |     |     }
  63 |     | 
  64 | *r  |     function safeTransfer(
  65 |     |         ERC20 token,
  66 |     |         address to,
  67 |     |         uint256 amount
  68 |     |     ) internal {
  69 | *r  |         bool success;
  70 |     | 
  71 |     |         assembly {
  72 |     |             // We'll write our calldata to this slot below, but restore it later.
  73 | *r  |             let memPointer := mload(0x40)
  74 |     | 
  75 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  76 | *r  |             mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
  77 | *r  |             mstore(4, to) // Append the "to" argument.
  78 | *r  |             mstore(36, amount) // Append the "amount" argument.
  79 |     | 
  80 | *r  |             success := and(
  81 |     |                 // Set success to whether the call reverted, if not we check it either
  82 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
  83 | *r  |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
  84 |     |                 // We use 68 because that's the total length of our calldata (4 + 32 * 2)
  85 |     |                 // Counterintuitively, this call() must be positioned after the or() in the
  86 |     |                 // surrounding and() because and() evaluates its arguments from right to left.
  87 | *r  |                 call(gas(), token, 0, 0, 68, 0, 32)
  88 |     |             )
  89 |     | 
  90 | *r  |             mstore(0x60, 0) // Restore the zero slot to zero.
  91 | *r  |             mstore(0x40, memPointer) // Restore the memPointer.
  92 |     |         }
  93 |     | 
  94 | *r  |         require(success, "TRANSFER_FAILED");
  95 |     |     }
  96 |     | 
  97 |     |     function safeApprove(
  98 |     |         ERC20 token,
  99 |     |         address to,
 100 |     |         uint256 amount
 101 |     |     ) internal {
 102 |     |         bool success;
 103 |     | 
 104 |     |         assembly {
 105 |     |             // We'll write our calldata to this slot below, but restore it later.
 106 |     |             let memPointer := mload(0x40)
 107 |     | 
 108 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
 109 |     |             mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
 110 |     |             mstore(4, to) // Append the "to" argument.
 111 |     |             mstore(36, amount) // Append the "amount" argument.
 112 |     | 
 113 |     |             success := and(
 114 |     |                 // Set success to whether the call reverted, if not we check it either
 115 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
 116 |     |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
 117 |     |                 // We use 68 because that's the total length of our calldata (4 + 32 * 2)
 118 |     |                 // Counterintuitively, this call() must be positioned after the or() in the
 119 |     |                 // surrounding and() because and() evaluates its arguments from right to left.
 120 |     |                 call(gas(), token, 0, 0, 68, 0, 32)
 121 |     |             )
 122 |     | 
 123 |     |             mstore(0x60, 0) // Restore the zero slot to zero.
 124 |     |             mstore(0x40, memPointer) // Restore the memPointer.
 125 |     |         }
 126 |     | 
 127 |     |         require(success, "APPROVE_FAILED");
 128 |     |     }
 129 |     | }
 130 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solstat/src/Gaussian.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "../../solmate/src/utils/FixedPointMathLib.sol";
   5 |     | import "./Units.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Gaussian Math Library.
   9 |     |  * @author @alexangelj
  10 |     |  *
  11 |     |  * @notice Models the normal distribution using the special Complimentary Error Function.
  12 |     |  *
  13 |     |  * @dev Only implements a distribution with mean (µ) = 0 and variance (σ) = 1.
  14 |     |  * Uses Numerical Recipes as a framework and reference C implemenation.
  15 |     |  * Numerical Recipes cites the original textbook written by Abramowitz and Stegun,
  16 |     |  * "Handbook of Mathematical Functions", which should be read to understand these
  17 |     |  * special functions and the implications of their numerical approximations.
  18 |     |  *
  19 |     |  * @custom:source Handbook of Mathematical Functions https://personal.math.ubc.ca/~cbm/aands/abramowitz_and_stegun.pdf.
  20 |     |  * @custom:source Numerical Recipes https://e-maxx.ru/bookz/files/numerical_recipes.pdf.
  21 |     |  * @custom:source Inspired by https://github.com/errcw/gaussian.
  22 |     |  */
  23 |     | library Gaussian {
  24 |     |     using FixedPointMathLib for int256;
  25 |     |     using FixedPointMathLib for uint256;
  26 |     | 
  27 |     |     error Infinity();
  28 |     |     error NegativeInfinity();
  29 |     | 
  30 | r   |     uint256 internal constant HALF_WAD = 0.5 ether;
  31 |     |     uint256 internal constant PI = 3_141592653589793238;
  32 |     |     int256 internal constant SQRT_2PI = 2_506628274631000502;
  33 |     |     int256 internal constant SIGN = -1;
  34 |     |     int256 internal constant SCALAR = 1e18;
  35 |     |     int256 internal constant HALF_SCALAR = 1e9;
  36 |     |     int256 internal constant SCALAR_SQRD = 1e36;
  37 |     |     int256 internal constant HALF = 5e17;
  38 | *r  |     int256 internal constant ONE = 1e18;
  39 | *r  |     int256 internal constant TWO = 2e18;
  40 |     |     int256 internal constant NEGATIVE_TWO = -2e18;
  41 |     |     int256 internal constant SQRT2 = 1_414213562373095048; // √2 with 18 decimals of precision.
  42 |     |     int256 internal constant ERFC_A = 1_265512230000000000;
  43 |     |     int256 internal constant ERFC_B = 1_000023680000000000;
  44 |     |     int256 internal constant ERFC_C = 374091960000000000; // 1e-1
  45 |     |     int256 internal constant ERFC_D = 96784180000000000; // 1e-2
  46 |     |     int256 internal constant ERFC_E = -186288060000000000; // 1e-1
  47 |     |     int256 internal constant ERFC_F = 278868070000000000; // 1e-1
  48 |     |     int256 internal constant ERFC_G = -1_135203980000000000;
  49 |     |     int256 internal constant ERFC_H = 1_488515870000000000;
  50 |     |     int256 internal constant ERFC_I = -822152230000000000; // 1e-1
  51 |     |     int256 internal constant ERFC_J = 170872770000000000; // 1e-1
  52 |     |     int256 internal constant IERFC_A = -707110000000000000; // 1e-1
  53 |     |     int256 internal constant IERFC_B = 2_307530000000000000;
  54 |     |     int256 internal constant IERFC_C = 270610000000000000; // 1e-1
  55 |     |     int256 internal constant IERFC_D = 992290000000000000; // 1e-1
  56 |     |     int256 internal constant IERFC_E = 44810000000000000; // 1e-2
  57 |     |     int256 internal constant IERFC_F = 1_128379167095512570;
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Approximation of the Complimentary Error Function.
  61 |     |      * Related to the Error Function: `erfc(x) = 1 - erf(x)`.
  62 |     |      * Both cumulative distribution and error functions are integrals
  63 |     |      * which cannot be expressed in elementary terms. They are called special functions.
  64 |     |      * The error and complimentary error functions have numerical approximations
  65 |     |      * which is what is used in this library to compute the cumulative distribution function.
  66 |     |      *
  67 |     |      * @dev This is a special function with its own identities.
  68 |     |      * Identity: `erfc(-x) = 2 - erfc(x)`.
  69 |     |      * Special Values:
  70 |     |      * erfc(-infinity)	=	2
  71 |     |      * erfc(0)      	=	1
  72 |     |      * erfc(infinity)	=	0
  73 |     |      *
  74 |     |      * @custom:epsilon Fractional error less than 1.2e-7.
  75 |     |      * @custom:source Numerical Recipes in C 2e p221.
  76 |     |      * @custom:source https://mathworld.wolfram.com/Erfc.html.
  77 |     |      */
  78 | *r  |     function erfc(int256 input) internal pure returns (int256 output) {
  79 | *r  |         uint256 z = abs(input);
  80 | *r  |         int256 t;
  81 |     |         int256 step;
  82 |     |         int256 k;
  83 |     |         assembly {
  84 | *r  |             let quo := sdiv(mul(z, ONE), TWO) // 1 / (1 + z / 2).
  85 | *r  |             let den := add(ONE, quo)
  86 | *r  |             t := sdiv(SCALAR_SQRD, den)
  87 |     | 
  88 | *r  |             function muli(pxn, pxd) -> res {
  89 | *r  |                 res := sdiv(mul(pxn, pxd), ONE)
  90 |     |             }
  91 |     | 
  92 |     |             {
  93 | *r  |                 step := add(
  94 | *r  |                     ERFC_F,
  95 | *r  |                     muli(
  96 | *r  |                         t,
  97 | *r  |                         add(
  98 |     |                             ERFC_G,
  99 | *r  |                             muli(
 100 | *r  |                                 t,
 101 | *r  |                                 add(
 102 | *r  |                                     ERFC_H,
 103 | *r  |                                     muli(t, add(ERFC_I, muli(t, ERFC_J)))
 104 |     |                                 )
 105 |     |                             )
 106 |     |                         )
 107 |     |                     )
 108 |     |                 )
 109 |     |             }
 110 |     |             {
 111 | *r  |                 step := muli(
 112 |     |                     t,
 113 | *r  |                     add(
 114 | *r  |                         ERFC_B,
 115 |     |                         muli(
 116 |     |                             t,
 117 | *r  |                             add(
 118 | *r  |                                 ERFC_C,
 119 |     |                                 muli(
 120 |     |                                     t,
 121 | *r  |                                     add(
 122 | *r  |                                         ERFC_D,
 123 | *r  |                                         muli(t, add(ERFC_E, muli(t, step)))
 124 |     |                                     )
 125 |     |                                 )
 126 |     |                             )
 127 |     |                         )
 128 |     |                     )
 129 |     |                 )
 130 |     |             }
 131 |     | 
 132 | *r  |             k := add(sub(mul(SIGN, muli(z, z)), ERFC_A), step)
 133 |     |         }
 134 |     | 
 135 | *r  |         int256 expWad = FixedPointMathLib.expWad(k);
 136 | *r  |         int256 r;
 137 | *r  |         assembly {
 138 | *r  |             r := sdiv(mul(t, expWad), ONE)
 139 | *r  |             switch iszero(slt(input, 0))
 140 | *r  |             case 0 {
 141 | *r  |                 output := sub(TWO, r)
 142 |     |             }
 143 | r   |             case 1 {
 144 | r   |                 output := r
 145 |     |             }
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @notice Approximation of the Inverse Complimentary Error Function - erfc^(-1).
 151 |     |      *
 152 |     |      * @dev Equal to `ierfc(erfc(x)) = erfc(ierfc(x))` for 0 < x < 2.
 153 |     |      * Related to the Inverse Error Function: `ierfc(1 - x) = ierf(x)`.
 154 |     |      * This is a special function with its own identities.
 155 |     |      * Domain:      0 < x < 2
 156 |     |      * Special values:
 157 |     |      * ierfc(0)	=	infinity
 158 |     |      * ierfc(1)	=	0
 159 |     |      * ierfc(2)	=	-infinity
 160 |     |      *
 161 |     |      * @custom:source Numerical Recipes 3e p265.
 162 |     |      * @custom:source https://mathworld.wolfram.com/InverseErfc.html.
 163 |     |      */
 164 | r   |     function ierfc(int256 x) internal pure returns (int256 z) {
 165 |     |         assembly {
 166 |     |             // x >= 2, iszero(x < 2 ? 1 : 0) ? 1 : 0.
 167 | r   |             if iszero(slt(x, TWO)) {
 168 |     |                 z := mul(add(not(100), 1), SCALAR)
 169 |     |             }
 170 |     | 
 171 |     |             // x <= 0.
 172 | r   |             if iszero(sgt(x, 0)) {
 173 |     |                 z := mul(100, SCALAR)
 174 |     |             }
 175 |     |         }
 176 |     | 
 177 | r   |         if (z != 0) return z;
 178 |     | 
 179 | r   |         int256 xx; // (x < ONE) ? x : TWO - x.
 180 |     |         assembly {
 181 | r   |             switch iszero(slt(x, ONE))
 182 | r   |             case 0 {
 183 |     |                 xx := x
 184 |     |             }
 185 | r   |             case 1 {
 186 | r   |                 xx := sub(TWO, x)
 187 |     |             }
 188 |     |         }
 189 |     | 
 190 | r   |         int256 logInput = diviWad(xx, TWO);
 191 | r   |         if (logInput == 0) revert Infinity();
 192 | r   |         int256 ln = FixedPointMathLib.lnWad(logInput);
 193 | r   |         uint256 t = uint256(muliWad(NEGATIVE_TWO, ln)).sqrt();
 194 |     |         assembly {
 195 | r   |             t := mul(t, HALF_SCALAR)
 196 |     |         }
 197 |     | 
 198 | r   |         int256 r;
 199 |     |         assembly {
 200 |     |             function muli(pxn, pxd) -> res {
 201 |     |                 res := sdiv(mul(pxn, pxd), ONE)
 202 |     |             }
 203 |     | 
 204 | r   |             r := muli(
 205 |     |                 IERFC_A,
 206 | r   |                 sub(
 207 | r   |                     sdiv(
 208 | r   |                         mul(add(IERFC_B, muli(t, IERFC_C)), ONE),
 209 | r   |                         add(ONE, muli(t, add(IERFC_D, muli(t, IERFC_E))))
 210 |     |                     ),
 211 | r   |                     t
 212 |     |                 )
 213 |     |             )
 214 |     |         }
 215 |     | 
 216 | r   |         uint256 itr;
 217 | r   |         while (itr < 2) {
 218 | r   |             int256 err = erfc(r);
 219 |     |             assembly {
 220 | r   |                 err := sub(err, xx)
 221 |     |             }
 222 |     | 
 223 | r   |             int256 input;
 224 |     |             assembly {
 225 | r   |                 input := add(not(sdiv(mul(r, r), ONE)), 1) // -(r * r).
 226 |     |             }
 227 |     | 
 228 | r   |             int256 expWad = input.expWad();
 229 |     | 
 230 | r   |             assembly {
 231 |     |                 function muli(pxn, pxd) -> res {
 232 |     |                     res := sdiv(mul(pxn, pxd), ONE)
 233 |     |                 }
 234 |     | 
 235 | r   |                 r := add(
 236 | r   |                     r,
 237 | r   |                     sdiv(
 238 | r   |                         mul(err, ONE),
 239 | r   |                         sub(muli(IERFC_F, expWad), muli(r, err))
 240 |     |                     )
 241 |     |                 )
 242 |     | 
 243 | r   |                 itr := add(itr, 1)
 244 |     |             }
 245 |     |         }
 246 |     | 
 247 |     |         assembly {
 248 | r   |             switch iszero(slt(x, ONE)) // x < ONE ? r : -r.
 249 | r   |             case 0 {
 250 |     |                 z := r
 251 |     |             }
 252 | r   |             case 1 {
 253 | r   |                 z := add(not(r), 1)
 254 |     |             }
 255 |     |         }
 256 |     |     }
 257 |     | 
 258 |     |     /**
 259 |     |      * @notice Approximation of the Cumulative Distribution Function.
 260 |     |      *
 261 |     |      * @dev Equal to `D(x) = 0.5[ 1 + erf((x - µ) / σ√2)]`.
 262 |     |      * Only computes cdf of a distribution with µ = 0 and σ = 1.
 263 |     |      *
 264 |     |      * @custom:error Maximum error of 1.2e-7.
 265 |     |      * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.
 266 |     |      */
 267 | *r  |     function cdf(int256 x) internal pure returns (int256 z) {
 268 |     |         int256 negated;
 269 |     |         assembly {
 270 | *r  |             let res := sdiv(mul(x, ONE), SQRT2)
 271 | *r  |             negated := add(not(res), 1)
 272 |     |         }
 273 |     | 
 274 | *r  |         int256 _erfc = erfc(negated);
 275 |     |         assembly {
 276 | *r  |             z := sdiv(mul(ONE, _erfc), TWO)
 277 |     |         }
 278 |     |     }
 279 |     | 
 280 |     |     /**
 281 |     |      * @notice Approximation of the Probability Density Function.
 282 |     |      *
 283 |     |      * @dev Equal to `Z(x) = (1 / σ√2π)e^( (-(x - µ)^2) / 2σ^2 )`.
 284 |     |      * Only computes pdf of a distribution with µ = 0 and σ = 1.
 285 |     |      *
 286 |     |      * @custom:error Maximum error of 1.2e-7.
 287 |     |      * @custom:source https://mathworld.wolfram.com/ProbabilityDensityFunction.html.
 288 |     |      */
 289 |     |     function pdf(int256 x) internal pure returns (int256 z) {
 290 |     |         int256 e;
 291 |     |         assembly {
 292 |     |             e := sdiv(mul(add(not(x), 1), x), TWO) // (-x * x) / 2.
 293 |     |         }
 294 |     |         e = FixedPointMathLib.expWad(e);
 295 |     | 
 296 |     |         assembly {
 297 |     |             z := sdiv(mul(e, ONE), SQRT_2PI)
 298 |     |         }
 299 |     |     }
 300 |     | 
 301 |     |     /**
 302 |     |      * @notice Approximation of the Percent Point Function.
 303 |     |      *
 304 |     |      * @dev Equal to `D(x)^(-1) = µ - σ√2(ierfc(2x))`.
 305 |     |      * Only computes ppf of a distribution with µ = 0 and σ = 1.
 306 |     |      *
 307 |     |      * @custom:error Maximum error of 1.2e-7.
 308 |     |      * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.
 309 |     |      */
 310 | r   |     function ppf(int256 x) internal pure returns (int256 z) {
 311 | r   |         if (x == int256(HALF_WAD)) return int256(0); // returns 3.75e-8, but we know it's zero.
 312 | r   |         if (x >= ONE) revert Infinity();
 313 | r   |         if (x == 0) revert NegativeInfinity();
 314 |     |         assembly {
 315 | r   |             x := mul(x, 2)
 316 |     |         }
 317 |     | 
 318 | r   |         int256 _ierfc = ierfc(x);
 319 |     | 
 320 |     |         assembly {
 321 | r   |             let res := sdiv(mul(SQRT2, _ierfc), ONE)
 322 | r   |             z := add(not(res), 1) // -res.
 323 |     |         }
 324 |     |     }
 325 |     | }
 326 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solstat/src/Invariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | import "./Gaussian.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Invariant of Primitive RMM.
   8 |     |  * @author @alexangelj
   9 |     |  * @notice Invariant is `k` with the trading function `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.
  10 |     |  *
  11 |     |  * @dev Terms which can potentially be ambiguous are given discrete names.
  12 |     |  * This makes it easier to search for terms and update terms.
  13 |     |  * Variables can sometimes not be trusted to be or act like their names.
  14 |     |  * This naming scheme avoids this problem using a glossary to define them.
  15 |     |  *
  16 |     |  * // -------------------- Glossary --------------------- //
  17 |     |  *
  18 |     |  * `R_x` - Amount of asset token reserves per single unit of liquidity.
  19 |     |  * `R_y` - Amount of quote token reserves per single unit of liquidity.
  20 |     |  * `stk` - Strike price of the pool. The terminal price of each asset token.
  21 |     |  * `vol` - Implied volatility of the pool. Higher vol = higher price impact on swaps.
  22 |     |  * `tau` - Time until the pool expires. Amount of seconds until the pool's curve becomes flat around `stk`.
  23 |     |  * `inv` - Invariant of the pool. Difference between theoretical $ value and actual $ value per liquidity.
  24 |     |  *
  25 |     |  * `WAD` - Signed or unsigned fixed point number with up to 18 decimals and up to 256 total bits wide.
  26 |     |  * `YEAR`- Equal to the amount of seconds in a year. Used in `invariant` function.
  27 |     |  *
  28 |     |  * // -------------------- Units ------------------------ //
  29 |     |  *
  30 |     |  * `R_x` - Units are unsigned WAD. Represents value of tokens, decimals matter.
  31 |     |  * `R_y` - Units are unsigned WAD. Represents value of tokens, decimals matter.
  32 |     |  * `stk` - Units are unsigned WAD. Represents value of tokens, decimals matter.
  33 |     |  * `vol` - Units are unsigned WAD. Represents a percentage in which 100% = WAD.
  34 |     |  * `tau` - Units are YEAR. Represents a time unit which `1.0` is equal to YEAR.
  35 |     |  * `inv` - Units are signed WAD. Initial value of zero and decreases over time.
  36 |     |  *
  37 |     |  * // -------------------- Denoted By ----------------- //
  38 |     |  *
  39 |     |  * `R_x` - Denoted by `x`.
  40 |     |  * `R_y` - Denoted by `y`.
  41 |     |  * `stk` - Denoted by `K`.
  42 |     |  * `vol` - Denoted by `σ`.
  43 |     |  * `tau` - Denoted by `τ`.
  44 |     |  * `inv` - Denoted by `k`.
  45 |     |  *
  46 |     |  * // -------------------- Error Bounds ----------------- //
  47 |     |  *
  48 |     |  * `inv` - Up to 1e-9.
  49 |     |  *
  50 |     |  * // ------------------------ ~ ------------------------ //
  51 |     |  */
  52 |     | library Invariant {
  53 |     |     using Gaussian for int256; // Uses the `cdf` and `pdf` functions.
  54 |     |     using FixedPointMathLib for uint256; // Uses the `sqrt` function.
  55 |     | 
  56 | *r  |     uint256 internal constant WAD = 1 ether;
  57 |     |     uint256 internal constant DOUBLE_WAD = 2 ether;
  58 |     |     int256 internal constant ONE = 1 ether;
  59 |     |     int256 internal constant YEAR = 31556952;
  60 |     |     int256 internal constant HALF_SCALAR = 1e9;
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Reverts when an input value is out of bounds of its acceptable range.
  64 |     |      */
  65 |     |     error OOB();
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Uses reserves `R_x` to compute reserves `R_y`.
  69 |     |      *
  70 |     |      * @dev Computes `y` in `y = KΦ(Φ⁻¹(1-x) - σ√τ) + k`.
  71 |     |      * Primary function use to compute the invariant.
  72 |     |      * Simplifies to `K(1 -x) + k` when time to expiry is zero.
  73 |     |      * Reverts if `R_x` is greater than one. Units are a fixed point number with 18 decimals.
  74 |     |      *
  75 |     |      * We handle some special cases, try this:
  76 |     |      * `normalcdlower(normalicdlower(1) - 0.1)` in https://keisan.casio.com/calculator
  77 |     |      * Gaussian.sol reverts for `ppf(1)` and `ppf(0)`, so we handle those cases.
  78 |     |      *
  79 |     |      * @param R_x Quantity of token reserve `x` within the bounds of [0, 1].
  80 |     |      * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.
  81 |     |      * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.
  82 |     |      * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.
  83 |     |      * @param inv Current invariant given the actual `R_x`. Zero if computing invariant itself.
  84 |     |      * @return R_y Quantity of token reserve `y` within the bounds of [0, stk].
  85 |     |      *
  86 |     |      * @custom:error Technically, none. This is the source of truth for the trading function.
  87 |     |      * @custom:source https://primitive.xyz/whitepaper
  88 |     |      */
  89 | *r  |     function getY(
  90 |     |         uint256 R_x,
  91 |     |         uint256 stk,
  92 |     |         uint256 vol,
  93 |     |         uint256 tau,
  94 |     |         int256 inv
  95 | *r  |     ) internal pure returns (uint256 R_y) {
  96 | *r  |         if (R_x > WAD) revert OOB(); // Negative input for `ppf` is invalid.
  97 | *r  |         if (R_x == WAD) return uint256(int256(stk) + inv); // For `ppf(0)` case, because 1 - R_x == 0, and `y = K * 1 + k` simplifies to `y = K + k`
  98 | *r  |         if (R_x == 0) return uint256(inv); // For `ppf(1)` case, because 1 - 0 == 1, and `y = K * 0 + k` simplifies to `y = k`.
  99 | r   |         if (tau != 0) {
 100 |     |             // Short circuits because tau != 0 is more likely.
 101 | r   |             uint256 sec;
 102 |     |             assembly {
 103 | r   |                 sec := sdiv(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.
 104 |     |             }
 105 |     | 
 106 | r   |             uint256 sdr = sec.sqrt(); // √τ.
 107 |     |             assembly {
 108 | r   |                 sdr := mul(sdr, HALF_SCALAR) // Unit math: sdr * HALF_SCALAR = SCALAR.
 109 | r   |                 sdr := sdiv(mul(vol, sdr), ONE) // σ√τ.
 110 |     |             }
 111 |     | 
 112 |     |             int256 phi;
 113 |     |             assembly {
 114 | r   |                 phi := sub(ONE, R_x)
 115 |     |             }
 116 | r   |             phi = phi.ppf(); // Φ⁻¹(1-x).
 117 |     | 
 118 |     |             int256 cdf;
 119 |     |             assembly {
 120 | r   |                 cdf := sub(phi, sdr) // Φ⁻¹(1-x) - σ√τ.
 121 |     |             }
 122 | r   |             cdf = cdf.cdf(); // Φ(Φ⁻¹(1-x) - σ√τ).
 123 |     | 
 124 |     |             assembly {
 125 | r   |                 R_y := add(sdiv(mul(stk, cdf), ONE), inv)
 126 |     |             }
 127 |     |         } else {
 128 |     |             assembly {
 129 |     |                 R_y := add(sdiv(mul(stk, sub(ONE, R_x)), ONE), inv)
 130 |     |             }
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Uses reserves `R_y` to compute reserves `R_x`.
 136 |     |      *
 137 |     |      * @dev Computes `x` in `x = 1 - Φ(Φ⁻¹( (y + k) / K ) + σ√τ)`.
 138 |     |      * Not used in invariant function. Used for computing swap outputs.
 139 |     |      * Simplifies to `1 - ( (y + k) / K )` when time to expiry is zero.
 140 |     |      * Reverts if `R_y` is greater than one. Units are WAD.
 141 |     |      *
 142 |     |      * Dangerous! There are important bounds to using this function.
 143 |     |      *
 144 |     |      * @param R_y Quantity of token reserve `y` within the bounds of [0, stk].
 145 |     |      * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.
 146 |     |      * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.
 147 |     |      * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.
 148 |     |      * @param inv Current invariant given the actual reserves `R_y`.
 149 |     |      * @return R_x Quantity of token reserve `x` within the bounds of [0, 1].
 150 |     |      *
 151 |     |      * @custom:error Up to 1e-6. This an **approximated** "inverse" of the `getY` function.
 152 |     |      * @custom:source https://primitive.xyz/whitepaper
 153 |     |      */
 154 |     |     function getX(
 155 |     |         uint256 R_y,
 156 |     |         uint256 stk,
 157 |     |         uint256 vol,
 158 |     |         uint256 tau,
 159 |     |         int256 inv
 160 |     |     ) internal pure returns (uint256 R_x) {
 161 |     |         // Short circuits because tau != 0 is more likely.
 162 |     |         if (tau != 0) {
 163 |     |             uint256 sec;
 164 |     |             assembly {
 165 |     |                 sec := div(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.
 166 |     |             }
 167 |     | 
 168 |     |             uint256 sdr = sec.sqrt(); // √τ.
 169 |     |             assembly {
 170 |     |                 sdr := mul(sdr, HALF_SCALAR) // Unit math: HALF_SCALAR * HALF_SCALAR = SCALAR.
 171 |     |                 sdr := div(mul(vol, sdr), ONE) // σ√τ.
 172 |     |             }
 173 |     | 
 174 |     |             int256 phi;
 175 |     |             assembly {
 176 |     |                 phi := sdiv(mul(add(R_y, inv), ONE), stk) // (y + k) / K.
 177 |     |             }
 178 |     | 
 179 |     |             if (phi < 0) revert OOB(); // Negative input for `ppf` is invalid.
 180 |     |             if (phi > ONE) revert OOB();
 181 |     |             if (phi == ONE) return 0; // `x = 1 - Φ(Φ⁻¹( 1 ) + σ√τ)` simplifies to  `x = 0`.
 182 |     |             if (phi == 0) return WAD; // `x = 1 - Φ(Φ⁻¹( 0 ) + σ√τ)` simplifies to `x = 1`.
 183 |     | 
 184 |     |             phi = phi.ppf(); // Φ⁻¹( (y + k) / K ).
 185 |     | 
 186 |     |             int256 cdf;
 187 |     |             assembly {
 188 |     |                 cdf := add(phi, sdr) // Φ⁻¹( (y + k) / K ) + σ√τ.
 189 |     |             }
 190 |     |             cdf = cdf.cdf(); // Φ(Φ⁻¹( (y + k) / K ) + σ√τ).
 191 |     | 
 192 |     |             assembly {
 193 |     |                 R_x := sub(ONE, cdf)
 194 |     |             }
 195 |     |         } else {
 196 |     |             assembly {
 197 |     |                 R_x := sub(ONE, sdiv(mul(add(R_y, inv), ONE), stk))
 198 |     |             }
 199 |     |         }
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @notice Computes the invariant of the RMM trading function.
 204 |     |      *
 205 |     |      * @dev Computes `k` in `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.
 206 |     |      * Used to validate swaps, the most critical function.
 207 |     |      *
 208 |     |      * @custom:source https://rmm.eth.xyz
 209 |     |      */
 210 |     |     function invariant(
 211 |     |         uint256 R_y,
 212 |     |         uint256 R_x,
 213 |     |         uint256 stk,
 214 |     |         uint256 vol,
 215 |     |         uint256 tau
 216 |     |     ) internal pure returns (int256 inv) {
 217 |     |         uint256 y = getY(R_x, stk, vol, tau, inv); // `inv` is 0 because we are solving `inv`, aka `k`.
 218 |     |         assembly {
 219 |     |             inv := sub(R_y, y)
 220 |     |         }
 221 |     |     }
 222 |     | }
 223 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/lib/solstat/src/Units.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | error Min();
  5 | *r  | 
  6 | *r  | function abs(int256 input) pure returns (uint256 output) {
  7 | *r  |     if (input == type(int256).min) revert Min();
  8 | *r  |     if (input < 0) {
  9 |     |         assembly {
 10 | *r  |             output := add(not(input), 1)
 11 |     |         }
 12 |     |     } else {
 13 |     |         assembly {
 14 |     |             output := input
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 
 19 | r   | /// @dev From solmate@v7, changes last `div` to `sdiv`.
 20 |     | function muli(
 21 |     |     int256 x,
 22 |     |     int256 y,
 23 |     |     int256 denominator
 24 |     | ) pure returns (int256 z) {
 25 |     |     assembly {
 26 |     |         // Store x * y in z for now.
 27 | r   |         z := mul(x, y)
 28 |     | 
 29 |     |         // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
 30 | r   |         if iszero(
 31 | r   |             and(iszero(iszero(denominator)), or(iszero(x), eq(sdiv(z, x), y)))
 32 |     |         ) {
 33 |     |             revert(0, 0)
 34 |     |         }
 35 |     | 
 36 |     |         // Divide z by the denominator.
 37 | r   |         z := sdiv(z, denominator)
 38 |     |     }
 39 |     | }
 40 | r   | 
 41 | r   | function muliWad(int256 x, int256 y) pure returns (int256 z) {
 42 | r   |     z = muli(x, y, 1 ether);
 43 |     | }
 44 | r   | 
 45 | r   | function diviWad(int256 x, int256 y) pure returns (int256 z) {
 46 | r   |     z = muli(x, 1 ether, y);
 47 |     | }
 48 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/InvariantAllocateUnallocate.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./setup/InvariantTargetContract.sol";
   5 |     | 
   6 |     | contract InvariantAllocateUnallocate is InvariantTargetContract {
   7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
   8 |     | 
   9 |     |     function allocate(uint deltaLiquidity, uint index) public {
  10 |     |         deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);
  11 |     | 
  12 |     |         // Allocate to a random pool.
  13 |     |         // VERY IMPORTANT
  14 |     |         setPoolId(ctx.getRandomPoolId(index));
  15 |     | 
  16 |     |         _assertAllocate(deltaLiquidity);
  17 |     |     }
  18 |     | 
  19 |     |     // avoid stack too deep
  20 |     |     uint expectedDeltaAsset;
  21 |     |     uint expectedDeltaQuote;
  22 |     |     bool transferAssetIn;
  23 |     |     bool transferQuoteIn;
  24 |     |     int assetCredit;
  25 |     |     int quoteCredit;
  26 |     |     uint deltaAsset;
  27 |     |     uint deltaQuote;
  28 |     |     uint userAssetBalance;
  29 |     |     uint userQuoteBalance;
  30 |     |     uint physicalAssetPayment;
  31 |     |     uint physicalQuotePayment;
  32 |     | 
  33 |     |     HyperState prev;
  34 |     |     HyperState post;
  35 |     | 
  36 |     |     function _assertAllocate(uint deltaLiquidity) internal {
  37 |     |         // TODO: cleanup reset of these
  38 |     |         transferAssetIn = true;
  39 |     |         transferQuoteIn = true;
  40 |     | 
  41 |     |         // Preconditions
  42 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
  43 |     |         assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
  44 |     |         assertTrue(pool.lastPrice != 0, "Pool not created with a price");
  45 |     | 
  46 |     |         // Amounts of tokens that will be allocated to pool.
  47 |     |         (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(
  48 |     |             __poolId__,
  49 |     |             int128(uint128(deltaLiquidity))
  50 |     |         );
  51 |     | 
  52 |     |         // If net balance > 0, there are tokens in the contract which are not in a pool or balance.
  53 |     |         // They will be credited to the msg.sender of the next call.
  54 |     |         assetCredit = __hyper__.getNetBalance(address(__asset__));
  55 |     |         quoteCredit = __hyper__.getNetBalance(address(__quote__));
  56 |     | 
  57 |     |         // Net balances should always be positive outside of execution.
  58 |     |         assertTrue(assetCredit >= 0, "negative-net-asset-tokens");
  59 |     |         assertTrue(quoteCredit >= 0, "negative-net-quote-tokens");
  60 |     | 
  61 |     |         // Internal balance of tokens spendable by user.
  62 |     |         userAssetBalance = getBalance(address(__hyper__), address(this), address(__asset__));
  63 |     |         userQuoteBalance = getBalance(address(__hyper__), address(this), address(__quote__));
  64 |     | 
  65 |     |         // If there is a net balance, user can use it to pay their cost.
  66 |     |         // Total payment the user must make.
  67 |     |         physicalAssetPayment = uint(assetCredit) > expectedDeltaAsset ? 0 : expectedDeltaAsset - uint(assetCredit);
  68 |     |         physicalQuotePayment = uint(quoteCredit) > expectedDeltaQuote ? 0 : expectedDeltaQuote - uint(quoteCredit);
  69 |     | 
  70 |     |         physicalAssetPayment = uint(userAssetBalance) > physicalAssetPayment
  71 |     |             ? 0
  72 |     |             : physicalAssetPayment - uint(userAssetBalance);
  73 |     |         physicalQuotePayment = uint(userQuoteBalance) > physicalQuotePayment
  74 |     |             ? 0
  75 |     |             : physicalQuotePayment - uint(userQuoteBalance);
  76 |     | 
  77 |     |         // If user can pay for the allocate using their internal balance of tokens, don't need to transfer tokens in.
  78 |     |         // Won't need to transfer in tokens if user payment is zero.
  79 |     |         if (physicalAssetPayment == 0) transferAssetIn = false;
  80 |     |         if (physicalQuotePayment == 0) transferQuoteIn = false;
  81 |     | 
  82 |     |         // If the user has to pay externally, give them tokens.
  83 |     |         if (transferAssetIn) __asset__.mint(address(this), physicalAssetPayment);
  84 |     |         if (transferQuoteIn) __quote__.mint(address(this), physicalQuotePayment);
  85 |     | 
  86 |     |         // Execution
  87 |     |         prev = getState();
  88 |     |         (deltaAsset, deltaQuote) = __hyper__.allocate(__poolId__, deltaLiquidity);
  89 |     |         post = getState();
  90 |     | 
  91 |     |         // Postconditions
  92 |     | 
  93 |     |         assertEq(deltaAsset, expectedDeltaAsset, "pool-delta-asset");
  94 |     |         assertEq(deltaQuote, expectedDeltaQuote, "pool-delta-quote");
  95 |     |         assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, "pool-total-liquidity");
  96 |     |         assertTrue(post.totalPoolLiquidity > prev.totalPoolLiquidity, "pool-liquidity-increases");
  97 |     |         assertEq(
  98 |     |             post.callerPositionLiquidity,
  99 |     |             prev.callerPositionLiquidity + deltaLiquidity,
 100 |     |             "position-liquidity-increases"
 101 |     |         );
 102 |     | 
 103 |     |         assertEq(post.reserveAsset, prev.reserveAsset + physicalAssetPayment + uint(assetCredit), "reserve-asset");
 104 |     |         assertEq(post.reserveQuote, prev.reserveQuote + physicalQuotePayment + uint(quoteCredit), "reserve-quote");
 105 |     |         assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + physicalAssetPayment, "physical-asset");
 106 |     |         assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + physicalQuotePayment, "physical-quote");
 107 |     | 
 108 |     |         uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;
 109 |     |         uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;
 110 |     |         assertTrue(feeDelta0 == feeDelta1, "asset-growth");
 111 |     | 
 112 |     |         uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;
 113 |     |         uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;
 114 |     |         assertTrue(feeDelta2 == feeDelta3, "quote-growth");
 115 |     | 
 116 |     |         emit FinishedCall("Allocate");
 117 |     | 
 118 |     |         checkVirtualInvariant();
 119 |     |     }
 120 |     | 
 121 |     |     event FinishedCall(string);
 122 |     | 
 123 |     |     function unallocate(uint deltaLiquidity, uint index) external {
 124 |     |         deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);
 125 |     | 
 126 |     |         // Unallocate from a random pool.
 127 |     |         // VERY IMPORTANT
 128 |     |         setPoolId(ctx.getRandomPoolId(index));
 129 |     | 
 130 |     |         _assertUnallocate(deltaLiquidity);
 131 |     |     }
 132 |     | 
 133 |     |     function _assertUnallocate(uint deltaLiquidity) internal {
 134 |     |         // TODO: Add use max flag support.
 135 |     | 
 136 |     |         // Get some liquidity.
 137 |     |         HyperPosition memory pos = getPosition(address(__hyper__), address(this), __poolId__);
 138 |     |         require(pos.freeLiquidity >= deltaLiquidity, "Not enough liquidity");
 139 |     | 
 140 |     |         if (pos.freeLiquidity >= deltaLiquidity) {
 141 |     |             // Preconditions
 142 |     |             HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 143 |     |             assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
 144 |     |             assertTrue(pool.lastPrice != 0, "Pool not created with a price");
 145 |     | 
 146 |     |             // Unallocate
 147 |     |             uint timestamp = block.timestamp + 4; // todo: fix default jit policy
 148 |     |             vm.warp(timestamp);
 149 |     |             __hyper__.setTimestamp(uint128(timestamp));
 150 |     | 
 151 |     |             (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(
 152 |     |                 __poolId__,
 153 |     |                 -int128(uint128(deltaLiquidity))
 154 |     |             );
 155 |     |             prev = getState();
 156 |     |             (uint unallocatedAsset, uint unallocatedQuote) = __hyper__.unallocate(__poolId__, deltaLiquidity);
 157 |     |             HyperState memory end = getState();
 158 |     | 
 159 |     |             assertEq(unallocatedAsset, expectedDeltaAsset, "asset-delta");
 160 |     |             assertEq(unallocatedQuote, expectedDeltaQuote, "quote-delta");
 161 |     |             assertEq(end.reserveAsset, prev.reserveAsset - unallocatedAsset, "reserve-asset");
 162 |     |             assertEq(end.reserveQuote, prev.reserveQuote - unallocatedQuote, "reserve-quote");
 163 |     |             assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity - deltaLiquidity, "total-liquidity");
 164 |     |             assertTrue(prev.totalPositionLiquidity >= deltaLiquidity, "total-pos-liq-underflow");
 165 |     |             assertTrue(prev.callerPositionLiquidity >= deltaLiquidity, "caller-pos-liq-underflow");
 166 |     |             assertEq(
 167 |     |                 end.totalPositionLiquidity,
 168 |     |                 prev.totalPositionLiquidity - deltaLiquidity,
 169 |     |                 "total-position-liquidity"
 170 |     |             );
 171 |     |             assertEq(
 172 |     |                 end.callerPositionLiquidity,
 173 |     |                 prev.callerPositionLiquidity - deltaLiquidity,
 174 |     |                 "caller-position-liquidity"
 175 |     |             );
 176 |     |         }
 177 |     |         emit FinishedCall("Unallocate");
 178 |     | 
 179 |     |         checkVirtualInvariant();
 180 |     |     }
 181 |     | 
 182 |     |     function checkVirtualInvariant() internal {
 183 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 184 |     |         // TODO: Breaks when we call this function on a pool with zero liquidity...
 185 |     |         (uint dAsset, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);
 186 |     |         emit log("dAsset", dAsset);
 187 |     |         emit log("dQuote", dQuote);
 188 |     | 
 189 |     |         uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));
 190 |     |         uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));
 191 |     | 
 192 |     |         emit log("bAsset", bAsset);
 193 |     |         emit log("bQuote", bQuote);
 194 |     | 
 195 |     |         int diffAsset = int(bAsset) - int(dAsset);
 196 |     |         int diffQuote = int(bQuote) - int(dQuote);
 197 |     |         emit log("diffAsset", diffAsset);
 198 |     |         emit log("diffQuote", diffQuote);
 199 |     | 
 200 |     |         assertTrue(bAsset >= dAsset, "invariant-virtual-reserves-asset");
 201 |     |         assertTrue(bQuote >= dQuote, "invariant-virtual-reserves-quote");
 202 |     | 
 203 |     |         emit FinishedCall("Check Virtual Invariant");
 204 |     |     }
 205 |     | 
 206 |     |     event log(string, uint);
 207 |     |     event log(string, int);
 208 |     | }
 209 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/InvariantCreatePool.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/HyperLib.sol" as HyperTypes;
   5 |     | import "contracts/Enigma.sol" as Enigma;
   6 |     | import "./setup/InvariantTargetContract.sol";
   7 |     | 
   8 |     | contract InvariantCreatePool is InvariantTargetContract {
   9 |     |     Forwarder forwarder;
  10 |     | 
  11 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {
  12 |     |         forwarder = new Forwarder();
  13 |     |     }
  14 |     | 
  15 |     |     function create_pool(
  16 |     |         uint index,
  17 |     |         uint128 price,
  18 |     |         uint128 strike,
  19 |     |         uint24 sigma,
  20 |     |         uint32 maturity,
  21 |     |         uint32 gamma,
  22 |     |         uint32 priorityGamma
  23 |     |     ) external {
  24 |     |         vm.assume(strike != 0);
  25 |     |         vm.assume(sigma != 0);
  26 |     | 
  27 |     |         maturity = uint32(block.timestamp + bound(maturity, 1, 365 days));
  28 |     |         price = uint128(bound(price, 1, 1e36));
  29 |     |         gamma = uint32(bound(sigma, 1e4 - HyperTypes.MAX_FEE, 1e4 - HyperTypes.MIN_FEE));
  30 |     |         priorityGamma = uint32(bound(sigma, gamma, 1e4 - HyperTypes.MIN_FEE));
  31 |     | 
  32 |     |         // Random user
  33 |     |         address caller = ctx.getRandomUser(index);
  34 |     |         address[] memory tokens = new address[](3);
  35 |     |         tokens[0] = address(ctx.__asset__());
  36 |     |         tokens[1] = address(ctx.__quote__());
  37 |     |         //tokens[0] = address(ctx.__weth__());
  38 |     | 
  39 |     |         address[] memory shuffled = shuffle(index, tokens);
  40 |     |         address token0 = shuffled[0];
  41 |     |         address token1 = shuffled[1];
  42 |     |         assertTrue(token0 != token1, "same-token");
  43 |     | 
  44 |     |         CreateArgs memory args = CreateArgs(
  45 |     |             caller,
  46 |     |             token0,
  47 |     |             token1,
  48 |     |             price,
  49 |     |             strike,
  50 |     |             sigma,
  51 |     |             maturity,
  52 |     |             gamma,
  53 |     |             priorityGamma
  54 |     |         );
  55 |     |         _assertCreatePool(args);
  56 |     |     }
  57 |     | 
  58 |     |     function shuffle(uint random, address[] memory array) internal view returns (address[] memory output) {
  59 |     |         for (uint256 i = 0; i < array.length; i++) {
  60 |     |             uint256 n = i + (random % (array.length - i));
  61 |     |             address temp = array[n];
  62 |     |             array[n] = array[i];
  63 |     |             array[i] = temp;
  64 |     |         }
  65 |     | 
  66 |     |         output = array;
  67 |     |     }
  68 |     | 
  69 |     |     struct CreateArgs {
  70 |     |         address caller;
  71 |     |         address token0;
  72 |     |         address token1;
  73 |     |         uint128 price;
  74 |     |         uint128 strike;
  75 |     |         uint24 sigma;
  76 |     |         uint32 maturity;
  77 |     |         uint32 gamma;
  78 |     |         uint32 priorityGamma;
  79 |     |     }
  80 |     | 
  81 |     |     bytes[] instructions;
  82 |     | 
  83 |     |     function _assertCreatePool(CreateArgs memory args) internal {
  84 |     |         bool isMutable = true;
  85 |     |         uint24 pairId = __hyper__.getPairId(args.token0, args.token1);
  86 |     |         {
  87 |     |             // HyperPair not created? Push a create pair call to the stack.
  88 |     |             if (pairId == 0) instructions.push(Enigma.encodeCreatePair(args.token0, args.token1));
  89 |     | 
  90 |     |             // Push create pool to stack
  91 |     |             instructions.push(
  92 |     |                 Enigma.encodeCreatePool(
  93 |     |                     pairId,
  94 |     |                     address(this),
  95 |     |                     1, // priorityFee
  96 |     |                     1, // fee
  97 |     |                     1, // vol
  98 |     |                     1, // dur
  99 |     |                     5,
 100 |     |                     int24(20_000),
 101 |     |                     args.price
 102 |     |                 )
 103 |     |             ); // temp
 104 |     |         }
 105 |     |         bytes memory payload = Enigma.encodeJumpInstruction(instructions);
 106 |     |         vm.prank(args.caller);
 107 |     |         console.logBytes(payload);
 108 |     |         (bool success, bytes memory reason) = address(__hyper__).call(payload);
 109 |     |         assembly {
 110 |     |             log0(add(32, reason), mload(reason))
 111 |     |         }
 112 |     | 
 113 |     |         //bool success = forwarder.forward(address(__hyper__), payload); // TODO: Fallback function does not bubble up custom errors.
 114 |     |         assertTrue(success, "hyper-call-failed");
 115 |     | 
 116 |     |         // Refetch the poolId. Current poolId could be "magic" zero variable.
 117 |     |         pairId = __hyper__.getPairId(args.token0, args.token1);
 118 |     |         assertTrue(pairId != 0, "pair-not-created");
 119 |     | 
 120 |     |         // todo: make sure we create the last pool...
 121 |     |         uint64 poolId = Enigma.encodePoolId(pairId, isMutable, uint32(__hyper__.getPoolNonce()));
 122 |     | 
 123 |     |         // Add the created pool to the list of pools.
 124 |     |         assertTrue(getPool(address(__hyper__), poolId).lastPrice != 0, "pool-price-zero");
 125 |     |         ctx.addPoolId(poolId);
 126 |     | 
 127 |     |         // Reset instructions so we don't use some old payload data...
 128 |     |         delete instructions;
 129 |     |     }
 130 |     | }
 131 |     | 
 132 |     | interface DoJump {
 133 |     |     function doJumpProcess(bytes calldata data) external payable;
 134 |     | }
 135 |     | 
 136 |     | contract Forwarder {
 137 |     |     function forward(address hyper, bytes calldata data) external payable returns (bool) {
 138 |     |         try DoJump(hyper).doJumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {
 139 |     |             assembly {
 140 |     |                 revert(add(32, reason), mload(reason))
 141 |     |             }
 142 |     |         }
 143 |     |         return true;
 144 |     |     }
 145 |     | }
 146 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/InvariantDeposit.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantDeposit is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     function deposit(uint amount, uint index) external {
 10 |     |         amount = bound(amount, 1, 1e36);
 11 |     | 
 12 |     |         address target = ctx.getRandomUser(index);
 13 |     | 
 14 |     |         vm.deal(target, amount);
 15 |     | 
 16 |     |         address weth = __hyper__.WETH();
 17 |     | 
 18 |     |         uint preBal = getBalance(address(__hyper__), target, weth);
 19 |     |         uint preRes = getReserve(address(__hyper__), weth);
 20 |     |         vm.prank(target);
 21 |     |         __hyper__.deposit{value: amount}();
 22 |     |         uint postRes = getReserve(address(__hyper__), weth);
 23 |     |         uint postBal = getBalance(address(__hyper__), target, weth);
 24 |     | 
 25 |     |         assertEq(postRes, preRes + amount, "weth-reserve");
 26 |     |         assertEq(postBal, preBal + amount, "weth-balance");
 27 |     |         assertEq(address(__hyper__).balance, 0, "eth-balance");
 28 |     |         assertEq(getPhysicalBalance(address(__hyper__), weth), postRes, "weth-physical");
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/InvariantFundDraw.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantFundDraw is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     function fund_asset(uint amount, uint index) public {
 10 |     |         amount = bound(amount, 1, 1e36);
 11 |     | 
 12 |     |         address target = ctx.getRandomUser(index);
 13 |     | 
 14 |     |         // If net balance > 0, there are tokens in the contract which are not in a pool or balance.
 15 |     |         // They will be credited to the msg.sender of the next call.
 16 |     |         int netAssetBalance = __hyper__.getNetBalance(address(__asset__));
 17 |     |         int netQuoteBalance = __hyper__.getNetBalance(address(__quote__));
 18 |     |         assertTrue(netAssetBalance >= 0, "negative-net-asset-tokens");
 19 |     |         assertTrue(netQuoteBalance >= 0, "negative-net-quote-tokens");
 20 |     | 
 21 |     |         vm.prank(target);
 22 |     |         __asset__.approve(address(__hyper__), amount);
 23 |     |         deal(address(__asset__), target, amount);
 24 |     | 
 25 |     |         uint preRes = getReserve(address(__hyper__), address(__asset__));
 26 |     |         uint preBal = getBalance(address(__hyper__), target, address(__asset__));
 27 |     |         vm.prank(target);
 28 |     |         __hyper__.fund(address(__asset__), amount);
 29 |     |         uint postRes = getReserve(address(__hyper__), address(__asset__));
 30 |     |         uint postBal = getBalance(address(__hyper__), target, address(__asset__));
 31 |     | 
 32 |     |         assertEq(postBal, preBal + amount + uint(netAssetBalance), "fund-delta-asset-balance");
 33 |     |         assertEq(postRes, preRes + amount + uint(netQuoteBalance), "fund-delta-asset-reserve");
 34 |     |     }
 35 |     | 
 36 |     |     function fund_quote(uint amount, uint index) public {
 37 |     |         amount = bound(amount, 1, 1e36);
 38 |     | 
 39 |     |         address target = ctx.getRandomUser(index);
 40 |     | 
 41 |     |         vm.prank(target);
 42 |     |         __quote__.approve(address(__hyper__), amount);
 43 |     |         deal(address(__quote__), target, amount);
 44 |     | 
 45 |     |         uint preRes = getReserve(address(__hyper__), address(__quote__));
 46 |     |         uint preBal = getBalance(address(__hyper__), target, address(__quote__));
 47 |     |         vm.prank(target);
 48 |     |         __hyper__.fund(address(__quote__), amount);
 49 |     |         uint postRes = getReserve(address(__hyper__), address(__quote__));
 50 |     |         uint postBal = getBalance(address(__hyper__), target, address(__quote__));
 51 |     | 
 52 |     |         assertEq(postBal, preBal + amount, "fund-delta-quote-balance");
 53 |     |         assertEq(postRes, preRes + amount, "fund-delta-quote-reserve");
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/InvariantSendTokens.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantSendTokens is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     event SentTokens(address indexed token, uint amount);
 10 |     | 
 11 |     |     function sendAssetTokens(uint amount) external {
 12 |     |         amount = bound(amount, 1, 2 ** 127);
 13 |     |         transfer(__asset__, amount);
 14 |     |     }
 15 |     | 
 16 |     |     function sendQuoteTokens(uint amount) external {
 17 |     |         amount = bound(amount, 1, 2 ** 127);
 18 |     |         transfer(__quote__, amount);
 19 |     |     }
 20 |     | 
 21 |     |     function transfer(TestERC20 token, uint amount) internal {
 22 |     |         token.mint(address(__hyper__), amount);
 23 |     |         emit SentTokens(address(token), amount);
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/InvariantWarper.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantWarper is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     function warper(uint amount) external {
 10 |     |         ctx.customWarp(block.timestamp + bound(amount, 1, 365 days));
 11 |     |     }
 12 |     | 
 13 |     |     function warpAfterMaturity(uint amount) external {
 14 |     |         amount = bound(amount, 1 days, 700 days);
 15 |     |         uint tau = HyperTau(address(__hyper__)).computeCurrentTau(__poolId__);
 16 |     |         ctx.customWarp(block.timestamp + tau + amount);
 17 |     |     }
 18 |     | }
 19 |     | 
 20 |     | interface HyperTau {
 21 |     |     function computeCurrentTau(uint64 poolId) external view returns (uint);
 22 |     | }
 23 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/TestE2EInvariant.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./setup/TestE2ESetup.sol";
   5 |     | import "./setup/TestInvariantSetup.sol";
   6 |     | 
   7 |     | import {InvariantAllocateUnallocate} from "./InvariantAllocateUnallocate.sol";
   8 |     | import {InvariantFundDraw} from "./InvariantFundDraw.sol";
   9 |     | import {InvariantDeposit} from "./InvariantDeposit.sol";
  10 |     | import {InvariantSendTokens} from "./InvariantSendTokens.sol";
  11 |     | import {InvariantWarper} from "./InvariantWarper.sol";
  12 |     | import {InvariantCreatePool} from "./InvariantCreatePool.sol";
  13 |     | 
  14 |     | bytes32 constant SLOT_LOCKED = bytes32(uint(5));
  15 |     | 
  16 |     | /**
  17 |     |  * @dev Most important test suite, verifies the critical invariants of Hyper.
  18 |     |  *
  19 |     |  * Invariant 1. balanceOf >= getReserve for all tokens.
  20 |     |  * Invariant 2. AccountSystem.settled == true.
  21 |     |  * Invariant 3. AccountSystem.prepared == false.
  22 |     |  * Invariant 4. (balanceOf(asset), balanceOf(quote)) >= hyper.getVirtualReserves, for all pools.
  23 |     |  * Invariant 5. ∑ hyper.positions(owner, poolId).freeLiquidity == hyper.pools(poolId).liquidity, for all pools.
  24 |     |  */
  25 |     | contract TestE2EInvariant is TestInvariantSetup, TestE2ESetup {
  26 |     |     InvariantAllocateUnallocate internal _allocateUnallocate;
  27 |     |     InvariantFundDraw internal _fundDraw;
  28 |     |     InvariantDeposit internal _deposit;
  29 |     |     InvariantSendTokens internal _sendTokens;
  30 |     |     InvariantWarper internal _warper;
  31 |     |     InvariantCreatePool internal _createPool;
  32 |     | 
  33 |     |     uint64[] public __poolIds__;
  34 |     | 
  35 |     |     function setUp() public override {
  36 |     |         super.setUp();
  37 |     | 
  38 |     |         (address hyper, address asset, address quote) = (address(__hyper__), address(__asset__), address(__quote__));
  39 |     | 
  40 |     |         _allocateUnallocate = new InvariantAllocateUnallocate(hyper, asset, quote);
  41 |     |         _fundDraw = new InvariantFundDraw(hyper, asset, quote);
  42 |     |         _deposit = new InvariantDeposit(hyper, asset, quote);
  43 |     |         _sendTokens = new InvariantSendTokens(hyper, asset, quote);
  44 |     |         _warper = new InvariantWarper(hyper, asset, quote);
  45 |     |         _createPool = new InvariantCreatePool(hyper, asset, quote);
  46 |     | 
  47 |     |         addTargetContract(address(_allocateUnallocate));
  48 |     |         addTargetContract(address(_fundDraw));
  49 |     |         addTargetContract(address(_deposit));
  50 |     |         addTargetContract(address(_sendTokens));
  51 |     |         addTargetContract(address(_warper));
  52 |     |         addTargetContract(address(_createPool));
  53 |     | 
  54 |     |         __users__.push(address(_allocateUnallocate));
  55 |     |         __users__.push(address(_fundDraw));
  56 |     |         __users__.push(address(_deposit));
  57 |     |         __users__.push(address(_sendTokens));
  58 |     |         __users__.push(address(_warper));
  59 |     |         __users__.push(address(_createPool));
  60 |     | 
  61 |     |         addPoolId(__poolId__);
  62 |     |     }
  63 |     | 
  64 |     |     function invariant_assert_pools_created() public {
  65 |     |         assertTrue(__poolIds__.length > 0);
  66 |     |     }
  67 |     | 
  68 |     |     function invariant_asset_balance_gte_reserves() public {
  69 |     |         (uint reserve, uint physical, ) = getBalances(address(__asset__));
  70 |     |         assertTrue(physical >= reserve, "invariant-asset-physical-balance");
  71 |     |     }
  72 |     | 
  73 |     |     function invariant_quote_balance_gte_reserves() public {
  74 |     |         (uint reserve, uint physical, ) = getBalances(address(__quote__));
  75 |     |         assertTrue(physical >= reserve, "invariant-quote-physical-balance");
  76 |     |     }
  77 |     | 
  78 |     |     function invariant_account_settled() public {
  79 |     |         (, bool settled) = __hyper__.__account__();
  80 |     |         assertTrue(settled, "invariant-settled");
  81 |     |     }
  82 |     | 
  83 |     |     function invariant_account_prepared() public {
  84 |     |         (bool prepared, ) = __hyper__.__account__();
  85 |     |         assertTrue(!prepared, "invariant-prepared");
  86 |     |     }
  87 |     | 
  88 |     |     function invariant_virtual_pool_asset_reserves() public {
  89 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
  90 |     | 
  91 |     |         if (pool.liquidity > 0) {
  92 |     |             (uint dAsset, ) = __hyper__.getVirtualReserves(__poolId__);
  93 |     |             uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));
  94 |     |             assertTrue(bAsset >= dAsset, "invariant-virtual-reserves-asset");
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     function invariant_virtual_pool_quote_reserves() public {
  99 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 100 |     | 
 101 |     |         if (pool.liquidity > 0) {
 102 |     |             (, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);
 103 |     |             uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));
 104 |     |             assertTrue(bQuote >= dQuote, "invariant-virtual-reserves-quote");
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     function invariant_liquidity_sum() public {
 109 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 110 |     | 
 111 |     |         uint sum;
 112 |     |         for (uint i; i != __users__.length; ++i) {
 113 |     |             HyperPosition memory pos = getPosition(address(__hyper__), __users__[i], __poolId__);
 114 |     |             sum += pos.freeLiquidity;
 115 |     |         }
 116 |     | 
 117 |     |         assertTrue(sum == pool.liquidity, "invariant-liquidity-sum");
 118 |     |     }
 119 |     | 
 120 |     |     function invariant_reentrancy() public {
 121 |     |         bytes32 locked = vm.load(address(__hyper__), SLOT_LOCKED);
 122 |     |         assertEq(uint(locked), 1, "invariant-locked");
 123 |     | 
 124 |     |         uint balance = address(__hyper__).balance;
 125 |     |         assertEq(balance, 0, "invariant-ether");
 126 |     |     }
 127 |     | 
 128 |     |     function getBalances(address token) internal view returns (uint reserve, uint physical, uint balances) {
 129 |     |         reserve = getReserve(address(__hyper__), token);
 130 |     |         physical = getPhysicalBalance(address(__hyper__), token);
 131 |     |         balances = getBalanceSum(address(__hyper__), token, __users__);
 132 |     |     }
 133 |     | 
 134 |     |     function addPoolId(uint64 poolId) public {
 135 |     |         assertTrue(poolId != 0, "zero poolId");
 136 |     |         __poolIds__.push(poolId);
 137 |     |     }
 138 |     | 
 139 |     |     function getRandomUser(uint id) public returns (address) {
 140 |     |         assertTrue(__users__.length > 0);
 141 |     |         uint index = id % __users__.length;
 142 |     |         address user = __users__[index];
 143 |     |         return user;
 144 |     |     }
 145 |     | 
 146 |     |     function getRandomPoolId(uint id) public returns (uint64) {
 147 |     |         assertTrue(__poolIds__.length > 0);
 148 |     |         uint index = id % __poolIds__.length;
 149 |     |         uint64 poolId = __poolIds__[index];
 150 |     |         return poolId;
 151 |     |     }
 152 |     | }
 153 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/TestInvariantBasic.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "./setup/TestInvariantSetup.sol";
  6 |     | 
  7 |     | /** @dev Example invariant testing contract, for reference only. https://github.com/foundry-rs/foundry/pull/1572#discussion_r869737535 */
  8 |     | contract InvariantBreaker is Test {
  9 |     |     bool public flag0 = true;
 10 |     |     bool public flag1 = true;
 11 |     | 
 12 |     |     function set0(int val) public returns (bool) {
 13 |     |         if (val % 100 == 0) flag0 = false;
 14 |     |         return flag0;
 15 |     |     }
 16 |     | 
 17 |     |     function set1(int val) public returns (bool) {
 18 |     |         if (val % 10 == 0 && !flag0) flag1 = false;
 19 |     |         return flag1;
 20 |     |     }
 21 |     | }
 22 |     | 
 23 |     | /** @dev Example invariant test. Always fails! */
 24 |     | contract TestInvariantBasic is TestInvariantSetup, Test {
 25 |     |     InvariantBreaker inv;
 26 |     | 
 27 |     |     function setUp() public {
 28 |     |         inv = new InvariantBreaker();
 29 |     |         addTargetContract(address(inv));
 30 |     |     }
 31 |     | 
 32 |     |     function invariant_neverFalse() public view {
 33 |     |         // note: uncomment to test invariant testing
 34 |     |         // require(inv.flag1());
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/setup/InvariantTargetContract.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "test/helpers/HelperHyperView.sol";
  6 |     | import {HyperPool, HyperPosition, HyperTimeOverride, TestERC20} from "test/helpers/HyperTestOverrides.sol";
  7 |     | 
  8 |     | interface Context {
  9 |     |     function users() external view returns (address[] memory);
 10 |     | 
 11 |     |     function getRandomPoolId(uint id) external view returns (uint64);
 12 |     | 
 13 |     |     function setPoolId(uint64 poolId) external;
 14 |     | 
 15 |     |     function addPoolId(uint64 poolId) external;
 16 |     | 
 17 |     |     function customWarp(uint time) external;
 18 |     | 
 19 |     |     function getRandomUser(uint id) external view returns (address);
 20 |     | 
 21 |     |     function __weth__() external view returns (TestERC20);
 22 |     | 
 23 |     |     function __asset__() external view returns (TestERC20);
 24 |     | 
 25 |     |     function __quote__() external view returns (TestERC20);
 26 |     | }
 27 |     | 
 28 |     | /** @dev Target contract must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */
 29 |     | contract InvariantTargetContract is HelperHyperView, Test {
 30 |     |     Context ctx;
 31 |     | 
 32 |     |     uint64 public __poolId__ = 0x0000010000000001;
 33 |     |     HyperTimeOverride public __hyper__; // Actual contract
 34 |     |     TestERC20 public __quote__;
 35 |     |     TestERC20 public __asset__;
 36 |     | 
 37 |     |     constructor(address hyper_, address asset_, address quote_) {
 38 |     |         ctx = Context(msg.sender);
 39 |     |         __hyper__ = HyperTimeOverride(payable(hyper_));
 40 |     |         __asset__ = TestERC20(asset_);
 41 |     |         __quote__ = TestERC20(quote_);
 42 |     | 
 43 |     |         __asset__.approve(hyper_, type(uint).max);
 44 |     |         __quote__.approve(hyper_, type(uint).max);
 45 |     |     }
 46 |     | 
 47 |     |     /** @dev Uses the initialized context for the getState function. */
 48 |     |     function getState() internal view returns (HyperState memory) {
 49 |     |         return getState(address(__hyper__), __poolId__, address(this), ctx.users());
 50 |     |     }
 51 |     | 
 52 |     |     function setPoolId(uint64 poolId) internal {
 53 |     |         ctx.setPoolId(poolId); // TODO: duplicating for now...
 54 |     | 
 55 |     |         HyperPair memory pair = getPair(address(__hyper__), Processor.decodePairIdFromPoolId(poolId));
 56 |     |         __asset__ = TestERC20(pair.tokenAsset);
 57 |     |         __quote__ = TestERC20(pair.tokenQuote);
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/setup/TestE2ESetup.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "solmate/tokens/WETH.sol";
   5 |     | import "contracts/HyperLib.sol";
   6 |     | import "contracts/libraries/Price.sol";
   7 |     | 
   8 |     | import "forge-std/Test.sol";
   9 |     | import {TestERC20, HyperTimeOverride, FixedPointMathLib} from "test/helpers/HyperTestOverrides.sol";
  10 |     | 
  11 |     | import "test/helpers/HelperHyperActions.sol";
  12 |     | import "test/helpers/HelperHyperInvariants.sol";
  13 |     | import "test/helpers/HelperHyperProfiles.sol";
  14 |     | import "test/helpers/HelperHyperView.sol";
  15 |     | 
  16 |     | uint constant STARTING_BALANCE = 0;
  17 |     | 
  18 |     | contract Helpers is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView {}
  19 |     | 
  20 |     | /** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */
  21 |     | contract TestE2ESetup is Helpers, Test {
  22 |     |     using FixedPointMathLib for uint256;
  23 |     |     using FixedPointMathLib for int256;
  24 |     | 
  25 |     |     // ===== Global Variables ===== //
  26 |     |     uint64 public __poolId__ = 0x0000010000000001;
  27 |     |     address[] public __users__;
  28 |     | 
  29 |     |     WETH public __weth__;
  30 |     |     TestERC20 public __quote__;
  31 |     |     TestERC20 public __asset__;
  32 |     |     HyperTimeOverride public __hyper__; // Actual contract
  33 |     | 
  34 |     |     // ===== Set up ===== //
  35 |     | 
  36 |     |     function setUp() public virtual {
  37 |     |         initContracts();
  38 |     |         initUsers();
  39 |     |         initScenarios();
  40 |     |         initPrerequisites();
  41 |     |         afterSetUp();
  42 |     |     }
  43 |     | 
  44 |     |     /** @dev Requires tokens to be spent and spenders to be approved. */
  45 |     |     function initPrerequisites() internal {
  46 |     |         approveTokens();
  47 |     |     }
  48 |     | 
  49 |     |     /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */
  50 |     |     receive() external payable {
  51 |     |         receiveOverride();
  52 |     |     }
  53 |     | 
  54 |     |     /** @dev Uses the initialized context for the getState function. */
  55 |     |     function getState() internal view virtual returns (HyperState memory) {
  56 |     |         return getState(address(__hyper__), __poolId__, address(this), __users__);
  57 |     |     }
  58 |     | 
  59 |     |     /** @dev Hook to run after test setup. */
  60 |     |     function afterSetUp() public virtual {}
  61 |     | 
  62 |     |     /** @dev Replace receive ether logic. */
  63 |     |     function receiveOverride() public virtual {}
  64 |     | 
  65 |     |     // ===== Contracts Context ===== //
  66 |     |     function initContracts() internal {
  67 |     |         __weth__ = new WETH();
  68 |     |         __hyper__ = new HyperTimeOverride(address(__weth__));
  69 |     |         __quote__ = new TestERC20("USD Coin", "USDC", 6);
  70 |     |         __asset__ = new TestERC20("18 Decimals", "18DEC", 18);
  71 |     | 
  72 |     |         setLabels();
  73 |     |     }
  74 |     | 
  75 |     |     function setLabels() internal {
  76 |     |         vm.label(address(this), "Self");
  77 |     |         vm.label(address(__weth__), "Weth");
  78 |     |         vm.label(address(__hyper__), "HyperTimeOverride");
  79 |     |         vm.label(address(__quote__), "QuoteToken");
  80 |     |         vm.label(address(__asset__), "AssetToken");
  81 |     |     }
  82 |     | 
  83 |     |     // ===== Users ===== //
  84 |     | 
  85 |     |     function users() public view virtual returns (address[] memory) {
  86 |     |         return __users__;
  87 |     |     }
  88 |     | 
  89 |     |     function initUsers() internal {
  90 |     |         address self = address(this);
  91 |     |         address alicent = address(0x0001);
  92 |     |         address boba = address(0x0002);
  93 |     | 
  94 |     |         addUser(self, "Self");
  95 |     |         addUser(alicent, "Alicent");
  96 |     |         addUser(boba, "Boba");
  97 |     |     }
  98 |     | 
  99 |     |     function addUser(address user, string memory label) public {
 100 |     |         vm.label(user, label);
 101 |     |         __users__.push(user);
 102 |     |     }
 103 |     | 
 104 |     |     // ===== Test Scenarios ===== //
 105 |     | 
 106 |     |     function initScenarios() internal {
 107 |     |         __hyper__.setTimestamp(uint128(block.timestamp)); // Important
 108 |     |         // Create default pool
 109 |     |         bytes memory data = createPool(
 110 |     |             address(__asset__),
 111 |     |             address(__quote__),
 112 |     |             address(0),
 113 |     |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
 114 |     |             uint16(1e4 - DEFAULT_GAMMA),
 115 |     |             uint16(DEFAULT_SIGMA),
 116 |     |             uint16(DEFAULT_DURATION_DAYS),
 117 |     |             DEFAULT_JIT,
 118 |     |             DEFAULT_TICK,
 119 |     |             DEFAULT_PRICE
 120 |     |         );
 121 |     | 
 122 |     |         (bool success, ) = address(__hyper__).call(data);
 123 |     |         assertTrue(success, "create pool call failed");
 124 |     |     }
 125 |     | 
 126 |     |     // ===== Utils ===== //
 127 |     | 
 128 |     |     /** @dev Does not include weth. */
 129 |     |     function approveTokens() internal {
 130 |     |         for (uint z; z != __users__.length; ++z) {
 131 |     |             vm.prank(__users__[z]); // Sets caller
 132 |     |             __asset__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 133 |     |             __quote__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /** @dev Does not include weth. */
 138 |     |     function fundUsers(uint deltaAsset, uint deltaQuote) internal {
 139 |     |         for (uint i; i != __users__.length; ++i) {
 140 |     |             deal(address(__asset__), __users__[i], deltaAsset); // TODO: Use regular ERC20, since we can deal.
 141 |     |             deal(address(__quote__), __users__[i], deltaQuote); // TODO: Use regular ERC20, since we can deal.
 142 |     |         }
 143 |     |     }
 144 |     | 
 145 |     |     function customWarp(uint time) public virtual {
 146 |     |         vm.warp(time);
 147 |     |         __hyper__.setTimestamp(uint128(time));
 148 |     |     }
 149 |     | 
 150 |     |     event SetNewPoolId(uint64);
 151 |     | 
 152 |     |     /** @dev Sets the pool id and assets in TestE2ESetup state. Affects all tests! */
 153 |     |     function setPoolId(uint64 poolId) public {
 154 |     |         __poolId__ = poolId;
 155 |     | 
 156 |     |         HyperPair memory pair = getPair(address(__hyper__), Enigma.decodePairIdFromPoolId(poolId));
 157 |     |         __asset__ = TestERC20(pair.tokenAsset);
 158 |     |         __quote__ = TestERC20(pair.tokenQuote);
 159 |     | 
 160 |     |         emit SetNewPoolId(poolId);
 161 |     |     }
 162 |     | }
 163 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/E2E/setup/TestInvariantSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /** @dev Invariant tests must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */
  5 |     | contract TestInvariantSetup {
  6 |     |     address[] private _targetContracts;
  7 |     | 
  8 |     |     function addTargetContract(address target) internal {
  9 |     |         _targetContracts.push(target);
 10 |     |     }
 11 |     | 
 12 |     |     function targetContracts() public view returns (address[] memory) {
 13 |     |         require(_targetContracts.length != uint(0), "no-target-contracts");
 14 |     |         return _targetContracts;
 15 |     |     }
 16 |     | }
 17 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/crytic/TestE2EHyper.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /* import "./setup/TestEchidnaSetup.sol"; */
  5 |     | 
  6 |     | contract TestE2EHyper {
  7 |     |     event AssertionFailed();
  8 |     | 
  9 |     |     function echidna_jit_policy() public returns (bool) {
 10 |     |         if (5 != 4) emit AssertionFailed();
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/crytic/setup/TestEchidnaSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "solmate/tokens/WETH.sol";
  5 |     | import "contracts/libraries/Price.sol";
  6 |     | import "contracts/HyperLib.sol";
  7 |     | import "test/helpers/HelperHyperActions.sol";
  8 |     | import "test/helpers/HelperHyperInvariants.sol";
  9 |     | import "test/helpers/HelperHyperProfiles.sol";
 10 |     | import "test/helpers/HelperHyperView.sol";
 11 |     | 
 12 |     | import {TestERC20, HyperTimeOverride} from "test/helpers/HyperTestOverrides.sol";
 13 |     | 
 14 |     | uint constant STARTING_BALANCE = 4000e18;
 15 |     | 
 16 |     | contract TestEchidnaEvents {
 17 |     |     event AssertionFailed();
 18 |     |     event AssertionFailed(uint);
 19 |     |     event AssertionFailed(uint, uint);
 20 |     |     event AssertionFailed(uint, uint, uint);
 21 |     |     event AssertionFailed(string, uint);
 22 |     |     event AssertionFailed(bytes);
 23 |     |     event AssertionFailed(int);
 24 |     | }
 25 |     | 
 26 |     | contract Addresses {
 27 |     |     User public __user__;
 28 |     |     WETH public __weth__;
 29 |     |     HyperTimeOverride public __hyper__;
 30 |     |     TestERC20 public __usdc__;
 31 |     |     TestERC20 public __token_18__;
 32 |     | }
 33 |     | 
 34 |     | contract User {}
 35 |     | 
 36 |     | contract TestEchidnaSetup is
 37 |     |     TestEchidnaEvents,
 38 |     |     HelperHyperActions,
 39 |     |     HelperHyperInvariants,
 40 |     |     HelperHyperProfiles,
 41 |     |     HelperHyperView,
 42 |     |     Addresses
 43 |     | {
 44 |     |     using FixedPointMathLib for uint256;
 45 |     |     using FixedPointMathLib for int256;
 46 |     | 
 47 |     |     constructor() {
 48 |     |         initContracts();
 49 |     |         fundUsers();
 50 |     |         approveSpenders();
 51 |     | 
 52 |     |         afterSetUp();
 53 |     |     }
 54 |     | 
 55 |     |     function initContracts() internal {
 56 |     |         __user__ = new User();
 57 |     |         __weth__ = new WETH();
 58 |     | 
 59 |     |         // --- Hyper Contracts --- //
 60 |     |         __hyper__ = new HyperTimeOverride(address(__weth__));
 61 |     | 
 62 |     |         // --- Tokens --- //
 63 |     |         __usdc__ = new TestERC20("USD Coin", "USDC", 6);
 64 |     |         __token_18__ = new TestERC20("18 Decimals", "18DEC", 18);
 65 |     |     }
 66 |     | 
 67 |     |     /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */
 68 |     |     receive() external payable {
 69 |     |         receiveOverride();
 70 |     |     }
 71 |     | 
 72 |     |     /** @dev Hook to run after test setup. */
 73 |     |     function afterSetUp() public virtual {}
 74 |     | 
 75 |     |     /** @dev Hook to implement to handle receive differently. */
 76 |     |     function receiveOverride() public virtual {}
 77 |     | 
 78 |     |     function deal(TestERC20 token, address to, uint amount) internal {
 79 |     |         token.mint(to, amount);
 80 |     |     }
 81 |     | 
 82 |     |     /** @dev Does not include weth. */
 83 |     |     function fundUsers() internal {
 84 |     |         deal(__token_18__, address(__user__), STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.
 85 |     |         deal(__usdc__, address(__user__), STARTING_BALANCE);
 86 |     |     }
 87 |     | 
 88 |     |     /** @dev Does not include weth. */
 89 |     |     function approveSpenders() internal {
 90 |     |         TestERC20(__token_18__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 91 |     |         TestERC20(__usdc__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 92 |     |     }
 93 |     | }
 94 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperAllocate.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {HyperPool, JUST_IN_TIME_LIQUIDITY_POLICY, HyperPair} from "contracts/HyperLib.sol";
   5 |     | import "./setup/TestHyperSetup.sol";
   6 |     | 
   7 |     | struct Amounts {
   8 |     |     uint expectedDelta0;
   9 |     |     uint expectedDelta1;
  10 |     |     uint computedDelta0;
  11 |     |     uint computedDelta1;
  12 |     |     uint prevReserve0;
  13 |     |     uint prevReserve1;
  14 |     |     uint postReserve0;
  15 |     |     uint postReserve1;
  16 |     | }
  17 |     | 
  18 |     | contract TestHyperAllocate is TestHyperSetup {
  19 |     |     using SafeCastLib for uint;
  20 |     | 
  21 |     |     Amounts _amounts;
  22 |     | 
  23 |     |     modifier afterTest() {
  24 |     |         _;
  25 |     |         delete _amounts;
  26 |     |     }
  27 |     | 
  28 |     |     function testAllocateNonStandardDecimals() public postTestInvariantChecks afterTest {
  29 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  30 |     |         assertTrue(pool.lastTimestamp != 0, "pool-created");
  31 |     | 
  32 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40));
  33 |     | 
  34 |     |         address hyper = address(__hyperTestingContract__);
  35 |     |         uint64 poolId = defaultScenario.poolId;
  36 |     | 
  37 |     |         uint128 liquidity = DEFAULT_LIQUIDITY;
  38 |     |         (_amounts.computedDelta0, _amounts.computedDelta1) = pool.getAmountsWad(); // one liquidity wad
  39 |     | 
  40 |     |         (_amounts.expectedDelta0, _amounts.expectedDelta1) = (
  41 |     |             Assembly.scaleFromWadDown(_amounts.computedDelta0, pair.decimalsAsset),
  42 |     |             Assembly.scaleFromWadDown(_amounts.computedDelta1, pair.decimalsQuote)
  43 |     |         );
  44 |     | 
  45 |     |         (_amounts.prevReserve0, _amounts.prevReserve1) = (
  46 |     |             getReserve(hyper, pair.tokenAsset),
  47 |     |             getReserve(hyper, pair.tokenQuote)
  48 |     |         );
  49 |     | 
  50 |     |         __hyperTestingContract__.allocate(poolId, liquidity);
  51 |     | 
  52 |     |         (_amounts.postReserve0, _amounts.postReserve1) = (
  53 |     |             getReserve(hyper, pair.tokenAsset),
  54 |     |             getReserve(hyper, pair.tokenQuote)
  55 |     |         );
  56 |     | 
  57 |     |         assertEq(_amounts.postReserve0, _amounts.prevReserve0 + _amounts.expectedDelta0, "asset-reserves");
  58 |     |         assertEq(_amounts.postReserve1, _amounts.prevReserve1 + _amounts.expectedDelta1, "quote-reserves");
  59 |     |     }
  60 |     | 
  61 |     |     function testAllocateFull() public postTestInvariantChecks {
  62 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  63 |     |         assertTrue(pool.lastTimestamp != 0, "pool-created");
  64 |     | 
  65 |     |         uint256 price = pool.lastPrice;
  66 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId));
  67 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40));
  68 |     | 
  69 |     |         uint tau = pool.lastTau(); // seconds
  70 |     | 
  71 |     |         uint256 theoreticalR2 = Price.getXWithPrice(
  72 |     |             price,
  73 |     |             Price.computePriceWithTick(pool.params.maxTick),
  74 |     |             pool.params.volatility,
  75 |     |             tau
  76 |     |         );
  77 |     | 
  78 |     |         uint delLiquidity = 4_000_000;
  79 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, delLiquidity);
  80 |     | 
  81 |     |         uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  82 |     |         uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  83 |     |         assertTrue(globalR1 > 0);
  84 |     |         assertTrue(globalR2 > 0);
  85 |     |         assertApproxEqAbs(globalR2, (theoreticalR2 * delLiquidity) / 1e18, 1, "asset-reserve-theoretic");
  86 |     |     }
  87 |     | 
  88 |     |     function testAllocateUseMax() public postTestInvariantChecks {
  89 |     |         uint assetBalance = defaultScenario.asset.balanceOf(address(this));
  90 |     |         uint quoteBalance = defaultScenario.quote.balanceOf(address(this));
  91 |     |         uint maxLiquidity = __hyperTestingContract__.getMaxLiquidity(
  92 |     |             defaultScenario.poolId,
  93 |     |             assetBalance,
  94 |     |             quoteBalance
  95 |     |         );
  96 |     | 
  97 |     |         (address asset, address quote) = (address(defaultScenario.asset), address(defaultScenario.quote));
  98 |     | 
  99 |     |         __hyperTestingContract__.fund(asset, assetBalance);
 100 |     |         __hyperTestingContract__.fund(quote, quoteBalance);
 101 |     | 
 102 |     |         assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);
 103 |     |         quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);
 104 |     |         maxLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, assetBalance, quoteBalance);
 105 |     | 
 106 |     |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getLiquidityDeltas(
 107 |     |             defaultScenario.poolId,
 108 |     |             -int128(maxLiquidity.safeCastTo128()) // negative delta rounds output amounts down
 109 |     |         );
 110 |     | 
 111 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, type(uint256).max);
 112 |     | 
 113 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 114 |     |         assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);
 115 |     |         quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);
 116 |     |         (uint128 reserveAsset, uint128 reserveQuote) = pool.getVirtualReserves();
 117 |     | 
 118 |     |         assertEq(deltaAsset, reserveAsset, "delta-asset");
 119 |     |         assertEq(deltaQuote, reserveQuote, "delta-quote");
 120 |     |         assertEq(maxLiquidity, pool.liquidity, "delta-liquidity");
 121 |     |         assertEq(
 122 |     |             assetBalance,
 123 |     |             getReserve(address(__hyperTestingContract__), asset) - (deltaAsset + 1), // round up
 124 |     |             "asset-balance"
 125 |     |         );
 126 |     |         assertEq(
 127 |     |             quoteBalance,
 128 |     |             getReserve(address(__hyperTestingContract__), quote) - (deltaQuote + 1), // round up
 129 |     |             "quote-balance"
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * note: Found an interesting overflow bug!
 135 |     |      * 170141183460469231731687303715884105728 is equal to 2^127.
 136 |     |      * Values between 2^127 and 2^128 will break allocate, because of the implicit conversion
 137 |     |      * from uint128 to int128 causing an overflow.
 138 |     |      */
 139 |     |     function testFuzzAllocateUnallocateSuccessful(uint128 deltaLiquidity) public postTestInvariantChecks {
 140 |     |         vm.assume(deltaLiquidity != 0);
 141 |     |         vm.assume(deltaLiquidity < (2 ** 126 - 1e36)); // note: if its 2^127, it could still overflow since liquidity is multiplied against token amounts in getLiquidityDeltas.
 142 |     |         // TODO: Add use max flag support.
 143 |     |         _assertAllocate(deltaLiquidity);
 144 |     |     }
 145 |     | 
 146 |     |     /** @dev ALlocates then asserts the invariants. */
 147 |     |     function _assertAllocate(uint128 deltaLiquidity) internal {
 148 |     |         // Preconditions
 149 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 150 |     |         assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
 151 |     |         assertTrue(pool.lastPrice != 0, "Pool not created with a price");
 152 |     | 
 153 |     |         (uint expectedDeltaAsset, uint expectedDeltaQuote) = __hyperTestingContract__.getLiquidityDeltas(
 154 |     |             defaultScenario.poolId,
 155 |     |             int128(deltaLiquidity)
 156 |     |         );
 157 |     |         defaultScenario.asset.mint(address(this), expectedDeltaAsset);
 158 |     |         defaultScenario.quote.mint(address(this), expectedDeltaQuote);
 159 |     | 
 160 |     |         // Execution
 161 |     |         HyperState memory prev = getState();
 162 |     |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.allocate(defaultScenario.poolId, deltaLiquidity);
 163 |     |         HyperState memory post = getState();
 164 |     | 
 165 |     |         // Postconditions
 166 |     |         {
 167 |     |             assertEq(deltaAsset, expectedDeltaAsset, "pool-delta-asset");
 168 |     |             assertEq(deltaQuote, expectedDeltaQuote, "pool-delta-quote");
 169 |     |             assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, "pool-total-liquidity");
 170 |     |             assertTrue(post.totalPoolLiquidity > prev.totalPoolLiquidity, "pool-liquidity-increases");
 171 |     |             assertEq(
 172 |     |                 post.callerPositionLiquidity,
 173 |     |                 prev.callerPositionLiquidity + deltaLiquidity,
 174 |     |                 "position-liquidity-increases"
 175 |     |             );
 176 |     | 
 177 |     |             assertEq(post.reserveAsset, prev.reserveAsset + expectedDeltaAsset, "reserve-asset");
 178 |     |             assertEq(post.reserveQuote, prev.reserveQuote + expectedDeltaQuote, "reserve-quote");
 179 |     |             assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + expectedDeltaAsset, "physical-asset");
 180 |     |             assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + expectedDeltaQuote, "physical-quote");
 181 |     | 
 182 |     |             uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;
 183 |     |             uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;
 184 |     |             assertTrue(feeDelta0 == feeDelta1, "asset-growth");
 185 |     | 
 186 |     |             uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;
 187 |     |             uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;
 188 |     |             assertTrue(feeDelta2 == feeDelta3, "quote-growth");
 189 |     |         }
 190 |     | 
 191 |     |         // Unallocate
 192 |     |         customWarp(block.timestamp + JUST_IN_TIME_LIQUIDITY_POLICY); // TODO: make this public function.
 193 |     |         (uint unallocatedAsset, uint unallocatedQuote) = __hyperTestingContract__.unallocate(
 194 |     |             defaultScenario.poolId,
 195 |     |             deltaLiquidity
 196 |     |         );
 197 |     | 
 198 |     |         // remove all credits, since unallocate will increase this amount.
 199 |     |         __hyperTestingContract__.draw(
 200 |     |             address(defaultScenario.asset),
 201 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),
 202 |     |             address(this)
 203 |     |         );
 204 |     |         __hyperTestingContract__.draw(
 205 |     |             address(defaultScenario.quote),
 206 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),
 207 |     |             address(this)
 208 |     |         );
 209 |     | 
 210 |     |         {
 211 |     |             HyperState memory end = getState();
 212 |     |             assertApproxEqAbs(unallocatedAsset, deltaAsset, 1, "unallocate-delta-asset");
 213 |     |             assertApproxEqAbs(unallocatedQuote, deltaQuote, 1, "unallocate-delta-quote");
 214 |     |             assertApproxEqAbs(end.reserveAsset, prev.reserveAsset, 1, "unallocate-reserve-asset");
 215 |     |             assertApproxEqAbs(end.reserveQuote, prev.reserveQuote, 1, "unallocate-reserve-quote");
 216 |     |             assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity, "unallocate-pool-liquidity");
 217 |     |             assertEq(end.totalPositionLiquidity, prev.totalPositionLiquidity, "unallocate-sum-position-liquidity");
 218 |     |             assertEq(end.callerPositionLiquidity, prev.callerPositionLiquidity, "unallocate-caller-position-liquidity");
 219 |     |         }
 220 |     |     }
 221 |     | }
 222 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperClaim.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./setup/TestHyperSetup.sol";
   5 |     | 
   6 |     | contract TestHyperClaim is TestHyperSetup {
   7 |     |     using FixedPointMathLib for uint;
   8 |     | 
   9 |     |     function testClaimNoPosition_reverts() public {
  10 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPosition.selector, address(this), defaultScenario.poolId));
  11 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, 0, 0);
  12 |     |     }
  13 |     | 
  14 |     |     function testClaim_successful_PositionOwedAmountsReturnsZero() public {
  15 |     |         basicAllocate();
  16 |     |         basicSwap();
  17 |     | 
  18 |     |         // Has asset tokens owed
  19 |     | 
  20 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  21 |     |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
  22 |     |         uint tokensOwed = Assembly
  23 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)
  24 |     |             .mulWadDown(pool.liquidity);
  25 |     | 
  26 |     |         uint pre = _getBalance(hx(), address(this), (defaultScenario.asset));
  27 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);
  28 |     |         uint post = _getBalance(hx(), address(this), (defaultScenario.asset));
  29 |     | 
  30 |     |         pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  31 |     | 
  32 |     |         assertEq(post, pre + tokensOwed, "delta");
  33 |     |         assertEq(post, tokensOwed, "claimed-bal");
  34 |     |         assertEq(pos.tokensOwedAsset, 0, "zero-claim");
  35 |     |     }
  36 |     | 
  37 |     |     function testClaimGetBalanceReturnsFeeAmount_asset() public {
  38 |     |         basicAllocate();
  39 |     |         basicSwap();
  40 |     | 
  41 |     |         // Has asset tokens owed
  42 |     | 
  43 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  44 |     |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
  45 |     |         uint tokensOwed = Assembly
  46 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)
  47 |     |             .mulWadDown(pool.liquidity);
  48 |     | 
  49 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);
  50 |     |         uint post = _getBalance(hx(), address(this), (defaultScenario.asset));
  51 |     |         assertEq(post, tokensOwed, "claimed-bal");
  52 |     |     }
  53 |     | 
  54 |     |     function testClaimGetBalanceReturnsFeeAmount_quote() public {
  55 |     |         basicAllocate();
  56 |     |         basicSwapQuoteIn();
  57 |     | 
  58 |     |         // Has asset tokens owed
  59 |     | 
  60 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  61 |     |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
  62 |     |         uint tokensOwed = Assembly
  63 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalQuote, pos.feeGrowthQuoteLast)
  64 |     |             .mulWadDown(pool.liquidity);
  65 |     | 
  66 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, 0, tokensOwed);
  67 |     |         uint post = _getBalance(hx(), address(this), defaultScenario.quote);
  68 |     |         assertEq(post, tokensOwed, "claimed-bal");
  69 |     |     }
  70 |     | 
  71 |     |     function testClaimGetBalanceReturnsFeeAmount_reward() public {
  72 |     |         // Rewards only accrue to controlled pools
  73 |     |         createControlledPool();
  74 |     | 
  75 |     |         TestScenario memory scenario = scenarios[1]; // assumes it was the second one...
  76 |     |         assertTrue(
  77 |     |             keccak256(abi.encodePacked(scenario.label)) == keccak256(abi.encodePacked("Controlled")),
  78 |     |             "not controlled?"
  79 |     |         );
  80 |     | 
  81 |     |         __weth__.deposit{value: 0.01 ether}();
  82 |     |         __weth__.approve(address(__hyperTestingContract__), type(uint256).max);
  83 |     | 
  84 |     |         _alloc(scenario.poolId);
  85 |     |         __hyperTestingContract__.stake(scenario.poolId, 1 ether);
  86 |     | 
  87 |     |         // pass some time for staking
  88 |     |         customWarp(__hyperTestingContract__.timestamp() + 1);
  89 |     | 
  90 |     |         _swap(scenario.poolId); // swapping in controlled pool should increment reward token (weth)
  91 |     | 
  92 |     |         // Has asset tokens owed
  93 |     | 
  94 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), scenario.poolId);
  95 |     |         HyperPool memory pool = _getPool(hs(), scenario.poolId);
  96 |     |         uint tokensOwed = Assembly
  97 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalReward, pos.feeGrowthRewardLast)
  98 |     |             .mulWadDown(pool.liquidity);
  99 |     | 
 100 |     |         __hyperTestingContract__.claim(scenario.poolId, 0, 0);
 101 |     |         uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 102 |     |         assertEq(post, tokensOwed, "claimed-bal");
 103 |     |     }
 104 |     | 
 105 |     |     function testClaimCreditsAssetBalance() public postTestInvariantChecks {
 106 |     |         basicAllocate();
 107 |     |         basicSwap(); // swaps __asset__ in, so pays fees in asset.
 108 |     | 
 109 |     |         HyperPool memory pool = defaultPool();
 110 |     |         uint real0 = _getReserve(hx(), defaultScenario.asset);
 111 |     |         uint real1 = _getReserve(hx(), defaultScenario.quote);
 112 |     |         (uint res0, uint res1) = pool.getVirtualReserves();
 113 |     | 
 114 |     |         basicUnallocate();
 115 |     |         maxDraw(); // zero balance to ensure we aren't paying ourself.
 116 |     | 
 117 |     |         HyperPosition memory pos = defaultPosition();
 118 |     |         pool = defaultPool();
 119 |     |         (uint fee0, uint fee1) = (pos.tokensOwedAsset, pos.tokensOwedQuote);
 120 |     |         assertTrue(fee0 > 0, "fee0-zero");
 121 |     |         assertTrue(pool.liquidity == 0, "non-zero-liquidity");
 122 |     | 
 123 |     |         // Claim
 124 |     |         uint prevReserve = _getReserve(hx(), defaultScenario.asset);
 125 |     |         uint prevBalance = _getBalance(hx(), address(this), defaultScenario.asset);
 126 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, fee0, fee1);
 127 |     |         uint nextBalance = _getBalance(hx(), address(this), defaultScenario.asset);
 128 |     | 
 129 |     |         maxDraw(); // clear reserve
 130 |     | 
 131 |     |         uint nextReserve = _getReserve(hx(), defaultScenario.asset);
 132 |     |         assertTrue(nextBalance > prevBalance, "no fee claimed");
 133 |     |         assertTrue(nextReserve < prevReserve, "no fee removed");
 134 |     |     }
 135 |     | }
 136 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperCreate.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "forge-std/Vm.sol";
   5 |     | import "./setup/TestHyperSetup.sol";
   6 |     | 
   7 |     | contract TestHyperCreate is TestHyperSetup {
   8 |     |     function testFuzzCreatePol(
   9 |     |         uint16 priorityFee,
  10 |     |         uint16 fee,
  11 |     |         uint16 jit,
  12 |     |         uint16 duration,
  13 |     |         uint16 volatility,
  14 |     |         int24 maxTick,
  15 |     |         uint128 price
  16 |     |     ) public {
  17 |     |         fee = uint16(bound(fee, MIN_FEE, MAX_FEE));
  18 |     |         priorityFee = uint16(bound(priorityFee, 1, fee));
  19 |     |         jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));
  20 |     |         duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));
  21 |     |         volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
  22 |     |         maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));
  23 |     |         vm.assume(price > 0);
  24 |     |         vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.
  25 |     |         bytes memory data = Enigma.encodeCreatePool(
  26 |     |             uint24(1),
  27 |     |             address(this),
  28 |     |             priorityFee,
  29 |     |             fee,
  30 |     |             volatility,
  31 |     |             duration,
  32 |     |             jit,
  33 |     |             maxTick,
  34 |     |             price
  35 |     |         );
  36 |     |         bool success = __revertCatcher__.process(data);
  37 |     |         uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(2));
  38 |     | 
  39 |     |         HyperPool memory pool = _getPool(hs(), poolId);
  40 |     |         HyperCurve memory actual = pool.params;
  41 |     | 
  42 |     |         assertTrue(success, "fuzz create pool failed");
  43 |     |         assertEq(pool.controller, address(this), "controller");
  44 |     |         assertEq(actual.priorityFee, priorityFee, "priorityFee");
  45 |     |         assertEq(actual.fee, fee, "fee");
  46 |     |         assertEq(actual.volatility, volatility, "volatility");
  47 |     |         assertEq(actual.duration, duration, "duration");
  48 |     |         assertEq(actual.jit, jit, "jit");
  49 |     |         assertEq(actual.maxTick, maxTick, "maxTick");
  50 |     |     }
  51 |     | 
  52 |     |     function testCreatePoolNonControlledHasDefaultJit() public {
  53 |     |         __hyperTestingContract__.setJitPolicy(JUST_IN_TIME_LIQUIDITY_POLICY); // for assertion below.
  54 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(0), 1, 100, 100, 100, 100, 100, 100);
  55 |     |         bool success = __revertCatcher__.process(data);
  56 |     |         assertTrue(success, "create failed");
  57 |     |         assertEq(_getPool(hs(), defaultScenario.poolId + 1).params.jit, JUST_IN_TIME_LIQUIDITY_POLICY);
  58 |     |     }
  59 |     | 
  60 |     |     function testCreatePoolZeroPriceReverts() public {
  61 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 1, 1, 1, 1, 1, 1, 0);
  62 |     |         vm.expectRevert(ZeroPrice.selector);
  63 |     |         bool success = __revertCatcher__.process(data);
  64 |     |         assertTrue(!success);
  65 |     |     }
  66 |     | 
  67 |     |     function testCreatePoolPriorityFeeInvalidFeeReverts() public {
  68 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 0, 1, 1, 1, 1, 1, 1);
  69 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, 0));
  70 |     |         bool success = __revertCatcher__.process(data);
  71 |     |         assertTrue(!success);
  72 |     |     }
  73 |     | 
  74 |     |     function testFuzzChangeParameters(
  75 |     |         uint16 priorityFee,
  76 |     |         uint16 fee,
  77 |     |         uint16 jit,
  78 |     |         uint16 duration,
  79 |     |         uint16 volatility,
  80 |     |         int24 maxTick
  81 |     |     ) public {
  82 |     |         uint64 poolId = _createDefaultPool();
  83 |     |         fee = uint16(bound(fee, MIN_FEE, MAX_FEE));
  84 |     |         priorityFee = uint16(bound(priorityFee, 1, fee));
  85 |     |         jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));
  86 |     |         duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));
  87 |     |         volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
  88 |     |         maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));
  89 |     |         vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.
  90 |     | 
  91 |     |         __hyperTestingContract__.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
  92 |     |         HyperCurve memory actual = _getPool(hs(), poolId).params;
  93 |     |         assertEq(actual.priorityFee, priorityFee, "priorityFee");
  94 |     |         assertEq(actual.fee, fee, "fee");
  95 |     |         assertEq(actual.volatility, volatility, "volatility");
  96 |     |         assertEq(actual.duration, duration, "duration");
  97 |     |         assertEq(actual.jit, jit, "jit");
  98 |     |         assertEq(actual.maxTick, maxTick, "maxTick");
  99 |     |     }
 100 |     | 
 101 |     |     function testChangeParametersPriorityFeeSuccess() public {
 102 |     |         uint64 poolId = _createDefaultPool();
 103 |     |         uint16 prev = _getPool(hs(), poolId).params.priorityFee;
 104 |     |         __hyperTestingContract__.changeParameters(poolId, DEFAULT_FEE + 10, DEFAULT_FEE + 20, 0, 0, 0, 0);
 105 |     |         uint16 post = _getPool(hs(), poolId).params.priorityFee;
 106 |     |         assertEq(post, prev + 10, "priority-fee-change");
 107 |     |     }
 108 |     | 
 109 |     |     function testChangeParametersSuccessKeepsPoolSolvency() public {
 110 |     |         uint64 poolId = _createDefaultPool();
 111 |     |         (uint prev0, uint prev1) = __hyperTestingContract__.getVirtualReserves(poolId);
 112 |     |         __hyperTestingContract__.changeParameters(
 113 |     |             poolId,
 114 |     |             0,
 115 |     |             0,
 116 |     |             DEFAULT_VOLATILITY * 2,
 117 |     |             DEFAULT_DURATION + 30,
 118 |     |             0,
 119 |     |             DEFAULT_TICK + 500
 120 |     |         );
 121 |     |         (uint post0, uint post1) = __hyperTestingContract__.getVirtualReserves(poolId);
 122 |     |         assertEq(post0, prev0, "virtual-asset-balance-altered");
 123 |     |         assertEq(post1, prev1, "virtual-quote-balance-altered");
 124 |     |     }
 125 |     | 
 126 |     |     function testChangeParametersNotControllerReverts() public {
 127 |     |         uint64 poolId = _createDefaultPool();
 128 |     |         uint16 failureArg = 1;
 129 |     |         vm.expectRevert(NotController.selector);
 130 |     |         vm.prank(address(0x0006));
 131 |     |         __hyperTestingContract__.changeParameters(
 132 |     |             poolId,
 133 |     |             DEFAULT_FEE,
 134 |     |             DEFAULT_FEE,
 135 |     |             DEFAULT_VOLATILITY,
 136 |     |             DEFAULT_DURATION,
 137 |     |             DEFAULT_JIT,
 138 |     |             DEFAULT_TICK
 139 |     |         );
 140 |     |     }
 141 |     | 
 142 |     |     function testChangeParametersInvalidVolatilityReverts() public {
 143 |     |         uint64 poolId = _createDefaultPool();
 144 |     |         uint16 failureArg = 1;
 145 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));
 146 |     |         __hyperTestingContract__.changeParameters(
 147 |     |             poolId,
 148 |     |             DEFAULT_FEE,
 149 |     |             DEFAULT_FEE,
 150 |     |             1,
 151 |     |             DEFAULT_DURATION,
 152 |     |             DEFAULT_JIT,
 153 |     |             DEFAULT_TICK
 154 |     |         );
 155 |     |     }
 156 |     | 
 157 |     |     function testChangeParametersInvalidDurationReverts() public {
 158 |     |         uint64 poolId = _createDefaultPool();
 159 |     |         uint16 failureArg = 5000;
 160 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDuration.selector, failureArg));
 161 |     |         __hyperTestingContract__.changeParameters(
 162 |     |             poolId,
 163 |     |             DEFAULT_FEE,
 164 |     |             DEFAULT_FEE,
 165 |     |             DEFAULT_VOLATILITY,
 166 |     |             5000,
 167 |     |             DEFAULT_JIT,
 168 |     |             DEFAULT_TICK
 169 |     |         );
 170 |     |     }
 171 |     | 
 172 |     |     function testChangeParametersInvalidTickReverts() public {
 173 |     |         uint64 poolId = _createDefaultPool();
 174 |     |         int24 failureArg = 1000000;
 175 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidTick.selector, uint24(failureArg)));
 176 |     |         __hyperTestingContract__.changeParameters(
 177 |     |             poolId,
 178 |     |             DEFAULT_FEE,
 179 |     |             DEFAULT_FEE,
 180 |     |             DEFAULT_VOLATILITY,
 181 |     |             DEFAULT_DURATION,
 182 |     |             DEFAULT_JIT,
 183 |     |             failureArg
 184 |     |         );
 185 |     |     }
 186 |     | 
 187 |     |     function testChangeParametersInvalidJitReverts() public {
 188 |     |         uint64 poolId = _createDefaultPool();
 189 |     |         uint16 failureArg = 10000;
 190 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidJit.selector, failureArg));
 191 |     |         __hyperTestingContract__.changeParameters(
 192 |     |             poolId,
 193 |     |             DEFAULT_FEE,
 194 |     |             DEFAULT_FEE,
 195 |     |             DEFAULT_VOLATILITY,
 196 |     |             DEFAULT_DURATION,
 197 |     |             failureArg,
 198 |     |             DEFAULT_TICK
 199 |     |         );
 200 |     |     }
 201 |     | 
 202 |     |     function testChangeParametersPriorityFeeAboveFeeReverts() public {
 203 |     |         uint64 poolId = _createDefaultPool();
 204 |     |         HyperCurve memory curve = HyperCurve({
 205 |     |             maxTick: DEFAULT_TICK,
 206 |     |             jit: DEFAULT_JIT,
 207 |     |             fee: 55,
 208 |     |             duration: DEFAULT_DURATION,
 209 |     |             volatility: DEFAULT_VOLATILITY,
 210 |     |             priorityFee: 56,
 211 |     |             createdAt: 100000000
 212 |     |         });
 213 |     |         (, bytes memory revertData) = curve.checkParameters();
 214 |     |         assertEq(revertData, abi.encodeWithSelector(InvalidFee.selector, curve.priorityFee));
 215 |     |         vm.expectRevert(revertData);
 216 |     |         __hyperTestingContract__.changeParameters(
 217 |     |             poolId,
 218 |     |             curve.priorityFee,
 219 |     |             curve.fee,
 220 |     |             curve.volatility,
 221 |     |             curve.duration,
 222 |     |             curve.jit,
 223 |     |             curve.maxTick
 224 |     |         );
 225 |     |     }
 226 |     | 
 227 |     |     function testChangeParametersInvalidFeeReverts() public {
 228 |     |         uint16 failureArg = 2 ** 16 - 10;
 229 |     |         uint64 poolId = _createDefaultPool();
 230 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
 231 |     |         __hyperTestingContract__.changeParameters(
 232 |     |             poolId,
 233 |     |             DEFAULT_FEE,
 234 |     |             failureArg,
 235 |     |             DEFAULT_VOLATILITY,
 236 |     |             DEFAULT_DURATION,
 237 |     |             DEFAULT_JIT,
 238 |     |             DEFAULT_TICK
 239 |     |         );
 240 |     |     }
 241 |     | 
 242 |     |     function _createDefaultPool() internal returns (uint64 poolId) {
 243 |     |         uint24 pairId = uint24(1);
 244 |     |         bytes memory createData = Enigma.encodeCreatePool(
 245 |     |             pairId, // assumes first pair is created
 246 |     |             address(this),
 247 |     |             DEFAULT_FEE,
 248 |     |             DEFAULT_FEE,
 249 |     |             DEFAULT_VOLATILITY,
 250 |     |             DEFAULT_DURATION,
 251 |     |             DEFAULT_JIT,
 252 |     |             DEFAULT_TICK,
 253 |     |             DEFAULT_PRICE
 254 |     |         );
 255 |     |         bool success = __revertCatcher__.process(createData);
 256 |     |         assertTrue(success, "did not create pool");
 257 |     | 
 258 |     |         poolId = Enigma.encodePoolId(pairId, true, uint32(2));
 259 |     |     }
 260 |     | }
 261 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperDeploy.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Vm.sol";
  5 |     | import "./setup/TestHyperSetup.sol";
  6 |     | 
  7 |     | contract TestHyperDeploy is TestHyperSetup {
  8 |     |     event Deployed(string, address);
  9 |     | 
 10 |     |     function testDeploy() public {
 11 |     |         address weth = address(new WETH());
 12 |     |         address usdc = address(new TestERC20("USDC", "USD Coin", 6));
 13 |     |         Hyper hyper = new Hyper(weth);
 14 |     | 
 15 |     |         emit Deployed("Deployed weth at: ", weth);
 16 |     |         emit Deployed("Deployed hyper at: ", address(hyper));
 17 |     |         emit Deployed("Deployed usdc at: ", usdc);
 18 |     | 
 19 |     |         assertEq(hyper.WETH(), weth, "weth address");
 20 |     |         (, bool settled) = hyper.__account__();
 21 |     |         assertTrue(settled, "settled");
 22 |     |         // todo: fix version
 23 |     |         //assertTrue(bytes32(abi.encodePacked(hyper.VERSION())) == bytes32(abi.encodePacked("beta-v0.0.1")));
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperDeposit.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Vm.sol";
  5 |     | import "./setup/TestHyperSetup.sol";
  6 |     | 
  7 |     | contract TestHyperDeposit is TestHyperSetup {
  8 |     |     function testDepositMsgValueZero_reverts() public {
  9 |     |         vm.expectRevert(ZeroValue.selector);
 10 |     |         __hyperTestingContract__.deposit{value: 0}();
 11 |     |     }
 12 |     | 
 13 |     |     function testDepositWethTotalSupplyReturnsMsgValue() public {
 14 |     |         uint pre = __weth__.totalSupply();
 15 |     |         __hyperTestingContract__.deposit{value: 100}();
 16 |     |         uint post = __weth__.totalSupply();
 17 |     |         uint delta = post - pre;
 18 |     |         assertEq(post, 100, "ts");
 19 |     |         assertEq(delta, 100, "del");
 20 |     |     }
 21 |     | 
 22 |     |     function testDepositCallersBalanceReturnsMsgValue() public {
 23 |     |         uint pre = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 24 |     |         __hyperTestingContract__.deposit{value: 100}();
 25 |     |         uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 26 |     |         uint delta = post - pre;
 27 |     |         assertEq(post, 100, "ts");
 28 |     |         assertEq(delta, 100, "del");
 29 |     |     }
 30 |     | 
 31 |     |     function testDepositEtherBalanceReturnsZero() public {
 32 |     |         __hyperTestingContract__.deposit{value: 100}();
 33 |     |         uint actual = address(__hyperTestingContract__).balance;
 34 |     |         assertEq(actual, 0, "balance");
 35 |     |     }
 36 |     | 
 37 |     |     function testDepositWethReservesReturnsMsgValue() public {
 38 |     |         uint pre = getReserve(address(__hyperTestingContract__), address(__weth__));
 39 |     |         __hyperTestingContract__.deposit{value: 100}();
 40 |     |         uint post = getReserve(address(__hyperTestingContract__), address(__weth__));
 41 |     |         uint delta = post - pre;
 42 |     |         assertEq(post, 100, "ts");
 43 |     |         assertEq(delta, 100, "del");
 44 |     |     }
 45 |     | 
 46 |     |     function testDepositBalanceOfWethReturnsMsgValue() public {
 47 |     |         __hyperTestingContract__.deposit{value: 100}();
 48 |     |         uint actual = __weth__.balanceOf(address(__hyperTestingContract__));
 49 |     |         assertEq(actual, 100, "balance");
 50 |     |     }
 51 |     | 
 52 |     |     function testDepositWrapsEther() public postTestInvariantChecks {
 53 |     |         uint prevWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));
 54 |     |         uint prevBalance = address(this).balance;
 55 |     |         __hyperTestingContract__.deposit{value: 4000}();
 56 |     |         uint nextBalance = address(this).balance;
 57 |     |         uint nextWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));
 58 |     | 
 59 |     |         assertTrue(nextBalance < prevBalance);
 60 |     |         assertTrue(nextWethBalance > prevWethBalance);
 61 |     |     }
 62 |     | 
 63 |     |     function testDepositIncreasesUserBalance() public postTestInvariantChecks {
 64 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 65 |     |         __hyperTestingContract__.deposit{value: 4000}();
 66 |     |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 67 |     | 
 68 |     |         assertTrue(nextBalance > prevBalance, "balance-not-increased");
 69 |     |     }
 70 |     | 
 71 |     |     event Deposit(address indexed account, uint amount);
 72 |     | 
 73 |     |     function testDepositWrapsEther_emit_Deposit() public {
 74 |     |         vm.expectEmit(true, true, false, true, address(__hyperTestingContract__));
 75 |     |         emit Deposit(address(this), 4000);
 76 |     |         __hyperTestingContract__.deposit{value: 4000}();
 77 |     |     }
 78 |     | 
 79 |     |     event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);
 80 |     | 
 81 |     |     function testDepositWrapsEther_emit_IncreaseUserBalance() public {
 82 |     |         vm.expectEmit(true, true, true, true, address(__hyperTestingContract__));
 83 |     |         emit IncreaseUserBalance(address(this), address(__weth__), 4000);
 84 |     |         __hyperTestingContract__.deposit{value: 4000}();
 85 |     |     }
 86 |     | }
 87 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperDraw.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | 
  6 |     | contract TestHyperDraw is TestHyperSetup {
  7 |     |     function testDrawReducesBalance() public postTestInvariantChecks {
  8 |     |         // Fund the account
  9 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);
 10 |     | 
 11 |     |         // Draw
 12 |     |         uint prevReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
 13 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 14 |     |         __hyperTestingContract__.draw(address(defaultScenario.asset), 4000, address(this));
 15 |     |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 16 |     |         uint nextReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
 17 |     | 
 18 |     |         assertTrue(nextBalance == 0);
 19 |     |         assertTrue(nextBalance < prevBalance);
 20 |     |         assertTrue(nextReserve < prevReserve);
 21 |     |     }
 22 |     | 
 23 |     |     function testDrawRevertsWithDrawBalance() public {
 24 |     |         vm.expectRevert(DrawBalance.selector);
 25 |     |         __hyperTestingContract__.draw(address(defaultScenario.asset), 1e18, address(this));
 26 |     |     }
 27 |     | 
 28 |     |     function testDrawFromWethTransfersEther() public postTestInvariantChecks {
 29 |     |         // First fund the account
 30 |     |         __hyperTestingContract__.deposit{value: 4000}();
 31 |     | 
 32 |     |         // Draw
 33 |     |         uint prevBalance = address(this).balance;
 34 |     |         __hyperTestingContract__.draw(address(__weth__), 4000, address(this));
 35 |     |         uint nextBalance = address(this).balance;
 36 |     | 
 37 |     |         assertTrue(nextBalance > prevBalance);
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperFund.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | 
  6 |     | contract TestHyperFund is TestHyperSetup {
  7 |     |     function testFundIncreasesBalance() public postTestInvariantChecks {
  8 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  9 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);
 10 |     |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 11 |     | 
 12 |     |         assertTrue(nextBalance > prevBalance, "increase-internal-bal");
 13 |     |     }
 14 |     | 
 15 |     |     function testFuzzFundDrawSuccessful(uint128 amount) public {
 16 |     |         vm.assume(amount > 0);
 17 |     |         _assertFundDraw(amount);
 18 |     |     }
 19 |     | 
 20 |     |     function _assertFundDraw(uint amount) internal {
 21 |     |         // Preconditions
 22 |     |         defaultScenario.asset.approve(address(__hyperTestingContract__), amount);
 23 |     |         deal(address(defaultScenario.asset), address(this), amount);
 24 |     | 
 25 |     |         // Execution
 26 |     |         uint preBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 27 |     |         HyperState memory prev = getState();
 28 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), amount);
 29 |     |         HyperState memory post = getState();
 30 |     |         uint postBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 31 |     | 
 32 |     |         // Post conditions
 33 |     |         assertTrue(postBal > preBal, "bal-increase");
 34 |     |         assertEq(postBal, preBal + amount, "bal-increase-exact");
 35 |     |         assertEq(post.reserveAsset, prev.reserveAsset + amount, "reserve-increase");
 36 |     |         assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + amount, "physical-increase");
 37 |     |         assertEq(post.totalBalanceAsset, prev.totalBalanceAsset + amount, "total-bal-increase");
 38 |     | 
 39 |     |         __hyperTestingContract__.draw(address(defaultScenario.asset), amount, address(this));
 40 |     |         HyperState memory end = getState();
 41 |     |         uint endBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 42 |     | 
 43 |     |         assertEq(endBal, preBal, "reverse-exact-bal");
 44 |     |         assertEq(end.reserveAsset, prev.reserveAsset, "reverse-exact-reserve");
 45 |     |         assertEq(end.physicalBalanceAsset, prev.physicalBalanceAsset, "reverse-exact-physical");
 46 |     |     }
 47 |     | }
 48 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperProcessing.t.sol
    1 |     | // SPDX-License-Identifier: UNLICENSED
    2 |     | pragma solidity 0.8.13;
    3 |     | 
    4 |     | import "contracts/HyperLib.sol" as HyperTypes;
    5 |     | import "./setup/TestHyperSetup.sol";
    6 |     | 
    7 |     | contract TestHyperProcessing is TestHyperSetup {
    8 |     |     using SafeCastLib for uint;
    9 |     | 
   10 |     |     function afterSetUp() public override {
   11 |     |         assertTrue(
   12 |     |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp != 0,
   13 |     |             "Pool not created"
   14 |     |         );
   15 |     |         assertTrue(
   16 |     |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick != 0,
   17 |     |             "Pool not initialized with price"
   18 |     |         );
   19 |     |         assertTrue(
   20 |     |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity == 0,
   21 |     |             "Pool initialized with liquidity"
   22 |     |         );
   23 |     |     }
   24 |     | 
   25 |     |     // ===== Getters ===== //
   26 |     | 
   27 |     |     function testGetAmounts() public {
   28 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
   29 |     |         HyperCurve memory curve = pool.params;
   30 |     |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getAmounts(defaultScenario.poolId);
   31 |     |         uint maxDelta = 0.001 ether; // 1ether = 100%, 0.001 ether = 0.10%
   32 |     |         assertApproxEqRel(
   33 |     |             deltaAsset,
   34 |     |             Assembly.scaleFromWadDown(DEFAULT_ASSET_RESERVE, pool.pair.decimalsAsset),
   35 |     |             maxDelta,
   36 |     |             "asset-reserve"
   37 |     |         ); // todo: fix default amounts
   38 |     |         assertApproxEqRel(
   39 |     |             deltaQuote,
   40 |     |             Assembly.scaleFromWadDown(DEFAULT_QUOTE_RESERVE, pool.pair.decimalsQuote),
   41 |     |             maxDelta,
   42 |     |             "quote-reserve"
   43 |     |         );
   44 |     |     }
   45 |     | 
   46 |     |     function testGetLiquidityMinted() public {
   47 |     |         uint deltaLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, 1, 1e19);
   48 |     |     }
   49 |     | 
   50 |     |     // ===== Enigma ===== //
   51 |     | 
   52 |     |     function testJumpProcessCreatesPair() public {
   53 |     |         bytes[] memory instructions = new bytes[](1);
   54 |     |         instructions[0] = (Enigma.encodeCreatePair(address(__token_8__), address(defaultScenario.quote)));
   55 |     |         bytes memory data = Enigma.encodeJumpInstruction(instructions);
   56 |     |         bool success = __revertCatcher__.jumpProcess(data);
   57 |     |         assertTrue(success);
   58 |     | 
   59 |     |         uint24 pairId = uint16(__hyperTestingContract__.getPairNonce());
   60 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);
   61 |     |         assertTrue(pair.tokenAsset != address(0));
   62 |     |         assertTrue(pair.tokenQuote != address(0));
   63 |     |     }
   64 |     | 
   65 |     |     function testProcessRevertsWithInvalidInstructionZeroOpcode() public {
   66 |     |         vm.expectRevert(InvalidInstruction.selector);
   67 |     |         __revertCatcher__.process(hex"00");
   68 |     |     }
   69 |     | 
   70 |     |     function testProcessRevertsWithInvalidInstruction() public {
   71 |     |         vm.expectRevert(InvalidInstruction.selector);
   72 |     |         __revertCatcher__.process(hex"44");
   73 |     |     }
   74 |     | 
   75 |     |     // ===== Effects ===== //
   76 |     | 
   77 |     |     // --- Swap --- //
   78 |     | 
   79 |     |     function testSwapExactInNonExistentPoolIdReverts() public {
   80 |     |         uint64 failureArg = uint64(0x01);
   81 |     |         bytes memory data = Enigma.encodeSwap(0, failureArg, 0x01, 0x01, 0x01, 0x01, 0);
   82 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
   83 |     |         bool success = __revertCatcher__.process(data);
   84 |     |         assertTrue(!success);
   85 |     |     }
   86 |     | 
   87 |     |     function testSwapExactInZeroSwapAmountReverts() public {
   88 |     |         uint128 failureArg = 0;
   89 |     |         bytes memory data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, failureArg, 0x01, 0x01, 0);
   90 |     |         vm.expectRevert(ZeroInput.selector);
   91 |     |         bool success = __revertCatcher__.process(data);
   92 |     |         assertTrue(!success);
   93 |     |     }
   94 |     | 
   95 |     |     function testSwapExactInPoolPriceUpdated() public postTestInvariantChecks {
   96 |     |         // Add liquidity first
   97 |     |         bytes memory data = Enigma.encodeAllocate(
   98 |     |             0,
   99 |     |             defaultScenario.poolId,
  100 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  101 |     |             0x01
  102 |     |         );
  103 |     |         bool success = __revertCatcher__.process(data);
  104 |     |         assertTrue(success);
  105 |     |         // move some time
  106 |     |         customWarp(block.timestamp + 1);
  107 |     | 
  108 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
  109 |     | 
  110 |     |         uint8 useMax = 0;
  111 |     |         uint8 direction = 0;
  112 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  113 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  114 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
  115 |     |         success = __revertCatcher__.process(data);
  116 |     |         assertTrue(success);
  117 |     | 
  118 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
  119 |     |         assertTrue(next != prev);
  120 |     |     }
  121 |     | 
  122 |     |     /* function testSwapExactInPoolSlotIndexUpdated() public {
  123 |     |         // Add liquidity first
  124 |     |         bytes memory data = Enigma.encodeAllocate(
  125 |     |             0,
  126 |     |             defaultScenario.poolId,
  127 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  128 |     |             0x01
  129 |     |         );
  130 |     |         bool success = __revertCatcher__.process(data);
  131 |     |         assertTrue(success);
  132 |     |         // move some time
  133 |     |         customWarp(block.timestamp + 1);
  134 |     | 
  135 |     |         int256 prev = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;
  136 |     | 
  137 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  138 |     |         data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x12, 0x02, 0x1f, 0x01, 0);
  139 |     |         success = __revertCatcher__.process(data);
  140 |     |         assertTrue(success);
  141 |     | 
  142 |     |         int256 next = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;
  143 |     |         assertTrue(next != prev);
  144 |     |     } */
  145 |     | 
  146 |     |     function testSwapUseMax() public postTestInvariantChecks {
  147 |     |         uint amount = type(uint256).max;
  148 |     |         uint limit = amount;
  149 |     |         // Add liquidity first
  150 |     |         bytes memory data = Enigma.encodeAllocate(
  151 |     |             0,
  152 |     |             defaultScenario.poolId,
  153 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  154 |     |             0x01
  155 |     |         );
  156 |     |         bool success = __revertCatcher__.process(data);
  157 |     |         assertTrue(success);
  158 |     | 
  159 |     |         // move some time
  160 |     |         customWarp(block.timestamp + 1);
  161 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  162 |     |         bool direction = true;
  163 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));
  164 |     | 
  165 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  166 |     |         assertTrue(next == prev);
  167 |     |     }
  168 |     | 
  169 |     |     function testSwapInQuote() public postTestInvariantChecks {
  170 |     |         uint limit = type(uint256).max;
  171 |     |         uint amount = 2222;
  172 |     |         // Add liquidity first
  173 |     |         bytes memory data = Enigma.encodeAllocate(
  174 |     |             0,
  175 |     |             defaultScenario.poolId,
  176 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  177 |     |             0x01
  178 |     |         );
  179 |     |         bool success = __revertCatcher__.process(data);
  180 |     |         assertTrue(success);
  181 |     | 
  182 |     |         // move some time
  183 |     |         customWarp(block.timestamp + 1);
  184 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  185 |     |         bool direction = false;
  186 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));
  187 |     | 
  188 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  189 |     |         assertTrue(next == prev);
  190 |     |     }
  191 |     | 
  192 |     |     function testSwapReverse() public {
  193 |     |         bool direction = true;
  194 |     |         uint limit = type(uint256).max;
  195 |     |         uint amount = 17e16;
  196 |     |         // Add liquidity first
  197 |     |         /* bytes memory data = Enigma.encodeAllocate(
  198 |     |             0,
  199 |     |             defaultScenario.poolId,
  200 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  201 |     |             0x01
  202 |     |         );
  203 |     |         bool success = __revertCatcher__.process(data);
  204 |     |         assertTrue(success); */
  205 |     |         allocatePool(address(__hyperTestingContract__), defaultScenario.poolId, 10e19);
  206 |     | 
  207 |     |         // deposit first
  208 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), amount);
  209 |     |         uint256 prev = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  210 |     | 
  211 |     |         (uint output, ) = __hyperTestingContract__.swap(
  212 |     |             defaultScenario.poolId,
  213 |     |             direction,
  214 |     |             amount,
  215 |     |             getMaxSwapLimit(direction)
  216 |     |         );
  217 |     |         direction = false;
  218 |     |         (uint input, ) = __hyperTestingContract__.swap(
  219 |     |             defaultScenario.poolId,
  220 |     |             direction,
  221 |     |             output,
  222 |     |             getMaxSwapLimit(direction)
  223 |     |         );
  224 |     | 
  225 |     |         uint256 next = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  226 |     |         assertTrue(next <= prev, "invalid-user-gained-balance");
  227 |     |         assertTrue(input < amount, "invalid-invariant-got-more-out");
  228 |     |     }
  229 |     | 
  230 |     |     function testSwapExpiredPoolReverts() public {
  231 |     |         uint limit = type(uint256).max;
  232 |     |         uint amount = 2222;
  233 |     |         // Add liquidity first
  234 |     |         bytes memory data = Enigma.encodeAllocate(
  235 |     |             0,
  236 |     |             defaultScenario.poolId,
  237 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  238 |     |             0x01
  239 |     |         );
  240 |     |         bool success = __revertCatcher__.process(data);
  241 |     |         assertTrue(success);
  242 |     | 
  243 |     |         // move some time beyond maturity
  244 |     |         customWarp(
  245 |     |             block.timestamp +
  246 |     |                 getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(
  247 |     |                     __hyperTestingContract__.timestamp()
  248 |     |                 ) +
  249 |     |                 1
  250 |     |         );
  251 |     | 
  252 |     |         vm.expectRevert(PoolExpired.selector);
  253 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, false, amount, limit);
  254 |     |     }
  255 |     | 
  256 |     |     function testSwapExactInPoolLiquidityUnchanged() public postTestInvariantChecks {
  257 |     |         // Add liquidity first
  258 |     |         bytes memory data = Enigma.encodeAllocate(
  259 |     |             0,
  260 |     |             defaultScenario.poolId,
  261 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  262 |     |             0x01
  263 |     |         );
  264 |     |         bool success = __revertCatcher__.process(data);
  265 |     |         assertTrue(success);
  266 |     |         // move some time
  267 |     |         customWarp(block.timestamp + 1);
  268 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  269 |     | 
  270 |     |         uint8 useMax = 0;
  271 |     |         uint8 direction = 0;
  272 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  273 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  274 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
  275 |     |         success = __revertCatcher__.process(data);
  276 |     |         assertTrue(success);
  277 |     | 
  278 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  279 |     |         assertTrue(next == prev);
  280 |     |     }
  281 |     | 
  282 |     |     function testSwapExactInPoolTimestampUpdated() public postTestInvariantChecks {
  283 |     |         // Add liquidity first
  284 |     |         bytes memory data = Enigma.encodeAllocate(
  285 |     |             0,
  286 |     |             defaultScenario.poolId,
  287 |     |             0x13, // 19 zeroes, so 10e19 liquidity, note: 0x0a amount breaks test? todo: handle case where insufficient liquidity
  288 |     |             0x01
  289 |     |         );
  290 |     |         bool success = __revertCatcher__.process(data);
  291 |     |         assertTrue(success);
  292 |     |         // move some time
  293 |     |         customWarp(block.timestamp + 1);
  294 |     | 
  295 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;
  296 |     |         uint8 useMax = 0;
  297 |     |         uint8 direction = 0;
  298 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  299 |     | 
  300 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  301 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
  302 |     |         success = __revertCatcher__.process(data);
  303 |     |         assertTrue(success);
  304 |     | 
  305 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;
  306 |     |         assertTrue(next != prev);
  307 |     |     }
  308 |     | 
  309 |     |     function testSwapExactInGlobalAssetBalanceIncreases() public postTestInvariantChecks {
  310 |     |         // Add liquidity first
  311 |     |         bytes memory data = Enigma.encodeAllocate(
  312 |     |             0,
  313 |     |             defaultScenario.poolId,
  314 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  315 |     |             0x01
  316 |     |         );
  317 |     |         bool success = __revertCatcher__.process(data);
  318 |     |         assertTrue(success);
  319 |     |         // move some time
  320 |     |         customWarp(block.timestamp + 1);
  321 |     | 
  322 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  323 |     | 
  324 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  325 |     |         uint8 useMax = 0;
  326 |     |         uint8 direction = 0;
  327 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  328 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
  329 |     |         success = __revertCatcher__.process(data);
  330 |     |         assertTrue(success);
  331 |     | 
  332 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  333 |     |         assertTrue(next > prev);
  334 |     |     }
  335 |     | 
  336 |     |     function testSwapExactInGlobalQuoteBalanceDecreases() public postTestInvariantChecks {
  337 |     |         // Add liquidity first
  338 |     |         bytes memory data = Enigma.encodeAllocate(
  339 |     |             0,
  340 |     |             defaultScenario.poolId,
  341 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  342 |     |             0x01
  343 |     |         );
  344 |     |         bool success = __revertCatcher__.process(data);
  345 |     |         assertTrue(success);
  346 |     |         // move some time
  347 |     |         customWarp(block.timestamp + 1);
  348 |     | 
  349 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  350 |     | 
  351 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  352 |     |         uint8 useMax = 0;
  353 |     |         uint8 direction = 0;
  354 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  355 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
  356 |     |         success = __revertCatcher__.process(data);
  357 |     |         assertTrue(success, "swap failed");
  358 |     | 
  359 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  360 |     |         assertTrue(next == prev, "reserves-changed");
  361 |     |     }
  362 |     | 
  363 |     |     // --- Allocate --- //
  364 |     | 
  365 |     |     function testAllocateNonExistentPoolIdReverts() public {
  366 |     |         uint64 failureArg = uint64(48);
  367 |     |         bytes memory data = Enigma.encodeAllocate(0, failureArg, 0x01, 0x01);
  368 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  369 |     |         bool success = __revertCatcher__.process(data);
  370 |     |         assertTrue(!success, "forwarder call failed");
  371 |     |     }
  372 |     | 
  373 |     |     function testAllocateZeroLiquidityReverts() public {
  374 |     |         uint8 failureArg = 0;
  375 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, 0x00, failureArg);
  376 |     |         vm.expectRevert(ZeroLiquidity.selector);
  377 |     |         bool success = __revertCatcher__.process(data);
  378 |     |         assertTrue(!success, "forwarder call failed");
  379 |     |     }
  380 |     | 
  381 |     |     function testProcessAllocateFull() public postTestInvariantChecks {
  382 |     |         uint256 price = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
  383 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), (defaultScenario.poolId));
  384 |     |         uint tau = getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(
  385 |     |             __hyperTestingContract__.timestamp()
  386 |     |         );
  387 |     |         uint strike = Price.computePriceWithTick(curve.maxTick);
  388 |     |         console.log(tau, strike, curve.volatility);
  389 |     |         uint256 theoreticalR2 = Price.getXWithPrice(price, strike, curve.volatility, tau);
  390 |     | 
  391 |     |         uint8 power = uint8(0x06); // 6 zeroes
  392 |     |         uint8 amount = uint8(0x04); // 4 with 6 zeroes = 4_000_000 wei
  393 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  394 |     | 
  395 |     |         __revertCatcher__.process(data);
  396 |     | 
  397 |     |         uint delLiquidity = 4_000_000;
  398 |     |         uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  399 |     |         uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  400 |     |         assertTrue(globalR1 > 0);
  401 |     |         assertTrue(globalR2 > 0);
  402 |     |         uint expected = (theoreticalR2 * delLiquidity) / 1e18;
  403 |     |         console.log("expected", expected);
  404 |     |         console.log("globalR2", globalR2);
  405 |     |         // todo: fix this test
  406 |     |         assertApproxEqAbs(globalR2, expected, 1e2, "asset-reserve-theoretic"); // todo: fix, should it be this far?
  407 |     |     }
  408 |     | 
  409 |     |     function testAllocatePositionTimestampUpdated() public postTestInvariantChecks {
  410 |     |         uint64 positionId = defaultScenario.poolId;
  411 |     | 
  412 |     |         uint256 prevPositionTimestamp = getPosition(
  413 |     |             address(__hyperTestingContract__),
  414 |     |             address(__revertCatcher__),
  415 |     |             positionId
  416 |     |         ).lastTimestamp;
  417 |     | 
  418 |     |         uint8 amount = 0x01;
  419 |     |         uint8 power = 0x01;
  420 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  421 |     |         bool success = __revertCatcher__.process(data);
  422 |     |         assertTrue(success, "forwarder call failed");
  423 |     | 
  424 |     |         uint256 nextPositionTimestamp = getPosition(
  425 |     |             address(__hyperTestingContract__),
  426 |     |             address(__revertCatcher__),
  427 |     |             positionId
  428 |     |         ).lastTimestamp;
  429 |     | 
  430 |     |         assertTrue(prevPositionTimestamp == 0);
  431 |     |         assertTrue(nextPositionTimestamp > prevPositionTimestamp && nextPositionTimestamp == block.timestamp);
  432 |     |     }
  433 |     | 
  434 |     |     function testAllocatePositionfreeLiquidityIncreases() public postTestInvariantChecks {
  435 |     |         uint64 positionId = defaultScenario.poolId;
  436 |     | 
  437 |     |         uint256 prevPositionfreeLiquidity = getPosition(
  438 |     |             address(__hyperTestingContract__),
  439 |     |             address(__revertCatcher__),
  440 |     |             positionId
  441 |     |         ).freeLiquidity;
  442 |     | 
  443 |     |         uint8 amount = 0x01;
  444 |     |         uint8 power = 0x01;
  445 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  446 |     |         bool success = __revertCatcher__.process(data);
  447 |     |         assertTrue(success, "forwarder call failed");
  448 |     | 
  449 |     |         uint256 nextPositionfreeLiquidity = getPosition(
  450 |     |             address(__hyperTestingContract__),
  451 |     |             address(__revertCatcher__),
  452 |     |             positionId
  453 |     |         ).freeLiquidity;
  454 |     | 
  455 |     |         assertTrue(prevPositionfreeLiquidity == 0);
  456 |     |         assertTrue(nextPositionfreeLiquidity > prevPositionfreeLiquidity);
  457 |     |     }
  458 |     | 
  459 |     |     function testAllocateGlobalAssetIncreases() public postTestInvariantChecks {
  460 |     |         uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  461 |     | 
  462 |     |         uint8 amount = 0x01;
  463 |     |         uint8 power = 0x01;
  464 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  465 |     |         bool success = __revertCatcher__.process(data);
  466 |     |         assertTrue(success, "forwarder call failed");
  467 |     | 
  468 |     |         uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  469 |     |         assertTrue(nextGlobal != 0, "next globalReserves is zero");
  470 |     |         assertTrue(nextGlobal > prevGlobal, "globalReserves did not change");
  471 |     |     }
  472 |     | 
  473 |     |     function testAllocateGlobalQuoteIncreases() public postTestInvariantChecks {
  474 |     |         uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  475 |     | 
  476 |     |         uint8 amount = 0x01;
  477 |     |         uint8 power = 0x01;
  478 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  479 |     |         bool success = __revertCatcher__.process(data);
  480 |     |         assertTrue(success, "forwarder call failed");
  481 |     | 
  482 |     |         uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  483 |     |         assertTrue(nextGlobal != 0, "next globalReserves is zero");
  484 |     |         assertTrue(nextGlobal > prevGlobal, "globalReserves did not change");
  485 |     |     }
  486 |     | 
  487 |     |     // --- Remove Liquidity --- //
  488 |     | 
  489 |     |     function testUnallocateZeroLiquidityReverts() public {
  490 |     |         bytes memory data = Enigma.encodeUnallocate(0, defaultScenario.poolId, 0x00, 0x00);
  491 |     |         vm.expectRevert(ZeroLiquidity.selector);
  492 |     |         bool success = __revertCatcher__.process(data);
  493 |     |         assertTrue(!success);
  494 |     |     }
  495 |     | 
  496 |     |     function testUnallocateNonExistentPoolReverts() public {
  497 |     |         uint64 failureArg = 42;
  498 |     |         bytes memory data = Enigma.encodeUnallocate(0, 42, 0x01, 0x01);
  499 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  500 |     |         bool success = __revertCatcher__.process(data);
  501 |     |         assertTrue(!success);
  502 |     |     }
  503 |     | 
  504 |     |     // needs a mutable pool, or a pool with a non-zero jit policy
  505 |     |     function testUnallocatePositionJitPolicyReverts() public postTestInvariantChecks {
  506 |     |         uint16 jit = 99;
  507 |     |         bytes memory createData = Enigma.encodeCreatePool(
  508 |     |             uint24(1), // pairId
  509 |     |             address(this), // controller
  510 |     |             DEFAULT_FEE,
  511 |     |             DEFAULT_FEE,
  512 |     |             uint16(DEFAULT_SIGMA),
  513 |     |             DEFAULT_DURATION_DAYS,
  514 |     |             jit,
  515 |     |             DEFAULT_TICK,
  516 |     |             DEFAULT_PRICE
  517 |     |         );
  518 |     | 
  519 |     |         bool success = __revertCatcher__.process(createData);
  520 |     |         assertTrue(success, "forwarder call failed");
  521 |     | 
  522 |     |         uint64 poolId = Enigma.encodePoolId(uint24(0x01), true, uint32(__hyperTestingContract__.getPoolNonce()));
  523 |     | 
  524 |     |         uint8 amount = 0x01;
  525 |     |         uint8 power = 0x01;
  526 |     |         bytes memory data = Enigma.encodeAllocate(0, poolId, power, amount);
  527 |     |         success = __revertCatcher__.process(data);
  528 |     |         assertTrue(success, "forwarder call failed");
  529 |     | 
  530 |     |         // Set the distance for the position by warping in time.
  531 |     |         uint256 distance = 22;
  532 |     |         uint256 warpTimestamp = block.timestamp + distance;
  533 |     |         customWarp(warpTimestamp);
  534 |     | 
  535 |     |         data = Enigma.encodeUnallocate(0, poolId, power, amount);
  536 |     | 
  537 |     |         vm.expectRevert(abi.encodeWithSelector(JitLiquidity.selector, distance));
  538 |     |         success = __revertCatcher__.process(data);
  539 |     |         assertTrue(!success, "Should not suceed in testUnllocatePositionJit");
  540 |     |     }
  541 |     | 
  542 |     |     function testUnallocatePositionTimestampUpdated() public postTestInvariantChecks {
  543 |     |         int24 hiTick = DEFAULT_TICK;
  544 |     |         int24 loTick = DEFAULT_TICK - 256;
  545 |     |         uint8 amount = 0x01;
  546 |     |         uint8 power = 0x01;
  547 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  548 |     |         bool success = __revertCatcher__.process(data);
  549 |     |         assertTrue(success, "forwarder call failed");
  550 |     | 
  551 |     |         uint64 positionId = defaultScenario.poolId;
  552 |     |         uint256 prevPositionTimestamp = getPosition(
  553 |     |             address(__hyperTestingContract__),
  554 |     |             address(__revertCatcher__),
  555 |     |             positionId
  556 |     |         ).lastTimestamp;
  557 |     | 
  558 |     |         uint256 warpTimestamp = block.timestamp + 1;
  559 |     |         customWarp(warpTimestamp);
  560 |     | 
  561 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  562 |     |         success = __revertCatcher__.process(data);
  563 |     | 
  564 |     |         uint256 nextPositionTimestamp = getPosition(
  565 |     |             address(__hyperTestingContract__),
  566 |     |             address(__revertCatcher__),
  567 |     |             positionId
  568 |     |         ).lastTimestamp;
  569 |     | 
  570 |     |         assertTrue(nextPositionTimestamp > prevPositionTimestamp && nextPositionTimestamp == warpTimestamp);
  571 |     |     }
  572 |     | 
  573 |     |     function testUnallocatePositionfreeLiquidityDecreases() public postTestInvariantChecks {
  574 |     |         int24 hiTick = DEFAULT_TICK;
  575 |     |         int24 loTick = DEFAULT_TICK - 256;
  576 |     |         uint8 amount = 0x01;
  577 |     |         uint8 power = 0x01;
  578 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  579 |     |         bool success = __revertCatcher__.process(data);
  580 |     |         assertTrue(success, "forwarder call failed");
  581 |     | 
  582 |     |         uint64 positionId = defaultScenario.poolId;
  583 |     |         uint256 prevPositionLiquidity = getPosition(
  584 |     |             address(__hyperTestingContract__),
  585 |     |             address(__revertCatcher__),
  586 |     |             positionId
  587 |     |         ).freeLiquidity;
  588 |     | 
  589 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  590 |     |         success = __revertCatcher__.process(data);
  591 |     | 
  592 |     |         uint256 nextPositionLiquidity = getPosition(
  593 |     |             address(__hyperTestingContract__),
  594 |     |             address(__revertCatcher__),
  595 |     |             positionId
  596 |     |         ).freeLiquidity;
  597 |     | 
  598 |     |         assertTrue(nextPositionLiquidity < prevPositionLiquidity);
  599 |     |     }
  600 |     | 
  601 |     |     function testUnallocateGlobalAssetDecreases() public postTestInvariantChecks {
  602 |     |         uint8 amount = 0x01;
  603 |     |         uint8 power = 0x05; // if this is low enough, it will revert because token amounts rounded down to zero.
  604 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  605 |     |         bool success = __revertCatcher__.process(data);
  606 |     |         assertTrue(success);
  607 |     | 
  608 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  609 |     | 
  610 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  611 |     |         success = __revertCatcher__.process(data);
  612 |     | 
  613 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  614 |     |         assertTrue(next == prev, "reserves-changed"); // unallocated amounts are credited to user
  615 |     |     }
  616 |     | 
  617 |     |     /// @dev IMPORTANT TEST. For low token decimals, be very aware of the amount of liquidity involved in each tx.
  618 |     |     function testUnallocateGlobalQuoteDecreases() public postTestInvariantChecks {
  619 |     |         uint8 amount = 0x01;
  620 |     |         uint8 power = 0x0c; // 1e12 liquidity
  621 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  622 |     |         bool success = __revertCatcher__.process(data);
  623 |     |         assertTrue(success);
  624 |     | 
  625 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  626 |     | 
  627 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  628 |     |         success = __revertCatcher__.process(data);
  629 |     | 
  630 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  631 |     |         assertTrue(next == prev, "reserves-changed"); // unallocated amounts are credited to user
  632 |     |     }
  633 |     | 
  634 |     |     // --- Stake Position --- //
  635 |     | 
  636 |     |     function testStakeExternalEpochIncrements() public {
  637 |     |         uint8 amount = 0x05;
  638 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, amount);
  639 |     | 
  640 |     |         uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  641 |     |             .stakeTimestamp;
  642 |     |         __hyperTestingContract__.stake(defaultScenario.poolId, amount);
  643 |     |         uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  644 |     |             .stakeTimestamp;
  645 |     | 
  646 |     |         assertTrue(nextId != prevId);
  647 |     |     }
  648 |     | 
  649 |     |     function testStakePositionStakedUpdated() public postTestInvariantChecks {
  650 |     |         int24 lo = DEFAULT_TICK - 256;
  651 |     |         int24 hi = DEFAULT_TICK;
  652 |     |         uint8 amount = 0x01;
  653 |     |         uint8 power = 0x01;
  654 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  655 |     |         bool success = __revertCatcher__.process(data);
  656 |     |         assertTrue(success);
  657 |     | 
  658 |     |         uint64 positionId = defaultScenario.poolId;
  659 |     | 
  660 |     |         bool prevPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
  661 |     |             .stakeTimestamp != 0;
  662 |     | 
  663 |     |         data = Enigma.encodeStakePosition(positionId, amount);
  664 |     |         success = __revertCatcher__.process(data);
  665 |     | 
  666 |     |         bool nextPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
  667 |     |             .stakeTimestamp != 0;
  668 |     | 
  669 |     |         assertTrue(nextPositionStaked != prevPositionStaked, "Position staked did not update.");
  670 |     |         assertTrue(nextPositionStaked, "Position staked is not true.");
  671 |     |     }
  672 |     | 
  673 |     |     function testStakePoolStakedLiquidityUpdated() public postTestInvariantChecks {
  674 |     |         int24 lo = DEFAULT_TICK - 256;
  675 |     |         int24 hi = DEFAULT_TICK;
  676 |     |         uint8 amount = 0x01;
  677 |     |         uint8 power = 0x01;
  678 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  679 |     |         bool success = __revertCatcher__.process(data);
  680 |     |         assertTrue(success);
  681 |     | 
  682 |     |         uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)
  683 |     |             .stakedLiquidity;
  684 |     | 
  685 |     |         uint64 positionId = defaultScenario.poolId;
  686 |     |         data = Enigma.encodeStakePosition(positionId, amount);
  687 |     |         success = __revertCatcher__.process(data);
  688 |     | 
  689 |     |         uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)
  690 |     |             .stakedLiquidity;
  691 |     | 
  692 |     |         if (
  693 |     |             lo <= getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick &&
  694 |     |             hi > getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick
  695 |     |         ) {
  696 |     |             assertTrue(nextPoolStakedLiquidity > prevPoolStakedLiquidity, "Pool staked liquidity did not increase.");
  697 |     |             assertTrue(
  698 |     |                 nextPoolStakedLiquidity ==
  699 |     |                     getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
  700 |     |                         .freeLiquidity,
  701 |     |                 "Pool staked liquidity not equal to liquidity of staked position."
  702 |     |             );
  703 |     |         } else {
  704 |     |             assertTrue(
  705 |     |                 nextPoolStakedLiquidity == prevPoolStakedLiquidity,
  706 |     |                 "Pool staked liquidity changed even though position staked out of range."
  707 |     |             );
  708 |     |         }
  709 |     |     }
  710 |     | 
  711 |     |     function testStakeNonExistentPoolIdReverts() public {
  712 |     |         uint64 failureArg = uint64(3214);
  713 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  714 |     |         __hyperTestingContract__.stake(failureArg, 100);
  715 |     |     }
  716 |     | 
  717 |     |     function testStakeZeroLiquidityRevertsWithInsufficientPosition() public {
  718 |     |         vm.expectRevert(abi.encodeWithSelector(InsufficientPosition.selector, defaultScenario.poolId));
  719 |     |         __hyperTestingContract__.stake(defaultScenario.poolId, 100);
  720 |     |     }
  721 |     | 
  722 |     |     // --- Unstake Position --- //
  723 |     | 
  724 |     |     function testUnstakeExternalEpochIncrements() public {
  725 |     |         uint8 amount = 0x05;
  726 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, amount);
  727 |     |         __hyperTestingContract__.stake(defaultScenario.poolId, amount);
  728 |     | 
  729 |     |         uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  730 |     |             .unstakeTimestamp;
  731 |     | 
  732 |     |         customWarp(prevId + 1);
  733 |     |         __hyperTestingContract__.unstake(defaultScenario.poolId, amount);
  734 |     |         uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  735 |     |             .unstakeTimestamp;
  736 |     | 
  737 |     |         // todo: add better tests
  738 |     |         //assertTrue(nextId != prevId);
  739 |     |     }
  740 |     | 
  741 |     |     function testUnstakePositionStakedUpdated() public postTestInvariantChecks {
  742 |     |         uint8 amount = 0x01;
  743 |     |         uint8 power = 0x0f;
  744 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  745 |     |         bool success = __revertCatcher__.process(data);
  746 |     |         assertTrue(success);
  747 |     | 
  748 |     |         uint128 stakeAmount = uint128(amount * 10 ** power);
  749 |     | 
  750 |     |         uint64 positionId = defaultScenario.poolId;
  751 |     |         data = Enigma.encodeStakePosition(positionId, stakeAmount);
  752 |     |         success = __revertCatcher__.process(data);
  753 |     | 
  754 |     |         HyperPosition memory pos = getPosition(
  755 |     |             address(__hyperTestingContract__),
  756 |     |             address(this),
  757 |     |             defaultScenario.poolId
  758 |     |         );
  759 |     | 
  760 |     |         // touch pool to update it so we know how much staked liquidity the position has
  761 |     |         uint8 useMax = 0;
  762 |     |         uint8 direction = 0;
  763 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  764 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x09, 0x01, 0x0, limit, direction);
  765 |     |         success = __revertCatcher__.process(data);
  766 |     | 
  767 |     |         HyperPosition memory revertCatcherPos = defaultRevertCatcherPosition();
  768 |     | 
  769 |     |         uint256 prevPositionStaked = getPosition(
  770 |     |             address(__hyperTestingContract__),
  771 |     |             address(__revertCatcher__),
  772 |     |             positionId
  773 |     |         ).unstakeTimestamp;
  774 |     | 
  775 |     |         uint prevStaked = revertCatcherPos.stakedLiquidity;
  776 |     | 
  777 |     |         data = Enigma.encodeUnstakePosition(positionId, stakeAmount);
  778 |     |         customWarp(prevPositionStaked + 1);
  779 |     |         success = __revertCatcher__.process(data);
  780 |     |         revertCatcherPos = defaultRevertCatcherPosition();
  781 |     | 
  782 |     |         uint256 nextPositionStaked = getPosition(
  783 |     |             address(__hyperTestingContract__),
  784 |     |             address(__revertCatcher__),
  785 |     |             positionId
  786 |     |         ).unstakeTimestamp;
  787 |     | 
  788 |     |         uint postStaked = revertCatcherPos.stakedLiquidity;
  789 |     |         assertEq(postStaked, prevStaked - stakeAmount, "stake-liquidity-decreases");
  790 |     |         assertTrue(postStaked < prevStaked, "stake-did-not-decrease");
  791 |     |         //assertTrue(nextPositionStaked != prevPositionStaked, "Position staked did not update.");
  792 |     |         //assertTrue(nextPositionStaked != 0, "Position staked is true.");
  793 |     |     }
  794 |     | 
  795 |     |     // note: some unintended side effects most likely from update/sync pool messing with price
  796 |     |     // it creates a discrepency in the contract where the contract holds more tokens than the sum
  797 |     |     // of all claims is entitled to.
  798 |     |     function testUnstakePoolStakedLiquidityUpdated() public postTestInvariantChecks {
  799 |     |         uint8 amount = 0x01;
  800 |     |         uint8 power = 0x0f;
  801 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  802 |     |         bool success = __revertCatcher__.process(data);
  803 |     |         assertTrue(success);
  804 |     | 
  805 |     |         uint64 positionId = defaultScenario.poolId;
  806 |     |         data = Enigma.encodeStakePosition(positionId, amount);
  807 |     |         success = __revertCatcher__.process(data);
  808 |     | 
  809 |     |         // touch pool to update it so we know how much staked liquidity the position has
  810 |     |         uint8 useMax = 0;
  811 |     |         uint8 direction = 0;
  812 |     |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
  813 |     |         data = Enigma.encodeSwap(useMax, positionId, 0x09, 0x01, 0x0, limit, direction);
  814 |     |         success = __revertCatcher__.process(data);
  815 |     | 
  816 |     |         uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), positionId).stakedLiquidity;
  817 |     | 
  818 |     |         HyperPosition memory pos = defaultRevertCatcherPosition();
  819 |     |         customWarp(pos.unstakeTimestamp + 1);
  820 |     |         data = Enigma.encodeUnstakePosition(positionId, amount);
  821 |     |         success = __revertCatcher__.process(data);
  822 |     | 
  823 |     |         pos = defaultRevertCatcherPosition();
  824 |     |         customWarp((pos.unstakeTimestamp + 1) * 2);
  825 |     | 
  826 |     |         // TODO: FIX FAILING TEST
  827 |     | 
  828 |     |         // touch pool to update it so we know how much staked liquidity the position has
  829 |     |         // data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, 0x01, 0x15, 0x01, 0);
  830 |     |         // success = __revertCatcher__.process(data);
  831 |     |         //
  832 |     |         // // todo: currently fails because unstaking does not change staked liquidity.
  833 |     |         // uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__),defaultScenario.poolId).stakedLiquidity;
  834 |     |         //
  835 |     |         // if (lo <= getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick && hi > getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick) {
  836 |     |         //     assertTrue(nextPoolStakedLiquidity < prevPoolStakedLiquidity, "Pool staked liquidity did not increase.");
  837 |     |         //     assertTrue(nextPoolStakedLiquidity == 0, "Pool staked liquidity does not equal 0 after unstake.");
  838 |     |         // } else {
  839 |     |         //     assertTrue(
  840 |     |         //         nextPoolStakedLiquidity == prevPoolStakedLiquidity,
  841 |     |         //         "Pool staked liquidity changed even though position staked out of range."
  842 |     |         //     );
  843 |     |         // }
  844 |     |     }
  845 |     | 
  846 |     |     function testUnstakeNonExistentPoolIdReverts() public {
  847 |     |         uint64 failureArg = 1224;
  848 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  849 |     |         __hyperTestingContract__.unstake(failureArg, 555);
  850 |     |     }
  851 |     | 
  852 |     |     function testUnstakeNotStakedReverts() public {
  853 |     |         vm.expectRevert(abi.encodeWithSelector(PositionNotStaked.selector, defaultScenario.poolId));
  854 |     |         __hyperTestingContract__.unstake(defaultScenario.poolId, 555);
  855 |     |     }
  856 |     | 
  857 |     |     // --- Create HyperPair --- //
  858 |     | 
  859 |     |     function testCreatePairSameTokensReverts() public {
  860 |     |         address token = address(new TestERC20("t", "t", 18));
  861 |     |         bytes memory data = Enigma.encodeCreatePair(token, token);
  862 |     |         vm.expectRevert(SameTokenError.selector);
  863 |     |         bool success = __revertCatcher__.process(data);
  864 |     |         assertTrue(!success, "forwarder call failed");
  865 |     |     }
  866 |     | 
  867 |     |     function testCreatePairPairExistsReverts() public {
  868 |     |         bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.asset), address(defaultScenario.quote));
  869 |     |         vm.expectRevert(abi.encodeWithSelector(PairExists.selector, 1));
  870 |     |         bool success = __revertCatcher__.process(data);
  871 |     |     }
  872 |     | 
  873 |     |     function testCreatePairLowerDecimalBoundsAssetReverts() public {
  874 |     |         address token0 = address(new TestERC20("t", "t", 5));
  875 |     |         address token1 = address(new TestERC20("t", "t", 18));
  876 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  877 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));
  878 |     |         bool success = __revertCatcher__.process(data);
  879 |     |     }
  880 |     | 
  881 |     |     function testCreatePairLowerDecimalBoundsQuoteReverts() public {
  882 |     |         address token0 = address(new TestERC20("t", "t", 18));
  883 |     |         address token1 = address(new TestERC20("t", "t", 5));
  884 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  885 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));
  886 |     |         bool success = __revertCatcher__.process(data);
  887 |     |     }
  888 |     | 
  889 |     |     function testCreatePairUpperDecimalBoundsAssetReverts() public {
  890 |     |         address token0 = address(new TestERC20("t", "t", 24));
  891 |     |         address token1 = address(new TestERC20("t", "t", 18));
  892 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  893 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));
  894 |     |         bool success = __revertCatcher__.process(data);
  895 |     |     }
  896 |     | 
  897 |     |     function testCreatePairUpperDecimalBoundsQuoteReverts() public {
  898 |     |         address token0 = address(new TestERC20("t", "t", 18));
  899 |     |         address token1 = address(new TestERC20("t", "t", 24));
  900 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  901 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));
  902 |     |         bool success = __revertCatcher__.process(data);
  903 |     |     }
  904 |     | 
  905 |     |     function testCreatePairPairNonceIncrementedReturnsOneAdded() public {
  906 |     |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
  907 |     |         address token0 = address(new TestERC20("t", "t", 18));
  908 |     |         address token1 = address(new TestERC20("t", "t", 18));
  909 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  910 |     |         bool success = __revertCatcher__.process(data);
  911 |     |         uint256 nonce = __hyperTestingContract__.getPairNonce();
  912 |     |         assertEq(nonce, prevNonce + 1);
  913 |     |     }
  914 |     | 
  915 |     |     function testCreatePairFetchesPairIdReturnsNonZero() public {
  916 |     |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
  917 |     |         address token0 = address(new TestERC20("t", "t", 18));
  918 |     |         address token1 = address(new TestERC20("t", "t", 18));
  919 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  920 |     |         bool success = __revertCatcher__.process(data);
  921 |     |         uint256 pairId = __hyperTestingContract__.getPairId(token0, token1);
  922 |     |         assertTrue(pairId != 0);
  923 |     |     }
  924 |     | 
  925 |     |     function testCreatePairFetchesPairDataReturnsAddresses() public {
  926 |     |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
  927 |     |         address token0 = address(new TestERC20("t", "t", 18));
  928 |     |         address token1 = address(new TestERC20("t", "t", 18));
  929 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  930 |     |         bool success = __revertCatcher__.process(data);
  931 |     |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
  932 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);
  933 |     |         assertEq(pair.tokenAsset, token0);
  934 |     |         assertEq(pair.tokenQuote, token1);
  935 |     |         assertEq(pair.decimalsAsset, 18);
  936 |     |         assertEq(pair.decimalsQuote, 18);
  937 |     |     }
  938 |     | 
  939 |     |     /* // --- Create Curve --- //
  940 |     | 
  941 |     |     function testCreateCurveCurveExistsReverts() public {
  942 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
  943 |     |         bytes memory data = Enigma.encodeCreateCurve(
  944 |     |             curve.sigma,
  945 |     |             curve.maturity,
  946 |     |             uint16(1e4 - curve.gamma),
  947 |     |             uint16(1e4 - curve.priorityGamma),
  948 |     |             curve.strike
  949 |     |         );
  950 |     |         vm.expectRevert(abi.encodeWithSelector(CurveExists.selector, 1));
  951 |     |         bool success = __revertCatcher__.process(data);
  952 |     |     }
  953 |     | 
  954 |     |     function testCreateCurveFeeParameterOutsideBoundsReverts() public {
  955 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
  956 |     |         uint16 failureArg = 5e4;
  957 |     |         bytes memory data = Enigma.encodeCreateCurve(
  958 |     |             curve.sigma,
  959 |     |             curve.maturity,
  960 |     |             failureArg,
  961 |     |             uint16(1e4 - curve.priorityGamma),
  962 |     |             curve.strike
  963 |     |         );
  964 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
  965 |     |         bool success = __revertCatcher__.process(data);
  966 |     |     }
  967 |     | 
  968 |     |     function testCreateCurvePriorityFeeParameterOutsideBoundsReverts() public {
  969 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
  970 |     |         uint16 failureArg = 5e4;
  971 |     |         bytes memory data = Enigma.encodeCreateCurve(
  972 |     |             curve.sigma,
  973 |     |             curve.maturity,
  974 |     |             uint16(1e4 - curve.gamma),
  975 |     |             failureArg,
  976 |     |             curve.strike
  977 |     |         );
  978 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
  979 |     |         bool success = __revertCatcher__.process(data);
  980 |     |     }
  981 |     | 
  982 |     |     function testCreateCurveRMMPoolZeroSigmaReverts() public {
  983 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
  984 |     |         uint24 failureArg = 0;
  985 |     |         bytes memory data = Enigma.encodeCreateCurve(
  986 |     |             failureArg,
  987 |     |             curve.maturity,
  988 |     |             uint16(1e4 - curve.gamma),
  989 |     |             uint16(1e4 - curve.priorityGamma),
  990 |     |             curve.strike
  991 |     |         );
  992 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));
  993 |     |         bool success = __revertCatcher__.process(data);
  994 |     |     }
  995 |     | 
  996 |     |     function testCreateCurveRMMPoolZeroStrikeReverts() public {
  997 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
  998 |     |         uint128 failureArg = 0;
  999 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1000 |     |             curve.sigma,
 1001 |     |             curve.maturity,
 1002 |     |             uint16(1e4 - curve.gamma),
 1003 |     |             uint16(1e4 - curve.priorityGamma),
 1004 |     |             failureArg
 1005 |     |         );
 1006 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidStrike.selector, failureArg));
 1007 |     |         bool success = __revertCatcher__.process(data);
 1008 |     |     }
 1009 |     | 
 1010 |     |     function testCreateCurveCurveNonceIncrementReturnsOne() public {
 1011 |     |         uint256 prevNonce = __hyperTestingContract__.getCurveNonce();
 1012 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1013 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1014 |     |             curve.sigma + 1,
 1015 |     |             curve.maturity,
 1016 |     |             uint16(1e4 - curve.gamma),
 1017 |     |             uint16(1e4 - curve.priorityGamma),
 1018 |     |             curve.strike
 1019 |     |         );
 1020 |     |         bool success = __revertCatcher__.process(data);
 1021 |     |         uint256 nextNonce = __hyperTestingContract__.getCurveNonce();
 1022 |     |         assertEq(prevNonce, nextNonce - 1);
 1023 |     |     }
 1024 |     | 
 1025 |     |     function testCreateCurveFetchesCurveIdReturnsNonZero() public {
 1026 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1027 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1028 |     |             curve.sigma + 1,
 1029 |     |             curve.maturity,
 1030 |     |             uint16(1e4 - curve.gamma),
 1031 |     |             uint16(1e4 - curve.priorityGamma),
 1032 |     |             curve.strike
 1033 |     |         );
 1034 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1035 |     |             abi.encodePacked(
 1036 |     |                 curve.sigma + 1,
 1037 |     |                 curve.maturity,
 1038 |     |                 uint16(1e4 - curve.gamma),
 1039 |     |                 uint16(1e4 - curve.priorityGamma),
 1040 |     |                 curve.strike
 1041 |     |             )
 1042 |     |         );
 1043 |     |         bool success = __revertCatcher__.process(data);
 1044 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1045 |     |         assertTrue(curveId != 0);
 1046 |     |     }
 1047 |     | 
 1048 |     |     function testCreateCurveFetchesCurveDataReturnsParametersSet() public {
 1049 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1050 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1051 |     |             curve.sigma + 1,
 1052 |     |             curve.maturity,
 1053 |     |             uint16(1e4 - curve.gamma),
 1054 |     |             uint16(1e4 - curve.priorityGamma),
 1055 |     |             curve.strike
 1056 |     |         );
 1057 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1058 |     |             abi.encodePacked(
 1059 |     |                 curve.sigma + 1,
 1060 |     |                 curve.maturity,
 1061 |     |                 uint16(1e4 - curve.gamma),
 1062 |     |                 uint16(1e4 - curve.priorityGamma),
 1063 |     |                 curve.strike
 1064 |     |             )
 1065 |     |         );
 1066 |     |         bool success = __revertCatcher__.process(data);
 1067 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1068 |     |         HyperCurve memory newCurve = getCurve(address(__hyperTestingContract__), curveId);
 1069 |     |         assertEq(newCurve.sigma, curve.sigma + 1);
 1070 |     |         assertEq(newCurve.maturity, curve.maturity);
 1071 |     |         assertEq(newCurve.gamma, curve.gamma);
 1072 |     |         assertEq(newCurve.priorityGamma, curve.priorityGamma);
 1073 |     |         assertEq(newCurve.strike, curve.strike);
 1074 |     |     } */
 1075 |     | 
 1076 |     |     // --- Create Pool --- //
 1077 |     |     // todo: fix
 1078 |     | 
 1079 |     |     /* function testCreatePoolZeroPriceParameterReverts() public {
 1080 |     |         uint128 failureArg = 0;
 1081 |     |         bytes memory data = Enigma.encodeCreatePool(1, failureArg);
 1082 |     |         vm.expectRevert(ZeroPrice.selector);
 1083 |     |         bool success = __revertCatcher__.process(data);
 1084 |     |     } */
 1085 |     | 
 1086 |     |     // todo: fix
 1087 |     |     /* function testCreatePoolExistentPoolReverts() public {
 1088 |     |         uint64 failureArg = defaultScenario.poolId;
 1089 |     |         bytes memory data = Enigma.encodeCreatePool(failureArg, 1);
 1090 |     |         vm.expectRevert(PoolExists.selector);
 1091 |     |         bool success = __revertCatcher__.process(data);
 1092 |     |     } */
 1093 |     | 
 1094 |     |     // todo: fix
 1095 |     |     /* function testCreatePoolMagicPairId() public {
 1096 |     |         // Create a new curve to increment the nonce to 2
 1097 |     |         bytes memory data = Enigma.encodeCreateCurve(4, type(uint32).max - 1, 4, 4, 4);
 1098 |     |         __revertCatcher__.process(data);
 1099 |     | 
 1100 |     |         uint64 magicVariable = 0x000000000002;
 1101 |     |         data = Enigma.encodeCreatePool(magicVariable, 1);
 1102 |     |         bool success = __revertCatcher__.process(data);
 1103 |     |         assertTrue(success);
 1104 |     |     } */
 1105 |     |     /* 
 1106 |     |     function testCreatePoolMagicCurveId() public {
 1107 |     |         // Create a new pair to increment the nonce to 2
 1108 |     |         bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.quote), address(__weth__));
 1109 |     |         __revertCatcher__.process(data);
 1110 |     | 
 1111 |     |         uint64 magicVariable = 0x000200000000;
 1112 |     |         data = Enigma.encodeCreatePool(magicVariable, 1);
 1113 |     |         bool success = __revertCatcher__.process(data);
 1114 |     |         assertTrue(success);
 1115 |     |     }
 1116 |     | 
 1117 |     |     function testCreatePoolRMMPoolExpiredReverts() public {
 1118 |     |         address token0 = address(new TestERC20("t", "t", 18));
 1119 |     |         address token1 = address(new TestERC20("t", "t", 18));
 1120 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
 1121 |     |         bool success = __revertCatcher__.process(data);
 1122 |     |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
 1123 |     | 
 1124 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1125 |     |         data = Enigma.encodeCreateCurve(
 1126 |     |             curve.sigma + 1,
 1127 |     |             uint32(0),
 1128 |     |             uint16(1e4 - curve.gamma),
 1129 |     |             uint16(1e4 - curve.priorityGamma),
 1130 |     |             curve.strike
 1131 |     |         );
 1132 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1133 |     |             abi.encodePacked(curve.sigma + 1, uint32(0), uint16(1e4 - curve.gamma), curve.strike)
 1134 |     |         );
 1135 |     |         success = __revertCatcher__.process(data);
 1136 |     | 
 1137 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1138 |     |         uint64 id = Enigma.encodePoolId(pairId, curveId);
 1139 |     |         data = Enigma.encodeCreatePool(id, 1_000);
 1140 |     |         vm.expectRevert(PoolExpired.selector);
 1141 |     |         success = __revertCatcher__.process(data);
 1142 |     |     }
 1143 |     | 
 1144 |     |     function testCreatePoolFetchesPoolDataReturnsNonZeroBlockTimestamp() public {
 1145 |     |         address token0 = address(new TestERC20("t", "t", 18));
 1146 |     |         address token1 = address(new TestERC20("t", "t", 18));
 1147 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
 1148 |     |         bool success = __revertCatcher__.process(data);
 1149 |     |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
 1150 |     | 
 1151 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1152 |     |         data = Enigma.encodeCreateCurve(
 1153 |     |             curve.sigma + 1,
 1154 |     |             curve.maturity,
 1155 |     |             uint16(1e4 - curve.gamma),
 1156 |     |             uint16(1e4 - curve.priorityGamma),
 1157 |     |             curve.strike
 1158 |     |         );
 1159 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1160 |     |             abi.encodePacked(
 1161 |     |                 curve.sigma + 1,
 1162 |     |                 curve.maturity,
 1163 |     |                 uint16(1e4 - curve.gamma),
 1164 |     |                 uint16(1e4 - curve.priorityGamma),
 1165 |     |                 curve.strike
 1166 |     |             )
 1167 |     |         );
 1168 |     |         success = __revertCatcher__.process(data);
 1169 |     | 
 1170 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1171 |     |         uint64 id = Enigma.encodePoolId(pairId, curveId);
 1172 |     |         data = Enigma.encodeCreatePool(id, 1_000);
 1173 |     |         success = __revertCatcher__.process(data);
 1174 |     | 
 1175 |     |         uint256 time = getPool(address(__hyperTestingContract__), id).lastTimestamp;
 1176 |     |         assertTrue(time != 0);
 1177 |     |     } */
 1178 |     | }
 1179 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperSwap.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "contracts/HyperLib.sol" as HyperTypes;
  5 |     | import "./setup/TestHyperSetup.sol";
  6 |     | import "test/helpers/HelperHyperProfiles.sol";
  7 |     | 
  8 |     | contract TestHyperSwap is TestHyperSetup {
  9 |     |     modifier allocateFirst() {
 10 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 10 ether);
 11 |     |         _;
 12 |     |     }
 13 |     | 
 14 |     |     function testSwap_should_succeed() public allocateFirst {
 15 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 16 |     | 
 17 |     |         uint input = DEFAULT_SWAP_INPUT;
 18 |     |         uint expected = DEFAULT_SWAP_OUTPUT; // 6 decimals
 19 |     |         (uint out, ) = pool.getAmountOut(
 20 |     |             getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40)),
 21 |     |             true,
 22 |     |             input,
 23 |     |             0
 24 |     |         );
 25 |     | 
 26 |     |         (uint output, uint remainder) = __hyperTestingContract__.swap(
 27 |     |             defaultScenario.poolId,
 28 |     |             true,
 29 |     |             input,
 30 |     |             0 // limit
 31 |     |         );
 32 |     | 
 33 |     |         assertEq(output, expected, "expected-output");
 34 |     | 
 35 |     |         (uint amount0, uint amount1) = pool.getAmounts();
 36 |     |         console.log("amounts", amount0, amount1);
 37 |     |         console.log("outputs, actual, expected", output, out);
 38 |     |     }
 39 |     | 
 40 |     |     function testSwap_back_and_forth_outputs_less() public allocateFirst {
 41 |     |         uint256 start = 10000;
 42 |     | 
 43 |     |         bool direction = false;
 44 |     |         (uint output, ) = __hyperTestingContract__.swap(
 45 |     |             defaultScenario.poolId,
 46 |     |             direction,
 47 |     |             start,
 48 |     |             direction ? 0 : type(uint128).max
 49 |     |         );
 50 |     | 
 51 |     |         direction = true;
 52 |     |         (uint finalOutput, ) = __hyperTestingContract__.swap(
 53 |     |             defaultScenario.poolId,
 54 |     |             direction,
 55 |     |             output,
 56 |     |             direction ? 0 : type(uint128).max
 57 |     |         );
 58 |     | 
 59 |     |         assertGt(start, finalOutput);
 60 |     |     }
 61 |     | 
 62 |     |     function testSwap_revert_PoolExpired() public allocateFirst {
 63 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 64 |     |         uint end = pool.params.createdAt + Assembly.convertDaysToSeconds(pool.params.duration);
 65 |     |         customWarp(end + 1);
 66 |     |         vm.expectRevert(PoolExpired.selector);
 67 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, false, 10000, type(uint128).max);
 68 |     |     }
 69 |     | 
 70 |     |     function testSwap_revert_ZeroInput() public {
 71 |     |         vm.expectRevert(ZeroInput.selector);
 72 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, true, 0, 0);
 73 |     |     }
 74 |     | 
 75 |     |     /*
 76 |     |     function testSwap_revert_NonExistentPool() public {
 77 |     |         vm.expectRevert(NonExistentPool.selector);
 78 |     |         __hyperTestingContract__.swap(
 79 |     |             42,
 80 |     |             true,
 81 |     |             1,
 82 |     |             0
 83 |     |         );
 84 |     |     }
 85 |     |     */
 86 |     | }
 87 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestHyperUnallocate.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | 
  6 |     | contract TestHyperUnallocate is TestHyperSetup {
  7 |     |     function testUnallocateUseMax() public postTestInvariantChecks {
  8 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
  9 |     | 
 10 |     |         uint maxLiquidity = getPosition(address(__hyperTestingContract__), msg.sender, defaultScenario.poolId)
 11 |     |             .freeLiquidity;
 12 |     | 
 13 |     |         __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint256).max);
 14 |     | 
 15 |     |         assertEq(0, getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity);
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestPriceComputePrice.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceComputePrice is TestPriceSetup {
  7 |     |     using Price for Price.RMM;
  8 |     | 
  9 |     |     function testComputedPriceWithDefaultAssetReserve() public {
 10 |     |         uint actual = cases[0].getPriceWithX(DEFAULT_ASSET_RESERVE);
 11 |     |         uint err = 1e4; // TODO: Fix for error...
 12 |     |         assertTrue(actual <= DEFAULT_PRICE + err && actual >= DEFAULT_PRICE - err);
 13 |     |     }
 14 |     | 
 15 |     |     // ===== Raw ===== //
 16 |     | 
 17 |     |     function testComputePriceWithZeroChangeInTauReturnsPrice() public {
 18 |     |         uint price = DEFAULT_PRICE;
 19 |     |         uint actual = cases[0].computePriceWithChangeInTau(price, 0);
 20 |     |         assertEq(actual, price);
 21 |     |     }
 22 |     | 
 23 |     |     function testComputePriceWithEpsilonEqualsTauReturnsStrike() public {
 24 |     |         Price.RMM memory info = cases[0];
 25 |     |         uint price = DEFAULT_PRICE;
 26 |     |         uint epsilon = info.tau;
 27 |     |         uint actual = info.computePriceWithChangeInTau(price, epsilon);
 28 |     |         assertEq(actual, info.strike);
 29 |     |     }
 30 |     | 
 31 |     |     function testFuzzComputePriceWithChangeInTau(uint32 epsilon) public {
 32 |     |         Price.RMM memory info = cases[0];
 33 |     |         // Fuzzing Filters
 34 |     |         vm.assume(epsilon > 0); // Fuzzing non-zero test cases only.
 35 |     |         vm.assume(epsilon < info.tau); // Epsilon > tau is the same as epsilon == tau.
 36 |     | 
 37 |     |         // Behavior: as epsilon gets larger, tau gets smaller, price increases, reaches inflection, price tends to strike after inflection point.
 38 |     |         uint price = DEFAULT_PRICE;
 39 |     |         uint actual = info.computePriceWithChangeInTau(price, epsilon);
 40 |     |         uint actualDiff = actual - info.strike;
 41 |     |         uint expectedDiff = price - info.strike;
 42 |     |         assertTrue(actualDiff > expectedDiff); // maybe? As tau gets smaller, price should increase until epsilon >= tau.
 43 |     |     }
 44 |     | 
 45 |     |     function testComputePriceWithEpsilonChangeEqualToTauReturnsPrice() public {
 46 |     |         uint price = DEFAULT_PRICE;
 47 |     |         uint actual = cases[0].computePriceWithChangeInTau(price, cases[0].tau);
 48 |     |         assertEq(actual, price);
 49 |     |     }
 50 |     | }
 51 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestPriceComputeReserves.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceComputeReserves is TestPriceSetup {
  7 |     |     using Price for Price.RMM;
  8 |     | 
  9 |     |     function testComputedAssetReserveWithDefaultPrice() public {
 10 |     |         uint actual = cases[0].getXWithPrice(DEFAULT_PRICE);
 11 |     |         assertEq(actual, DEFAULT_ASSET_RESERVE);
 12 |     |     }
 13 |     | 
 14 |     |     function testComputedQuoteReserveWithDefaultAssetReserve() public {
 15 |     |         uint actual = cases[0].getYWithX(DEFAULT_ASSET_RESERVE);
 16 |     |         assertEq(actual, DEFAULT_QUOTE_RESERVE);
 17 |     |     }
 18 |     | 
 19 |     |     function testComputedAssetReserveWithDefaultQuoteReserve() public {
 20 |     |         uint actual = cases[0].getXWithY(DEFAULT_QUOTE_RESERVE);
 21 |     |         assertEq(actual, DEFAULT_ASSET_RESERVE);
 22 |     |     }
 23 |     | 
 24 |     |     function testComputedReservesWithDefaultPrice() public {
 25 |     |         (uint actualQuoteReserve, uint actualAssetReserve) = cases[0].computeReserves(DEFAULT_PRICE);
 26 |     |         assertEq(actualQuoteReserve, DEFAULT_QUOTE_RESERVE);
 27 |     |         assertEq(actualAssetReserve, DEFAULT_ASSET_RESERVE);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestPriceInvariant.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceInvariant is TestPriceSetup {
  7 |     |     using Price for Price.RMM;
  8 |     | 
  9 |     |     function testInvariantReturnsZeroWithDefaultPool() public {
 10 |     |         int actual = cases[0].invariantOf(DEFAULT_QUOTE_RESERVE, DEFAULT_ASSET_RESERVE);
 11 |     |         assertEq(actual, 0);
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/TestPriceUtils.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceUtils is TestPriceSetup {
  7 |     |     // ===== Utils ===== //
  8 |     | 
  9 |     |     function testConvertPercentageReturnsOne() public {
 10 |     |         uint percentage = Price.PERCENTAGE;
 11 |     |         uint expected = Price.WAD;
 12 |     |         uint converted = Price.convertPercentageToWad(percentage);
 13 |     |         assertEq(converted, expected);
 14 |     |     }
 15 |     | 
 16 |     |     function testFuzzConvertPercentageReturnsComputedValue(uint percentage) public {
 17 |     |         vm.assume(percentage < type(uint64).max);
 18 |     |         uint expected = (percentage * Price.WAD) / Price.PERCENTAGE;
 19 |     |         uint converted = Price.convertPercentageToWad(percentage);
 20 |     |         assertEq(converted, expected);
 21 |     |     }
 22 |     | }
 23 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/setup/TestHyperSetup.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "solmate/tokens/WETH.sol";
   5 |     | import "solmate/utils/SafeCastLib.sol";
   6 |     | import "contracts/HyperLib.sol";
   7 |     | import "contracts/libraries/Price.sol";
   8 |     | 
   9 |     | import "forge-std/Test.sol";
  10 |     | import {TestERC20, Hyper, HyperTimeOverride, HyperCatchReverts, RevertCatcher, FixedPointMathLib} from "test/helpers/HyperTestOverrides.sol";
  11 |     | 
  12 |     | import "test/helpers/HelperHyperActions.sol";
  13 |     | import "test/helpers/HelperHyperInvariants.sol";
  14 |     | import "test/helpers/HelperHyperProfiles.sol";
  15 |     | import "test/helpers/HelperHyperView.sol";
  16 |     | 
  17 |     | uint constant STARTING_BALANCE = 4000e18;
  18 |     | 
  19 |     | struct TestScenario {
  20 |     |     TestERC20 asset;
  21 |     |     TestERC20 quote;
  22 |     |     uint64 poolId;
  23 |     |     string label;
  24 |     | }
  25 |     | 
  26 |     | /** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */
  27 |     | contract TestHyperSetup is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView, Test {
  28 |     |     using FixedPointMathLib for uint256;
  29 |     |     using FixedPointMathLib for int256;
  30 |     |     using SafeCastLib for uint;
  31 |     | 
  32 |     |     WETH public __weth__;
  33 |     |     Hyper public __hyper__; // Actual contract
  34 |     |     HyperTimeOverride public __hyperTimeOverride__; // Inherits Hyper, adds block.timestamp and jit policy overrides
  35 |     |     HyperCatchReverts public __hyperTestingContract__; // Inherits HyperTimeOverrides, adds endpoints to process functions.
  36 |     |     RevertCatcher public __revertCatcher__;
  37 |     | 
  38 |     |     TestERC20 public __usdc__;
  39 |     |     TestERC20 public __token_8__;
  40 |     |     TestERC20 public __token_18__;
  41 |     |     TestERC20 public __badToken__;
  42 |     | 
  43 |     |     address[] public __contracts__;
  44 |     |     address[] public __users__;
  45 |     |     address[] public __tokens__;
  46 |     | 
  47 |     |     TestScenario public defaultScenario;
  48 |     |     TestScenario[] public scenarios;
  49 |     | 
  50 |     |     modifier postTestInvariantChecks() virtual {
  51 |     |         _;
  52 |     |         assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.asset), __users__);
  53 |     |         assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.quote), __users__);
  54 |     |     }
  55 |     | 
  56 |     |     function setUp() public {
  57 |     |         initContracts();
  58 |     |         initUsers();
  59 |     |         initScenarios();
  60 |     |         initPrerequisites();
  61 |     |         afterSetUp();
  62 |     |     }
  63 |     | 
  64 |     |     function getState() public view returns (HyperState memory) {
  65 |     |         return getState(address(__hyperTestingContract__), defaultScenario.poolId, address(this), __users__);
  66 |     |     }
  67 |     | 
  68 |     |     /** Hook to override receive. Defaults to just accepting ether sent to this test contract. */
  69 |     |     receive() external payable {
  70 |     |         receiveOverride();
  71 |     |     }
  72 |     | 
  73 |     |     /** @dev Hook to run after test setup. */
  74 |     |     function afterSetUp() public virtual {}
  75 |     | 
  76 |     |     function receiveOverride() public virtual {}
  77 |     | 
  78 |     |     function initContracts() internal {
  79 |     |         __weth__ = new WETH();
  80 |     | 
  81 |     |         // --- Hyper Contracts --- //
  82 |     |         __hyper__ = new Hyper(address(__weth__));
  83 |     |         __hyperTimeOverride__ = new HyperTimeOverride(address(__weth__));
  84 |     |         __hyperTestingContract__ = new HyperCatchReverts(address(__weth__));
  85 |     |         __revertCatcher__ = new RevertCatcher(address(__hyperTestingContract__));
  86 |     |         __contracts__.push(address(__hyper__));
  87 |     |         __contracts__.push(address(__hyperTimeOverride__));
  88 |     |         __contracts__.push(address(__hyperTestingContract__));
  89 |     |         __contracts__.push(address(__revertCatcher__));
  90 |     | 
  91 |     |         __usdc__ = new TestERC20("USD Coin", "USDC", 6);
  92 |     |         __token_8__ = new TestERC20("8 Decimals", "8DEC", 8);
  93 |     |         __token_18__ = new TestERC20("18 Decimals", "18DEC", 18);
  94 |     |         __badToken__ = new TestERC20("Non-standard ERC20", "BAD", 18); // TODO: Add proper bad token.
  95 |     |         __tokens__.push(address(__usdc__));
  96 |     |         __tokens__.push(address(__token_8__));
  97 |     |         __tokens__.push(address(__token_18__));
  98 |     |         __tokens__.push(address(__badToken__));
  99 |     | 
 100 |     |         setLabels();
 101 |     |     }
 102 |     | 
 103 |     |     function initUsers() internal {
 104 |     |         address self = address(this);
 105 |     |         address alicent = address(0x0001);
 106 |     |         address boba = address(0x0002);
 107 |     |         address revertCatcher = address(__revertCatcher__);
 108 |     | 
 109 |     |         vm.label(self, "Self");
 110 |     |         vm.label(alicent, "Alicent");
 111 |     |         vm.label(boba, "Boba");
 112 |     | 
 113 |     |         __users__.push(self);
 114 |     |         __users__.push(alicent);
 115 |     |         __users__.push(boba);
 116 |     |         __users__.push(revertCatcher);
 117 |     |     }
 118 |     | 
 119 |     |     function initScenarios() internal {
 120 |     |         __hyperTestingContract__.setTimestamp(uint128(block.timestamp)); // Important
 121 |     |         // Create default pool
 122 |     |         bytes memory data = createPool(
 123 |     |             address(__token_18__),
 124 |     |             address(__usdc__),
 125 |     |             address(0),
 126 |     |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
 127 |     |             uint16(1e4 - DEFAULT_GAMMA),
 128 |     |             uint16(DEFAULT_SIGMA),
 129 |     |             uint16(DEFAULT_DURATION_DAYS),
 130 |     |             DEFAULT_JIT,
 131 |     |             DEFAULT_TICK,
 132 |     |             DEFAULT_PRICE
 133 |     |         );
 134 |     | 
 135 |     |         bool success = __revertCatcher__.jumpProcess(data);
 136 |     |         assertTrue(success, "__revertCatcher__ call failed");
 137 |     | 
 138 |     |         // Create default scenario and add to all scenarios.
 139 |     |         defaultScenario = TestScenario(__token_18__, __usdc__, FIRST_POOL, "Default");
 140 |     |         scenarios.push(defaultScenario);
 141 |     |     }
 142 |     | 
 143 |     |     uint64 public constant FIRST_POOL = 0x0000010000000001;
 144 |     |     uint64 public constant SECOND_POOL_FIRST_PAIR = 0x0000010000000002;
 145 |     | 
 146 |     |     /** @dev Requires tokens to be spent and spenders to be approved. */
 147 |     |     function initPrerequisites() internal {
 148 |     |         fundUsers();
 149 |     |         approveTokens();
 150 |     |     }
 151 |     | 
 152 |     |     /** @dev Does not include weth. */
 153 |     |     function approveTokens() internal {
 154 |     |         for (uint x; x != __tokens__.length; ++x) {
 155 |     |             for (uint y; y != __contracts__.length; ++y) {
 156 |     |                 for (uint z; z != __users__.length; ++z) {
 157 |     |                     vm.prank(__users__[z]); // Sets caller
 158 |     |                     TestERC20(__tokens__[x]).approve(__contracts__[y], type(uint256).max); // Approves test contracts to spend tokens.
 159 |     |                 }
 160 |     |             }
 161 |     |         }
 162 |     |     }
 163 |     | 
 164 |     |     /** @dev Does not include weth. */
 165 |     |     function fundUsers() internal {
 166 |     |         for (uint i; i != __users__.length; ++i) {
 167 |     |             for (uint j; j != __tokens__.length; ++j) {
 168 |     |                 deal(__tokens__[j], __users__[i], STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.
 169 |     |             }
 170 |     |         }
 171 |     |     }
 172 |     | 
 173 |     |     function setLabels() internal {
 174 |     |         vm.label(address(this), "Self");
 175 |     |         vm.label(address(__weth__), "Weth");
 176 |     |         vm.label(address(__revertCatcher__), "RevertCatcher");
 177 |     |         vm.label(address(__hyper__), "DefaultHyper");
 178 |     |         vm.label(address(__hyperTimeOverride__), "HyperTimeOverride");
 179 |     |         vm.label(address(__hyperTestingContract__), "HyperCatchReverts");
 180 |     |         vm.label(address(__usdc__), "USDC");
 181 |     |         vm.label(address(__token_8__), "Token8Decimals");
 182 |     |         vm.label(address(__token_18__), "Token18Decimals");
 183 |     |         vm.label(address(__badToken__), "BadToken");
 184 |     |     }
 185 |     | 
 186 |     |     function customWarp(uint time) internal {
 187 |     |         vm.warp(time);
 188 |     |         __hyperTestingContract__.setTimestamp(uint128(time));
 189 |     |     }
 190 |     | 
 191 |     |     function createControlledPool() internal {
 192 |     |         bytes memory data = Enigma.encodeCreatePool(
 193 |     |             uint24(1), // first pair, is it good in this test?
 194 |     |             address(this),
 195 |     |             100,
 196 |     |             DEFAULT_FEE,
 197 |     |             DEFAULT_VOLATILITY,
 198 |     |             DEFAULT_DURATION,
 199 |     |             DEFAULT_JIT,
 200 |     |             DEFAULT_MAX_TICK,
 201 |     |             DEFAULT_PRICE
 202 |     |         );
 203 |     | 
 204 |     |         bool success = __revertCatcher__.process(data);
 205 |     |         assertTrue(success, "controlled pool not created");
 206 |     | 
 207 |     |         // assumes second pool has not been created...
 208 |     |         // can be fixed by getting pool nonce and encoding pool id.
 209 |     |         uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(__hyperTestingContract__.getPoolNonce()));
 210 |     |         scenarios.push(TestScenario(__token_18__, __usdc__, poolId, "Controlled"));
 211 |     |     }
 212 |     | 
 213 |     |     function basicSwap() internal {
 214 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 215 |     |         (uint output, ) = __hyperTestingContract__.swap(
 216 |     |             defaultScenario.poolId,
 217 |     |             true,
 218 |     |             (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether,
 219 |     |             1
 220 |     |         );
 221 |     | 
 222 |     |         assertTrue(output > 0, "no swap happened!");
 223 |     |     }
 224 |     | 
 225 |     |     function _swap(uint64 id) internal {
 226 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), id);
 227 |     |         (uint output, ) = __hyperTestingContract__.swap(id, true, (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether, 1);
 228 |     |         assertTrue(output > 0, "no swap happened!");
 229 |     |     }
 230 |     | 
 231 |     |     function basicSwapQuoteIn() internal {
 232 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 233 |     |         (uint output, ) = __hyperTestingContract__.swap(
 234 |     |             defaultScenario.poolId,
 235 |     |             false,
 236 |     |             (pool.getMaxSwapQuoteInWad() * 1 ether) / 2 ether,
 237 |     |             type(uint256).max
 238 |     |         );
 239 |     | 
 240 |     |         assertTrue(output > 0, "no swap happened!");
 241 |     |     }
 242 |     | 
 243 |     |     function basicAllocate() internal {
 244 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
 245 |     |     }
 246 |     | 
 247 |     |     function _alloc(uint64 id) internal {
 248 |     |         __hyperTestingContract__.allocate(id, 1 ether);
 249 |     |     }
 250 |     | 
 251 |     |     function basicUnallocate() internal {
 252 |     |         __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint).max); // max
 253 |     |     }
 254 |     | 
 255 |     |     function maxDraw() internal {
 256 |     |         __hyperTestingContract__.draw(
 257 |     |             address(defaultScenario.asset),
 258 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),
 259 |     |             address(this)
 260 |     |         );
 261 |     |         __hyperTestingContract__.draw(
 262 |     |             address(defaultScenario.quote),
 263 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),
 264 |     |             address(this)
 265 |     |         );
 266 |     |     }
 267 |     | 
 268 |     |     function defaultPool() internal view returns (HyperPool memory) {
 269 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 270 |     |         return pool;
 271 |     |     }
 272 |     | 
 273 |     |     function defaultRevertCatcherPosition() internal view returns (HyperPosition memory) {
 274 |     |         HyperPosition memory pos = getPosition(
 275 |     |             address(__hyperTestingContract__),
 276 |     |             address(__revertCatcher__),
 277 |     |             defaultScenario.poolId
 278 |     |         );
 279 |     |         return pos;
 280 |     |     }
 281 |     | 
 282 |     |     function defaultPosition() internal view returns (HyperPosition memory) {
 283 |     |         HyperPosition memory pos = getPosition(
 284 |     |             address(__hyperTestingContract__),
 285 |     |             address(this),
 286 |     |             defaultScenario.poolId
 287 |     |         );
 288 |     |         return pos;
 289 |     |     }
 290 |     | 
 291 |     |     /** @dev Casted to returns structs as memory */
 292 |     |     function hs() internal view returns (IHyperStruct) {
 293 |     |         return IHyperStruct(address(__hyperTestingContract__));
 294 |     |     }
 295 |     | 
 296 |     |     function hx() internal view returns (HyperLike) {
 297 |     |         return HyperLike(address(__hyperTestingContract__));
 298 |     |     }
 299 |     | }
 300 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/foundry/setup/TestPriceSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "contracts/libraries/Price.sol";
  6 |     | import "test/helpers/HelperHyperProfiles.sol";
  7 |     | 
  8 |     | contract TestPriceSetup is HelperHyperProfiles, Test {
  9 |     |     Price.RMM[] cases;
 10 |     | 
 11 |     |     function setUp() public {
 12 |     |         addTestCase(DEFAULT_STRIKE, DEFAULT_SIGMA, DEFAULT_MATURITY);
 13 |     |     }
 14 |     | 
 15 |     |     function addTestCase(uint strike, uint sigma, uint tau) internal returns (Price.RMM memory) {
 16 |     |         Price.RMM memory info = Price.RMM(strike, sigma, tau);
 17 |     |         cases.push(info);
 18 |     |         return info;
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/helpers/HelperHyperActions.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "contracts/Enigma.sol" as ProcessingLib;
  5 |     | import "./HelperHyperProfiles.sol";
  6 |     | 
  7 |     | contract HelperHyperActions {
  8 |     |     /** @dev Encodes jump process for creating a pair + curve + pool in one tx. */
  9 |     |     function createPool(
 10 |     |         address token0,
 11 |     |         address token1,
 12 |     |         address controller,
 13 |     |         uint16 priorityFee,
 14 |     |         uint16 fee,
 15 |     |         uint16 volatility,
 16 |     |         uint16 duration,
 17 |     |         uint16 jit,
 18 |     |         int24 maxTick,
 19 |     |         uint128 price
 20 |     |     ) internal pure returns (bytes memory data) {
 21 |     |         bytes[] memory instructions = new bytes[](2);
 22 |     |         uint24 magicPoolId = 0x000000;
 23 |     |         instructions[0] = (ProcessingLib.encodeCreatePair(token0, token1));
 24 |     |         instructions[1] = (
 25 |     |             ProcessingLib.encodeCreatePool(
 26 |     |                 magicPoolId, // magic variable
 27 |     |                 controller,
 28 |     |                 priorityFee,
 29 |     |                 fee,
 30 |     |                 volatility,
 31 |     |                 duration,
 32 |     |                 jit,
 33 |     |                 maxTick,
 34 |     |                 price
 35 |     |             )
 36 |     |         );
 37 |     |         data = ProcessingLib.encodeJumpInstruction(instructions);
 38 |     |     }
 39 |     | 
 40 |     |     function allocatePool(address hyper, uint64 poolId, uint amount) internal {
 41 |     |         bytes memory data = ProcessingLib.encodeAllocate(
 42 |     |             0, // useMax = false
 43 |     |             poolId,
 44 |     |             0x0, // amount multiplier = 10^0 = 1
 45 |     |             uint128(amount)
 46 |     |         );
 47 |     |         (bool success, ) = hyper.call{value: 0}(data);
 48 |     |         require(success, "failed to allocate");
 49 |     |     }
 50 |     | }
 51 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/helpers/HelperHyperInvariants.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {HyperLike} from "./HelperHyperView.sol";
  5 |     | 
  6 |     | interface ERC20Like {
  7 |     |     function balanceOf(address) external view returns (uint);
  8 |     | }
  9 |     | 
 10 |     | contract HelperHyperInvariants {
 11 |     |     error SettlementInvariantInvalid(uint, uint);
 12 |     | 
 13 |     |     function assertSettlementInvariant(
 14 |     |         address hyper,
 15 |     |         address token,
 16 |     |         address[] memory accounts
 17 |     |     ) internal view returns (bool) {
 18 |     |         uint reserve = HyperLike(hyper).getReserve(token);
 19 |     |         uint physical = ERC20Like(token).balanceOf(hyper);
 20 |     |         if (reserve > physical) revert SettlementInvariantInvalid(physical, reserve);
 21 |     |         return true;
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/helpers/HelperHyperProfiles.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | uint128 constant DEFAULT_STRIKE = 10e18;
  5 |     | uint24 constant DEFAULT_SIGMA = 1e4;
  6 |     | uint32 constant DEFAULT_MATURITY = 31556953; // adds 1
  7 |     | uint16 constant DEFAULT_FEE = 100; // 100 bps = 1%
  8 |     | uint32 constant DEFAULT_GAMMA = 9900;
  9 |     | uint32 constant DEFAULT_PRIORITY_GAMMA = 9950;
 10 |     | uint16 constant DEFAULT_DURATION_DAYS = 365;
 11 |     | uint128 constant DEFAULT_QUOTE_RESERVE = 3085375116376210650;
 12 |     | uint128 constant DEFAULT_ASSET_RESERVE = 308537516918601823; // 308596235182
 13 |     | uint128 constant DEFAULT_LIQUIDITY = 1e18;
 14 |     | uint128 constant DEFAULT_PRICE = 10e18;
 15 |     | int24 constant DEFAULT_TICK = int24(23027); // 10e18, rounded up! pay attention
 16 |     | uint constant DEFAULT_SWAP_INPUT = 0.1 ether;
 17 |     | uint constant DEFAULT_SWAP_OUTPUT = 97_627 wei;
 18 |     | uint16 constant DEFAULT_JIT = 4;
 19 |     | uint16 constant DEFAULT_VOLATILITY = 10_000;
 20 |     | uint16 constant DEFAULT_DURATION = 365;
 21 |     | int24 constant DEFAULT_MAX_TICK = int24(23027);
 22 |     | 
 23 |     | contract HelperHyperProfiles {}
 24 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/helpers/HelperHyperView.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/Enigma.sol" as Processor;
   5 |     | import "contracts/OS.sol" as Operating;
   6 |     | import {HyperPair, HyperCurve, HyperPool, HyperPosition} from "contracts/HyperLib.sol";
   7 |     | import {TestERC20} from "contracts/test/TestERC20.sol";
   8 |     | 
   9 |     | interface IHyperStruct {
  10 |     |     function pairs(uint24 pairId) external view returns (HyperPair memory);
  11 |     | 
  12 |     |     function positions(address owner, uint64 positionId) external view returns (HyperPosition memory);
  13 |     | 
  14 |     |     function pools(uint64 poolId) external view returns (HyperPool memory);
  15 |     | }
  16 |     | 
  17 |     | interface HyperLike {
  18 |     |     function getReserve(address) external view returns (uint);
  19 |     | 
  20 |     |     function getBalance(address, address) external view returns (uint);
  21 |     | 
  22 |     |     function getPairNonce() external view returns (uint16);
  23 |     | }
  24 |     | 
  25 |     | struct HyperState {
  26 |     |     uint reserveAsset; // getReserve
  27 |     |     uint reserveQuote; // getReserve
  28 |     |     uint physicalBalanceAsset; // balanceOf
  29 |     |     uint physicalBalanceQuote; // balanceOf
  30 |     |     uint totalBalanceAsset; // sum of all balances from getBalance
  31 |     |     uint totalBalanceQuote; // sum of all balances from getBalance
  32 |     |     uint totalPositionLiquidity; // sum of all position liquidity
  33 |     |     uint callerPositionLiquidity; // position.freeLiquidity
  34 |     |     uint totalPoolLiquidity; // pool.liquidity
  35 |     |     uint feeGrowthAssetPool; // getPool
  36 |     |     uint feeGrowthQuotePool; // getPool
  37 |     |     uint feeGrowthAssetPosition; // getPosition
  38 |     |     uint feeGrowthQuotePosition; // getPosition
  39 |     | }
  40 |     | 
  41 |     | interface TokenLike {
  42 |     |     function balanceOf(address) external view returns (uint);
  43 |     | }
  44 |     | 
  45 |     | contract HelperHyperView {
  46 | *r  |     function getPool(address hyper, uint64 poolId) internal view returns (HyperPool memory) {
  47 | *r  |         return IHyperStruct(hyper).pools(poolId);
  48 |     |     }
  49 |     | 
  50 |     |     function getCurve(address hyper, uint64 poolId) internal view returns (HyperCurve memory) {
  51 |     |         HyperPool memory pool = getPool(hyper, poolId);
  52 |     |         return pool.params;
  53 |     |     }
  54 |     | 
  55 | *r  |     function getPair(address hyper, uint24 pairId) internal view returns (HyperPair memory) {
  56 | *r  |         return IHyperStruct(hyper).pairs(pairId);
  57 |     |     }
  58 |     | 
  59 |     |     function getPosition(address hyper, address owner, uint64 positionId) internal view returns (HyperPosition memory) {
  60 |     |         return IHyperStruct(hyper).positions(owner, positionId);
  61 |     |     }
  62 |     | 
  63 | *r  |     function getReserve(address hyper, address token) internal view returns (uint) {
  64 | *r  |         return HyperLike(hyper).getReserve(token);
  65 |     |     }
  66 |     | 
  67 | *r  |     function getBalance(address hyper, address owner, address token) internal view returns (uint) {
  68 | *r  |         return HyperLike(hyper).getBalance(owner, token);
  69 |     |     }
  70 |     | 
  71 |     |     function _getPool(IHyperStruct hyper, uint64 poolId) internal view returns (HyperPool memory) {
  72 |     |         return (hyper).pools(poolId);
  73 |     |     }
  74 |     | 
  75 |     |     function _getPosition(
  76 |     |         IHyperStruct hyper,
  77 |     |         address owner,
  78 |     |         uint64 positionId
  79 |     |     ) internal view returns (HyperPosition memory) {
  80 |     |         return hyper.positions(owner, positionId);
  81 |     |     }
  82 |     | 
  83 |     |     function _getReserve(HyperLike hyper, TestERC20 token) internal view returns (uint) {
  84 |     |         return hyper.getReserve(address(token));
  85 |     |     }
  86 |     | 
  87 |     |     function _getBalance(HyperLike hyper, address owner, TestERC20 token) internal view returns (uint) {
  88 |     |         return hyper.getBalance(owner, address(token));
  89 |     |     }
  90 |     | 
  91 |     |     /** @dev Fetches pool state and account state for a single pool's tokens. */
  92 |     |     function getState(
  93 |     |         address hyper,
  94 |     |         uint64 poolId,
  95 |     |         address caller,
  96 |     |         address[] memory owners
  97 |     |     ) internal view returns (HyperState memory) {
  98 |     |         HyperPair memory pair = getPair(hyper, Processor.decodePairIdFromPoolId(poolId));
  99 |     |         address asset = pair.tokenAsset;
 100 |     |         address quote = pair.tokenQuote;
 101 |     | 
 102 |     |         HyperPool memory pool = getPool(hyper, poolId);
 103 |     |         HyperPosition memory position = getPosition(hyper, caller, poolId);
 104 |     | 
 105 |     |         HyperState memory state = HyperState(
 106 |     |             getReserve(hyper, asset),
 107 |     |             getReserve(hyper, quote),
 108 |     |             getPhysicalBalance(hyper, asset),
 109 |     |             getPhysicalBalance(hyper, quote),
 110 |     |             getBalanceSum(hyper, asset, owners),
 111 |     |             getBalanceSum(hyper, quote, owners),
 112 |     |             getPositionLiquiditySum(hyper, poolId, owners),
 113 |     |             position.freeLiquidity,
 114 |     |             pool.liquidity,
 115 |     |             pool.feeGrowthGlobalAsset,
 116 |     |             pool.feeGrowthGlobalQuote,
 117 |     |             position.feeGrowthAssetLast,
 118 |     |             position.feeGrowthQuoteLast
 119 |     |         );
 120 |     | 
 121 |     |         return state;
 122 |     |     }
 123 |     | 
 124 |     |     function getPhysicalBalance(address hyper, address token) internal view returns (uint) {
 125 |     |         return Operating.__balanceOf__(token, hyper);
 126 |     |     }
 127 |     | 
 128 |     |     function getVirtualBalance(address hyper, address token, address[] memory owners) internal view returns (uint) {
 129 |     |         uint sum = getReserve(hyper, token) + getBalanceSum(hyper, token, owners);
 130 |     |         return sum;
 131 |     |     }
 132 |     | 
 133 |     |     function getBalanceSum(address hyper, address token, address[] memory owners) internal view returns (uint) {
 134 |     |         uint sum;
 135 |     |         for (uint x; x != owners.length; ++x) {
 136 |     |             sum += getBalance(hyper, owners[x], token);
 137 |     |         }
 138 |     | 
 139 |     |         return sum;
 140 |     |     }
 141 |     | 
 142 |     |     function getPositionLiquiditySum(address hyper, uint64 poolId, address[] memory owners) internal view returns (uint) {
 143 |     |         uint sum;
 144 |     |         for (uint i; i != owners.length; ++i) {
 145 |     |             sum += getPosition(hyper, owners[i], poolId).freeLiquidity;
 146 |     |         }
 147 |     | 
 148 |     |         return sum;
 149 |     |     }
 150 |     | 
 151 |     |     function getMaxSwapLimit(bool sellAsset) internal pure returns (uint) {
 152 |     |         if (sellAsset) {
 153 |     |             // price goes down
 154 |     |             return 0;
 155 |     |         } else {
 156 |     |             // price goes up
 157 |     |             return type(uint).max;
 158 |     |         }
 159 |     |     }
 160 |     | }
 161 |     | 

/Users/nataliechin/GitHub/audits-2023/hyper/test/helpers/HyperTestOverrides.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/Hyper.sol";
   5 |     | import "contracts/HyperLib.sol";
   6 |     | import "contracts/test/TestERC20.sol";
   7 |     | 
   8 |     | contract HyperTimeOverride is Hyper {
   9 |     |     constructor(address weth) Hyper(weth) {}
  10 |     | 
  11 |     |     function _blockTimestamp() internal view override returns (uint128) {
  12 |     |         return uint128(timestamp);
  13 |     |     }
  14 |     | 
  15 |     |     function _liquidityPolicy() internal view override returns (uint) {
  16 |     |         return jitDelay;
  17 |     |     }
  18 |     | 
  19 |     |     // ===== Added ==== //
  20 |     | 
  21 |     |     uint public timestamp;
  22 |     |     uint public jitDelay;
  23 |     | 
  24 |     |     function setJitPolicy(uint delay) public {
  25 |     |         jitDelay = delay;
  26 |     |     }
  27 |     | 
  28 |     |     function setTimestamp(uint128 time) public {
  29 |     |         timestamp = time;
  30 |     |     }
  31 |     | 
  32 |     |     /** @dev Temp jump override for invariant tests. */
  33 |     |     function doJumpProcess(bytes calldata data) external payable lock interactions {
  34 |     |         Enigma._jumpProcess(data, super._process);
  35 |     |     }
  36 |     | }
  37 |     | 
  38 |     | /** @dev To catch reverts, external functions can be called by a contract that has a try-cactch. */
  39 |     | contract HyperCatchReverts is HyperTimeOverride {
  40 |     |     constructor(address weth) HyperTimeOverride(weth) {}
  41 |     | 
  42 |     |     // ===== Added ===== //
  43 |     | 
  44 |     |     /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */
  45 |     |     function jumpProcess(bytes calldata data) external payable lock interactions {
  46 |     |         Enigma._jumpProcess(data, super._process);
  47 |     |     }
  48 |     | 
  49 |     |     /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */
  50 |     |     function process(bytes calldata data) external payable lock interactions {
  51 |     |         super._process(data);
  52 |     |     }
  53 |     | 
  54 |     |     /** @dev Solidity does not support error catching with the fallback function, so we use this external function. */
  55 |     |     function mockFallback(bytes calldata data) external payable lock interactions {
  56 |     |         if (data[0] != Enigma.INSTRUCTION_JUMP) super._process(data);
  57 |     |         else Enigma._jumpProcess(data, super._process);
  58 |     |     }
  59 |     | }
  60 |     | 
  61 |     | contract RevertCatcher {
  62 |     |     HyperCatchReverts public hyper;
  63 |     | 
  64 |     |     constructor(address hyper_) {
  65 |     |         hyper = HyperCatchReverts(payable(hyper_));
  66 |     |     }
  67 |     | 
  68 |     |     receive() external payable {}
  69 |     | 
  70 |     |     function approve(address token, address spender) external {
  71 |     |         TestERC20(token).approve(spender, type(uint256).max);
  72 |     |     }
  73 |     | 
  74 |     |     function mockFallback(bytes calldata data) external payable returns (bool) {
  75 |     |         try hyper.mockFallback{value: msg.value}(data) {} catch (bytes memory reason) {
  76 |     |             assembly {
  77 |     |                 revert(add(32, reason), mload(reason))
  78 |     |             }
  79 |     |         }
  80 |     |         return true;
  81 |     |     }
  82 |     | 
  83 |     |     /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */
  84 |     |     function process(bytes calldata data) external payable returns (bool) {
  85 |     |         try hyper.process{value: msg.value}(data) {} catch (bytes memory reason) {
  86 |     |             assembly {
  87 |     |                 revert(add(32, reason), mload(reason))
  88 |     |             }
  89 |     |         }
  90 |     |         return true;
  91 |     |     }
  92 |     | 
  93 |     |     /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */
  94 |     |     function jumpProcess(bytes calldata data) external payable returns (bool) {
  95 |     |         try hyper.jumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {
  96 |     |             assembly {
  97 |     |                 revert(add(32, reason), mload(reason))
  98 |     |             }
  99 |     |         }
 100 |     |         return true;
 101 |     |     }
 102 |     | }
 103 |     | 

