/root/code/hyper/contracts/Assembly.sol
r   | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | /**
    | 
    |   -------------
    |   
    |   Using yul to handle low-level coversions
    |   can easily be a foot shotgun.
    | 
    |   We like the gas reductions.
    | 
    |   -------------
    | 
    |   Primitive™
    | 
    |  */
    | 
    | error CastOverflow(uint);
    | error InvalidLiquidity();
    | 
    | uint constant SECONDS_PER_DAY = 86_400 seconds;
*   | uint8 constant MIN_DECIMALS = 6;
*r  | uint8 constant MAX_DECIMALS = 18;
*   | 
*   | function isBetween(uint256 value, uint256 lower, uint256 upper) pure returns (bool valid) {
*   |     return __between(int256(value), int256(lower), int256(upper));
    | }
*   | 
*   | function __between(int256 value, int256 lower, int256 upper) pure returns (bool valid) {
    |     assembly {
    |         // Is `val` btwn lo and hi, inclusive?
*   |         function isValid(val, lo, hi) -> btwn {
*   |             btwn := iszero(sgt(mul(sub(val, lo), sub(val, hi)), 0)) // iszero(x > amount ? 1 : 0) ? true : false, (n - a) * (n - b) <= 0, n = amount, a = lower, b = upper
    |         }
    | 
*   |         valid := isValid(value, lower, upper)
    |     }
    | }
    | 
    | /** 
    | 
    |     @dev Reference:
    |     
    |     if (delta < 0) {
    |         output = input - uint128(-delta);
    |         if (output >= input) revert InvalidLiquidity();
    |     } else {
    |         output = input + uint128(delta);
    |         if (output < input) revert InvalidLiquidity();
    |     }
*   | */
    | function addSignedDelta(uint128 input, int128 delta) pure returns (uint128 output) {
    |     bytes memory revertData = abi.encodeWithSelector(InvalidLiquidity.selector);
*   |     assembly {
*   |         switch slt(delta, 0) // delta < 0 ? 1 : 0
    |         // negative delta
    |         case 1 {
    |             output := sub(input, add(not(delta), 1))
    |             switch slt(output, input) // output < input ? 1 : 0
    |             case 0 {
    |                 // not less than
    |                 revert(add(32, revertData), mload(revertData)) // 0x1fff9681
    |             }
    |         }
    |         // position delta
    |         case 0 {
    |             output := add(input, delta)
    |             switch slt(output, input) // (output < input ? 1 : 0) == 0 ? 1 : 0
    |             case 1 {
    |                 // less than
    |                 revert(add(32, revertData), mload(revertData)) // 0x1fff9681
    |             }
    |         }
    |     }
    | }
    | 
    | function computeCheckpoint(uint256 present, uint256 delta) pure returns (uint256 checkpoint) {
    |     checkpoint = present;
    | 
    |     if (delta != 0) {
    |         // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.
    |         assembly {
    |             checkpoint := add(present, delta)
    |         }
    |     }
    | }
    | 
    | function computeCheckpointDistance(uint256 present, uint256 past) pure returns (uint256 distance) {
    |     // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.
    |     assembly {
    |         distance := sub(present, past)
    |     }
    | }
*r  | 
    | function convertDaysToSeconds(uint amountDays) pure returns (uint amountSeconds) {
    |     assembly {
*r  |         amountSeconds := mul(amountDays, SECONDS_PER_DAY)
    |     }
    | }
    | 
    | function toBytes32(bytes memory raw) pure returns (bytes32 data) {
    |     assembly {
    |         data := mload(add(raw, 32))
    |         let shift := mul(sub(32, mload(raw)), 8)
    |         data := shr(shift, data)
    |     }
    | }
    | 
    | function toBytes16(bytes memory raw) pure returns (bytes16 data) {
    |     assembly {
    |         data := mload(add(raw, 32))
    |         let shift := mul(sub(16, mload(raw)), 8)
    |         data := shr(shift, data)
    |     }
    | }
*r  | 
    | function separate(bytes1 data) pure returns (bytes1 upper, bytes1 lower) {
*r  |     upper = data >> 4;
*r  |     lower = data & 0x0f;
    | }
    | 
    | function pack(bytes1 upper, bytes1 lower) pure returns (bytes1 data) {
    |     data = (upper << 4) | lower;
    | }
    | 
    | /**
    |  * @dev             Converts an array of bytes into an uint128, the array must adhere
    |  *                  to the the following format:
    |  *                  - First byte: Amount of trailing zeros.
    |  *                  - Rest of the array: A hexadecimal number.
*r  |  */
*r  | function toAmount(bytes calldata raw) pure returns (uint128 amount) {
    |     uint8 power = uint8(raw[0]);
    |     amount = uint128(toBytes16(raw[1:raw.length]));
*r  |     if (power != 0) amount = amount * uint128(10 ** power);
    | }
*r  | 
*r  | function computeScalar(uint decimals) pure returns (uint scalar) {
*r  |     return 10 ** (MAX_DECIMALS - decimals); // can revert on underflow
    | }
r   | 
r   | function scaleToWad(uint amountDec, uint decimals) pure returns (uint outputWad) {
r   |     uint factor = computeScalar(decimals);
    |     assembly {
r   |         outputWad := mul(amountDec, factor)
    |     }
    | }
    | 
    | function scaleFromWadUp(uint amountWad, uint decimals) pure returns (uint outputDec) {
    |     uint factor = computeScalar(decimals);
    |     assembly {
    |         outputDec := add(div(amountWad, factor), 1)
    |     }
    | }
*r  | 
*r  | function scaleFromWadDown(uint amountWad, uint decimals) pure returns (uint outputDec) {
*r  |     uint factor = computeScalar(decimals);
    |     assembly {
*r  |         outputDec := div(amountWad, factor)
    |     }
    | }
    | 
    | function scaleFromWadUpSigned(int amountWad, uint decimals) pure returns (int outputDec) {
    |     uint factor = computeScalar(decimals);
    |     assembly {
    |         outputDec := add(sdiv(amountWad, factor), 1)
    |     }
    | }
    | 
    | function scaleFromWadDownSigned(int amountWad, uint decimals) pure returns (int outputDec) {
    |     uint factor = computeScalar(decimals);
    |     assembly {
    |         outputDec := sdiv(amountWad, factor)
    |     }
    | }
    | 

/root/code/hyper/contracts/Enigma.sol
    | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | /**
    | 
    |   -------------
    |   
    |   This is called the Enigma, it's an alternative ABI.
    |   Originally, it was designed to compress calldata and therefore
    |   save gas on optimistic rollup networks.
    | 
    |   There are levels to the optimizations that can be made for it,
    |   but this one focuses on the alternative multicall: jump process.
    | 
    |   Multicalls will pad all calls to a full bytes32.
    |   This means two calls are at least 64 bytes.
    |   This alternative multicall can process over 10 calls in the same 64 bytes.
    |   The smallest bytes provided by a call is for allocate and unallocate, at 11 bytes.
    | 
    |   Multicalls also process transactions sequentially.
    |   State cannot be carried over transiently between transactions.
    |   With Enigma, we can transiently set state (only specific state),
    |   and use it across "instructions".
    | 
    |   Without jump instruction, this alternative encoding is overkill.
    | 
    |   Be aware of function selector hash collisions.
    |   Data is delivered via the `fallback` function.
    | 
    |   -------------
    | 
    |   Primitive™
    | 
    |  */
    | 
    | import "./Assembly.sol" as Assembly;
    | 
    | uint8 constant JUMP_PROCESS_START_POINTER = 2;
    | bytes1 constant UNKNOWN = 0x00;
    | bytes1 constant ALLOCATE = 0x01;
    | bytes1 constant UNSET00 = 0x02;
    | bytes1 constant UNALLOCATE = 0x03;
    | bytes1 constant UNSET01 = 0x04;
    | bytes1 constant SWAP = 0x05;
    | bytes1 constant STAKE_POSITION = 0x06;
    | bytes1 constant UNSTAKE_POSITION = 0x07;
    | bytes1 constant UNSET02 = 0x08;
    | bytes1 constant UNSET03 = 0x09;
    | bytes1 constant CREATE_POOL = 0x0B;
    | bytes1 constant CREATE_PAIR = 0x0C;
    | bytes1 constant UNSET04 = 0x0D;
    | bytes1 constant INSTRUCTION_JUMP = 0xAA;
    | 
    | error InvalidJump(uint256 pointer); // 0x80f63bd1
    | error InvalidBytesLength(uint256 expected, uint256 length); // 0xe19dc95e
*r  | 
    | function __startProcess__(function(bytes calldata) _process) {
*r  |     if (msg.data[0] != INSTRUCTION_JUMP) _process(msg.data);
    |     else _jumpProcess(msg.data, _process);
    | }
    | 
    | /** @dev  [jump instruction, instructions.length, pointer, ...instruction, pointer, ...etc] */
    | function _jumpProcess(bytes calldata data, function(bytes calldata) _process) {
    |     uint8 length = uint8(data[1]);
    |     uint8 pointer = JUMP_PROCESS_START_POINTER;
    |     uint256 start;
    |     // For each instruction set...
    |     for (uint256 i; i != length; ++i) {
    |         // Start at the index of the first byte of the next instruction.
    |         start = pointer;
    |         // Set the new pointer to the next instruction, located at the pointer.
    |         pointer = uint8(data[pointer]);
    |         // The `start:` includes the pointer byte, while the `:end` `pointer` is excluded.
    |         if (pointer > data.length) revert InvalidJump(pointer);
    |         bytes calldata instruction = data[start:pointer];
    |         // Process the instruction.
    |         _process(instruction[1:]); // note: Removes the pointer to the next instruction.
    |     }
    | }
    | 
    | function encodeJumpInstruction(bytes[] memory instructions) pure returns (bytes memory) {
    |     uint8 nextPointer;
    |     uint8 len = uint8(instructions.length);
    |     bytes memory payload = bytes.concat(INSTRUCTION_JUMP, bytes1(len));
    | 
    |     // for each instruction set...
    |     for (uint i; i != len; ++i) {
    |         bytes memory instruction = instructions[i];
    |         uint8 size = uint8(instruction.length);
    | 
    |         // Using instruction and index of instruction in list, we create a new array with a pointer to the next instruction in front of the instruction payload.
    |         if (i == 0) {
    |             nextPointer = size + 3; // [added0, instruction, added1, nextPointer]
    |         } else {
    |             nextPointer = nextPointer + size + 1; // [currentPointer, instruction, nextPointer]
    |         }
    | 
    |         bytes memory edited = bytes.concat(bytes1(nextPointer), instruction);
    |         payload = bytes.concat(payload, edited);
    |     }
    | 
    |     return payload;
    | }
    | 
    | function decodePairIdFromPoolId(uint64 poolId) pure returns (uint24) {
r   |     return uint24(poolId >> 40);
    | }
    | 
    | function encodePoolId(uint24 pairId, bool isMutable, uint32 poolNonce) pure returns (uint64) {
    |     return uint64(bytes8(abi.encodePacked(pairId, isMutable ? uint8(1) : uint8(0), poolNonce)));
    | }
    | 
    | function decodePoolId(
    |     bytes calldata data
    | ) pure returns (uint64 poolId, uint24 pairId, uint8 isMutable, uint32 poolNonce) {
    |     if (data.length != 8) revert InvalidBytesLength(8, data.length);
    |     poolId = uint64(bytes8(data));
    |     pairId = uint16(bytes2(data[:3]));
    |     isMutable = uint8(bytes1(data[3:4]));
    |     poolNonce = uint32(bytes4(data[4:]));
    | }
*   | 
*   | function encodeCreatePair(address token0, address token1) pure returns (bytes memory data) {
*   |     data = abi.encodePacked(CREATE_PAIR, token0, token1);
    | }
*   | 
*   | function decodeCreatePair(bytes calldata data) pure returns (address tokenAsset, address tokenQuote) {
*   |     if (data.length != 41) revert InvalidBytesLength(41, data.length);
*   |     tokenAsset = address(bytes20(data[1:21]));
*   |     tokenQuote = address(bytes20(data[21:]));
    | }
    | 
    | function encodeCreatePool(
    |     uint24 pairId,
    |     address controller,
    |     uint16 priorityFee,
    |     uint16 fee,
    |     uint16 vol,
    |     uint16 dur,
    |     uint16 jit,
    |     int24 max,
    |     uint128 price
    | ) pure returns (bytes memory data) {
    |     data = abi.encodePacked(CREATE_POOL, pairId, controller, priorityFee, fee, vol, dur, jit, max, price);
    | }
    | 
    | function decodeCreatePool(
    |     bytes calldata data
    | )
    |     pure
    |     returns (
    |         uint24 pairId,
    |         address controller,
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 vol,
    |         uint16 dur,
    |         uint16 jit,
    |         int24 max,
    |         uint128 price
    |     )
    | {
    |     if (data.length != 53) revert InvalidBytesLength(53, data.length);
    |     pairId = uint24(bytes3(data[1:4]));
    |     controller = address(bytes20(data[4:24]));
    |     priorityFee = uint16(bytes2(data[24:26]));
    |     fee = uint16(bytes2(data[26:28]));
    |     vol = uint16(bytes2(data[28:30]));
    |     dur = uint16(bytes2(data[30:32]));
    |     jit = uint16(bytes2(data[32:34]));
    |     max = int24(uint24(bytes3(data[34:37])));
    |     price = uint128(bytes16(data[37:]));
    | }
    | 
    | function encodeAllocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {
    |     data = abi.encodePacked(Assembly.pack(bytes1(useMax), ALLOCATE), poolId, power, amount);
    | }
    | 
    | function decodeAllocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {
    |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
    |     (bytes1 maxFlag, ) = Assembly.separate(data[0]);
    |     useMax = uint8(maxFlag);
    |     poolId = uint64(bytes8(data[1:9]));
    |     deltaLiquidity = Assembly.toAmount(data[9:]);
    | }
    | 
    | function encodeUnallocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {
    |     data = abi.encodePacked(Assembly.pack(bytes1(useMax), UNALLOCATE), poolId, power, amount);
    | }
r   | 
    | function decodeUnallocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {
    |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
    |     useMax = uint8(data[0] >> 4);
    |     poolId = uint64(bytes8(data[1:9]));
r   |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
    | }
    | 
    | function encodeSwap(
    |     uint8 useMax,
    |     uint64 poolId,
    |     uint8 power0,
    |     uint128 amount0,
    |     uint8 power1,
    |     uint128 amount1,
    |     uint8 direction
    | ) pure returns (bytes memory data) {
    |     //    pointerToAmount1 = instruction, poolId, pointer, power0, amount0, power1 {pointer}->
    |     uint8 pointerToAmount1 = 0x01 + 0x08 + 0x01 + 0x10 + 0x01;
    |     data = abi.encodePacked(
    |         Assembly.pack(bytes1(useMax), SWAP),
    |         poolId,
    |         pointerToAmount1,
    |         power0,
    |         amount0,
    |         power1,
    |         amount1,
    |         direction
    |     );
    | }
    | 
    | function decodeSwap(
    |     bytes calldata data
    | ) pure returns (uint8 useMax, uint64 poolId, uint128 input, uint128 limit, uint8 direction) {
    |     useMax = uint8(data[0] >> 4);
    |     poolId = uint64(bytes8(data[1:9]));
    |     uint8 pointer = uint8(data[9]);
    |     input = uint128(Assembly.toAmount(data[10:pointer]));
    |     limit = uint128(Assembly.toAmount(data[pointer:data.length - 1]));
    |     direction = uint8(data[data.length - 1]);
    | }
    | 
    | function encodeStakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {
    |     data = abi.encodePacked(STAKE_POSITION, poolId, deltaLiquidity);
    | }
*r  | 
r   | function decodeStakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {
r   |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
    |     poolId = uint64(bytes8(data[1:9]));
*   |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
    | }
    | 
    | function encodeUnstakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {
    |     data = abi.encodePacked(UNSTAKE_POSITION, poolId, deltaLiquidity);
    | }
    | 
    | function decodeUnstakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {
    |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
    |     poolId = uint64(bytes8(data[1:9]));
    |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
    | }
    | 

/root/code/hyper/contracts/Hyper.sol
    | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | /**
    | 
    |   ------------------------------------
    | 
    |   Hyper is a replicating market maker.
    | 
    |   ------------------------------------
    | 
    |   Primitive™
    | 
    |  */
    | 
    | import "./HyperLib.sol";
    | import "./interfaces/IWETH.sol";
    | import "./interfaces/IHyper.sol";
    | import "./interfaces/IERC20.sol";
*r  | 
    | contract Hyper is IHyper {
    |     using Price for Price.RMM;
    |     using SafeCastLib for uint;
    |     using FixedPointMathLib for int256;
    |     using FixedPointMathLib for uint256;
    |     using {Assembly.isBetween} for uint8;
    |     using {Assembly.scaleFromWadDownSigned} for int;
    |     using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;
    | 
*r  |     function VERSION() public pure returns (string memory) {
    |         assembly {
    |             // Load 0x20 (32) in memory at slot 0x00, this corresponds to the
    |             // offset location of the next data.
*   |             mstore(0x00, 0x20)
    | 
    |             // Then we load both the length of our string (11 bytes, 0x0b in hex) and its
    |             // actual hex value (0x626574612d76302e302e31) using the offset 0x2b. Using this
    |             // particular offset value will right pad the length at the end of the slot
    |             // and left pad the string at the beginning of the next slot, assuring the
    |             // right ABI format to return a string.
*   |             mstore(0x2b, 0x0b626574612d76302e302e31) // "beta-v0.0.1"
    | 
    |             // Return all the 96 bytes (0x60) of data that was loaded into the memory.
*   |             return(0x00, 0x60)
    |         }
    |     }
    | 
*   |     OS.AccountSystem public __account__;
    | 
    |     address public immutable WETH;
*   |     uint256 public getPairNonce;
*   |     uint256 public getPoolNonce;
    | 
*r  |     mapping(uint24 => HyperPair) public pairs;
    |     mapping(uint64 => HyperPool) public pools;
*   |     mapping(address => mapping(address => uint24)) public getPairId;
*   |     mapping(address => mapping(uint64 => HyperPosition)) public positions;
    | 
*   |     uint256 public locked = 1;
    |     Payment[] private _payments;
    |     SwapState private _state;
    | 
    |     modifier lock() {
*r  |         if (locked != 1) revert InvalidReentrancy();
    | 
*r  |         locked = 2;
    |         _;
*   |         locked = 1;
    |     }
    | 
    |     /** @dev Used on every external operation that touches tokens. */
    |     modifier interactions() {
*r  |         if (__account__.prepared) revert InvalidReentrancy();
*r  |         __account__.__wrapEther__(WETH); // Deposits msg.value ether, this contract receives WETH.
*r  |         __account__.prepared = false;
    |         _;
*r  |         __account__.prepared = true;
    | 
*r  |         _settlement();
    | 
*   |         if (!__account__.settled) revert InvalidSettlement();
    |     }
    | 
    |     constructor(address weth) {
    |         WETH = weth;
    |         __account__.settled = true;
    |     }
    | 
    |     receive() external payable {
*   |         if (msg.sender != WETH) revert();
    |     }
    | 
    |     /**  @dev Alternative entrypoint to process operations using encoded calldata transferred directly as `msg.data`. */
    |     fallback() external payable lock interactions {
*r  |         Enigma.__startProcess__(_process);
    |     }
    | 
    |     /** @dev balanceOf(token) - getReserve(token). If negative, you win. */
*r  |     function getNetBalance(address token) public view returns (int256) {
*r  |         return __account__.getNetBalance(token, address(this));
    |     }
    | 
    |     /** @dev Virtual balance of `token`. */
*   |     function getReserve(address token) public view returns (uint) {
*   |         return __account__.reserves[token];
    |     }
    | 
    |     /** @dev Internal balance of `owner` of `token`. */
*r  |     function getBalance(address owner, address token) public view returns (uint) {
*r  |         return __account__.balances[owner][token];
    |     }
    |     
    |     /** @dev Transient stored tokens */
*   |     function getWarm() public view returns (address[] memory warm) {
*   |         return __account__.warm;
    |     }
    | 
    | 
    |     // ===== Actions ===== //
    | 
    |     /// @inheritdoc IHyperActions
*r  |     function allocate(
    |         uint64 poolId,
    |         uint amount
r   |     ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {
r   |         bool useMax = amount == type(uint).max;
r   |         (deltaAsset, deltaQuote) = _allocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());
    |     }
    | 
    |     /// @inheritdoc IHyperActions
r   |     function unallocate(
    |         uint64 poolId,
    |         uint amount
r   |     ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {
r   |         bool useMax = amount == type(uint).max;
r   |         (deltaAsset, deltaQuote) = _unallocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());
    |     }
    | 
    |     /// @inheritdoc IHyperActions
r   |     function stake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {
r   |         _stake(poolId, deltaLiquidity);
    |     }
    | 
    |     /// @inheritdoc IHyperActions
r   |     function unstake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {
r   |         _unstake(poolId, deltaLiquidity);
    |     }
    | 
    |     /// @inheritdoc IHyperActions
r   |     function swap(
    |         uint64 poolId,
    |         bool sellAsset,
    |         uint amount,
    |         uint limit
r   |     ) external lock interactions returns (uint output, uint remainder) {
r   |         if (limit == type(uint256).max) limit = type(uint128).max;
r   |         bool useMax = amount == type(uint256).max; // magic variable.
r   |         uint128 input = useMax ? type(uint128).max : amount.safeCastTo128();
    |         (, remainder, , output) = _swapExactIn(
    |             Order({
    |                 useMax: useMax ? 1 : 0,
    |                 poolId: poolId,
    |                 input: input,
    |                 limit: limit.safeCastTo128(),
    |                 direction: sellAsset ? 0 : 1
    |             })
    |         );
    |     }
    | 
    |     /// @inheritdoc IHyperActions
r   |     function draw(address token, uint256 amount, address to) external lock interactions {
r   |         if (to == address(this)) revert InvalidTransfer(); // todo: Investigate attack vectors if this was not here.
r   |         if (amount > getBalance(msg.sender, token)) revert DrawBalance();
    | 
    |         _applyDebit(token, amount);
    |         _decreaseReserves(token, amount);
    | 
    |         if (token == WETH) OS.__dangerousUnwrapEther__(WETH, to, amount);
    |         else OS.SafeTransferLib.safeTransfer(OS.ERC20(token), to, amount);
    |     }
    | 
    |     /// @inheritdoc IHyperActions
r   |     function fund(address token, uint256 amount) external override lock interactions {
r   |         __account__.dangerousFund(token, address(this), amount); // transferFrom(msg.sender)
    |     }
    | 
    |     /// @inheritdoc IHyperActions
*   |     function deposit() external payable override lock interactions {
*   |         if (msg.value == 0) revert ZeroValue();
*   |         emit Deposit(msg.sender, msg.value);
    |         // interactions modifier does the work.
    |     }
    | 
    |     // todo: test
r   |     function claim(uint64 poolId, uint deltaAsset, uint deltaQuote) external lock interactions {
r   |         HyperPool memory pool = pools[poolId];
r   |         HyperPosition storage pos = positions[msg.sender][poolId];
r   |         if (pos.lastTimestamp == 0) revert NonExistentPosition(msg.sender, poolId);
    | 
    |         pos.syncPositionFees(pool.liquidity, pool.feeGrowthGlobalAsset, pool.feeGrowthGlobalQuote);
    |         pos.tokensOwedAsset -= deltaAsset.safeCastTo128();
    |         pos.tokensOwedQuote -= deltaQuote.safeCastTo128();
    | 
    |         if (deltaAsset > 0) _applyCredit(pool.pair.tokenAsset, deltaAsset); // todo: problem, what balance do fees accrue to?
    |         if (deltaQuote > 0) _applyCredit(pool.pair.tokenQuote, deltaQuote); // todo: add debit to this contract?
    | 
    |         pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward);
    |         uint128 deltaReward = pos.tokensOwedReward;
    |         pos.tokensOwedReward -= deltaReward;
    | 
    |         // todo: a hack that utilizes Hyper contract as a fee bucket for priority swaps.
    |         // Currently uses WETH as the reward token. However, these priority fees
    |         // are paid based on liquidity.
    |         // If 1 WAD of liquidity is worth a small amount, the priority fee cost
    |         // a lot relative to the liquidity's value.
    |         // A better change is making this reward token configurable.
    |         if (deltaReward > 0) {
    |             _applyCredit(WETH, deltaReward); // gift to `msg.sender`.
    |             if (getBalance(address(this), WETH) < deltaReward) revert InvalidReward();
    |             __account__.debit(address(this), WETH, deltaReward); // only place hyper's balance is used
    |         }
    | 
    |         emit Collect(
    |             poolId,
    |             msg.sender,
    |             deltaAsset,
    |             pool.pair.tokenAsset,
    |             deltaQuote,
    |             pool.pair.tokenQuote,
    |             deltaReward,
    |             WETH
    |         );
    |     }
    | 
    |     // ===== Effects ===== //
    | 
    |     /** @dev Increases virtal reserves and liquidity. Debits `msg.sender`. */
    |     function _allocate(
    |         bool useMax,
    |         uint64 poolId,
    |         uint128 deltaLiquidity
    |     ) internal returns (uint256 deltaAsset, uint256 deltaQuote) {
    |         HyperPool memory pool = pools[poolId];
    |         if (!pool.exists()) revert NonExistentPool(poolId);
    | 
    |         if (useMax) {
    |             deltaLiquidity = pool.getMaxLiquidity({
    |                 deltaAsset: getBalance(msg.sender, pool.pair.tokenAsset),
    |                 deltaQuote: getBalance(msg.sender, pool.pair.tokenQuote)
    |             });
    |         }
    | 
    |         if (deltaLiquidity == 0) revert ZeroLiquidity();
    |         (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(toInt128(deltaLiquidity)); // note: rounds up.
    | 
    |         ChangeLiquidityParams memory args = ChangeLiquidityParams({
    |             owner: msg.sender,
    |             poolId: poolId,
    |             timestamp: _blockTimestamp(),
    |             deltaAsset: deltaAsset,
    |             deltaQuote: deltaQuote,
    |             tokenAsset: pool.pair.tokenAsset,
    |             tokenQuote: pool.pair.tokenQuote,
    |             deltaLiquidity: toInt128(deltaLiquidity)
    |         });
    | 
    |         _changeLiquidity(args);
    |         emit Allocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);
    |     }
    | 
    |     /** @dev Reduces virtual reserves and liquidity. Credits `msg.sender`. */
    |     function _unallocate(
    |         bool useMax,
    |         uint64 poolId,
    |         uint128 deltaLiquidity
    |     ) internal returns (uint deltaAsset, uint deltaQuote) {
    |         if (useMax) deltaLiquidity = positions[msg.sender][poolId].freeLiquidity;
    |         if (deltaLiquidity == 0) revert ZeroLiquidity();
    | 
    |         HyperPool memory pool = pools[poolId];
    |         if (!pool.exists()) revert NonExistentPool(poolId);
    | 
    |         (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(-toInt128(deltaLiquidity)); // rounds down
    | 
    |         ChangeLiquidityParams memory args = ChangeLiquidityParams({
    |             owner: msg.sender,
    |             poolId: poolId,
    |             timestamp: _blockTimestamp(),
    |             deltaAsset: deltaAsset,
    |             deltaQuote: deltaQuote,
    |             tokenAsset: pool.pair.tokenAsset,
    |             tokenQuote: pool.pair.tokenQuote,
    |             deltaLiquidity: -toInt128(deltaLiquidity)
    |         });
    | 
    |         _changeLiquidity(args);
    |         emit Unallocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);
    |     }
    | 
    |     function _changeLiquidity(ChangeLiquidityParams memory args) internal returns (uint feeAsset, uint feeQuote) {
    |         (HyperPool storage pool, HyperPosition storage pos) = (pools[args.poolId], positions[args.owner][args.poolId]);
    | 
    |         (feeAsset, feeQuote) = pos.syncPositionFees(
    |             pool.liquidity,
    |             pool.feeGrowthGlobalAsset,
    |             pool.feeGrowthGlobalQuote
    |         );
    | 
    |         _changePosition(args);
    |     }
    | 
    |     /** @dev Changes position liquidity and timestamp. */
    |     function _changePosition(ChangeLiquidityParams memory args) internal {
    |         HyperPosition storage position = positions[args.owner][args.poolId];
    | 
    |         if (args.deltaLiquidity < 0) {
    |             uint distance = position.getTimeSinceChanged(_blockTimestamp());
    |             if (pools[args.poolId].params.jit > distance) revert JitLiquidity(distance);
    |         }
    | 
    |         position.changePositionLiquidity(args.timestamp, args.deltaLiquidity);
    | 
    |         _changePool(args);
    |     }
    | 
    |     /** @dev Changes virtual reserves and pool liquidity. Does not update timestamp of pool. */
    |     function _changePool(ChangeLiquidityParams memory args) internal {
    |         (address asset, address quote) = (args.tokenAsset, args.tokenQuote);
    | 
    |         pools[args.poolId].changePoolLiquidity(args.deltaLiquidity);
    | 
    |         if (args.deltaLiquidity < 0) {
    |             _decreaseReserves(asset, args.deltaAsset);
    |             _decreaseReserves(quote, args.deltaQuote);
    |         } else {
    |             // note: Reserves are used at the end of instruction processing to interactions transactions.
    |             _increaseReserves(asset, args.deltaAsset);
    |             _increaseReserves(quote, args.deltaQuote);
    |         }
    |     }
    | 
r   |     function _stake(uint64 poolId, uint128 deltaLiquidity) internal {
r   |         HyperPool storage pool = pools[poolId];
r   |         if (!pool.exists()) revert NonExistentPool(poolId);
    | 
    |         HyperPosition memory pos = positions[msg.sender][poolId];
    |         if (deltaLiquidity == 0) revert ZeroLiquidity();
    |         if (pos.freeLiquidity < deltaLiquidity) revert InsufficientPosition(poolId);
    | 
    |         uint feeEarned = _changeStake(poolId, toInt128(deltaLiquidity));
    |         pool.stakedLiquidityDelta += toInt128(deltaLiquidity);
    |         emit Stake(poolId, msg.sender, deltaLiquidity);
    |     }
    | 
r   |     function _unstake(uint64 poolId, uint128 deltaLiquidity) internal returns (uint feeEarned) {
r   |         HyperPool storage pool = pools[poolId];
r   |         if (!pool.exists()) revert NonExistentPool(poolId);
    | 
    |         uint timestamp = _blockTimestamp();
    |         HyperPosition memory pos = positions[msg.sender][poolId];
    |         if (pos.stakeTimestamp == 0) revert PositionNotStaked(poolId);
    |         if (pos.unstakeTimestamp > timestamp) revert StakeNotMature(poolId); // todo: Investigate if its okay to unstake whenever.
    | 
    |         feeEarned = _changeStake(poolId, -toInt128(deltaLiquidity));
    |         pool.stakedLiquidityDelta -= toInt128(deltaLiquidity);
    |         emit Unstake(poolId, msg.sender, deltaLiquidity);
    |     }
    | 
    |     function _changeStake(uint64 poolId, int128 deltaLiquidity) internal returns (uint feeEarned) {
    |         uint timestamp = _blockTimestamp();
    |         HyperPool memory pool = pools[poolId];
    |         HyperPosition storage pos = positions[msg.sender][poolId];
    |         if (pos.stakeTimestamp == 0) pos.stakeTimestamp = timestamp.safeCastTo32();
    |         if (pos.unstakeTimestamp == 0) pos.unstakeTimestamp = pool.params.maturity();
    | 
    |         feeEarned = pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward); // must apply before liquidity changes.
    |         pos.changePositionLiquidity(timestamp, -deltaLiquidity);
    |         pos.stakedLiquidity = Assembly.addSignedDelta(pos.stakedLiquidity, deltaLiquidity);
    |     }
    | 
    |     // ===== Swaps ===== //
    | 
    |     /** * @dev Swaps in direction (0 or 1) exact input of tokens (0 = asset, 1 = quote) for output of tokens (0 = quote, 1 = asset) up to limit price. */
    |     function _swapExactIn(
    |         Order memory args
    |     ) internal returns (uint64 poolId, uint256 remainder, uint256 input, uint256 output) {
    |         if (args.input == 0) revert ZeroInput();
    | 
    |         HyperPool storage pool = pools[args.poolId];
    |         if (!pool.exists()) revert NonExistentPool(args.poolId);
    | 
    |         _state.sell = args.direction == 0; // 0: asset -> quote, 1: quote -> asset
    |         _state.fee = msg.sender == pool.controller ? pool.params.priorityFee : uint(pool.params.fee);
    |         _state.feeGrowthGlobal = _state.sell ? pool.feeGrowthGlobalAsset : pool.feeGrowthGlobalQuote;
    |         _state.tokenInput = _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote;
    |         _state.tokenOutput = _state.sell ? pool.pair.tokenQuote : pool.pair.tokenAsset;
    | 
    |         Price.RMM memory rmm = Price.RMM({strike: pool.params.strike(), sigma: pool.params.volatility, tau: 0});
    |         Iteration memory _swap;
    |         {
    |             (uint256 price, int24 tick, uint updatedTau) = _computeSyncedPrice(args.poolId);
    |             rmm.tau = updatedTau;
    | 
    |             uint internalBalance = getBalance(msg.sender, _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote);
    |             remainder = args.useMax == 1 ? internalBalance : args.input;
    |             remainder = remainder.scaleToWad(_state.sell ? pool.pair.decimalsAsset : pool.pair.decimalsQuote); // WAD
    |             _swap = Iteration({
    |                 price: price,
    |                 tick: tick,
    |                 feeAmount: 0,
    |                 remainder: remainder,
    |                 liquidity: pool.liquidity,
    |                 input: 0,
    |                 output: 0
    |             });
    |         }
    |         if (rmm.tau == 0) revert PoolExpired();
    | 
    |         // =---= Effects =---= //
    | 
    |         // These are WAD values.
    |         uint256 liveIndependent;
    |         uint256 nextIndependent;
    |         uint256 liveDependent;
    |         uint256 nextDependent;
    |         uint priorityFeeAmount;
    | 
    |         {
    |             uint256 maxInput;
    |             uint256 deltaInput;
    | 
    |             // Virtual reserves
    |             if (_state.sell) {
    |                 (liveDependent, liveIndependent) = rmm.computeReserves(_swap.price);
r   |                 maxInput = (FixedPointMathLib.WAD - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.
    |             } else {
    |                 (liveIndependent, liveDependent) = rmm.computeReserves(_swap.price);
    |                 maxInput = (rmm.strike - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.
    |             }
    | 
    |             priorityFeeAmount = msg.sender == pool.controller ? (pool.liquidity * _state.fee) / 10_000 : 0;
    |             _swap.feeAmount = priorityFeeAmount != 0
    |                 ? 0
    |                 : ((_swap.remainder > maxInput ? maxInput : _swap.remainder) * _state.fee) / 10_000;
    |             _state.feeGrowthGlobal = FixedPointMathLib.divWadDown(_swap.feeAmount, _swap.liquidity);
    |             if (priorityFeeAmount != 0) _state.priorityFeeGrowthGlobal = priorityFeeAmount.divWadDown(_swap.liquidity); // todo: change to staked liquidity
    | 
    |             if (_swap.remainder > maxInput) {
    |                 deltaInput = maxInput - _swap.feeAmount;
    |                 nextIndependent = liveIndependent + deltaInput.divWadDown(_swap.liquidity);
    |                 _swap.remainder -= (deltaInput + _swap.feeAmount);
    |             } else {
    |                 deltaInput = _swap.remainder - _swap.feeAmount;
    |                 nextIndependent = liveIndependent + deltaInput.divWadDown(_swap.liquidity);
    |                 deltaInput = _swap.remainder; // Swap input amount including the fee payment.
    |                 _swap.remainder = 0; // Clear the remainder to zero, as the order has been filled.
    |             }
    | 
    |             // Compute the output of the swap by computing the difference between the dependent reserves.
    |             if (_state.sell) nextDependent = rmm.getYWithX(nextIndependent);
    |             else nextDependent = rmm.getXWithY(nextIndependent);
    | 
    |             _swap.input += deltaInput;
    |             _swap.output += (liveDependent - nextDependent);
    |         }
    | 
    |         {
    |             uint256 nextPrice;
    |             uint256 limitPrice = args.limit;
    |             int256 liveInvariantWad;
    |             int256 nextInvariantWad;
    | 
    |             if (_state.sell) {
    |                 liveInvariantWad = rmm.invariantOf(liveDependent, liveIndependent);
    |                 nextInvariantWad = rmm.invariantOf(nextDependent, nextIndependent);
    |                 nextPrice = rmm.getPriceWithX(nextIndependent);
    |             } else {
    |                 liveInvariantWad = rmm.invariantOf(liveIndependent, liveDependent);
    |                 nextInvariantWad = rmm.invariantOf(nextIndependent, nextDependent);
    |                 nextPrice = rmm.getPriceWithX(nextDependent);
    |             }
    | 
    |             if (!_state.sell && nextPrice > limitPrice) revert SwapLimitReached();
    |             if (_state.sell && limitPrice > nextPrice) revert SwapLimitReached();
    | 
    |             liveInvariantWad = liveInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote); // invariant is denominated in quote token.
    |             nextInvariantWad = nextInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote);
    |             if (nextInvariantWad < liveInvariantWad) revert InvalidInvariant(liveInvariantWad, nextInvariantWad);
    | 
    |             _swap.price = (nextPrice * 10_000_001) / 10_000_000; // todo: this prevents failure in fuzz tests, investigate further. Related to precision.
    |         }
    | 
    |         {
    |             uint inputDec;
    |             uint outputDec;
    |             if (_state.sell) {
    |                 inputDec = pool.pair.decimalsAsset;
    |                 outputDec = pool.pair.decimalsQuote;
    |             } else {
    |                 inputDec = pool.pair.decimalsQuote;
    |                 outputDec = pool.pair.decimalsAsset;
    |             }
    | 
    |             _swap.input = _swap.input.scaleFromWadUp(inputDec);
    |             _swap.output = _swap.output.scaleFromWadDown(outputDec);
    |         }
    | 
    |         // Apply pool effects.
    |         _syncPool(
    |             args.poolId,
    |             Price.computeTickWithPrice(_swap.price),
    |             _swap.price,
    |             _swap.liquidity,
    |             _state.sell ? _state.feeGrowthGlobal : 0,
    |             _state.sell ? 0 : _state.feeGrowthGlobal,
    |             _state.priorityFeeGrowthGlobal
    |         );
    | 
    |         _increaseReserves(_state.tokenInput, _swap.input);
    |         _decreaseReserves(_state.tokenOutput, _swap.output);
    | 
    |         // Apply reserve effects.
    |         if (priorityFeeAmount != 0) {
    |             // Uses hyper's internal balance as a fee bucket for priority swaps.
    |             // todo: investigate two different pools accruing priority rewards in the same bucket,
    |             // and if it's possible to "steal" another pool's accrued priority rewards.
    |             _increaseReserves(WETH, priorityFeeAmount);
    |             emit IncreaseUserBalance(address(this), WETH, priorityFeeAmount);
    |             __account__.credit(address(this), WETH, priorityFeeAmount);
    |         }
    | 
    |         emit Swap(args.poolId, _swap.price, _state.tokenInput, _swap.input, _state.tokenOutput, _swap.output);
    | 
    |         delete _state;
    |         return (args.poolId, _swap.remainder, _swap.input, _swap.output);
    |     }
    | 
    |     /**
    |      * @dev Computes the price of the pool, which changes over time.
    |      *
    |      * @custom:reverts Underflows if the reserve of the input token is lower than the next one, after the next price movement.
    |      * @custom:reverts Underflows if current reserves of output token is less then next reserves.
    |      */
r   |     function _computeSyncedPrice(uint64 poolId) internal view returns (uint256 price, int24 tick, uint updatedTau) {
r   |         HyperPool memory pool = pools[poolId];
r   |         if (!pool.exists()) revert NonExistentPool(poolId);
    | 
    |         (price, tick, updatedTau) = (pool.lastPrice, pool.lastTick, pool.tau(_blockTimestamp()));
    | 
    |         uint passed = getTimePassed(poolId);
    |         if (passed > 0) {
    |             uint256 lastTau = pool.lastTau(); // pool.params.maturity() - pool.lastTimestamp.
    |             (price, tick) = pool.computePriceChangeWithTime(lastTau, passed);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Effects on a Pool after a successful swap order condition has been met.
    |      */
    |     function _syncPool(
    |         uint64 poolId,
    |         int24 tick,
    |         uint256 price,
    |         uint256 liquidity,
    |         uint256 feeGrowthGlobalAsset,
    |         uint256 feeGrowthGlobalQuote,
    |         uint256 feeGrowthGlobalReward
    |     ) internal returns (uint256 timeDelta) {
    |         HyperPool storage pool = pools[poolId];
    | 
    |         uint256 timestamp = _blockTimestamp();
    |         timeDelta = getTimePassed(poolId);
    | 
    |         // todo: better configuration of this value?
    |         uint requiredTimePassedForStake = 1;
    |         if (timeDelta >= requiredTimePassedForStake) {
    |             pool.stakedLiquidity = Assembly.addSignedDelta(pool.stakedLiquidity, pool.stakedLiquidityDelta);
    |             pool.stakedLiquidityDelta = 0;
    |         }
    | 
    |         if (pool.lastTick != tick) pool.lastTick = tick;
    |         if (pool.lastPrice != price) pool.lastPrice = price.safeCastTo128();
    |         if (pool.liquidity != liquidity) pool.liquidity = liquidity.safeCastTo128();
    |         if (pool.lastTimestamp != timestamp) pool.syncPoolTimestamp(timestamp);
    | 
    |         pool.feeGrowthGlobalAsset = Assembly.computeCheckpoint(pool.feeGrowthGlobalAsset, feeGrowthGlobalAsset);
    |         pool.feeGrowthGlobalQuote = Assembly.computeCheckpoint(pool.feeGrowthGlobalQuote, feeGrowthGlobalQuote);
    |         pool.feeGrowthGlobalReward = Assembly.computeCheckpoint(pool.feeGrowthGlobalReward, feeGrowthGlobalReward);
    |     }
    | 
    |     // ===== Initializing Pools ===== //
    | 
*   |     function _createPair(address asset, address quote) internal returns (uint24 pairId) {
*   |         if (asset == quote) revert SameTokenError();
    | 
*   |         pairId = getPairId[asset][quote];
*   |         if (pairId != 0) revert PairExists(pairId);
    | 
*   |         (uint8 decimalsAsset, uint8 decimalsQuote) = (IERC20(asset).decimals(), IERC20(quote).decimals());
*   |         if (!decimalsAsset.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))
    |             revert InvalidDecimals(decimalsAsset);
*   |         if (!decimalsQuote.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))
    |             revert InvalidDecimals(decimalsQuote);
    | 
    |         unchecked {
*   |             pairId = uint24(++getPairNonce);
    |         }
    | 
*   |         getPairId[asset][quote] = pairId; // note: order of tokens matters!
*   |         pairs[pairId] = HyperPair({
    |             tokenAsset: asset,
    |             decimalsAsset: decimalsAsset,
    |             tokenQuote: quote,
    |             decimalsQuote: decimalsQuote
    |         });
    | 
*   |         emit CreatePair(pairId, asset, quote, decimalsAsset, decimalsQuote);
    |     }
    | 
    |     /** @dev If pairId == 0, its a magic variable that uses current pair nonce. */
    |     function _createPool(
    |         uint24 pairId,
    |         address controller,
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 vol,
    |         uint16 dur,
    |         uint16 jit,
    |         int24 max,
    |         uint128 price
    |     ) internal returns (uint64 poolId) {
    |         if (price == 0) revert ZeroPrice(); 
    | 
    |         uint32 timestamp = uint(_blockTimestamp()).safeCastTo32();
    |         HyperPool memory pool;
    |         pool.controller = controller;
    |         pool.lastTimestamp = timestamp;
    |         pool.lastPrice = price;
    |         pool.lastTick = Price.computeTickWithPrice(pool.lastPrice);
    |         bool hasController = pool.controller != address(0);
    |         if (hasController && priorityFee == 0) revert InvalidFee(priorityFee); // Cannot set priority to 0.
    | 
    |         uint24 pairNonce = pairId == 0 ? uint24(getPairNonce) : pairId; // magic variable todo: fix, possible to set 0 pairId if getPairNonce is 0
    |         pool.pair = pairs[pairNonce];
    | 
    |         HyperCurve memory params = HyperCurve({
    |             maxTick: max,
    |             jit: hasController ? jit : uint8(_liquidityPolicy()),
    |             fee: fee,
    |             duration: dur,
    |             volatility: vol,
    |             priorityFee: hasController ? priorityFee : 0, // min fee
    |             createdAt: timestamp
    |         });
    |         params.validateParameters();
    |         pool.params = params;
    | 
    |         uint32 poolNonce;
    |         unchecked {
    |             poolNonce = uint32(++getPoolNonce);
    |         }
    | 
    |         poolId = Enigma.encodePoolId(pairNonce, hasController, poolNonce);
    |         if (pools[poolId].exists()) revert PoolExists(); // todo: poolNonce always increments, so this never gets hit, remove
    | 
    |         pools[poolId] = pool; // effect
    | 
    |         emit CreatePool(poolId, hasController, pool.pair.tokenAsset, pool.pair.tokenQuote, price);
    |     }
    | 
r   |     function changeParameters(
    |         uint64 poolId,
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 volatility,
    |         uint16 duration,
    |         uint16 jit,
    |         int24 maxTick
    |     ) external lock interactions {
r   |         HyperPool storage pool = pools[poolId];
r   |         if (pool.controller != msg.sender) revert NotController();
    | 
    |         HyperCurve memory modified = pool.params;
    |         if (jit != 0) modified.jit = jit;
    |         if (maxTick != 0) modified.maxTick = maxTick;
    |         if (fee != 0) modified.fee = fee;
    |         if (volatility != 0) modified.volatility = volatility;
    |         if (duration != 0) modified.duration = duration;
    |         if (priorityFee != 0) modified.priorityFee = priorityFee;
    | 
    |         pool.changePoolParameters(modified);
    | 
    |         emit ChangeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
    |     }
    | 
    |     /** @dev Overridable in tests.  */
r   |     function _blockTimestamp() internal view virtual returns (uint128) {
*r  |         return uint128(block.timestamp);
    |     }
    | 
    |     /** @dev Overridable in tests.  */
    |     function _liquidityPolicy() internal view virtual returns (uint256) {
    |         return JUST_IN_TIME_LIQUIDITY_POLICY;
    |     }
    | 
    |     // ===== Accounting System ===== //
    |     /**
    |      * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.
    |      *
    |      * @custom:security Directly manipulates reserves.
    |      */
    |     function _increaseReserves(address token, uint256 amount) internal {
    |         __account__.increase(token, amount);
    |         emit IncreaseReserveBalance(token, amount);
    |     }
    | 
    |     /**
    |      * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.
    |      *
    |      * @custom:security Directly manipulates reserves.
    |      * @custom:reverts With `InsufficientReserve` if current reserve balance for `token` iss less than `amount`.
    |      */
    |     function _decreaseReserves(address token, uint256 amount) internal {
    |         __account__.decrease(token, amount);
    |         emit DecreaseReserveBalance(token, amount);
    |     }
    | 
    |     /**
    |      * @dev A positive credit is a receivable paid to the `msg.sender` internal balance.
    |      *      Positive credits are only applied to the internal balance of the account.
    |      *      Therefore, it does not require a state change for the global reserves.
    |      *
    |      * @custom:security Directly manipulates intrernal balances.
    |      */
    |     function _applyCredit(address token, uint256 amount) internal {
    |         __account__.credit(msg.sender, token, amount);
    |         emit IncreaseUserBalance(msg.sender, token, amount);
    |     }
    | 
    |     /**
    |      * @dev A positive debit is a cost that must be paid for a transaction to be processed.
    |      *      If a balance exists for the token for the internal balance of `msg.sender`,
    |      *      it will be used to pay the debit. Else, the contract expects tokens to be transferred in.
    |      *
    |      * @custom:security Directly manipulates intrernal balances.
    |      */
    |     function _applyDebit(address token, uint256 amount) internal {
    |         __account__.debit(msg.sender, token, amount);
    |         emit DecreaseUserBalance(msg.sender, token, amount);
    |     }
    | 
    |     /**
    |      * @dev Alternative entrypoint to execute functions.
    |      * @param data Encoded Enigma data. First byte must be an Enigma instruction.
    |      */
*r  |     function _process(bytes calldata data) internal {
*r  |         (, bytes1 instruction) = Assembly.separate(data[0]); // Upper byte is useMax, lower byte is instruction.
    | 
*r  |         if (instruction == Enigma.ALLOCATE) {
    |             (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeAllocate(data);
    |             _allocate(useMax == 1, poolId, deltaLiquidity);
*r  |         } else if (instruction == Enigma.UNALLOCATE) {
    |             (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnallocate(data);
    |             _unallocate(useMax == 1, poolId, deltaLiquidity);
*r  |         } else if (instruction == Enigma.SWAP) {
    |             Order memory args;
    |             (args.useMax, args.poolId, args.input, args.limit, args.direction) = Enigma.decodeSwap(data);
    |             _swapExactIn(args);
*r  |         } else if (instruction == Enigma.STAKE_POSITION) {
r   |             (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeStakePosition(data);
r   |             _stake(poolId, deltaLiquidity);
*   |         } else if (instruction == Enigma.UNSTAKE_POSITION) {
    |             (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnstakePosition(data);
*   |             _unstake(poolId, deltaLiquidity);
*   |         } else if (instruction == Enigma.CREATE_POOL) {
    |             (
    |                 uint24 pairId,
    |                 address controller,
    |                 uint16 priorityFee,
    |                 uint16 fee,
    |                 uint16 vol,
    |                 uint16 dur,
    |                 uint16 jit,
    |                 int24 max,
    |                 uint128 price
    |             ) = Enigma.decodeCreatePool(data);
    |             _createPool(pairId, controller, priorityFee, fee, vol, dur, jit, max, price);
*r  |         } else if (instruction == Enigma.CREATE_PAIR) {
*   |             (address asset, address quote) = Enigma.decodeCreatePair(data);
*   |             _createPair(asset, quote);
    |         } else {
    |             revert InvalidInstruction();
    |         }
    |     }
    | 
    |     /**
    | 
    |         Be aware of these settlement invariants:
    | 
    |         Invariant 1. Every token that is interacted with is cached and exists.
    |         Invariant 2. Tokens are removed from cache, and cache is empty by end of settlement.
    |         Invariant 3. Cached tokens cannot be carried over from previous transactions.
    |         Invariant 4. Execution does not exit during the loops prematurely.
    |         Invariant 5. Account `settled` bool is set to true at end of `settlement`.
    |         Invariant 6. Debits reduce `reserves` of `token`.
    | 
    |      */
*r  |     function _settlement() internal {
*r  |         if (!__account__.prepared) revert OS.NotPreparedToSettle();
    | 
*r  |         address[] memory tokens = __account__.warm;
*r  |         uint256 loops = tokens.length;
*r  |         if (loops == 0) return __account__.reset(); // exit early.
    | 
*r  |         uint x;
*r  |         uint i = loops;
*r  |         do {
    |             // Loop backwards to pop tokens off.
*r  |             address token = tokens[i - 1];
    |             // Apply credits or debits to net balance.
*r  |             (uint credited, uint debited, uint remainder) = __account__.settle(token, address(this));
    |             // Reserves were increased, we paid a debit, therefore need to decrease reserves by `debited` amount.
*   |             if (debited > 0) {
    |                 emit DecreaseUserBalance(msg.sender, token, debited);
    |                 emit DecreaseReserveBalance(token, debited);
    |             }
    |             // Reserves were not tracking some tokens, increase the reserves to account for them.
*   |             if (credited > 0) {
*   |                 emit IncreaseUserBalance(msg.sender, token, credited);
*   |                 emit IncreaseReserveBalance(token, credited);
    |             }
    |             // Outstanding amount must be transferred in.
*   |             if (remainder > 0) _payments.push(Payment({token: token, amount: remainder}));
    |             // Token accounted for.
*   |             __account__.warm.pop();
    |             unchecked {
*   |                 --i;
*   |                 ++x;
    |             }
*   |         } while (i != 0);
    | 
*   |         Payment[] memory payments = _payments;
    | 
*   |         uint px = payments.length;
*   |         while (px != 0) {
    |             uint index = px - 1;
    |             OS.__dangerousTransferFrom__(payments[index].token, address(this), payments[index].amount);
    |             unchecked {
    |                 --px;
    |             }
    |         }
    | 
*   |         __account__.reset();
*   |         delete _payments;
    |     }
    | 
    |     // ===== View ===== //
    | 
    |     /** @dev Can be manipulated. */
r   |     function getLatestPrice(uint64 poolId) public view returns (uint price) {
r   |         (price, , ) = _computeSyncedPrice(poolId);
    |     }
    | 
*   |     function getTimePassed(uint64 poolId) public view returns (uint) {
*   |         return _blockTimestamp() - pools[poolId].lastTimestamp;
    |     }
    | 
*   |     function getVirtualReserves(uint64 poolId) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {
*   |         return pools[poolId].getVirtualReserves();
    |     }
    | 
*r  |     function getMaxLiquidity(
    |         uint64 poolId,
    |         uint deltaAsset,
    |         uint deltaQuote
r   |     ) public view override returns (uint128 deltaLiquidity) {
*r  |         return pools[poolId].getMaxLiquidity(deltaAsset, deltaQuote);
    |     }
    | 
*   |     function getLiquidityDeltas(
    |         uint64 poolId,
    |         int128 deltaLiquidity
    |     ) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {
    |         return pools[poolId].getLiquidityDeltas(deltaLiquidity);
    |     }
    | 
*   |     function getAmounts(uint64 poolId) public view override returns (uint256 deltaAsset, uint256 deltaQuote) {
*   |         return pools[poolId].getAmounts();
    |     }
    | 
r   |     function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) public view returns (uint output) {
r   |         uint24 pairId = Enigma.decodePairIdFromPoolId(poolId);
r   |         HyperPool memory pool = pools[poolId];
r   |         (output, ) = pool.getAmountOut({
r   |             pair: pairs[pairId],
r   |             sellAsset: sellAsset,
r   |             amountIn: amountIn,
r   |             timeSinceUpdate: _blockTimestamp() - pool.lastTimestamp // invariant: should not underflow.
    |         });
    |     }
    | }
    | 

/root/code/hyper/contracts/HyperLib.sol
    | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | /**
    | 
    |   -------------
    | 
    |   Comprehensive library with all structs, errors,
    |   constants, and utils for Hyper.
    | 
    |   -------------
    | 
    |   Primitive™
    | 
    |  */
    | 
    | import "solmate/utils/SafeCastLib.sol";
    | import "./libraries/Price.sol";
    | import "./Assembly.sol" as Assembly;
    | import "./Enigma.sol" as Enigma;
    | import "./OS.sol" as OS;
    | 
    | using Price for Price.RMM;
    | using SafeCastLib for uint;
    | using FixedPointMathLib for uint;
    | using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;
    | using {checkParameters, maturity, strike, validateParameters} for HyperCurve global;
    | using {changePositionLiquidity, syncPositionFees, getTimeSinceChanged, syncPositionStakedFees} for HyperPosition global;
    | using {
    |     changePoolLiquidity,
    |     changePoolParameters,
    |     computePriceChangeWithTime,
    |     exists,
    |     getAmounts,
    |     getAmountOut,
    |     getAmountsWad,
    |     getLiquidityDeltas,
    |     getMaxLiquidity,
    |     getMaxSwapAssetInWad,
    |     getMaxSwapQuoteInWad,
    |     getRMM,
    |     getVirtualReserves,
    |     isMutable,
    |     syncPoolTimestamp,
    |     lastTau,
    |     tau
    | } for HyperPool global;
    | 
    | int24 constant MAX_TICK = 887272;
    | uint256 constant BUFFER = 300 seconds;
    | uint256 constant MIN_FEE = 1; // 0.01%
    | uint256 constant MAX_FEE = 1000; // 10%
    | uint256 constant MIN_VOLATILITY = 100; // 1%
    | uint256 constant MAX_VOLATILITY = 25_000; // 250%
    | uint256 constant MIN_DURATION = 1; // days, but without units
    | uint256 constant MAX_DURATION = 500; // days, but without units
    | uint256 constant JUST_IN_TIME_MAX = 600 seconds;
    | uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;
    | 
    | // todo: add selectors for debugging?
    | error DrawBalance();
    | error InsufficientPosition(uint64 poolId);
    | error InvalidDecimals(uint8 decimals);
    | error InvalidDuration(uint16);
    | error InvalidFee(uint16 fee);
    | error InvalidInstruction();
    | error InvalidInvariant(int256 prev, int256 next);
    | error InvalidJit(uint16);
    | error InvalidReentrancy();
    | error InvalidReward();
    | error InvalidSettlement();
    | error InvalidStrike(uint128 strike);
    | error InvalidTick(int24);
    | error InvalidTransfer();
    | error InvalidVolatility(uint24 sigma); // todo: fix, use uint16 type.
    | error JitLiquidity(uint256 distance);
    | error MaxFee(uint16 fee);
    | error NotController();
    | error NonExistentPool(uint64 poolId);
    | error NonExistentPosition(address owner, uint64 poolId);
    | error PairExists(uint24 pairId);
    | error PerLiquidityError(uint256 deltaAsset);
    | error PoolExists();
    | error PoolExpired();
    | error PositionStaked(uint96 positionId);
    | error PositionZeroLiquidity(uint96 positionId);
    | error PositionNotStaked(uint96 positionId);
    | error SameTokenError();
    | error StakeNotMature(uint64 poolId);
    | error SwapLimitReached();
    | error ZeroInput();
    | error ZeroLiquidity();
    | error ZeroPrice();
    | error ZeroValue();
    | 
    | struct HyperPair {
    |     address tokenAsset;
    |     uint8 decimalsAsset;
    |     address tokenQuote;
    |     uint8 decimalsQuote;
    | }
    | 
    | struct HyperCurve {
    |     // single slot
    |     int24 maxTick;
    |     uint16 jit;
    |     uint16 fee;
    |     uint16 duration;
    |     uint16 volatility;
    |     uint16 priorityFee;
    |     uint32 createdAt;
    | }
    | 
    | struct HyperPool {
    |     int24 lastTick;
    |     uint32 lastTimestamp; // updated on swaps.
    |     address controller;
    |     uint256 feeGrowthGlobalReward;
    |     uint256 feeGrowthGlobalAsset;
    |     uint256 feeGrowthGlobalQuote;
    |     uint128 lastPrice;
    |     uint128 liquidity; // available liquidity to remove
    |     uint128 stakedLiquidity; // locked liquidity
    |     int128 stakedLiquidityDelta; // liquidity to be added or removed
    |     HyperCurve params;
    |     HyperPair pair;
    | }
    | 
    | // todo: optimize slot
    | struct HyperPosition {
    |     uint128 freeLiquidity;
    |     uint128 stakedLiquidity;
    |     uint256 lastTimestamp;
    |     uint256 stakeTimestamp;
    |     uint256 unstakeTimestamp;
    |     uint256 feeGrowthRewardLast;
    |     uint256 feeGrowthAssetLast;
    |     uint256 feeGrowthQuoteLast;
    |     uint128 tokensOwedAsset;
    |     uint128 tokensOwedQuote;
    |     uint128 tokensOwedReward;
    | }
    | 
    | struct ChangeLiquidityParams {
    |     address owner;
    |     uint64 poolId;
    |     uint256 timestamp;
    |     uint256 deltaAsset;
    |     uint256 deltaQuote;
    |     address tokenAsset;
    |     address tokenQuote;
    |     int128 deltaLiquidity;
    | }
    | 
    | struct Order {
    |     uint8 useMax;
    |     uint64 poolId;
    |     uint128 input;
    |     uint128 limit;
    |     uint8 direction;
    | }
    | 
    | struct Iteration {
    |     int24 tick;
    |     uint256 price;
    |     uint256 remainder;
    |     uint256 feeAmount;
    |     uint256 liquidity;
    |     uint256 input;
    |     uint256 output;
    | }
    | 
    | struct SwapState {
    |     bool sell;
    |     address tokenInput;
    |     address tokenOutput;
    |     uint256 fee;
    |     uint256 feeGrowthGlobal;
    |     uint256 priorityFeeGrowthGlobal;
    | }
    | 
    | struct Payment {
    |     address token;
    |     uint amount;
    | }
    | 
    | function changePoolLiquidity(HyperPool storage self, int128 liquidityDelta) {
    |     self.liquidity = Assembly.addSignedDelta(self.liquidity, liquidityDelta);
    | }
    | 
    | function syncPoolTimestamp(HyperPool storage self, uint timestamp) {
    |     self.lastTimestamp = SafeCastLib.safeCastTo32(timestamp);
    | }
    | 
    | function changePoolParameters(HyperPool storage self, HyperCurve memory updated) {
    |     (bool success, ) = updated.validateParameters();
    |     self.params = updated;
    |     assert(success);
    | }
    | 
    | function changePositionLiquidity(HyperPosition storage self, uint256 timestamp, int128 liquidityDelta) {
    |     self.lastTimestamp = timestamp;
    |     self.freeLiquidity = Assembly.addSignedDelta(self.freeLiquidity, liquidityDelta);
    | }
    | 
    | /** @dev Liquidity must be altered after syncing positions and not before. */
    | function syncPositionFees(
    |     HyperPosition storage self,
    |     uint liquidity,
    |     uint feeGrowthAsset,
    |     uint feeGrowthQuote
    | ) returns (uint feeAssetEarned, uint feeQuoteEarned) {
    |     uint checkpointAsset = Assembly.computeCheckpointDistance(feeGrowthAsset, self.feeGrowthAssetLast);
    |     uint checkpointQuote = Assembly.computeCheckpointDistance(feeGrowthQuote, self.feeGrowthQuoteLast);
    | 
    |     feeAssetEarned = FixedPointMathLib.mulWadDown(checkpointAsset, liquidity);
    |     feeQuoteEarned = FixedPointMathLib.mulWadDown(checkpointQuote, liquidity);
    | 
    |     self.feeGrowthAssetLast = feeGrowthAsset;
    |     self.feeGrowthQuoteLast = feeGrowthQuote;
    | 
    |     self.tokensOwedAsset += SafeCastLib.safeCastTo128(feeAssetEarned);
    |     self.tokensOwedQuote += SafeCastLib.safeCastTo128(feeQuoteEarned);
    | }
    | 
    | function syncPositionStakedFees(HyperPosition storage self, uint liquidity, uint feeGrowth) returns (uint feeEarned) {
    |     uint checkpoint = Assembly.computeCheckpointDistance(feeGrowth, self.feeGrowthRewardLast);
    |     feeEarned = FixedPointMathLib.mulWadDown(checkpoint, liquidity);
    |     self.feeGrowthRewardLast = feeEarned;
    |     self.tokensOwedReward += SafeCastLib.safeCastTo128(feeEarned);
    | }
    | 
    | // ===== View ===== //
*   | 
*   | function getVirtualReserves(HyperPool memory self) view returns (uint128 reserveAsset, uint128 reserveQuote) {
*   |     return self.getLiquidityDeltas(-int128(self.liquidity)); // rounds down
    | }
r   | 
    | function getMaxLiquidity(
    |     HyperPool memory self,
    |     uint deltaAsset,
    |     uint deltaQuote
r   | ) view returns (uint128 deltaLiquidity) {
r   |     (uint amountAsset, uint amountQuote) = self.getAmounts();
r   |     uint liquidity0 = deltaAsset.divWadDown(amountAsset);
    |     uint liquidity1 = deltaQuote.divWadDown(amountQuote);
    |     deltaLiquidity = (liquidity0 < liquidity1 ? liquidity0 : liquidity1).safeCastTo128();
    | }
    | 
*   | /** @dev Rounds positive deltas up. Rounds negative deltas down. */
    | function getLiquidityDeltas(
    |     HyperPool memory self,
    |     int128 deltaLiquidity
*   | ) view returns (uint128 deltaAsset, uint128 deltaQuote) {
*   |     if (deltaLiquidity == 0) return (deltaAsset, deltaQuote);
    |     (uint amountAsset, uint amountQuote) = self.getAmounts();
    | 
    |     uint delta;
    |     if (deltaLiquidity > 0) {
    |         delta = uint128(deltaLiquidity);
    |         deltaAsset = amountAsset.mulWadUp(delta).safeCastTo128();
    |         deltaQuote = amountQuote.mulWadUp(delta).safeCastTo128();
    |     } else {
    |         delta = uint128(-deltaLiquidity);
    |         deltaAsset = amountAsset.mulWadDown(delta).safeCastTo128();
    |         deltaQuote = amountQuote.mulWadDown(delta).safeCastTo128();
    |     }
    | }
    | 
*r  | /** @dev Decimal amounts per WAD of liquidity, rounded down... */
*r  | function getAmounts(HyperPool memory self) view returns (uint amountAssetDec, uint amountQuoteDec) {
*r  |     (uint amountAssetWad, uint amountQuoteWad) = self.getAmountsWad();
*r  |     amountAssetDec = amountAssetWad.scaleFromWadDown(self.pair.decimalsAsset);
*r  |     amountQuoteDec = amountQuoteWad.scaleFromWadDown(self.pair.decimalsQuote);
    | }
    | 
*r  | /** @dev WAD Amounts per WAD of liquidity. */
*r  | function getAmountsWad(HyperPool memory self) view returns (uint amountAssetWad, uint amountQuoteWad) {
*r  |     Price.RMM memory rmm = self.getRMM();
*r  |     amountAssetWad = rmm.getXWithPrice(self.lastPrice);
*r  |     amountQuoteWad = rmm.getYWithX(amountAssetWad);
    | }
    | 
    | // ===== Derived ===== //
r   | 
    | function computePriceChangeWithTime(
    |     HyperPool memory self,
    |     uint timeRemaining,
    |     uint epsilon
r   | ) pure returns (uint price, int24 tick) {
r   |     uint maxPrice = Price.computePriceWithTick(self.params.maxTick);
r   |     price = Price.computePriceWithChangeInTau(maxPrice, self.params.volatility, self.lastPrice, timeRemaining, epsilon);
r   |     tick = Price.computeTickWithPrice(price);
    | }
    | 
    | function getTimeSinceChanged(HyperPosition memory self, uint timestamp) view returns (uint distance) {
    |     return timestamp - self.lastTimestamp;
    | }
r   | 
    | function exists(HyperPool memory self) view returns (bool) {
r   |     return self.lastTimestamp != 0;
    | }
    | 
    | function isMutable(HyperPool memory self) view returns (bool) {
    |     return self.controller != address(0);
    | }
*r  | 
*r  | function getRMM(HyperPool memory self) view returns (Price.RMM memory) {
*r  |     return Price.RMM({strike: self.params.strike(), sigma: self.params.volatility, tau: self.lastTau()});
    | }
*r  | 
*r  | function lastTau(HyperPool memory self) view returns (uint) {
*r  |     return self.tau(self.lastTimestamp);
    | }
*r  | 
*r  | function tau(HyperPool memory self, uint timestamp) view returns (uint) {
*r  |     uint end = self.params.maturity();
*r  |     if (timestamp > end) return 0;
*r  |     return end - timestamp;
    | }
*r  | 
*r  | function strike(HyperCurve memory self) view returns (uint) {
*r  |     return Price.computePriceWithTick(self.maxTick);
    | }
*r  | 
*r  | function maturity(HyperCurve memory self) view returns (uint32 endTimestamp) {
*r  |     return (Assembly.convertDaysToSeconds(self.duration) + self.createdAt).safeCastTo32();
    | }
    | 
    | function validateParameters(HyperCurve memory self) view returns (bool, bytes memory) {
    |     (bool success, bytes memory reason) = self.checkParameters();
    |     if (!success) {
    |         assembly {
    |             revert(add(32, reason), mload(reason))
    |         }
    |     }
    | 
    |     return (success, reason);
    | }
    | 
    | /** @dev Invalid parameters should revert. */
    | function checkParameters(HyperCurve memory self) view returns (bool, bytes memory) {
    |     if (!Assembly.isBetween(self.volatility, MIN_VOLATILITY, MAX_VOLATILITY))
    |         return (false, abi.encodeWithSelector(InvalidVolatility.selector, self.volatility));
    |     if (!Assembly.isBetween(self.duration, MIN_DURATION, MAX_DURATION))
    |         return (false, abi.encodeWithSelector(InvalidDuration.selector, self.duration));
    |     if (self.maxTick >= MAX_TICK) return (false, abi.encodeWithSelector(InvalidTick.selector, self.maxTick)); //  todo: fix, min tick check?
    |     if (self.jit > JUST_IN_TIME_MAX) return (false, abi.encodeWithSelector(InvalidJit.selector, self.jit));
    |     if (!Assembly.isBetween(self.fee, MIN_FEE, MAX_FEE))
    |         return (false, abi.encodeWithSelector(InvalidFee.selector, self.fee));
    |     // 0 priority fee == no controller, impossible to set to zero unless default from non controlled pools.
    |     if (!Assembly.isBetween(self.priorityFee, 0, self.fee))
    |         return (false, abi.encodeWithSelector(InvalidFee.selector, self.priorityFee));
    | 
    |     return (true, "");
    | }
    | 
    | // ===== Swaps ===== //
    | 
    | function getMaxSwapAssetInWad(HyperPool memory self) view returns (uint) {
    |     Price.RMM memory rmm = self.getRMM();
    |     (, uint res1) = rmm.computeReserves(self.lastPrice);
    |     uint maxInput = FixedPointMathLib.WAD - res1;
    |     maxInput = maxInput.mulWadDown(self.liquidity);
    |     return maxInput.scaleFromWadDown(self.pair.decimalsAsset);
    | }
    | 
    | function getMaxSwapQuoteInWad(HyperPool memory self) view returns (uint) {
    |     Price.RMM memory rmm = self.getRMM();
    |     (uint res0, ) = rmm.computeReserves(self.lastPrice);
    |     uint maxInput = rmm.strike - res0;
    |     maxInput = maxInput.mulWadDown(self.liquidity);
    |     return maxInput.scaleFromWadDown(self.pair.decimalsQuote);
    | }
r   | 
    | function getAmountOut(
    |     HyperPool memory self,
    |     HyperPair memory pair,
    |     bool sellAsset,
    |     uint amountIn,
    |     uint timeSinceUpdate
r   | ) view returns (uint, uint) {
r   |     Iteration memory data;
r   |     Price.RMM memory rmm = self.getRMM();
r   |     (data.price, data.tick) = self.computePriceChangeWithTime(self.lastTau(), timeSinceUpdate);
r   |     data.remainder = amountIn.scaleToWad(sellAsset ? pair.decimalsAsset : pair.decimalsQuote);
r   |     data.liquidity = self.liquidity;
    | 
    |     uint prevInd;
    |     uint prevDep;
    |     uint nextInd;
    |     uint nextDep;
    | 
    |     {
    |         uint maxInput;
    |         uint delInput;
    | 
r   |         if (sellAsset) {
    |             (prevDep, prevInd) = rmm.computeReserves(data.price);
    |             maxInput = (FixedPointMathLib.WAD - prevInd).mulWadDown(self.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.
    |         } else {
r   |             (prevInd, prevDep) = rmm.computeReserves(data.price);
    |             maxInput = (rmm.strike - prevInd).mulWadDown(self.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.
    |         }
    | 
    |         data.feeAmount = ((data.remainder > maxInput ? maxInput : data.remainder) * self.params.fee) / 10_000;
    | 
    |         if (data.remainder > maxInput) {
    |             delInput = maxInput - data.feeAmount;
    |             nextInd = prevInd + delInput.divWadDown(data.liquidity);
    |             data.remainder -= (delInput + data.feeAmount);
    |         } else {
    |             delInput = data.remainder - data.feeAmount;
    |             nextInd = prevInd + delInput.divWadDown(data.liquidity);
    |             delInput = data.remainder; // Swap input amount including the fee payment.
    |             data.remainder = 0; // Clear the remainder to zero, as the order has been filled.
    |         }
    | 
    |         // Compute the output of the swap by computing the difference between the dependent reserves.
    |         if (sellAsset) nextDep = rmm.getYWithX(nextInd);
    |         else nextDep = rmm.getXWithY(nextInd);
    | 
    |         data.input += delInput;
    |         data.output += (prevDep - nextDep);
    |     }
    | 
    |     {
    |         // Scale down amounts from WAD.
    |         uint inputDec;
    |         uint outputDec;
    |         if (sellAsset) {
    |             inputDec = pair.decimalsAsset;
    |             outputDec = pair.decimalsQuote;
    |         } else {
    |             inputDec = pair.decimalsQuote;
    |             outputDec = pair.decimalsAsset;
    |         }
    | 
    |         data.input = data.input.scaleFromWadUp(inputDec);
    |         data.output = data.output.scaleFromWadDown(outputDec);
    |     }
    | 
    |     return (data.output, data.remainder);
    | }
    | 
    | function toInt128(uint128 a) pure returns (int128 b) {
    |     assembly {
    |         if gt(a, 0x7fffffffffffffffffffffffffffffff) {
    |             revert(0, 0)
    |         }
    | 
    |         b := a
    |     }
    | }
    | 

/root/code/hyper/contracts/OS.sol
    | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | /**
    | 
    |   -------------
    |   
    |   This is a custom account system to support Enigma's
    |   jump processing. Without jump processing, the benefits 
    |   are marginal at best. Combining the two reduces the 
    |   marginal cost of aditional operations to only ~20% of a single operation. 
    |   This is by design, in order to support a system that interacts with a lot
    |   of different parameters, tokens, actors, and pools.
    | 
    |   -------------
    | 
    |   Glossary:
    | 
    |   Virtual Reserves  - Expected balance of tokens.
    |   Physical Reserves - Actual balance of tokens.
    |   Net Balance       - Difference of physical reserve and virtual reserve.
    |   Credit            - Increase (+) spendable tokens.
    |   Debit             - Decrease (-) spendable tokens.
    |   Settle            - Apply net balance (+/-) as credit (+) or debit (-) to user.
    | 
    |   -------------
    | 
    |   Primitive™
    | 
    |  */
    | 
    | import "solmate/utils/SafeTransferLib.sol";
    | import "./interfaces/IWETH.sol";
    | import "./interfaces/IERC20.sol";
    | import "./Assembly.sol" as Assembly;
    | 
    | using {
    |     __wrapEther__,
    |     dangerousFund,
    |     cache,
    |     credit,
    |     debit,
    |     decrease,
    |     increase,
    |     reset,
    |     settle,
    |     touch,
    |     getNetBalance
    | } for AccountSystem global;
    | 
    | error EtherTransferFail(); // 0x75f42683
    | error InsufficientReserve(uint amount, uint delta); // 0x315276c9
    | error InvalidBalance(); // 0xc52e3eff
    | error NotPreparedToSettle(); // 0xf7cede50
    | 
    | struct AccountSystem {
    |     // user -> token -> internal balance.
    |     mapping(address => mapping(address => uint)) balances;
    |     // token -> virtual reserve.
    |     mapping(address => uint) reserves;
    |     // token -> cached status. todo: make this a bitmap
    |     mapping(address => bool) cached;
    |     // Transiently stored cached tokens, must be length zero outside of execution.
    |     address[] warm;
    |     // Must be `false` outside of execution.
    |     bool prepared;
    |     // Must be `true` outside of execution.
    |     bool settled;
    | }
    | 
*r  | /** @dev Gas optimized. */
*r  | function __balanceOf__(address token, address account) view returns (uint256) {
*r  |     (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, account));
*r  |     if (!success || data.length != 32) revert InvalidBalance();
*r  |     return abi.decode(data, (uint256));
    | }
    | 
*r  | /** @dev Must validate `weth` is real weth. */
    | function __wrapEther__(AccountSystem storage self, address weth) {
*r  |     if (msg.value > 0) {
*r  |         self.touch(weth);
*r  |         IWETH(weth).deposit{value: msg.value}();
    |     }
    | }
    | 
    | /** @dev Dangerously sends ether to `to` in a low-level call. */
    | function __dangerousUnwrapEther__(address weth, address to, uint256 amount) {
    |     IWETH(weth).withdraw(amount);
    |     __dangerousTransferEther__(to, amount);
    | }
    | 
    | /** @dev Dangerously sends ether to `to` in a low-level call. */
    | function __dangerousTransferEther__(address to, uint256 value) {
    |     (bool success, ) = to.call{value: value}(new bytes(0));
    |     if (!success) revert EtherTransferFail();
    | }
    | 
r   | /** @dev External call to the `to` address is dangerous. */
    | function __dangerousTransferFrom__(address token, address to, uint amount) {
r   |     SafeTransferLib.safeTransferFrom(ERC20(token), msg.sender, to, amount);
    | }
    | 
r   | /** @dev External call to the `to` address is dangerous. */
    | function dangerousFund(AccountSystem storage self, address token, address to, uint amount) {
r   |     self.touch(token);
r   |     __dangerousTransferFrom__(token, to, amount); // Settlement gifts tokens to msg.sender.
    | }
    | 
*   | /** @dev Increases an `owner`'s spendable balance. */
    | function credit(AccountSystem storage self, address owner, address token, uint amount) {
*   |     self.touch(token);
*   |     self.balances[owner][token] += amount;
    | }
    | 
    | /** @dev Decreases an `owner`'s spendable balance. */
    | function debit(
    |     AccountSystem storage self,
    |     address owner,
    |     address token,
    |     uint256 owed
    | ) returns (uint paid, uint remainder) {
    |     self.touch(token);
    |     uint balance = self.balances[owner][token];
    |     if (balance >= owed) {
    |         paid = owed;
    |         self.balances[owner][token] -= paid;
    |         remainder = 0;
    |     } else {
    |         paid = balance;
    |         self.balances[owner][token] -= paid;
    |         remainder = owed - paid;
    |     }
    | }
    | 
    | /** @dev Actives a token and increases the reserves. Settlement will pick up this activated token. */
    | function increase(AccountSystem storage self, address token, uint amount) {
    |     self.touch(token);
    |     self.reserves[token] += amount;
    | }
    | 
    | /** @dev Actives a token and decreases the reserves. Settlement will pick up this activated token. */
    | function decrease(AccountSystem storage self, address token, uint amount) {
    |     uint balance = self.reserves[token];
    |     if (amount > balance) revert InsufficientReserve(balance, amount);
    | 
    |     self.touch(token);
    |     self.reserves[token] -= amount;
    | }
    | 
*r  | /** @notice Settles the difference in balance between virtual tokens and physically held tokens. */
    | function settle(
    |     AccountSystem storage self,
    |     address token,
    |     address account
*r  | ) returns (uint credited, uint debited, uint remainder) {
*r  |     int net = self.getNetBalance(token, account);
*   |     if (net > 0) {
*   |         credited = uint(net);
    |         // unaccounted for tokens, e.g. transferred directly into Hyper.
*   |         self.credit(msg.sender, token, uint(net)); // gift to `msg.sender`.
*   |         self.reserves[token] += uint(net); // add the difference back to reserves, so net is zero.
    |     } else if (net < 0) {
    |         // missing tokens that must be paid for or transferred in.
    |         remainder = uint(-net);
    |         (debited, remainder) = self.debit(msg.sender, token, remainder);
*   |         if (debited > 0) self.reserves[token] -= debited; // using a balance means tokens are in contract already.
    |     }
    | 
*   |     delete self.cached[token]; // Note: Assumes this token is completely paid for by the end of the transaction.
    | }
    | 
*r  | /** @dev Interacting with a token will activate it, adding it to an array of interacted tokens for settlement to loop through. */
    | function touch(AccountSystem storage self, address token) {
*r  |     if (self.settled) self.settled = false; // If tokens are warm, they are not settled.
*r  |     if (!self.cached[token]) {
*r  |         self.warm.push(token);
    |         self.cache(token, true);
    |     }
    |     // do nothing if already cached.
    | }
    | 
*   | /** @dev Account system is reset after settlement is successful. */
    | function reset(AccountSystem storage self) {
*   |     assert(self.warm.length == 0); // todo: this is a valid assertion, but should we use assert?
*   |     self.settled = true;
*   |     delete self.warm;
*   |     delete self.prepared;
    | }
    | 
    | /** @dev Used to check if a token was already activated after being interacted with again. */
    | function cache(AccountSystem storage self, address token, bool status) {
*r  |     self.cached[token] = status;
    | }
    | 
*r  | /** @dev Computes surplus (positive) or deficit (negative) in actual tokens compared to tracked amounts. */
*r  | function getNetBalance(AccountSystem storage self, address token, address account) view returns (int256 net) {
*r  |     uint256 internalBalance = self.reserves[token];
*r  |     uint256 physicalBalance = __balanceOf__(token, account);
*r  |     net = int256(physicalBalance) - int256(internalBalance);
    | }
    | 

/root/code/hyper/contracts/echidna/EchidnaE2E.sol
    | pragma solidity ^0.8.0;
    | import "./Helper.sol";
    | import "solmate/tokens/WETH.sol";
    | import "../test/TestERC20.sol";
    | import "../Hyper.sol";
    | import "../Enigma.sol" as ProcessingLib;
    | import "../../test/helpers/HelperHyperProfiles.sol" as DefaultValues;
    | import "../../test/helpers/HelperHyperView.sol";
    | 
*r  | 
    | contract EchidnaE2E is HelperHyperView,Helper
    | {
    | 	WETH _weth;
    | 	TestERC20 _quote;
    | 	TestERC20 _asset;
    | 	Hyper _hyper;
    | 	uint24 pairId;
    | 	TestERC20[] hyperTokens;
    | 	uint64 [] poolIds;
    | 	bool isPairCreated;
    | 
    | 	constructor() public {
    | 		_weth = new WETH();
    | 		_quote = new TestERC20("6 Decimals","6DEC",6);
    | 		_asset = new TestERC20("18 Decimals", "18DEC", 18);
    | 
    | 		_hyper = new Hyper(address(_weth));
    | 		
    | 	}
    | 	OS.AccountSystem hyperAccount;
    | 	// ******************** Check Proper System Deployment ********************
    | 	function check_proper_deployment() public { 
    | 		assert(address(_weth) != address(0));
    | 		assert(address(_quote) != address(0));
    | 		assert(address(_asset) != address(0));
    | 		assert(address(_hyper) != address(0));
    | 
    | 		// Note: This invariant may break with tokens on hooks. 
    | 		assert(_hyper.locked() == 1);
    | 
    | 		// Retrieve the OS.__account__
    | 		(bool prepared, bool settled) = _hyper.__account__();
    | 		assert(!prepared);
    | 		assert(settled);
    | 
    | 		address[] memory warmTokens = _hyper.getWarm();
    | 		assert(warmTokens.length == 0);
    | 	}
    | 	// ******************** System wide Invariants ********************
    | 	function non_zero_priority_fee_if_controlled(uint64 id) public {
    | 		(HyperPool memory pool,) = retrieve_created_pool(id);
    | 		// if the pool has a controller, the priority fee should never be zero
    | 		if (pool.controller != address(0)) { 
    | 			assert(pool.params.priorityFee != 0);
    | 		}
    | 	}
    | 	// The token balance of Hyper should be greater or equal to the reserve for all tokens 
    | 	// Note: assumption that pairs are created through create_pair invariant test 
    | 	// which will add the token to the hyperTokens list 
    | 	// this function is built so that extending the creation of new pairs should not require code changes here
    | 	function token_balance_greater_or_equal_reserves() public {
    | 		uint256 reserveBalance = 0;
    | 		uint256 tokenBalance = 0;
    | 		for (uint8 i=0; i<hyperTokens.length; i++){
    | 			TestERC20 token = hyperTokens[i];
    | 			// retrieve reserves of the token and add to tracked reserve balance
    | 			reserveBalance = getReserve(address(_hyper),address(token));
    | 			// get token balance and add to tracked token balance
    | 			tokenBalance += token.balanceOf(address(_hyper));
    | 		}
    | 		assert(tokenBalance >= reserveBalance);
    | 	}		
    | 	function pool_last_price_not_greater_than_strike() public {
    | 		for (uint8 i = 0; i<poolIds.length; i++) {
    | 			uint64 poolId = poolIds[i];
    | 			HyperPool memory pool = getPool(address(_hyper),poolId);
    | 			HyperCurve memory curve = pool.params;
    | 
    | 			emit LogUint256("pool's last price",pool.lastPrice);
    | 			emit LogUint256("strike price",curve.strike());			
    | 
    | 			assert(pool.lastPrice <= curve.strike());
    | 		}
    | 	}
    | 	// Strike price for a pool should never be zero. 
    | 	// If it is, it suggests the mispricing and/or incorrect rounding of assets. 
*r  | 	function pool_strike_price_non_zero() public {
*r  | 		for (uint8 i = 0; i<poolIds.length; i++) {
    | 			uint64 poolId = poolIds[i];
    | 			HyperPool memory pool = getPool(address(_hyper),poolId);
    | 			HyperCurve memory curve = pool.params;
    | 
    | 			emit LogUint256("pool's last price",pool.lastPrice);
    | 			emit LogUint256("strike price",curve.strike());			
    | 
    | 			if(curve.strike() == 0) {
    | 				emit AssertionFailed("curve strike price is 0.");
    | 			}
    | 		}		
    | 	}
    | 
    | 	// ******************** Create Pairs ********************
    | 	/** Future Invariant: This assumes that there is a single pair of _asset and _quote token 
    | 	        - In the future, can be extended to deploy tokens from here and save the address in a list 
    | 			which allows echidna to test against different pairs. 
    | 			- Assumption: 1 pair for now. 
    | 	 */
    | 	function create_token(uint8 decimals) public returns (TestERC20 token){
    | 		TestERC20 token = new TestERC20("Token", "TKN", decimals);
    | 		assert(token.decimals() == decimals);
    | 	}
    | 	/* Future Invariant: This could be extended to create arbitrary pairs. 
    |     For now for complexity, I am leaving as is. 
    | 	Test overlapping token pairs
    | 	*/
*   | 	function create_pair_with_default() public { 
    | 		// require that this specific pair ID does not exist (i.e: this function has not been invoked yet)
*   | 		require(!isPairCreated);
    | 		// without this, Echidna may decide to call the TestERC20.setDecimals 
*   | 		require(_quote.decimals() == 6); 
*   | 		require(_asset.decimals() == 18);
*   | 		uint256 preCreationNonce = _hyper.getPairNonce();
    | 		
    | 		// encode createPair arguments and call hyper contract
*   | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(_asset), address(_quote));
*   |         (bool success, ) = address(_hyper).call(createPairData);
*   | 		assert(success);
*   | 		pair_id_saved_properly(address(_asset), address(_quote));
    | 
*   | 		uint256 pairNonce = _hyper.getPairNonce();
*   | 		assert(pairNonce == preCreationNonce + 1);
    | 	}
    | 	/** Future Invariant: This can likely be extended to ensure that pairID's must always match backwards to the tokens saved
    | 	 */
*   | 	function pair_id_saved_properly(address asset, address quote) private {
    | 		// retrieve recently created pair ID 
*   | 		pairId = _hyper.getPairId(address(asset),address(quote));
*   | 		if (pairId == 0) {
    | 			emit LogUint256("PairId Exists", uint256(pairId));
*   | 			assert(false);
    | 		}
    | 		
    | 		// retrieve pair information and ensure pair was saved 
*   | 		HyperPair memory pair  = getPair(address(_hyper),pairId);
*   | 		assert(pair.tokenAsset == address(asset));
*   | 		assert(pair.decimalsAsset == TestERC20(asset).decimals());
*   | 		assert(pair.tokenQuote == address(quote));
*   | 		assert(pair.decimalsQuote == TestERC20(quote).decimals());
    | 
    | 		// save internal Echidna state to test against
*   | 		isPairCreated = true;
*   | 		hyperTokens.push(TestERC20(asset));
*   | 		hyperTokens.push(TestERC20(quote));
    | 	}
    | 	function create_same_pair_should_fail() public {
    | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(_quote), address(_quote));
    |         (bool success, ) = address(_hyper).call(createPairData);
    | 		assert(!success);
    | 	}
    | 	function create_pair_with_less_than_min_decimals_should_fail(uint256 decimals) public {
    | 		decimals = uint8(between(decimals,0,5));
    | 		TestERC20 testToken = create_token(uint8(decimals));
    | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(_quote));
    |         (bool success, ) = address(_hyper).call(createPairData);
    | 		assert(!success);
    | 	}	
*   | 	function create_pair_with_more_than_max_decimals_should_fail(uint256 decimals) public {
    | 		decimals = uint8(between(decimals,19,type(uint64).max));
    | 		TestERC20 testToken = create_token(uint8(decimals));
    | 	 	bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(_quote));
    |         (bool success, ) = address(_hyper).call(createPairData);
*   | 		assert(!success);
    | 	}	
    | 	// ******************** Create Pool ********************
    | 	// Create a non controlled pool (controller address is 0) with default pair
    | 	// Note: This function can be extended to choose from any created pair and create a pool on top of it
    | 	function create_non_controlled_pool(
    | 		uint16 fee, 
    | 		int24 maxTick,
    | 		uint16 volatility, 
    | 		uint16 duration, 
    | 		uint128 price
    | 	) public {
    | 		if(!isPairCreated) { create_pair_with_default(); }
    | 		{ 
    | 			// scaling remaining pool creation values
    | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
    | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
    | 			maxTick = (-MIN_TICK) + (maxTick % (MAX_TICK - (-MIN_TICK))); // [-MIN_TICK,MAX_TICK]
    | 			if (maxTick == 0) {
    | 				maxTick+=1;
    | 			}
    | 			emit LogInt24("maxTick",maxTick);			
    | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
    | 		}
    | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
    | 			pairId,
    | 			address(0), // no controller 
    | 			0, // no priority fee 
    | 			fee,
    | 			volatility,
    | 			duration,
    | 			0, // no jit 
    | 			maxTick,
    | 			price
    | 		);		
    | 		{ 
    | 			(HyperPool memory pool,uint64 poolId) = execute_create_pool(createPoolData, false);
    | 			assert(!pool.isMutable());	
    | 			HyperCurve memory curve = pool.params;
    | 			assert(pool.lastTimestamp == block.timestamp);
    | 			assert(pool.lastPrice == price);
    | 			assert(curve.createdAt == block.timestamp);
    | 			assert(pool.controller == address(0));
    | 			assert(curve.priorityFee == 0);
    | 			assert(curve.fee == fee);
    | 			assert(curve.volatility == volatility);
    | 			assert(curve.duration == duration);
    | 			assert(curve.jit == JUST_IN_TIME_LIQUIDITY_POLICY);
    | 			assert(curve.maxTick == maxTick);				
    | 		}
    | 	}
    | 	function create_controlled_pool(
    | 		uint16 priorityFee,
    | 		uint16 fee, 
    | 		int24 maxTick,
    | 		uint16 volatility, 
    | 		uint16 duration, 
    | 		uint16 jit,
    | 		uint128 price
    | 	) public {
    | 		if(!isPairCreated) { create_pair_with_default(); }
    | 		// TODO CLEAN: Move this into a helper function so the rest of the create functions can reuse it.
    | 		{ 
    | 			// scaling remaining pool creation values
    | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
    | 			priorityFee = uint16(between(priorityFee, 1, fee));
    | 			emit LogUint256("priority fee", uint256(priorityFee));
    | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
    | 			maxTick = (-MIN_TICK) + (maxTick % (MAX_TICK - (-MIN_TICK))); // [-MIN_TICK,MAX_TICK]
    | 			if (maxTick == 0) {
    | 				maxTick+=1;
    | 			}
    | 			emit LogInt24("maxTick",maxTick);
    | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
    | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
    | 		}
    | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
    | 			pairId,
    | 			address(this), //controller
    | 			priorityFee, // no priority fee 
    | 			fee,
    | 			volatility,
    | 			duration,
    | 			jit, // no jit 
    | 			maxTick,
    | 			price
    | 		);		
    | 		{ 
    | 			(HyperPool memory pool,uint64 poolId) = execute_create_pool(createPoolData, true);		
    | 			assert(pool.isMutable());
    | 			HyperCurve memory curve = pool.params;
    | 			assert(pool.lastTimestamp == block.timestamp);
    | 			assert(curve.createdAt == block.timestamp);
    | 			assert(pool.controller == address(this));
    | 			assert(curve.priorityFee == priorityFee);
    | 			assert(curve.fee == fee);
    | 			assert(curve.volatility == volatility);
    | 			assert(curve.duration == duration);
    | 			assert(curve.jit == jit);
    | 			assert(curve.maxTick == maxTick);
    | 		}
    | 	}
r   | 	function create_controlled_pool_with_zero_priority_fee_should_fail(
    | 		uint16 fee, 
    | 		int24 maxTick,
    | 		uint16 volatility, 
    | 		uint16 duration, 
    | 		uint16 jit,
    | 		uint128 price
    | 	) public {
    | 		if(!isPairCreated) { create_pair_with_default(); }
    | 		uint16 priorityFee = 0;
    | 		{ 
    | 			// TODO CLEAN: Move this into a helper function so the rest of the create functions can reuse it.
    | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
    | 			emit LogUint256("priority fee", uint256(priorityFee));
    | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
    | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
    | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
    | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
    | 		}
    | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
    | 			pairId,
    | 			address(this), //controller
    | 			priorityFee, // no priority fee 
    | 			fee,
    | 			volatility,
    | 			duration,
    | 			jit, // no jit 
    | 			maxTick,
    | 			price
    | 		);		
    | 		(bool success, ) = address(_hyper).call(createPoolData);
    | 		assert(!success);
    | 	}
    | 	function create_pool_with_negative_max_tick_as_bounds(
    | 		uint16 priorityFee,
    | 		uint16 fee, 
    | 		int24 maxTick,
    | 		uint16 volatility, 
    | 		uint16 duration, 
    | 		uint16 jit,
    | 		uint128 price
    | 	) public {
    | 		if(!isPairCreated) { create_pair_with_default(); }
    | 		{ 
    | 			// TODO CLEAN: Move this into a helper function so the rest of the create functions can reuse it.
    | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
    | 			priorityFee = uint16(between(priorityFee, 1, fee));
    | 			emit LogUint256("priority fee", uint256(priorityFee));
    | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
    | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MIN_TICK,MAX_TICK]
    | 			if (maxTick == 0) {
    | 				maxTick+=1;
    | 			}
    | 			emit LogInt24("maxTick",maxTick);
    | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
    | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
    | 		}
    | 		bytes memory createPoolData = ProcessingLib.encodeCreatePool(
    | 			pairId,
    | 			address(this), //controller
    | 			priorityFee, // no priority fee 
    | 			fee,
    | 			volatility,
    | 			duration,
    | 			jit, // no jit 
    | 			maxTick,
    | 			price
    | 		);		
    | 		{ 
    | 			(HyperPool memory pool,uint64 poolId) = execute_create_pool(createPoolData, true);		
    | 			assert(pool.isMutable());
    | 			HyperCurve memory curve = pool.params;
    | 			assert(pool.lastTimestamp == block.timestamp);
    | 			assert(curve.createdAt == block.timestamp);
    | 			assert(pool.controller == address(this));
    | 			assert(curve.priorityFee == priorityFee);
    | 			assert(curve.fee == fee);
    | 			assert(curve.volatility == volatility);
    | 			assert(curve.duration == duration);
    | 			assert(curve.jit == jit);
    | 			assert(curve.maxTick == maxTick);
    | 		}
    | 	}	
    | 	function execute_create_pool(
    | 		bytes memory createPoolData, 
    | 		bool hasController
    | 	) private returns (HyperPool memory pool,uint64 poolId){
    | 		uint256 preCreationPoolNonce = _hyper.getPoolNonce();
    | 		(bool success, ) = address(_hyper).call(createPoolData);
    | 
    | 		// pool nonce should increase by 1 each time a pool is created
    | 		uint256 poolNonce = _hyper.getPoolNonce();
    | 		assert(poolNonce == preCreationPoolNonce + 1);
    | 		
    | 		// pool should be created and exist 
    | 		poolId = ProcessingLib.encodePoolId(pairId, hasController, uint32(poolNonce));
    | 		pool = getPool(address(_hyper),poolId);
    | 		if(!pool.exists()) { 
    | 			emit AssertionFailed("Pool should exist after being created.");
    | 		}
    | 
    | 		// save pools in Echidna
    | 		poolIds.push(poolId);
    | 	}
    | 	// ******************** Change Pool Parameters ********************	
    | 	function change_parameters(
    | 		uint256 id,
    | 		uint16 priorityFee,
    | 		uint16 fee, 
    | 		int24 maxTick,
    | 		uint16 volatility, 
    | 		uint16 duration, 
    | 		uint16 jit,
    | 		uint128 price
    | 	) public {
    | 		(HyperPool memory preChangeState,uint64 poolId) = retrieve_created_pool(id);
    | 		emit LogUint256("created pools",poolIds.length);
    | 		emit LogUint256("pool ID",uint256(poolId));
    | 		require(preChangeState.isMutable());
    | 		require(preChangeState.controller == address(this));
    | 		{ 
    | 			// scaling remaining pool creation values
    | 			fee = uint16(between(fee, MIN_FEE, MAX_FEE));
    | 			priorityFee = uint16(between(priorityFee, 1, fee));
    | 			volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    | 			duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
    | 			maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
    | 			jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
    | 			price = uint128(between(price,1,type(uint128).max)); // price is between 1-uint256.max		
    | 		}
    | 
    | 		_hyper.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
    | 		{ 
    | 			(HyperPool memory postChangeState,) = retrieve_created_pool(id);
    | 			HyperCurve memory preChangeCurve = preChangeState.params;
    | 			HyperCurve memory postChangeCurve = postChangeState.params;
    | 			assert(postChangeState.lastTimestamp == preChangeState.lastTimestamp); 
    | 			assert(postChangeState.controller == address(this));
    | 			assert(postChangeCurve.createdAt == preChangeCurve.createdAt);
    | 			assert(postChangeCurve.priorityFee == priorityFee);
    | 			assert(postChangeCurve.fee == fee);
    | 			assert(postChangeCurve.volatility == volatility);
    | 			assert(postChangeCurve.duration == duration);
    | 			assert(postChangeCurve.jit == jit);
    | 			assert(postChangeCurve.maxTick == maxTick);		
    | 		}
    | 	}
    | 	// Invariant: Attempting to change parameters of a nonmutable pool should fail 
    | 	// Invariant: Attempting to change parameters by a non-controller should fail
    | 	// ******************** Funding ********************	
    | 	function fund_with_correct_preconditions_should_succeed(
    | 		uint256 assetAmount,
    | 		uint256 quoteAmount
    | 	) public {
    | 		// asset and quote amount > 1
    | 		assetAmount = between(assetAmount,1,type(uint64).max);
    | 		quoteAmount = between(quoteAmount,1,type(uint64).max);
    | 
    | 		emit LogUint256("assetAmount",assetAmount);
    | 		emit LogUint256("quoteAmount",quoteAmount);
    | 		setup_fund(assetAmount, quoteAmount);
    | 
    | 		if(_asset.balanceOf(address(this)) < assetAmount) {
    | 			emit LogUint256("asset balance",_asset.balanceOf(address(this)));
    | 		}
    | 		if (_quote.balanceOf(address(this)) < quoteAmount) {
    | 			emit LogUint256("quote balance",_quote.balanceOf(address(this)));			
    | 		}
    | 
    | 		fund_token(address(_asset), assetAmount);
    | 		fund_token(address(_quote), quoteAmount);
    | 	}		
    | 	function fund_with_insufficient_funds_should_fail(uint256 assetAmount, uint256 quoteAmount) public {
    | 		assetAmount = between(assetAmount,1,type(uint256).max);
    | 		quoteAmount = between(quoteAmount,1,type(uint256).max);
    | 
    | 		try _hyper.fund(address(_asset),assetAmount) {
    | 			emit AssertionFailed("funding with insufficient funds should fail");
    | 		} 
    | 		catch {}
    | 
    | 
    | 		try _hyper.fund(address(_quote),quoteAmount) {
    | 			emit AssertionFailed("funding with insufficient quote should fail");
    | 		}
    | 		catch {}
    | 	}
    | 	function fund_with_insufficient_allowance_should_fail(uint256 fundAmount) public {
    | 		uint256 smallAssetAllowance = between(fundAmount,1,fundAmount-1);
    | 
    | 		// mint the asset to address(this) and approve some amount < fund
    | 		_asset.mint(address(this),fundAmount);
    | 		_asset.approve(address(_hyper),smallAssetAllowance);
    | 		try _hyper.fund(address(_asset),fundAmount) {
    | 			emit LogUint256("small asset allowance", smallAssetAllowance);
    | 			emit AssertionFailed("insufficient allowance should fail.");
    | 		}
    | 		catch {} 
    | 
    | 		// mint the quote token to address(this), approve some amount < fund
    | 		_quote.mint(address(this),fundAmount);
    | 		_quote.approve(address(_hyper),smallAssetAllowance);
    | 		try _hyper.fund(address(_quote),fundAmount) {
    | 			emit LogUint256("small asset allowance", smallAssetAllowance);			
    | 			emit AssertionFailed("insufficient allownce should fail.");
    | 		}
    | 		catch {} 
    | 	}
    | 	function fund_with_zero() public {
    | 		setup_fund(0,0);
    | 		_hyper.fund(address(_asset),0);
    | 		_hyper.fund(address(_quote),0);		
    | 	}
    | 
    | 	function fund_token(address token, uint256 amount) private returns(bool) {
    | 		uint256 senderBalancePreFund = TestERC20(token).balanceOf(address(this));	
    | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(token));
    | 		uint256 reservePreFund = getReserve(address(_hyper),address(token));
    | 		uint256 hyperBalancePreFund = TestERC20(token).balanceOf(address(_hyper));
    | 
    | 		try _hyper.fund(address(token),amount) {
    | 		} catch (bytes memory error) {
    | 			emit LogBytes("error", error);
    | 			assert(false);
    | 		}
    | 
    | 		// sender's token balance should decrease 
    | 		// usdc sender pre token balance = 100 ; usdc sender post token = 100 - 1
    | 		uint256 senderBalancePostFund = TestERC20(token).balanceOf(address(this));			
    | 		if(senderBalancePostFund != senderBalancePreFund - amount) {
    | 			emit LogUint256("postTransfer sender balance", senderBalancePostFund);
    | 			emit LogUint256("preTransfer:", senderBalancePreFund);
    | 			emit AssertionFailed("Sender balance did not decrease by amount after funding");
    | 		}
    | 		// hyper balance of the sender should increase 
    | 		// pre hyper balance = a; post hyperbalance + 100
    | 		uint256 virtualBalancePostFund = getBalance(address(_hyper),address(this),address(token));
    | 		if(virtualBalancePostFund != virtualBalancePreFund + amount){
    | 			emit LogUint256("virtual balance after funding", virtualBalancePostFund);
    | 			emit LogUint256("virtual balance before funding:", virtualBalancePreFund);
    | 			emit AssertionFailed("Virtual balance did not increase after funding");
    | 		}
    | 		// hyper reserves for token should increase
    | 		// reserve balance = b; post reserves + 100
    | 		uint256 reservePostFund = getReserve(address(_hyper),address(token));
    | 		if(reservePostFund != reservePreFund + amount){
    | 			emit LogUint256("reserve after funding", reservePostFund);
    | 			emit LogUint256("reserve balance before funding:", reservePreFund);
    | 			emit AssertionFailed("Reserve did not increase after funding");			
    | 		}
    | 		// hyper's token balance should increase
    | 		// pre balance of usdc = y; post balance = y + 100
    | 		uint256 hyperBalancePostFund = TestERC20(token).balanceOf(address(_hyper));
    | 		if(hyperBalancePostFund  != hyperBalancePreFund + amount){
    | 			emit LogUint256("hyper token balance after funding", hyperBalancePostFund);
    | 			emit LogUint256("hyper balance before funding:", hyperBalancePreFund);
    | 			emit AssertionFailed("hyper token balance did not increase after funding");			
    | 		}
    | 		return true;
    | 	}
    | 	function setup_fund(uint256 assetAmount, uint256 quoteAmount) private {
    | 		_asset.mint(address(this),assetAmount);
    | 		_quote.mint(address(this),quoteAmount);
    | 		_asset.approve(address(_hyper),type(uint256).max);
    | 		_quote.approve(address(_hyper),type(uint256).max);
    | 	}
    | 	// ******************** Draw ********************	
    | 	function draw_should_succeed(uint256 assetAmount,uint256 quoteAmount, address recipient) public {	
    | 		assetAmount = between(assetAmount,1,type(uint64).max);
    | 		quoteAmount = between(quoteAmount,1,type(uint64).max);
    | 		emit LogUint256("asset amount: ", assetAmount);
    | 		emit LogUint256("quote amount:", quoteAmount);
    | 
    | 		require(recipient != address(_hyper));
    | 		require(recipient != address(0));
    | 
    | 		draw_token(address(_asset),assetAmount, recipient);
    | 		draw_token(address(_quote),quoteAmount, recipient);
    | 	}
    | 	function draw_token(address token, uint256 amount, address recipient) private {
    | 		// make sure a user has funded already 
    | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(token));
    | 		require (virtualBalancePreFund>0);
    | 		amount = between(amount,1,virtualBalancePreFund);
    | 
    | 		uint256 recipientBalancePreFund = TestERC20(token).balanceOf(address(recipient));	
    | 		uint256 reservePreFund = getReserve(address(_hyper),address(token));
    | 		uint256 hyperBalancePreFund = TestERC20(token).balanceOf(address(_hyper));		
    | 
    | 		_hyper.draw(token,amount,recipient);
    | 		
    | 		//-- Postconditions 
    | 		// caller balance should decrease 
    | 		// pre caller balance = a; post caller balance = a - 100
    | 		uint256 virtualBalancePostFund = getBalance(address(_hyper),address(this),address(token));
    | 		if(virtualBalancePostFund != virtualBalancePreFund - amount){
    | 			emit LogUint256("virtual balance post draw",virtualBalancePostFund);
    | 			emit LogUint256("virtual balance pre draw", virtualBalancePreFund);
    | 			emit AssertionFailed("virtual balance should decrease after drawing tokens");
    | 		}
    | 		// reserves should decrease 
    | 		uint256 reservePostFund = getReserve(address(_hyper),address(token));
    | 		if(reservePostFund != reservePreFund - amount){
    | 			emit LogUint256("reserve post draw",reservePostFund);
    | 			emit LogUint256("reserve pre draw", reservePreFund);
    | 			emit AssertionFailed("reserve balance should decrease after drawing tokens");
    | 		}
    | 		// to address should increase 
    | 		// pre-token balance = a; post-token = a + 100
    | 		uint256 recipientBalancePostFund = TestERC20(token).balanceOf(address(recipient));			
    | 		if(recipientBalancePostFund  != recipientBalancePreFund + amount){
    | 			emit LogUint256("recipient balance post draw",recipientBalancePostFund);
    | 			emit LogUint256("recipient balance pre draw", recipientBalancePreFund);
    | 			emit AssertionFailed("recipient balance should increase after drawing tokens");			
    | 		}
    | 		// hyper token's balance should decrease
    | 		uint256 tokenPostFund = TestERC20(token).balanceOf(address(_hyper));
    | 		if(tokenPostFund != hyperBalancePreFund - amount){
    | 			emit LogUint256("token post draw",tokenPostFund);
    | 			emit LogUint256("token pre draw", hyperBalancePreFund);
    | 			emit AssertionFailed("hyper token balance should increase after drawing tokens");						
    | 		}
    | 	}	
*   | 	function draw_to_zero_should_fail(uint256 assetAmount) public {
    | 		// make sure a user has funded already 
    | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(_asset));
    | 		emit LogUint256("virtual balance pre fund",virtualBalancePreFund);
    | 		require (virtualBalancePreFund >= 0);
    | 		assetAmount = between(assetAmount,1,virtualBalancePreFund);
    | 
    | 		try _hyper.draw(address(_asset),assetAmount,address(0)) { 
    | 			emit AssertionFailed("draw should fail attempting to transfer to zero");
    | 		} catch { } 
    | 	}
    | 	function fund_then_draw(uint256 whichToken, uint256 amount) public {
    | 		// this can be extended to use the token list in `hyperTokens`
    | 		address token; 
    | 		if (whichToken%2==0) token = address(_asset);
    | 		else token = address(_quote);
    | 
    | 		setup_fund(amount,amount);
    | 
    | 		uint256 hyperBalancePreFund = TestERC20(token).balanceOf(address(_hyper));		
    | 		require(hyperBalancePreFund == 0);
    | 		
    | 		uint256 virtualBalancePreFund = getBalance(address(_hyper),address(this),address(token));
    | 		uint256 recipientBalancePreFund = TestERC20(token).balanceOf(address(this));	
    | 		uint256 reservePreFund = getReserve(address(_hyper),address(token));
    | 
    | 		// Call fund and draw
    | 		_hyper.fund(token,amount);
    | 		_hyper.draw(token,amount,address(this));
    | 
    | 		//-- Postconditions 
    | 		// caller balance should be equal 
    | 		uint256 virtualBalancePostFund = getBalance(address(_hyper),address(this),address(token));
    | 		if(virtualBalancePostFund != virtualBalancePreFund){
    | 			emit LogUint256("virtual balance post fund-draw",virtualBalancePostFund);
    | 			emit LogUint256("virtual balance pre fund-draw", virtualBalancePreFund);
    | 			emit AssertionFailed("virtual balance should be equal after fund-draw");
    | 		}
    | 		// reserves should be equal
    | 		uint256 reservePostFund = getReserve(address(_hyper),address(token));
    | 		if(reservePostFund != reservePreFund){
    | 			emit LogUint256("reserve post fund-draw",reservePostFund);
    | 			emit LogUint256("reserve pre fund-draw", reservePreFund);
    | 			emit AssertionFailed("reserve balance should be equal after fund-draw");
    | 		}
    | 		// recipient = sender balance should be equal
    | 		uint256 recipientBalancePostFund = TestERC20(token).balanceOf(address(this));			
    | 		if(recipientBalancePostFund  != recipientBalancePreFund){
    | 			emit LogUint256("recipient balance post fund-draw",recipientBalancePostFund);
    | 			emit LogUint256("recipient balance pre fund-draw", recipientBalancePreFund);
    | 			emit AssertionFailed("recipient balance should be equal after fund-draw");			
    | 		}
    | 		// hyper token's balance should be equal
    | 		uint256 tokenPostFund = TestERC20(token).balanceOf(address(_hyper));
    | 		if(tokenPostFund != hyperBalancePreFund){
    | 			emit LogUint256("token post fund-draw",tokenPostFund);
    | 			emit LogUint256("token pre fund-draw", hyperBalancePreFund);
    | 			emit AssertionFailed("hyper token balance should be equal after fund-draw");						
    | 		}		
    | 	}
    | 	// ******************** Depositing ********************	
    | 	function deposit_with_correct_preconditions_should_succeed() public payable {
    | 		require(msg.value>0);
    | 		emit LogUint256("msg.value",msg.value);
    | 
    | 		uint256 ethBalancePreTransfer = address(this).balance;
    | 		uint256 wethPreTransfer = _weth.balanceOf(address(_hyper));
    | 
    | 		try _hyper.deposit{value:msg.value}() {
    | 			uint256 ethBalancePostTransfer = address(this).balance;		
    | 			uint256 wethPostTransfer = _weth.balanceOf(address(_hyper));
    | 
    | 			// sender's eth balance should decrease 
    | 			assert(ethBalancePostTransfer == ethBalancePreTransfer - msg.value);
    | 			// weth balance of contract should increase
    | 			// pretransfer = b; post-transfer = b+msg.value
*   | 			assert(wethPostTransfer == wethPreTransfer+msg.value);
    | 			
    | 		} catch (bytes memory err) {
    | 			emit LogBytes("error",err);
    | 			emit AssertionFailed("deposit should not have failed.");
    | 		}
    | 	}	
    |     using SafeCastLib for uint;
    | 	// Future invariant: Funding with WETH and then depositing with ETH should have the same impact on the pool 
    | 	// ******************** Helper ********************	
    |     function allocate_should_succeed_with_correct_preconditions(uint256 id, uint amount) public {
    | 		(HyperPool memory pool,uint64 poolId) = retrieve_created_pool(id);
    | 		require(pool.lastPrice !=0);
    | 		require(pool.lastTimestamp !=0);
    | 
    | 		amount = between(amount,1,type(uint256).max);
    | 		uint128 deltaLiquidity;
    | 		if (amount == type(uint256).max) {
    | 			deltaLiquidity = 1;
    | 		} else {
    | 			deltaLiquidity = uint128(amount);
    | 		}
    | 		// require(deltaLiquidity != 0);
    | 
    | 		setup_fund(amount,amount);
    | 
    | 		(uint256 deltaAsset,uint256 deltaQuote) = _hyper.allocate(poolId,amount);
    | 
    | 	}
    | 	// allocate should fail on a nonexistent pool 
    | 	// allocate shoudl fail if deltaLiquidity = 0
    | 	// ******************** Helper ********************	
    |     function between(uint256 random,uint256 low, uint256 high) private returns (uint256) {
    |         return low + (random % (high - low));
    |     }
    | 	function retrieve_created_pool(uint256 id) private returns (HyperPool memory pool, uint64 poolId) {
    | 		require(poolIds.length > 0);
    | 		id = between(id,0,poolIds.length);
    | 		return (getPool(address(_hyper),poolIds[id]),poolIds[id]);
    | 	}
    | }

/root/code/hyper/contracts/echidna/Helper.sol
    | pragma solidity ^0.8.0;
    | contract Helper {
    | 	event AssertionFailed(string msg);
    | 	event LogUint256(string msg, uint256 value);
    | 	event LogBytes(string msg, bytes value);
    | 	event LogAddress(string msg, address tkn);
    | 	event LogInt24(string msg,int24 value);
    | 
    | 	int24 constant MAX_TICK = 887272;
    | 	int24 constant MIN_TICK = -414486;
    | 	uint256 constant BUFFER = 300 seconds;
    | 	uint256 constant MIN_FEE = 1; // 0.01%
    | 	uint256 constant MAX_FEE = 1000; // 10%
    | 	uint256 constant MIN_VOLATILITY = 100; // 1%
    | 	uint256 constant MAX_VOLATILITY = 25_000; // 250%
    | 	uint256 constant MIN_DURATION = 1; // days, but without units
    | 	uint256 constant MAX_DURATION = 500; // days, but without units
    | 	uint256 constant JUST_IN_TIME_MAX = 600 seconds;
    | 	uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;	
    | 
    | 	
    | }

/root/code/hyper/contracts/interfaces/IERC20.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity >=0.5.0;
    | 
    | interface IERC20 {
    |     function totalSupply() external view returns (uint256);
    | 
    |     function balanceOf(address account) external view returns (uint256);
    | 
    |     function transfer(address recipient, uint256 amount) external returns (bool);
    | 
    |     function allowance(address owner, address spender) external view returns (uint256);
    | 
    |     function approve(address spender, uint256 amount) external returns (bool);
    | 
    |     function transferFrom(
    |         address sender,
    |         address recipient,
    |         uint256 amount
    |     ) external returns (bool);
    | 
    |     event Transfer(address indexed from, address indexed to, uint256 value);
    | 
    |     event Approval(address indexed owner, address indexed spender, uint256 value);
    | 
    |     function decimals() external view returns (uint8);
    | }
    | 

/root/code/hyper/contracts/interfaces/IHyper.sol
    | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | import {HyperCurve, HyperPair} from "../HyperLib.sol";
    | 
    | interface IHyperEvents {
    |     event Deposit(address indexed account, uint amount);
    |     event DecreaseUserBalance(address indexed account, address indexed token, uint256 amount);
    |     event DecreaseReserveBalance(address indexed token, uint256 amount);
    |     event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);
    |     event IncreaseReserveBalance(address indexed token, uint256 amount);
    |     event Swap(
    |         uint64 indexed poolId,
    |         uint256 price,
    |         address indexed tokenIn,
    |         uint256 input,
    |         address indexed tokenOut,
    |         uint256 output
    |     );
    |     event Stake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);
    |     event Unstake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);
    |     event Allocate(
    |         uint64 indexed poolId,
    |         address indexed asset,
    |         address indexed quote,
    |         uint256 deltaAsset,
    |         uint256 deltaQuote,
    |         uint256 deltaLiquidity
    |     );
    |     event Unallocate(
    |         uint64 indexed poolId,
    |         address indexed asset,
    |         address indexed quote,
    |         uint256 deltaAsset,
    |         uint256 deltaQuote,
    |         uint256 deltaLiquidity
    |     );
    | 
    |     event ChangeParameters(
    |         uint64 indexed poolId,
    |         uint16 priorityFee,
    |         uint16 indexed fee,
    |         uint16 volatility,
    |         uint16 duration,
    |         uint16 jit,
    |         int24 indexed maxTick
    |     );
    |     event Collect(
    |         uint64 poolId,
    |         address account,
    |         uint feeAsset,
    |         address indexed asset,
    |         uint feeQuote,
    |         address indexed quote,
    |         uint feeReward,
    |         address indexed reward
    |     );
    |     event CreatePair(
    |         uint24 indexed pairId,
    |         address indexed asset,
    |         address indexed quote,
    |         uint8 decimalsAsset,
    |         uint8 decimalsQuote
    |     );
    |     event CreatePool(
    |         uint64 indexed poolId,
    |         bool isMutable,
    |         address indexed asset,
    |         address indexed quote,
    |         uint256 price
    |     );
    | }
    | 
    | interface IHyperGetters {
    |     function getNetBalance(address token) external view returns (int);
    | 
    |     function getReserve(address token) external view returns (uint);
    | 
    |     function getBalance(address owner, address token) external view returns (uint);
    | 
    |     function pairs(
    |         uint24 pairId
    |     ) external view returns (address tokenAsset, uint8 decimalsAsset, address tokenQuote, uint8 decimalsQuote);
    | 
    |     function pools(
    |         uint64 poolId
    |     )
    |         external
    |         view
    |         returns (
    |             int24 lastTick,
    |             uint32 lastTimestamp,
    |             address controller,
    |             uint256 feeGrowthGlobalReward,
    |             uint256 feeGrowthGlobalAsset,
    |             uint256 feeGrowthGlobalQuote,
    |             uint128 lastPrice,
    |             uint128 liquidity,
    |             uint128 stakedLiquidity,
    |             int128 stakedLiquidityDelta,
    |             HyperCurve memory,
    |             HyperPair memory
    |         );
    | 
    |     function positions(
    |         address owner,
    |         uint64 poolId
    |     )
    |         external
    |         view
    |         returns (
    |             uint128 freeLiquidity,
    |             uint128 stakedLiquidity,
    |             uint256 lastTimestamp,
    |             uint256 stakeTimestamp,
    |             uint256 unstakeTimestamp,
    |             uint256 feeGrowthRewardLast,
    |             uint256 feeGrowthAssetLast,
    |             uint256 feeGrowthQuoteLast,
    |             uint128 tokensOwedAsset,
    |             uint128 tokensOwedQuote,
    |             uint128 tokensOwedReward
    |         );
    | 
    |     function getPairNonce() external view returns (uint256);
    | 
    |     function getAmounts(uint64 poolId) external view returns (uint256 deltaAsset, uint256 deltaQuote);
    | 
    |     function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) external view returns (uint);
    | 
    |     function getVirtualReserves(uint64 poolId) external view returns (uint128 deltaAsset, uint128 deltaQuote);
    | 
    |     function getMaxLiquidity(
    |         uint64 poolId,
    |         uint deltaAsset,
    |         uint deltaQuote
    |     ) external view returns (uint128 deltaLiquidity);
    | 
    |     function getLiquidityDeltas(
    |         uint64 poolId,
    |         int128 deltaLiquidity
    |     ) external view returns (uint128 deltaAsset, uint128 deltaQuote);
    | 
    |     function getLatestPrice(uint64 poolId) external view returns (uint price);
    | }
    | 
    | interface IHyperActions {
    |     function allocate(uint64 poolId, uint deltaLiquidity) external returns (uint deltaAsset, uint deltaQuote);
    | 
    |     function unallocate(uint64 poolId, uint amount) external returns (uint deltaAsset, uint deltaQuote);
    | 
    |     function stake(uint64 poolId, uint128 deltaLiquidity) external;
    | 
    |     function unstake(uint64 poolId, uint128 deltaLiquidity) external;
    | 
    |     function swap(
    |         uint64 poolId,
    |         bool sellAsset,
    |         uint amount,
    |         uint limit
    |     ) external returns (uint output, uint remainder);
    | 
    |     function fund(address token, uint256 amount) external;
    | 
    |     function draw(address token, uint256 amount, address to) external;
    | 
    |     function deposit() external payable;
    | 
    |     function changeParameters(
    |         uint64 poolId,
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 volatility,
    |         uint16 duration,
    |         uint16 jit,
    |         int24 maxTick
    |     ) external;
    | }
    | 
    | interface IHyper is IHyperActions, IHyperEvents, IHyperGetters {}
    | 

/root/code/hyper/contracts/interfaces/IWETH.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.13;
    | 
    | interface IWETH {
    |     function deposit() external payable;
    | 
    |     function withdraw(uint256 wad) external;
    | }
    | 

/root/code/hyper/contracts/libraries/Price.sol
    | // SPDX-License-Identifier: AGPL-3.0-only
    | pragma solidity 0.8.13;
    | 
    | import "solstat/Invariant.sol";
    | 
    | using Price for Price.RMM global;
    | 
    | /**
    |  * @dev     Library for RMM to compute reserves, prices, and changes in reserves over time.
    |  * @notice  Units Glossary:
    |  *
    |  *          wad - `1 ether` == 1e18
    |  *          seconds - `1 seconds` == 1
    |  *          percentage - 10_000 == 100%
    |  *
    |  */
    | library Price {
    |     using FixedPointMathLib for uint256;
    |     using FixedPointMathLib for int256;
    | 
    |     struct RMM {
    |         uint256 strike; // wad
    |         uint256 sigma; // 10_000 = 100%;
    |         uint256 tau; // seconds
    |     }
    | 
    |     error OverflowWad(int256 wad);
    | 
*r  |     int256 internal constant TICK_BASE = 1_0001e14;
    |     uint256 internal constant DOUBLE_WAD = 2 ether;
    |     uint256 internal constant PERCENTAGE = 10_000;
r   |     uint256 internal constant SQRT_WAD = 1e9;
    |     uint256 internal constant WAD = 1 ether;
    |     uint256 internal constant YEAR = 31556953 seconds;
    | 
    |     // ===== Class Methods ===== //
    | 
    |     function invariantOf(RMM memory args, uint R_y, uint R_x) internal pure returns (int256) {
    |         return Invariant.invariant(R_y, R_x, args.strike, convertPercentageToWad(args.sigma), args.tau);
    |     }
    | 
*r  |     function getXWithPrice(RMM memory args, uint256 prc) internal pure returns (uint256 R_x) {
*r  |         R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);
    |     }
    | 
    |     function getPriceWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 prc) {
    |         prc = getPriceWithX(R_x, args.strike, args.sigma, args.tau);
    |     }
    | 
*r  |     function getYWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 R_y) {
*r  |         R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);
    |     }
    | 
    |     function getXWithY(RMM memory args, uint256 R_y) internal pure returns (uint256 R_x) {
    |         R_x = getXWithY(R_y, args.strike, args.sigma, args.tau, 0);
    |     }
    | 
    |     function computePriceWithChangeInTau(RMM memory args, uint256 prc, uint256 eps) internal pure returns (uint256) {
    |         return computePriceWithChangeInTau(args.strike, args.sigma, prc, args.tau, eps);
    |     }
    | 
r   |     function computeReserves(RMM memory args, uint prc) internal pure returns (uint R_y, uint R_x) {
r   |         R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);
    |         R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);
    |     }
    | 
    |     // ===== Raw Functions ===== //
    | 
    |     /**
    |      * @dev Computes change in price given a change in time in seconds.
    |      * @param stk WAD
    |      * @param vol percentage
    |      * @param prc WAD
    |      * @param tau seconds
    |      * @param epsilon seconds
    |      * @custom:math P(τ - ε) = ( P(τ)^(√(1 - ε/τ)) / K^2 )e^((1/2)(t^2)(√(τ)√(τ- ε) - (τ - ε)))
    |      */
r   |     function computePriceWithChangeInTau(
    |         uint256 stk,
    |         uint256 vol,
    |         uint256 prc,
    |         uint256 tau,
    |         uint256 epsilon
r   |     ) internal pure returns (uint256) {
r   |         if (epsilon == 0) return prc;
r   |         if (epsilon > tau) return stk;
    | 
    |         RMM memory params = RMM(stk, vol, tau);
    | 
    |         uint256 tauYears;
    |         assembly {
    |             tauYears := sdiv(mul(tau, WAD), YEAR) // tau * WAD / year = time in years scaled to WAD
    |         }
    | 
    |         uint256 epsilonYears;
    |         assembly {
    |             epsilonYears := sdiv(mul(epsilon, WAD), YEAR) // epsilon * WAD / year = epsilon in years scaled to WAD
    |         }
    | 
    |         uint256 term_0 = WAD - (epsilonYears.divWadUp(tauYears)); // WAD - ((epsilon * WAD) / tau rounded down), units are WAD - WAD, time units cancel out
    |         uint256 term_1 = term_0.sqrt(); // this sqrts WAD, so we end up with SQRT_WAD units
    | 
    |         uint256 term_2 = prc.divWadUp(params.strike); // p(t) / K, both units are already WAD
    |         uint256 term_3 = uint256(int256(term_2).powWad(int256(term_1 * SQRT_WAD)));
    | 
    |         uint256 term_7;
    |         {
    |             uint256 currentTau = tauYears - epsilonYears; // WAD - WAD = WAD
    |             uint256 tausSqrt = tauYears.sqrt() * (currentTau).sqrt(); // sqrt(1e18) = 1e9, so 1e9 * 1e9 = 1e18
    |             uint256 term_4 = tausSqrt - currentTau; // WAD - WAD = WAD
    | 
    |             uint256 sigmaWad = convertPercentageToWad(uint256(params.sigma));
    | 
    |             uint256 term_5 = (sigmaWad * sigmaWad) / DOUBLE_WAD; // 1e4 * 1e4 * 1e17 / 1e4 = 1e17, which is half WAD
*r  |             uint256 term_6 = uint256((int256(term_5.mulWadDown(term_4))).expWad()); // exp(WAD * WAD / WAD)
    |             term_7 = uint256(params.strike).mulWadDown(term_6); // WAD * WAD / WAD
    |         }
    | 
    |         uint256 price = term_3.mulWadDown(term_7); // WAD * WAD / WAD = WAD
    |         return price;
    |     }
    | 
    |     /**
    |      * @dev R_y = tradingFunction(R_x, ...)
    |      * @param R_x WAD
    |      * @param stk WAD
    |      * @param vol percentage
    |      * @param tau seconds
    |      * @param inv WAD
    |      * @return R_y WAD
    |      */
*r  |     function getYWithX(
    |         uint256 R_x,
    |         uint256 stk,
    |         uint256 vol,
    |         uint256 tau,
    |         int256 inv
*r  |     ) internal pure returns (uint256 R_y) {
*r  |         R_y = Invariant.getY(R_x, stk, convertPercentageToWad(vol), tau, inv);
    |     }
    | 
    |     /**
    |      * @dev R_x = tradingFunction(R_y, ...)
    |      * @param R_y WAD
    |      * @param stk WAD
    |      * @param vol percentage
    |      * @param tau seconds
    |      * @param inv WAD
    |      * @return R_x WAD
    |      */
    |     function getXWithY(
    |         uint256 R_y,
    |         uint256 stk,
    |         uint256 vol,
    |         uint256 tau,
    |         int256 inv
    |     ) internal pure returns (uint256 R_x) {
    |         R_x = Invariant.getX(R_y, stk, convertPercentageToWad(vol), tau, inv);
    |     }
    | 
    |     /**
    |      * @dev Used in `getAmounts` to compute the virtual amount of assets at the pool's price.
    |      * @param prc WAD
    |      * @param stk WAD
    |      * @param vol percentage
    |      * @param tau seconds
    |      * @return R_x WAD
    |      * @custom:math R_x = 1 - Φ(( ln(S/K) + (σ²/2)τ ) / σ√τ)
    |      */
*r  |     function getXWithPrice(uint256 prc, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 R_x) {
*r  |         if (prc != 0) {
r   |             int256 ln = FixedPointMathLib.lnWad(int256(FixedPointMathLib.divWadDown(prc, stk)));
r   |             uint256 tauYears = convertSecondsToWadYears(tau);
    | 
    |             uint256 sigmaWad = convertPercentageToWad(vol);
r   |             uint256 doubleSigma = (sigmaWad * sigmaWad) / uint256(Gaussian.TWO);
r   |             uint256 halfSigmaTau = doubleSigma * tauYears;
r   |             uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(sigmaWad);
    | 
r   |             int256 lnOverVol = (ln * Gaussian.ONE + int256(halfSigmaTau)) / int256(sqrtTauSigma);
    |             int256 cdf = Gaussian.cdf(lnOverVol);
    |             if (cdf > Gaussian.ONE) revert OverflowWad(cdf);
    |             R_x = uint256(Gaussian.ONE - cdf);
    |         }
    |     }
    | 
    |     /**
    |      * @dev price(R_x) = Ke^(Φ^-1(1 - R_x)σ√τ - 1/2σ^2τ)
    |      * @param R_x WAD
    |      * @param stk WAD
    |      * @param vol percentage
    |      * @param tau seconds
    |      * @return prc WAD
    |      */
    |     function getPriceWithX(uint256 R_x, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 prc) {
    |         uint256 tauYears = convertSecondsToWadYears(tau);
    |         uint256 volWad = convertPercentageToWad(vol);
    | 
    |         if (uint256(Gaussian.ONE) < R_x) revert OverflowWad(int256(R_x));
    |         int256 input = Gaussian.ONE - int256(R_x);
    |         int256 ppf = Gaussian.ppf(input);
    |         uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(volWad);
    |         int256 first = (ppf * int256(sqrtTauSigma)) / Gaussian.ONE; // Φ^-1(1 - R_x)σ√τ
    |         uint256 doubleSigma = (volWad * volWad) / uint256(Gaussian.TWO);
    |         int256 halfSigmaTau = int256(doubleSigma * tauYears) / Gaussian.ONE; // 1/2σ^2τ
    | 
    |         int256 exponent = first - halfSigmaTau;
    |         int256 exp = exponent.expWad();
    |         prc = uint256(exp).mulWadDown(stk);
    |     }
    | 
    |     // ===== Tick Math ===== //
    | 
    |     /**
    |      * @dev Computes a price value from a tick key.
    |      *
    |      * @custom:math price = e^(ln(1.0001) * tick)
    |      *
    |      * @param tick Key of a slot in a price/liquidity grid.
    |      * @return price WAD Value on a key (tick) value pair of a price grid.
    |      */
*r  |     function computePriceWithTick(int24 tick) internal pure returns (uint256 price) {
*r  |         int256 tickWad = int256(tick) * int256(FixedPointMathLib.WAD);
*r  |         price = uint256(FixedPointMathLib.powWad(TICK_BASE, tickWad));
    |     }
    | 
    |     /**
    |      * @dev Computes a tick value from the price.
    |      *
    |      * @custom:math tick = ln(price) / ln(1.0001)
    |      *
    |      * @param price WAD Value on a key (tick) value pair of a price grid.
    |      * @return tick Key of a slot in a price/liquidity grid.
    |      */
r   |     function computeTickWithPrice(uint256 price) internal pure returns (int24 tick) {
r   |         uint256 numerator = uint256(int256(price).lnWad());
r   |         uint256 denominator = uint256(TICK_BASE.lnWad());
r   |         tick = int24(int256((numerator)) / int256(denominator) + 1);
    |     }
    | 
    |     // ===== Utils ===== //
    | 
    |     function convertSecondsToWadYears(uint256 sec) internal pure returns (uint256 yrsWad) {
    |         assembly {
r   |             yrsWad := div(mul(sec, WAD), YEAR)
    |         }
    |     }
    | 
    |     function convertPercentageToWad(uint256 pct) internal pure returns (uint256 pctWad) {
    |         assembly {
*r  |             pctWad := div(mul(pct, WAD), PERCENTAGE)
    |         }
    |     }
    | }
    | 

/root/code/hyper/contracts/test/HyperForwarderHelper.sol
    | // SPDX-License-Identifier: UNLICENSED
    | pragma solidity 0.8.13;
    | 
    | interface IERC20 {
    |     function approve(address spender, uint256 amount) external;
    | }
    | 
    | contract HyperForwarderHelper {
    |     Caller public caller;
    | 
    |     event Success();
    |     event Fail(bytes reason);
    | 
    |     constructor() {
    |         caller = new Caller();
    |     }
    | 
    |     function approve(address token, address target) external {
    |         caller.approve(token, target, type(uint256).max);
    |     }
    | 
    |     // Assumes Hyper calls this, for testing only.
    |     function pass(address target, bytes calldata data) external payable returns (bool) {
    |         try caller.forward{value: msg.value}(target, data) {
    |             emit Success();
    |             return true;
    |         } catch (bytes memory reason) {
    |             emit Fail(reason);
    |             assembly {
    |                 revert(add(32, reason), mload(reason))
    |             }
    |         }
    |     }
    | 
    |     function getPoolId(uint24 pairId, bool isMutable, uint32 poolNonce) public pure returns (uint64) {
    |         return uint64(bytes8(abi.encodePacked(pairId, isMutable ? 1 : 0, poolNonce)));
    |     }
    | }
    | 
    | /// @dev msg.sender in Hyper calls.
    | contract Caller {
    |     function approve(address token, address to, uint256 amount) external {
    |         IERC20(token).approve(to, amount);
    |     }
    | 
    |     function forward(address target, bytes calldata data) external payable returns (bool) {
    |         (bool success, bytes memory returnData) = target.call{value: msg.value}(data);
    |         if (!success) {
    |             assembly {
    |                 revert(add(32, returnData), mload(returnData))
    |             }
    |         }
    | 
    |         return success;
    |     }
    | }
    | 

/root/code/hyper/contracts/test/TestERC20.sol
    | // SPDX-License-Identifier: UNLICENSED
    | pragma solidity 0.8.13;
    | 
    | import "../interfaces/IERC20.sol";
*r  | 
    | contract TestERC20 is IERC20 {
    |     mapping(address => uint256) private _balances;
    | 
    |     mapping(address => mapping(address => uint256)) private _allowances;
    | 
    |     uint256 private _totalSupply;
    | 
*   |     string public name;
*   |     string public symbol;
*   |     uint8 public override decimals;
    | 
    |     constructor(
    |         string memory name_,
    |         string memory symbol_,
    |         uint8 decimals_
    |     ) {
    |         name = name_;
    |         symbol = symbol_;
    |         decimals = decimals_;
    |     }
    | 
    |     /// @notice Used for testing pairs with decimals that are not 18
*   |     function setDecimals(uint8 decimals_) public {
*   |         decimals = decimals_;
    |     }
    | 
*   |     function totalSupply() public view virtual override returns (uint256) {
*   |         return _totalSupply;
    |     }
    | 
*   |     function balanceOf(address account) public view virtual override returns (uint256) {
*   |         return _balances[account];
    |     }
    | 
*   |     function mint(address to, uint256 wad) public {
*   |         _mint(to, wad);
    |     }
    | 
*r  |     function burn(address to, uint256 wad) public {
*r  |         _burn(to, wad);
    |     }
    | 
r   |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
r   |         _transfer(msg.sender, recipient, amount);
    |         return true;
    |     }
    | 
*   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
*   |         return _allowances[owner][spender];
    |     }
    | 
*   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
*   |         _approve(msg.sender, spender, amount);
*   |         return true;
    |     }
    | 
r   |     function transferFrom(
    |         address sender,
    |         address recipient,
    |         uint256 amount
r   |     ) public virtual override returns (bool) {
r   |         _transfer(sender, recipient, amount);
    | 
    |         uint256 currentAllowance = _allowances[sender][msg.sender];
r   |         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
    |         unchecked {
    |             _approve(sender, msg.sender, currentAllowance - amount);
    |         }
    | 
    |         return true;
    |     }
    | 
*r  |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
*r  |         _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
    |         return true;
    |     }
    | 
r   |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
r   |         uint256 currentAllowance = _allowances[msg.sender][spender];
r   |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
    |         unchecked {
    |             _approve(msg.sender, spender, currentAllowance - subtractedValue);
    |         }
    | 
    |         return true;
    |     }
    | 
r   |     function _transfer(
    |         address sender,
    |         address recipient,
    |         uint256 amount
    |     ) internal virtual {
r   |         require(sender != address(0), "ERC20: transfer from the zero address");
r   |         require(recipient != address(0), "ERC20: transfer to the zero address");
    | 
    |         _beforeTokenTransfer(sender, recipient, amount);
    | 
r   |         uint256 senderBalance = _balances[sender];
r   |         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
    |         unchecked {
    |             _balances[sender] = senderBalance - amount;
    |         }
    |         _balances[recipient] += amount;
    | 
    |         emit Transfer(sender, recipient, amount);
    |     }
    | 
*   |     function _mint(address account, uint256 amount) internal virtual {
*   |         require(account != address(0), "ERC20: mint to the zero address");
    | 
    |         _beforeTokenTransfer(address(0), account, amount);
    | 
*   |         _totalSupply += amount;
*   |         _balances[account] += amount;
*   |         emit Transfer(address(0), account, amount);
    |     }
    | 
*r  |     function _burn(address account, uint256 amount) internal virtual {
*r  |         require(account != address(0), "ERC20: burn from the zero address");
    | 
    |         _beforeTokenTransfer(account, address(0), amount);
    | 
*r  |         uint256 accountBalance = _balances[account];
*r  |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
    |         unchecked {
*   |             _balances[account] = accountBalance - amount;
    |         }
*   |         _totalSupply -= amount;
    | 
*   |         emit Transfer(account, address(0), amount);
    |     }
    | 
*r  |     function _approve(
    |         address owner,
    |         address spender,
    |         uint256 amount
    |     ) internal virtual {
*r  |         require(owner != address(0), "ERC20: approve from the zero address");
*r  |         require(spender != address(0), "ERC20: approve to the zero address");
    | 
*   |         _allowances[owner][spender] = amount;
*   |         emit Approval(owner, spender, amount);
    |     }
    | 
    |     function _beforeTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual {}
    | }
    | 

/root/code/hyper/contracts/test/TestHyperTime.sol
    | // SPDX-License-Identifier: UNLICENSED
    | pragma solidity 0.8.13;
    | 
    | import "../Hyper.sol";
    | 
    | contract TestHyperTime is Hyper {
    |     uint256 public timestamp;
    | 
    |     function set(uint256 x) public {
    |         timestamp = x;
    |     }
    | 
    |     constructor(address weth) Hyper(weth) {}
    | 
    |     function _blockTimestamp() internal view override returns (uint128) {
    |         return uint128(timestamp);
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/Base.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | import {StdStorage} from "./StdStorage.sol";
    | import {Vm, VmSafe} from "./Vm.sol";
    | 
    | abstract contract CommonBase {
    |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
    |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
    |     // console.sol and console2.sol work by executing a staticcall to this address.
    |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
    |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
    |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
    |     // Address of the test contract, deployed by the DEFAULT_SENDER.
    |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
    | 
    |     uint256 internal constant UINT256_MAX =
    |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
    | 
    |     Vm internal constant vm = Vm(VM_ADDRESS);
    |     StdStorage internal stdstore;
    | }
    | 
    | abstract contract TestBase is CommonBase {}
    | 
    | abstract contract ScriptBase is CommonBase {
    |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
    |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
    | 
    |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdAssertions.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | import {DSTest} from "ds-test/test.sol";
    | import {stdMath} from "./StdMath.sol";
    | 
    | abstract contract StdAssertions is DSTest {
    |     event log_array(uint256[] val);
    |     event log_array(int256[] val);
    |     event log_array(address[] val);
    |     event log_named_array(string key, uint256[] val);
    |     event log_named_array(string key, int256[] val);
    |     event log_named_array(string key, address[] val);
    | 
    |     function fail(string memory err) internal virtual {
    |         emit log_named_string("Error", err);
    |         fail();
    |     }
    | 
    |     function assertFalse(bool data) internal virtual {
    |         assertTrue(!data);
    |     }
    | 
    |     function assertFalse(bool data, string memory err) internal virtual {
    |         assertTrue(!data, err);
    |     }
    | 
    |     function assertEq(bool a, bool b) internal virtual {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [bool]");
    |             emit log_named_string("  Expected", b ? "true" : "false");
    |             emit log_named_string("    Actual", a ? "true" : "false");
    |             fail();
    |         }
    |     }
    | 
    |     function assertEq(bool a, bool b, string memory err) internal virtual {
    |         if (a != b) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    | 
    |     function assertEq(bytes memory a, bytes memory b) internal virtual {
    |         assertEq0(a, b);
    |     }
    | 
    |     function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {
    |         assertEq0(a, b, err);
    |     }
    | 
    |     function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {
    |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
    |             emit log("Error: a == b not satisfied [uint[]]");
    |             emit log_named_array("  Expected", b);
    |             emit log_named_array("    Actual", a);
    |             fail();
    |         }
    |     }
    | 
    |     function assertEq(int256[] memory a, int256[] memory b) internal virtual {
    |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
    |             emit log("Error: a == b not satisfied [int[]]");
    |             emit log_named_array("  Expected", b);
    |             emit log_named_array("    Actual", a);
    |             fail();
    |         }
    |     }
    | 
    |     function assertEq(address[] memory a, address[] memory b) internal virtual {
    |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
    |             emit log("Error: a == b not satisfied [address[]]");
    |             emit log_named_array("  Expected", b);
    |             emit log_named_array("    Actual", a);
    |             fail();
    |         }
    |     }
    | 
    |     function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {
    |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    | 
    |     function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {
    |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    | 
    |     function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {
    |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    | 
    |     // Legacy helper
    |     function assertEqUint(uint256 a, uint256 b) internal virtual {
    |         assertEq(uint256(a), uint256(b));
    |     }
    | 
    |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {
    |         uint256 delta = stdMath.delta(a, b);
    | 
    |         if (delta > maxDelta) {
    |             emit log("Error: a ~= b not satisfied [uint]");
    |             emit log_named_uint("  Expected", b);
    |             emit log_named_uint("    Actual", a);
    |             emit log_named_uint(" Max Delta", maxDelta);
    |             emit log_named_uint("     Delta", delta);
    |             fail();
    |         }
    |     }
    | 
    |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {
    |         uint256 delta = stdMath.delta(a, b);
    | 
    |         if (delta > maxDelta) {
    |             emit log_named_string("Error", err);
    |             assertApproxEqAbs(a, b, maxDelta);
    |         }
    |     }
    | 
    |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {
    |         uint256 delta = stdMath.delta(a, b);
    | 
    |         if (delta > maxDelta) {
    |             emit log("Error: a ~= b not satisfied [int]");
    |             emit log_named_int("  Expected", b);
    |             emit log_named_int("    Actual", a);
    |             emit log_named_uint(" Max Delta", maxDelta);
    |             emit log_named_uint("     Delta", delta);
    |             fail();
    |         }
    |     }
    | 
    |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {
    |         uint256 delta = stdMath.delta(a, b);
    | 
    |         if (delta > maxDelta) {
    |             emit log_named_string("Error", err);
    |             assertApproxEqAbs(a, b, maxDelta);
    |         }
    |     }
    | 
    |     function assertApproxEqRel(
    |         uint256 a,
    |         uint256 b,
    |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
    |     ) internal virtual {
    |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
    | 
    |         uint256 percentDelta = stdMath.percentDelta(a, b);
    | 
    |         if (percentDelta > maxPercentDelta) {
    |             emit log("Error: a ~= b not satisfied [uint]");
    |             emit log_named_uint("    Expected", b);
    |             emit log_named_uint("      Actual", a);
    |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
    |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
    |             fail();
    |         }
    |     }
    | 
    |     function assertApproxEqRel(
    |         uint256 a,
    |         uint256 b,
    |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
    |         string memory err
    |     ) internal virtual {
    |         if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.
    | 
    |         uint256 percentDelta = stdMath.percentDelta(a, b);
    | 
    |         if (percentDelta > maxPercentDelta) {
    |             emit log_named_string("Error", err);
    |             assertApproxEqRel(a, b, maxPercentDelta);
    |         }
    |     }
    | 
    |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {
    |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
    | 
    |         uint256 percentDelta = stdMath.percentDelta(a, b);
    | 
    |         if (percentDelta > maxPercentDelta) {
    |             emit log("Error: a ~= b not satisfied [int]");
    |             emit log_named_int("    Expected", b);
    |             emit log_named_int("      Actual", a);
    |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
    |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
    |             fail();
    |         }
    |     }
    | 
    |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {
    |         if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.
    | 
    |         uint256 percentDelta = stdMath.percentDelta(a, b);
    | 
    |         if (percentDelta > maxPercentDelta) {
    |             emit log_named_string("Error", err);
    |             assertApproxEqRel(a, b, maxPercentDelta);
    |         }
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdChains.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | pragma experimental ABIEncoderV2;
    | 
    | import {VmSafe} from "./Vm.sol";
    | 
    | /**
    |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
    |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
    |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
    |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
    |  * alias used in this contract, which can be found as the first argument to the
    |  * `setChainWithDefaultRpcUrl` call in the `initialize` function.
    |  *
    |  * There are two main ways to use this contract:
    |  *   1. Set a chain with `setChain(string memory chainAlias, Chain memory chain)`
    |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
    |  *
    |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
    |  * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
    |  * `defaultRpcUrls`.
    |  *
    |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
    |  *
    |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
    |  * we want to retrieve `mainnet`'s RPC URL:
    |  *   - If you haven't set any mainnet chain info with `setChain` and you haven't specified that
    |  *     chain in `foundry.toml`, the default data and RPC URL will be returned.
    |  *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if
    |  *     a URL is given or if an environment variable is given and that environment variable exists).
    |  *     Otherwise, the default data is returned.
    |  *   - If you specified data with `setChain` it will return that.
    |  *
    |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> defaults.
    |  */
    | abstract contract StdChains {
    |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
    | 
    |     bool private initialized;
    | 
    |     struct Chain {
    |         // The chain name.
    |         string name;
    |         // The chain's Chain ID.
    |         uint256 chainId;
    |         // A default RPC endpoint for this chain.
    |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
    |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
    |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
    |         string rpcUrl;
    |     }
    | 
    |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
    |     mapping(string => Chain) private chains;
    |     // Maps from the chain's alias to it's default RPC URL.
    |     mapping(string => string) private defaultRpcUrls;
    |     // Maps from a chain ID to it's alias.
    |     mapping(uint256 => string) private idToAlias;
    | 
    |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
    |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
    |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
    | 
    |         initialize();
    |         chain = chains[chainAlias];
    |         require(
    |             chain.chainId != 0,
    |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
    |         );
    | 
    |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
    |     }
    | 
    |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
    |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
    |         initialize();
    |         string memory chainAlias = idToAlias[chainId];
    | 
    |         chain = chains[chainAlias];
    | 
    |         require(
    |             chain.chainId != 0,
    |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
    |         );
    | 
    |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
    |     }
    | 
    |     // set chain info, with priority to argument's rpcUrl field.
    |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
    |         require(
    |             bytes(chainAlias).length != 0, "StdChains setChain(string,Chain): Chain alias cannot be the empty string."
    |         );
    | 
    |         require(chain.chainId != 0, "StdChains setChain(string,Chain): Chain ID cannot be 0.");
    | 
    |         initialize();
    |         string memory foundAlias = idToAlias[chain.chainId];
    | 
    |         require(
    |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
    |             string(
    |                 abi.encodePacked(
    |                     "StdChains setChain(string,Chain): Chain ID ",
    |                     vm.toString(chain.chainId),
    |                     " already used by \"",
    |                     foundAlias,
    |                     "\"."
    |                 )
    |             )
    |         );
    | 
    |         uint256 oldChainId = chains[chainAlias].chainId;
    |         delete idToAlias[oldChainId];
    | 
    |         chains[chainAlias] = chain;
    |         idToAlias[chain.chainId] = chainAlias;
    |     }
    | 
    |     // lookup rpcUrl, in descending order of priority:
    |     // current -> config (foundry.toml) -> default
    |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
    |         private
    |         view
    |         returns (Chain memory)
    |     {
    |         if (bytes(chain.rpcUrl).length == 0) {
    |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
    |                 chain.rpcUrl = configRpcUrl;
    |             } catch (bytes memory err) {
    |                 chain.rpcUrl = defaultRpcUrls[chainAlias];
    |                 // distinguish 'not found' from 'cannot read'
    |                 bytes memory notFoundError =
    |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
    |                 if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {
    |                     /// @solidity memory-safe-assembly
    |                     assembly {
    |                         revert(add(32, err), mload(err))
    |                     }
    |                 }
    |             }
    |         }
    |         return chain;
    |     }
    | 
    |     function initialize() private {
    |         if (initialized) return;
    | 
    |         initialized = true;
    | 
    |         // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`
    |         setChainWithDefaultRpcUrl("anvil", Chain("Anvil", 31337, "http://127.0.0.1:8545"));
    |         setChainWithDefaultRpcUrl(
    |             "mainnet", Chain("Mainnet", 1, "https://mainnet.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
    |         );
    |         setChainWithDefaultRpcUrl(
    |             "goerli", Chain("Goerli", 5, "https://goerli.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
    |         );
    |         setChainWithDefaultRpcUrl(
    |             "sepolia", Chain("Sepolia", 11155111, "https://sepolia.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
    |         );
    |         setChainWithDefaultRpcUrl("optimism", Chain("Optimism", 10, "https://mainnet.optimism.io"));
    |         setChainWithDefaultRpcUrl("optimism_goerli", Chain("Optimism Goerli", 420, "https://goerli.optimism.io"));
    |         setChainWithDefaultRpcUrl("arbitrum_one", Chain("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
    |         setChainWithDefaultRpcUrl(
    |             "arbitrum_one_goerli", Chain("Arbitrum One Goerli", 421613, "https://goerli-rollup.arbitrum.io/rpc")
    |         );
    |         setChainWithDefaultRpcUrl("arbitrum_nova", Chain("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
    |         setChainWithDefaultRpcUrl("polygon", Chain("Polygon", 137, "https://polygon-rpc.com"));
    |         setChainWithDefaultRpcUrl("polygon_mumbai", Chain("Polygon Mumbai", 80001, "https://rpc-mumbai.maticvigil.com"));
    |         setChainWithDefaultRpcUrl("avalanche", Chain("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
    |         setChainWithDefaultRpcUrl(
    |             "avalanche_fuji", Chain("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
    |         );
    |         setChainWithDefaultRpcUrl("bnb_smart_chain", Chain("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org"));
    |         setChainWithDefaultRpcUrl("bnb_smart_chain_testnet", Chain("BNB Smart Chain Testnet", 97, "https://data-seed-prebsc-1-s1.binance.org:8545"));// forgefmt: disable-line
    |         setChainWithDefaultRpcUrl("gnosis_chain", Chain("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
    |     }
    | 
    |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
    |     function setChainWithDefaultRpcUrl(string memory chainAlias, Chain memory chain) private {
    |         string memory rpcUrl = chain.rpcUrl;
    |         defaultRpcUrls[chainAlias] = rpcUrl;
    |         chain.rpcUrl = "";
    |         setChain(chainAlias, chain);
    |         chain.rpcUrl = rpcUrl; // restore argument
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdCheats.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | pragma experimental ABIEncoderV2;
    | 
    | import {StdStorage, stdStorage} from "./StdStorage.sol";
    | import {Vm} from "./Vm.sol";
    | 
    | abstract contract StdCheatsSafe {
    |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    | 
    |     bool private gasMeteringOff;
    | 
    |     // Data structures to parse Transaction objects from the broadcast artifact
    |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
    |     // and then converted to the one that is used by the user for better UX.
    | 
    |     struct RawTx1559 {
    |         string[] arguments;
    |         address contractAddress;
    |         string contractName;
    |         // json value name = function
    |         string functionSig;
    |         bytes32 hash;
    |         // json value name = tx
    |         RawTx1559Detail txDetail;
    |         // json value name = type
    |         string opcode;
    |     }
    | 
    |     struct RawTx1559Detail {
    |         AccessList[] accessList;
    |         bytes data;
    |         address from;
    |         bytes gas;
    |         bytes nonce;
    |         address to;
    |         bytes txType;
    |         bytes value;
    |     }
    | 
    |     struct Tx1559 {
    |         string[] arguments;
    |         address contractAddress;
    |         string contractName;
    |         string functionSig;
    |         bytes32 hash;
    |         Tx1559Detail txDetail;
    |         string opcode;
    |     }
    | 
    |     struct Tx1559Detail {
    |         AccessList[] accessList;
    |         bytes data;
    |         address from;
    |         uint256 gas;
    |         uint256 nonce;
    |         address to;
    |         uint256 txType;
    |         uint256 value;
    |     }
    | 
    |     // Data structures to parse Transaction objects from the broadcast artifact
    |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
    |     // and then converted to the one that is used by the user for better UX.
    | 
    |     struct TxLegacy {
    |         string[] arguments;
    |         address contractAddress;
    |         string contractName;
    |         string functionSig;
    |         string hash;
    |         string opcode;
    |         TxDetailLegacy transaction;
    |     }
    | 
    |     struct TxDetailLegacy {
    |         AccessList[] accessList;
    |         uint256 chainId;
    |         bytes data;
    |         address from;
    |         uint256 gas;
    |         uint256 gasPrice;
    |         bytes32 hash;
    |         uint256 nonce;
    |         bytes1 opcode;
    |         bytes32 r;
    |         bytes32 s;
    |         uint256 txType;
    |         address to;
    |         uint8 v;
    |         uint256 value;
    |     }
    | 
    |     struct AccessList {
    |         address accessAddress;
    |         bytes32[] storageKeys;
    |     }
    | 
    |     // Data structures to parse Receipt objects from the broadcast artifact.
    |     // The Raw structs is what is parsed from the JSON
    |     // and then converted to the one that is used by the user for better UX.
    | 
    |     struct RawReceipt {
    |         bytes32 blockHash;
    |         bytes blockNumber;
    |         address contractAddress;
    |         bytes cumulativeGasUsed;
    |         bytes effectiveGasPrice;
    |         address from;
    |         bytes gasUsed;
    |         RawReceiptLog[] logs;
    |         bytes logsBloom;
    |         bytes status;
    |         address to;
    |         bytes32 transactionHash;
    |         bytes transactionIndex;
    |     }
    | 
    |     struct Receipt {
    |         bytes32 blockHash;
    |         uint256 blockNumber;
    |         address contractAddress;
    |         uint256 cumulativeGasUsed;
    |         uint256 effectiveGasPrice;
    |         address from;
    |         uint256 gasUsed;
    |         ReceiptLog[] logs;
    |         bytes logsBloom;
    |         uint256 status;
    |         address to;
    |         bytes32 transactionHash;
    |         uint256 transactionIndex;
    |     }
    | 
    |     // Data structures to parse the entire broadcast artifact, assuming the
    |     // transactions conform to EIP1559.
    | 
    |     struct EIP1559ScriptArtifact {
    |         string[] libraries;
    |         string path;
    |         string[] pending;
    |         Receipt[] receipts;
    |         uint256 timestamp;
    |         Tx1559[] transactions;
    |         TxReturn[] txReturns;
    |     }
    | 
    |     struct RawEIP1559ScriptArtifact {
    |         string[] libraries;
    |         string path;
    |         string[] pending;
    |         RawReceipt[] receipts;
    |         TxReturn[] txReturns;
    |         uint256 timestamp;
    |         RawTx1559[] transactions;
    |     }
    | 
    |     struct RawReceiptLog {
    |         // json value = address
    |         address logAddress;
    |         bytes32 blockHash;
    |         bytes blockNumber;
    |         bytes data;
    |         bytes logIndex;
    |         bool removed;
    |         bytes32[] topics;
    |         bytes32 transactionHash;
    |         bytes transactionIndex;
    |         bytes transactionLogIndex;
    |     }
    | 
    |     struct ReceiptLog {
    |         // json value = address
    |         address logAddress;
    |         bytes32 blockHash;
    |         uint256 blockNumber;
    |         bytes data;
    |         uint256 logIndex;
    |         bytes32[] topics;
    |         uint256 transactionIndex;
    |         uint256 transactionLogIndex;
    |         bool removed;
    |     }
    | 
    |     struct TxReturn {
    |         string internalType;
    |         string value;
    |     }
    | 
    |     function assumeNoPrecompiles(address addr) internal virtual {
    |         // Assembly required since `block.chainid` was introduced in 0.8.0.
    |         uint256 chainId;
    |         assembly {
    |             chainId := chainid()
    |         }
    |         assumeNoPrecompiles(addr, chainId);
    |     }
    | 
    |     function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {
    |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
    |         // address), but the same rationale for excluding them applies so we include those too.
    | 
    |         // These should be present on all EVM-compatible chains.
    |         vm.assume(addr < address(0x1) || addr > address(0x9));
    | 
    |         // forgefmt: disable-start
    |         if (chainId == 10 || chainId == 420) {
    |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
    |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
    |         } else if (chainId == 42161 || chainId == 421613) {
    |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
    |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
    |         } else if (chainId == 43114 || chainId == 43113) {
    |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
    |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
    |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
    |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
    |         }
    |         // forgefmt: disable-end
    |     }
    | 
    |     function readEIP1559ScriptArtifact(string memory path)
    |         internal
    |         view
    |         virtual
    |         returns (EIP1559ScriptArtifact memory)
    |     {
    |         string memory data = vm.readFile(path);
    |         bytes memory parsedData = vm.parseJson(data);
    |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
    |         EIP1559ScriptArtifact memory artifact;
    |         artifact.libraries = rawArtifact.libraries;
    |         artifact.path = rawArtifact.path;
    |         artifact.timestamp = rawArtifact.timestamp;
    |         artifact.pending = rawArtifact.pending;
    |         artifact.txReturns = rawArtifact.txReturns;
    |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
    |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
    |         return artifact;
    |     }
    | 
    |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
    |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
    |         for (uint256 i; i < rawTxs.length; i++) {
    |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
    |         }
    |         return txs;
    |     }
    | 
    |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
    |         Tx1559 memory transaction;
    |         transaction.arguments = rawTx.arguments;
    |         transaction.contractName = rawTx.contractName;
    |         transaction.functionSig = rawTx.functionSig;
    |         transaction.hash = rawTx.hash;
    |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
    |         transaction.opcode = rawTx.opcode;
    |         return transaction;
    |     }
    | 
    |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
    |         internal
    |         pure
    |         virtual
    |         returns (Tx1559Detail memory)
    |     {
    |         Tx1559Detail memory txDetail;
    |         txDetail.data = rawDetail.data;
    |         txDetail.from = rawDetail.from;
    |         txDetail.to = rawDetail.to;
    |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
    |         txDetail.txType = _bytesToUint(rawDetail.txType);
    |         txDetail.value = _bytesToUint(rawDetail.value);
    |         txDetail.gas = _bytesToUint(rawDetail.gas);
    |         txDetail.accessList = rawDetail.accessList;
    |         return txDetail;
    |     }
    | 
    |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
    |         string memory deployData = vm.readFile(path);
    |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
    |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
    |         return rawToConvertedEIPTx1559s(rawTxs);
    |     }
    | 
    |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
    |         string memory deployData = vm.readFile(path);
    |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
    |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
    |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
    |         return rawToConvertedEIPTx1559(rawTx);
    |     }
    | 
    |     // Analogous to readTransactions, but for receipts.
    |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
    |         string memory deployData = vm.readFile(path);
    |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
    |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
    |         return rawToConvertedReceipts(rawReceipts);
    |     }
    | 
    |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
    |         string memory deployData = vm.readFile(path);
    |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
    |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
    |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
    |         return rawToConvertedReceipt(rawReceipt);
    |     }
    | 
    |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
    |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
    |         for (uint256 i; i < rawReceipts.length; i++) {
    |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
    |         }
    |         return receipts;
    |     }
    | 
    |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
    |         Receipt memory receipt;
    |         receipt.blockHash = rawReceipt.blockHash;
    |         receipt.to = rawReceipt.to;
    |         receipt.from = rawReceipt.from;
    |         receipt.contractAddress = rawReceipt.contractAddress;
    |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
    |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
    |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
    |         receipt.status = _bytesToUint(rawReceipt.status);
    |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
    |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
    |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
    |         receipt.logsBloom = rawReceipt.logsBloom;
    |         receipt.transactionHash = rawReceipt.transactionHash;
    |         return receipt;
    |     }
    | 
    |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
    |         internal
    |         pure
    |         virtual
    |         returns (ReceiptLog[] memory)
    |     {
    |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
    |         for (uint256 i; i < rawLogs.length; i++) {
    |             logs[i].logAddress = rawLogs[i].logAddress;
    |             logs[i].blockHash = rawLogs[i].blockHash;
    |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
    |             logs[i].data = rawLogs[i].data;
    |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
    |             logs[i].topics = rawLogs[i].topics;
    |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
    |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
    |             logs[i].removed = rawLogs[i].removed;
    |         }
    |         return logs;
    |     }
    | 
    |     // Deploy a contract by fetching the contract bytecode from
    |     // the artifacts directory
    |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
    |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
    |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
    |         }
    | 
    |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
    |     }
    | 
    |     function deployCode(string memory what) internal virtual returns (address addr) {
    |         bytes memory bytecode = vm.getCode(what);
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
    |         }
    | 
    |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
    |     }
    | 
    |     /// @dev deploy contract with value on construction
    |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
    |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
    |         }
    | 
    |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
    |     }
    | 
    |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
    |         bytes memory bytecode = vm.getCode(what);
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
    |         }
    | 
    |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
    |     }
    | 
    |     // creates a labeled address and the corresponding private key
    |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
    |         privateKey = uint256(keccak256(abi.encodePacked(name)));
    |         addr = vm.addr(privateKey);
    |         vm.label(addr, name);
    |     }
    | 
    |     // creates a labeled address
    |     function makeAddr(string memory name) internal virtual returns (address addr) {
    |         (addr,) = makeAddrAndKey(name);
    |     }
    | 
    |     function deriveRememberKey(string memory mnemonic, uint32 index)
    |         internal
    |         virtual
    |         returns (address who, uint256 privateKey)
    |     {
    |         privateKey = vm.deriveKey(mnemonic, index);
    |         who = vm.rememberKey(privateKey);
    |     }
    | 
    |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
    |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
    |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
    |     }
    | 
    |     function isFork() internal view virtual returns (bool status) {
    |         try vm.activeFork() {
    |             status = true;
    |         } catch (bytes memory) {}
    |     }
    | 
    |     modifier skipWhenForking() {
    |         if (!isFork()) {
    |             _;
    |         }
    |     }
    | 
    |     modifier skipWhenNotForking() {
    |         if (isFork()) {
    |             _;
    |         }
    |     }
    | 
    |     modifier noGasMetering() {
    |         vm.pauseGasMetering();
    |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
    |         // we check if gasMetering started in the off position. If it did, we don't want to turn
    |         // it back on until we exit the top level function that used the modifier
    |         //
    |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
    |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
    |         // so we only turn metering back on at the end of the funcA
    |         bool gasStartedOff = gasMeteringOff;
    |         gasMeteringOff = true;
    | 
    |         _;
    | 
    |         // if gas metering was on when this modifier was called, turn it back on at the end
    |         if (!gasStartedOff) {
    |             gasMeteringOff = false;
    |             vm.resumeGasMetering();
    |         }
    |     }
    | }
    | 
    | // Wrappers around cheatcodes to avoid footguns
    | abstract contract StdCheats is StdCheatsSafe {
    |     using stdStorage for StdStorage;
    | 
    |     StdStorage private stdstore;
    |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    | 
    |     // Skip forward or rewind time by the specified number of seconds
    |     function skip(uint256 time) internal virtual {
    |         vm.warp(block.timestamp + time);
    |     }
    | 
    |     function rewind(uint256 time) internal virtual {
    |         vm.warp(block.timestamp - time);
    |     }
    | 
    |     // Setup a prank from an address that has some ether
    |     function hoax(address who) internal virtual {
    |         vm.deal(who, 1 << 128);
    |         vm.prank(who);
    |     }
    | 
    |     function hoax(address who, uint256 give) internal virtual {
    |         vm.deal(who, give);
    |         vm.prank(who);
    |     }
    | 
    |     function hoax(address who, address origin) internal virtual {
    |         vm.deal(who, 1 << 128);
    |         vm.prank(who, origin);
    |     }
    | 
    |     function hoax(address who, address origin, uint256 give) internal virtual {
    |         vm.deal(who, give);
    |         vm.prank(who, origin);
    |     }
    | 
    |     // Start perpetual prank from an address that has some ether
    |     function startHoax(address who) internal virtual {
    |         vm.deal(who, 1 << 128);
    |         vm.startPrank(who);
    |     }
    | 
    |     function startHoax(address who, uint256 give) internal virtual {
    |         vm.deal(who, give);
    |         vm.startPrank(who);
    |     }
    | 
    |     // Start perpetual prank from an address that has some ether
    |     // tx.origin is set to the origin parameter
    |     function startHoax(address who, address origin) internal virtual {
    |         vm.deal(who, 1 << 128);
    |         vm.startPrank(who, origin);
    |     }
    | 
    |     function startHoax(address who, address origin, uint256 give) internal virtual {
    |         vm.deal(who, give);
    |         vm.startPrank(who, origin);
    |     }
    | 
    |     function changePrank(address who) internal virtual {
    |         vm.stopPrank();
    |         vm.startPrank(who);
    |     }
    | 
    |     // The same as Vm's `deal`
    |     // Use the alternative signature for ERC20 tokens
    |     function deal(address to, uint256 give) internal virtual {
    |         vm.deal(to, give);
    |     }
    | 
    |     // Set the balance of an account for any ERC20 token
    |     // Use the alternative signature to update `totalSupply`
    |     function deal(address token, address to, uint256 give) internal virtual {
    |         deal(token, to, give, false);
    |     }
    | 
    |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
    |         // get current balance
    |         (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));
    |         uint256 prevBal = abi.decode(balData, (uint256));
    | 
    |         // update balance
    |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
    | 
    |         // update total supply
    |         if (adjust) {
    |             (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));
    |             uint256 totSup = abi.decode(totSupData, (uint256));
    |             if (give < prevBal) {
    |                 totSup -= (prevBal - give);
    |             } else {
    |                 totSup += (give - prevBal);
    |             }
    |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
    |         }
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdError.sol
    | // SPDX-License-Identifier: MIT
    | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | library stdError {
    |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
    |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
    |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
    |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
    |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
    |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
    |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
    |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
    |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdJson.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.0 <0.9.0;
    | 
    | pragma experimental ABIEncoderV2;
    | 
    | import {VmSafe} from "./Vm.sol";
    | 
    | // Helpers for parsing and writing JSON files
    | // To parse:
    | // ```
    | // using stdJson for string;
    | // string memory json = vm.readFile("some_peth");
    | // json.parseUint("<json_path>");
    | // ```
    | // To write:
    | // ```
    | // using stdJson for string;
    | // string memory json = "deploymentArtifact";
    | // Contract contract = new Contract();
    | // json.serialize("contractAddress", address(contract));
    | // json = json.serialize("deploymentTimes", uint(1));
    | // // store the stringified JSON to the 'json' variable we have been using as a key
    | // // as we won't need it any longer
    | // string memory json2 = "finalArtifact";
    | // string memory final = json2.serialize("depArtifact", json);
    | // final.write("<some_path>");
    | // ```
    | 
    | library stdJson {
    |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
    | 
    |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
    |         return vm.parseJson(json, key);
    |     }
    | 
    |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
    |         return abi.decode(vm.parseJson(json, key), (uint256));
    |     }
    | 
    |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (uint256[]));
    |     }
    | 
    |     function readInt(string memory json, string memory key) internal pure returns (int256) {
    |         return abi.decode(vm.parseJson(json, key), (int256));
    |     }
    | 
    |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (int256[]));
    |     }
    | 
    |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
    |         return abi.decode(vm.parseJson(json, key), (bytes32));
    |     }
    | 
    |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (bytes32[]));
    |     }
    | 
    |     function readString(string memory json, string memory key) internal pure returns (string memory) {
    |         return abi.decode(vm.parseJson(json, key), (string));
    |     }
    | 
    |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (string[]));
    |     }
    | 
    |     function readAddress(string memory json, string memory key) internal pure returns (address) {
    |         return abi.decode(vm.parseJson(json, key), (address));
    |     }
    | 
    |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (address[]));
    |     }
    | 
    |     function readBool(string memory json, string memory key) internal pure returns (bool) {
    |         return abi.decode(vm.parseJson(json, key), (bool));
    |     }
    | 
    |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (bool[]));
    |     }
    | 
    |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
    |         return abi.decode(vm.parseJson(json, key), (bytes));
    |     }
    | 
    |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
    |         return abi.decode(vm.parseJson(json, key), (bytes[]));
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
    |         return vm.serializeBool(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeBool(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
    |         return vm.serializeUint(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeUint(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
    |         return vm.serializeInt(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeInt(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
    |         return vm.serializeAddress(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, address[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeAddress(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
    |         return vm.serializeBytes32(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeBytes32(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
    |         return vm.serializeBytes(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeBytes(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, string memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeString(jsonKey, key, value);
    |     }
    | 
    |     function serialize(string memory jsonKey, string memory key, string[] memory value)
    |         internal
    |         returns (string memory)
    |     {
    |         return vm.serializeString(jsonKey, key, value);
    |     }
    | 
    |     function write(string memory jsonKey, string memory path) internal {
    |         vm.writeJson(jsonKey, path);
    |     }
    | 
    |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
    |         vm.writeJson(jsonKey, path, valueKey);
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdMath.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | library stdMath {
    |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
    | 
    |     function abs(int256 a) internal pure returns (uint256) {
    |         // Required or it will fail when `a = type(int256).min`
    |         if (a == INT256_MIN) {
    |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    |         }
    | 
    |         return uint256(a > 0 ? a : -a);
    |     }
    | 
    |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
    |         return a > b ? a - b : b - a;
    |     }
    | 
    |     function delta(int256 a, int256 b) internal pure returns (uint256) {
    |         // a and b are of the same sign
    |         // this works thanks to two's complement, the left-most bit is the sign bit
    |         if ((a ^ b) > -1) {
    |             return delta(abs(a), abs(b));
    |         }
    | 
    |         // a and b are of opposite signs
    |         return abs(a) + abs(b);
    |     }
    | 
    |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
    |         uint256 absDelta = delta(a, b);
    | 
    |         return absDelta * 1e18 / b;
    |     }
    | 
    |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
    |         uint256 absDelta = delta(a, b);
    |         uint256 absB = abs(b);
    | 
    |         return absDelta * 1e18 / absB;
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdStorage.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | import {Vm} from "./Vm.sol";
    | 
    | struct StdStorage {
    |     mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
    |     mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
    |     bytes32[] _keys;
    |     bytes4 _sig;
    |     uint256 _depth;
    |     address _target;
    |     bytes32 _set;
    | }
    | 
    | library stdStorageSafe {
    |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
    |     event WARNING_UninitedSlot(address who, uint256 slot);
    | 
    |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    | 
    |     function sigs(string memory sigStr) internal pure returns (bytes4) {
    |         return bytes4(keccak256(bytes(sigStr)));
    |     }
    | 
    |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
    |     // slot complexity:
    |     //  if flat, will be bytes32(uint256(uint));
    |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
    |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
    |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
    |     function find(StdStorage storage self) internal returns (uint256) {
    |         address who = self._target;
    |         bytes4 fsig = self._sig;
    |         uint256 field_depth = self._depth;
    |         bytes32[] memory ins = self._keys;
    | 
    |         // calldata to test against
    |         if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
    |             return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
    |         }
    |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
    |         vm.record();
    |         bytes32 fdat;
    |         {
    |             (, bytes memory rdat) = who.staticcall(cald);
    |             fdat = bytesToBytes32(rdat, 32 * field_depth);
    |         }
    | 
    |         (bytes32[] memory reads,) = vm.accesses(address(who));
    |         if (reads.length == 1) {
    |             bytes32 curr = vm.load(who, reads[0]);
    |             if (curr == bytes32(0)) {
    |                 emit WARNING_UninitedSlot(who, uint256(reads[0]));
    |             }
    |             if (fdat != curr) {
    |                 require(
    |                     false,
    |                     "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
    |                 );
    |             }
    |             emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
    |             self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
    |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
    |         } else if (reads.length > 1) {
    |             for (uint256 i = 0; i < reads.length; i++) {
    |                 bytes32 prev = vm.load(who, reads[i]);
    |                 if (prev == bytes32(0)) {
    |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
    |                 }
    |                 // store
    |                 vm.store(who, reads[i], bytes32(hex"1337"));
    |                 bool success;
    |                 bytes memory rdat;
    |                 {
    |                     (success, rdat) = who.staticcall(cald);
    |                     fdat = bytesToBytes32(rdat, 32 * field_depth);
    |                 }
    | 
    |                 if (success && fdat == bytes32(hex"1337")) {
    |                     // we found which of the slots is the actual one
    |                     emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
    |                     self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
    |                     self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
    |                     vm.store(who, reads[i], prev);
    |                     break;
    |                 }
    |                 vm.store(who, reads[i], prev);
    |             }
    |         } else {
    |             require(false, "stdStorage find(StdStorage): No storage use detected for target.");
    |         }
    | 
    |         require(
    |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],
    |             "stdStorage find(StdStorage): Slot(s) not found."
    |         );
    | 
    |         delete self._target;
    |         delete self._sig;
    |         delete self._keys;
    |         delete self._depth;
    | 
    |         return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
    |     }
    | 
    |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
    |         self._target = _target;
    |         return self;
    |     }
    | 
    |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
    |         self._sig = _sig;
    |         return self;
    |     }
    | 
    |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
    |         self._sig = sigs(_sig);
    |         return self;
    |     }
    | 
    |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
    |         self._keys.push(bytes32(uint256(uint160(who))));
    |         return self;
    |     }
    | 
    |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
    |         self._keys.push(bytes32(amt));
    |         return self;
    |     }
    | 
    |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
    |         self._keys.push(key);
    |         return self;
    |     }
    | 
    |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
    |         self._depth = _depth;
    |         return self;
    |     }
    | 
    |     function read(StdStorage storage self) private returns (bytes memory) {
    |         address t = self._target;
    |         uint256 s = find(self);
    |         return abi.encode(vm.load(t, bytes32(s)));
    |     }
    | 
    |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
    |         return abi.decode(read(self), (bytes32));
    |     }
    | 
    |     function read_bool(StdStorage storage self) internal returns (bool) {
    |         int256 v = read_int(self);
    |         if (v == 0) return false;
    |         if (v == 1) return true;
    |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
    |     }
    | 
    |     function read_address(StdStorage storage self) internal returns (address) {
    |         return abi.decode(read(self), (address));
    |     }
    | 
    |     function read_uint(StdStorage storage self) internal returns (uint256) {
    |         return abi.decode(read(self), (uint256));
    |     }
    | 
    |     function read_int(StdStorage storage self) internal returns (int256) {
    |         return abi.decode(read(self), (int256));
    |     }
    | 
    |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
    |         bytes32 out;
    | 
    |         uint256 max = b.length > 32 ? 32 : b.length;
    |         for (uint256 i = 0; i < max; i++) {
    |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
    |         }
    |         return out;
    |     }
    | 
    |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
    |         bytes memory result = new bytes(b.length * 32);
    |         for (uint256 i = 0; i < b.length; i++) {
    |             bytes32 k = b[i];
    |             /// @solidity memory-safe-assembly
    |             assembly {
    |                 mstore(add(result, add(32, mul(32, i))), k)
    |             }
    |         }
    | 
    |         return result;
    |     }
    | }
    | 
    | library stdStorage {
    |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    | 
    |     function sigs(string memory sigStr) internal pure returns (bytes4) {
    |         return stdStorageSafe.sigs(sigStr);
    |     }
    | 
    |     function find(StdStorage storage self) internal returns (uint256) {
    |         return stdStorageSafe.find(self);
    |     }
    | 
    |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
    |         return stdStorageSafe.target(self, _target);
    |     }
    | 
    |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
    |         return stdStorageSafe.sig(self, _sig);
    |     }
    | 
    |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
    |         return stdStorageSafe.sig(self, _sig);
    |     }
    | 
    |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
    |         return stdStorageSafe.with_key(self, who);
    |     }
    | 
    |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
    |         return stdStorageSafe.with_key(self, amt);
    |     }
    | 
    |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
    |         return stdStorageSafe.with_key(self, key);
    |     }
    | 
    |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
    |         return stdStorageSafe.depth(self, _depth);
    |     }
    | 
    |     function checked_write(StdStorage storage self, address who) internal {
    |         checked_write(self, bytes32(uint256(uint160(who))));
    |     }
    | 
    |     function checked_write(StdStorage storage self, uint256 amt) internal {
    |         checked_write(self, bytes32(amt));
    |     }
    | 
    |     function checked_write(StdStorage storage self, bool write) internal {
    |         bytes32 t;
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             t := write
    |         }
    |         checked_write(self, t);
    |     }
    | 
    |     function checked_write(StdStorage storage self, bytes32 set) internal {
    |         address who = self._target;
    |         bytes4 fsig = self._sig;
    |         uint256 field_depth = self._depth;
    |         bytes32[] memory ins = self._keys;
    | 
    |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
    |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
    |             find(self);
    |         }
    |         bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);
    | 
    |         bytes32 fdat;
    |         {
    |             (, bytes memory rdat) = who.staticcall(cald);
    |             fdat = bytesToBytes32(rdat, 32 * field_depth);
    |         }
    |         bytes32 curr = vm.load(who, slot);
    | 
    |         if (fdat != curr) {
    |             require(
    |                 false,
    |                 "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
    |             );
    |         }
    |         vm.store(who, slot, set);
    |         delete self._target;
    |         delete self._sig;
    |         delete self._keys;
    |         delete self._depth;
    |     }
    | 
    |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
    |         return stdStorageSafe.read_bytes32(self);
    |     }
    | 
    |     function read_bool(StdStorage storage self) internal returns (bool) {
    |         return stdStorageSafe.read_bool(self);
    |     }
    | 
    |     function read_address(StdStorage storage self) internal returns (address) {
    |         return stdStorageSafe.read_address(self);
    |     }
    | 
    |     function read_uint(StdStorage storage self) internal returns (uint256) {
    |         return stdStorageSafe.read_uint(self);
    |     }
    | 
    |     function read_int(StdStorage storage self) internal returns (int256) {
    |         return stdStorageSafe.read_int(self);
    |     }
    | 
    |     // Private function so needs to be copied over
    |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
    |         bytes32 out;
    | 
    |         uint256 max = b.length > 32 ? 32 : b.length;
    |         for (uint256 i = 0; i < max; i++) {
    |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
    |         }
    |         return out;
    |     }
    | 
    |     // Private function so needs to be copied over
    |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
    |         bytes memory result = new bytes(b.length * 32);
    |         for (uint256 i = 0; i < b.length; i++) {
    |             bytes32 k = b[i];
    |             /// @solidity memory-safe-assembly
    |             assembly {
    |                 mstore(add(result, add(32, mul(32, i))), k)
    |             }
    |         }
    | 
    |         return result;
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/StdUtils.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | // TODO Remove import.
    | import {VmSafe} from "./Vm.sol";
    | 
    | abstract contract StdUtils {
    |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
    |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
    | 
    |     uint256 private constant INT256_MIN_ABS =
    |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
    |     uint256 private constant UINT256_MAX =
    |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
    | 
    |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
    |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
    |         // If x is between min and max, return x directly. This is to ensure that dictionary values
    |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
    |         if (x >= min && x <= max) return x;
    | 
    |         uint256 size = max - min + 1;
    | 
    |         // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
    |         // This helps ensure coverage of the min/max values.
    |         if (x <= 3 && size > x) return min + x;
    |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
    | 
    |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
    |         if (x > max) {
    |             uint256 diff = x - max;
    |             uint256 rem = diff % size;
    |             if (rem == 0) return max;
    |             result = min + rem - 1;
    |         } else if (x < min) {
    |             uint256 diff = min - x;
    |             uint256 rem = diff % size;
    |             if (rem == 0) return min;
    |             result = max - rem + 1;
    |         }
    |     }
    | 
    |     function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {
    |         result = _bound(x, min, max);
    |         console2_log("Bound Result", result);
    |     }
    | 
    |     function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {
    |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
    | 
    |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
    |         // int256 : -(2**255) ~ (2**255 - 1)
    |         // uint256:     0     ~ (2**256 - 1)
    |         // So, add 2**255, INT256_MIN_ABS to the integer values.
    |         //
    |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
    |         // So, use `~uint256(x) + 1` instead.
    |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
    |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
    |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
    | 
    |         uint256 y = _bound(_x, _min, _max);
    | 
    |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
    |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
    |         console2_log("Bound result", vm.toString(result));
    |     }
    | 
    |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
    |     /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
    |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
    |         // forgefmt: disable-start
    |         // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
    |         // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
    |         if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));
    |         if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));
    | 
    |         // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
    |         if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));
    |         if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));
    |         if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));
    |         // forgefmt: disable-end
    | 
    |         // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
    |         // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
    |         // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
    |         // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
    |         // We assume nobody can have a nonce large enough to require more than 32 bytes.
    |         return addressFromLast20Bytes(
    |             keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))
    |         );
    |     }
    | 
    |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
    |         internal
    |         pure
    |         virtual
    |         returns (address)
    |     {
    |         return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));
    |     }
    | 
    |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
    |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
    |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
    |     }
    | 
    |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
    |         return address(uint160(uint256(bytesValue)));
    |     }
    | 
    |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
    | 
    |     function console2_log(string memory p0, uint256 p1) private view {
    |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,uint256)", p0, p1));
    |         status;
    |     }
    | 
    |     function console2_log(string memory p0, string memory p1) private view {
    |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,string)", p0, p1));
    |         status;
    |     }
    | }
    | 

/root/code/hyper/lib/forge-std/src/Test.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | // 💬 ABOUT
    | // Standard Library's default Test
    | 
    | // 🧩 MODULES
    | import {console} from "./console.sol";
    | import {console2} from "./console2.sol";
    | import {StdAssertions} from "./StdAssertions.sol";
    | import {StdChains} from "./StdChains.sol";
    | import {StdCheats} from "./StdCheats.sol";
    | import {stdError} from "./StdError.sol";
    | import {stdJson} from "./StdJson.sol";
    | import {stdMath} from "./StdMath.sol";
    | import {StdStorage, stdStorage} from "./StdStorage.sol";
    | import {StdUtils} from "./StdUtils.sol";
    | import {Vm} from "./Vm.sol";
    | 
    | // 📦 BOILERPLATE
    | import {TestBase} from "./Base.sol";
    | import {DSTest} from "ds-test/test.sol";
    | 
    | // ⭐️ TEST
    | abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdUtils, TestBase {
    | // Note: IS_TEST() must return true.
    | // Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.
    | }
    | 

/root/code/hyper/lib/forge-std/src/Vm.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.6.2 <0.9.0;
    | 
    | pragma experimental ABIEncoderV2;
    | 
    | // Cheatcodes are marked as view/pure/none using the following rules:
    | // 0. A call's observable behaviour includes its return value, logs, reverts and state writes,
    | // 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),
    | // 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,
    | // 3. Otherwise you're `pure`.
    | 
    | interface VmSafe {
    |     struct Log {
    |         bytes32[] topics;
    |         bytes data;
    |         address emitter;
    |     }
    | 
    |     struct Rpc {
    |         string key;
    |         string url;
    |     }
    | 
    |     struct FsMetadata {
    |         bool isDir;
    |         bool isSymlink;
    |         uint256 length;
    |         bool readOnly;
    |         uint256 modified;
    |         uint256 accessed;
    |         uint256 created;
    |     }
    | 
    |     // Loads a storage slot from an address
    |     function load(address target, bytes32 slot) external view returns (bytes32 data);
    |     // Signs data
    |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    |     // Gets the address for a given private key
    |     function addr(uint256 privateKey) external pure returns (address keyAddr);
    |     // Gets the nonce of an account
    |     function getNonce(address account) external view returns (uint64 nonce);
    |     // Performs a foreign function call via the terminal
    |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
    |     // Sets environment variables
    |     function setEnv(string calldata name, string calldata value) external;
    |     // Reads environment variables, (name) => (value)
    |     function envBool(string calldata name) external view returns (bool value);
    |     function envUint(string calldata name) external view returns (uint256 value);
    |     function envInt(string calldata name) external view returns (int256 value);
    |     function envAddress(string calldata name) external view returns (address value);
    |     function envBytes32(string calldata name) external view returns (bytes32 value);
    |     function envString(string calldata name) external view returns (string memory value);
    |     function envBytes(string calldata name) external view returns (bytes memory value);
    |     // Reads environment variables as arrays
    |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
    |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
    |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
    |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
    |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
    |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
    |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
    |     // Read environment variables with default value
    |     function envOr(string calldata name, bool defaultValue) external returns (bool value);
    |     function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);
    |     function envOr(string calldata name, int256 defaultValue) external returns (int256 value);
    |     function envOr(string calldata name, address defaultValue) external returns (address value);
    |     function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);
    |     function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);
    |     function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);
    |     // Read environment variables as arrays with default value
    |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
    |         external
    |         returns (bool[] memory value);
    |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
    |         external
    |         returns (uint256[] memory value);
    |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
    |         external
    |         returns (int256[] memory value);
    |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
    |         external
    |         returns (address[] memory value);
    |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
    |         external
    |         returns (bytes32[] memory value);
    |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
    |         external
    |         returns (string[] memory value);
    |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
    |         external
    |         returns (bytes[] memory value);
    |     // Records all storage reads and writes
    |     function record() external;
    |     // Gets all accessed reads and write slot from a recording session, for a given address
    |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
    |     // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file
    |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
    |     // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file
    |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
    |     // Labels an address in call traces
    |     function label(address account, string calldata newLabel) external;
    |     // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain
    |     function broadcast() external;
    |     // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain
    |     function broadcast(address signer) external;
    |     // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain
    |     function broadcast(uint256 privateKey) external;
    |     // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain
    |     function startBroadcast() external;
    |     // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain
    |     function startBroadcast(address signer) external;
    |     // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain
    |     function startBroadcast(uint256 privateKey) external;
    |     // Stops collecting onchain transactions
    |     function stopBroadcast() external;
    |     // Reads the entire content of file to string
    |     function readFile(string calldata path) external view returns (string memory data);
    |     // Reads the entire content of file as binary. Path is relative to the project root.
    |     function readFileBinary(string calldata path) external view returns (bytes memory data);
    |     // Get the path of the current project root
    |     function projectRoot() external view returns (string memory path);
    |     // Get the metadata for a file/directory
    |     function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);
    |     // Reads next line of file to string
    |     function readLine(string calldata path) external view returns (string memory line);
    |     // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
    |     function writeFile(string calldata path, string calldata data) external;
    |     // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
    |     // Path is relative to the project root.
    |     function writeFileBinary(string calldata path, bytes calldata data) external;
    |     // Writes line to file, creating a file if it does not exist.
    |     function writeLine(string calldata path, string calldata data) external;
    |     // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
    |     function closeFile(string calldata path) external;
    |     // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:
    |     // - Path points to a directory.
    |     // - The file doesn't exist.
    |     // - The user lacks permissions to remove the file.
    |     function removeFile(string calldata path) external;
    |     // Convert values to a string
    |     function toString(address value) external pure returns (string memory stringifiedValue);
    |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
    |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
    |     function toString(bool value) external pure returns (string memory stringifiedValue);
    |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
    |     function toString(int256 value) external pure returns (string memory stringifiedValue);
    |     // Convert values from a string
    |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
    |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
    |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
    |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
    |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
    |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
    |     // Record all the transaction logs
    |     function recordLogs() external;
    |     // Gets all the recorded logs
    |     function getRecordedLogs() external returns (Log[] memory logs);
    |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}
    |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
    |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}
    |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
    |         external
    |         pure
    |         returns (uint256 privateKey);
    |     // Adds a private key to the local forge wallet and returns the address
    |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
    |     //
    |     // parseJson
    |     //
    |     // ----
    |     // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects
    |     // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in
    |     // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that
    |     // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded
    |     // as tuples, with the attributes in the order in which they are defined.
    |     // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}
    |     // a: uint256
    |     // b: address
    |     // To decode that json, we need to define a struct or a tuple as follows:
    |     // struct json = { uint256 a; address b; }
    |     // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to
    |     // decode the tuple in that order, and thus fail.
    |     // ----
    |     // Given a string of JSON, return it as ABI-encoded
    |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
    |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
    | 
    |     // Serialize a key and value to a JSON object stored in-memory that can be later written to a file
    |     // It returns the stringified version of the specific JSON file up to that moment.
    |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
    |         external
    |         returns (string memory json);
    |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
    |         external
    |         returns (string memory json);
    |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
    |         external
    |         returns (string memory json);
    |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
    |         external
    |         returns (string memory json);
    |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
    |         external
    |         returns (string memory json);
    |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
    |         external
    |         returns (string memory json);
    |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
    |         external
    |         returns (string memory json);
    | 
    |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
    |         external
    |         returns (string memory json);
    |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
    |         external
    |         returns (string memory json);
    |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
    |         external
    |         returns (string memory json);
    |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
    |         external
    |         returns (string memory json);
    |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
    |         external
    |         returns (string memory json);
    |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
    |         external
    |         returns (string memory json);
    |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
    |         external
    |         returns (string memory json);
    | 
    |     //
    |     // writeJson
    |     //
    |     // ----
    |     // Write a serialized JSON object to a file. If the file exists, it will be overwritten.
    |     // Let's assume we want to write the following JSON to a file:
    |     //
    |     // { "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
    |     //
    |     // ```
    |     //  string memory json1 = "some key";
    |     //  vm.serializeBool(json1, "boolean", true);
    |     //  vm.serializeBool(json1, "number", uint256(342));
    |     //  json2 = "some other key";
    |     //  string memory output = vm.serializeString(json2, "title", "finally json serialization");
    |     //  string memory finalJson = vm.serialize(json1, "object", output);
    |     //  vm.writeJson(finalJson, "./output/example.json");
    |     // ```
    |     // The critical insight is that every invocation of serialization will return the stringified version of the JSON
    |     // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version
    |     // to serialize them as values to another JSON object.
    |     //
    |     // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)
    |     // will find the object in-memory that is keyed by "some key".
    |     function writeJson(string calldata json, string calldata path) external;
    |     // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>
    |     // This is useful to replace a specific value of a JSON file, without having to parse the entire thing
    |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
    |     // Returns the RPC url for the given alias
    |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
    |     // Returns all rpc urls and their aliases `[alias, url][]`
    |     function rpcUrls() external view returns (string[2][] memory urls);
    |     // Returns all rpc urls and their aliases as structs.
    |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
    |     // If the condition is false, discard this run's fuzz inputs and generate new ones.
    |     function assume(bool condition) external pure;
    |     // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
    |     function pauseGasMetering() external;
    |     // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
    |     function resumeGasMetering() external;
    | }
    | 
    | interface Vm is VmSafe {
    |     // Sets block.timestamp
    |     function warp(uint256 newTimestamp) external;
    |     // Sets block.height
    |     function roll(uint256 newHeight) external;
    |     // Sets block.basefee
    |     function fee(uint256 newBasefee) external;
    |     // Sets block.difficulty
    |     function difficulty(uint256 newDifficulty) external;
    |     // Sets block.chainid
    |     function chainId(uint256 newChainId) external;
    |     // Stores a value to an address' storage slot.
    |     function store(address target, bytes32 slot, bytes32 value) external;
    |     // Sets the nonce of an account; must be higher than the current nonce of the account
    |     function setNonce(address account, uint64 newNonce) external;
    |     // Sets the *next* call's msg.sender to be the input address
    |     function prank(address msgSender) external;
    |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
    |     function startPrank(address msgSender) external;
    |     // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
    |     function prank(address msgSender, address txOrigin) external;
    |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
    |     function startPrank(address msgSender, address txOrigin) external;
    |     // Resets subsequent calls' msg.sender to be `address(this)`
    |     function stopPrank() external;
    |     // Sets an address' balance
    |     function deal(address account, uint256 newBalance) external;
    |     // Sets an address' code
    |     function etch(address target, bytes calldata newRuntimeBytecode) external;
    |     // Expects an error on next call
    |     function expectRevert(bytes calldata revertData) external;
    |     function expectRevert(bytes4 revertData) external;
    |     function expectRevert() external;
    |     // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    |     // Call this function, then emit an event, then call a function. Internally after the call, we check if
    |     // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
    |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
    |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
    |         external;
    |     // Mocks a call to an address, returning specified data.
    |     // Calldata can either be strict or a partial match, e.g. if you only
    |     // pass a Solidity selector to the expected calldata, then the entire Solidity
    |     // function will be mocked.
    |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
    |     // Mocks a call to an address with a specific msg.value, returning specified data.
    |     // Calldata match takes precedence over msg.value in case of ambiguity.
    |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
    |     // Clears all mocked calls
    |     function clearMockedCalls() external;
    |     // Expects a call to an address with the specified calldata.
    |     // Calldata can either be a strict or a partial match
    |     function expectCall(address callee, bytes calldata data) external;
    |     // Expects a call to an address with the specified msg.value and calldata
    |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
    |     // Sets block.coinbase
    |     function coinbase(address newCoinbase) external;
    |     // Snapshot the current state of the evm.
    |     // Returns the id of the snapshot that was created.
    |     // To revert a snapshot use `revertTo`
    |     function snapshot() external returns (uint256 snapshotId);
    |     // Revert the state of the EVM to a previous snapshot
    |     // Takes the snapshot id to revert to.
    |     // This deletes the snapshot and all snapshots taken after the given snapshot id.
    |     function revertTo(uint256 snapshotId) external returns (bool success);
    |     // Creates a new fork with the given endpoint and block and returns the identifier of the fork
    |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
    |     // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork
    |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
    |     // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,
    |     // and returns the identifier of the fork
    |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
    |     // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork
    |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
    |     // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before
    |     // the transaction, returns the identifier of the fork
    |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
    |     // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork
    |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
    |     // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
    |     function selectFork(uint256 forkId) external;
    |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
    |     function activeFork() external view returns (uint256 forkId);
    |     // Updates the currently active fork to given block number
    |     // This is similar to `roll` but for the currently active fork
    |     function rollFork(uint256 blockNumber) external;
    |     // Updates the currently active fork to given transaction
    |     // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block
    |     function rollFork(bytes32 txHash) external;
    |     // Updates the given fork to given block number
    |     function rollFork(uint256 forkId, uint256 blockNumber) external;
    |     // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block
    |     function rollFork(uint256 forkId, bytes32 txHash) external;
    |     // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
    |     // Meaning, changes made to the state of this account will be kept when switching forks
    |     function makePersistent(address account) external;
    |     function makePersistent(address account0, address account1) external;
    |     function makePersistent(address account0, address account1, address account2) external;
    |     function makePersistent(address[] calldata accounts) external;
    |     // Revokes persistent status from the address, previously added via `makePersistent`
    |     function revokePersistent(address account) external;
    |     function revokePersistent(address[] calldata accounts) external;
    |     // Returns true if the account is marked as persistent
    |     function isPersistent(address account) external view returns (bool persistent);
    |     // In forking mode, explicitly grant the given address cheatcode access
    |     function allowCheatcodes(address account) external;
    |     // Fetches the given transaction from the active fork and executes it on the current state
    |     function transact(bytes32 txHash) external;
    |     // Fetches the given transaction from the given fork and executes it on the current state
    |     function transact(uint256 forkId, bytes32 txHash) external;
    | }
    | 

/root/code/hyper/lib/forge-std/src/console.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.4.22 <0.9.0;
    | 
    | library console {
    |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    | 
    |     function _sendLogPayload(bytes memory payload) private view {
    |         uint256 payloadLength = payload.length;
    |         address consoleAddress = CONSOLE_ADDRESS;
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             let payloadStart := add(payload, 32)
    |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
    |         }
    |     }
    | 
    |     function log() internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log()"));
    |     }
    | 
    |     function logInt(int p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
    |     }
    | 
    |     function logUint(uint p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
    |     }
    | 
    |     function logString(string memory p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    |     }
    | 
    |     function logBool(bool p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    |     }
    | 
    |     function logAddress(address p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    |     }
    | 
    |     function logBytes(bytes memory p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
    |     }
    | 
    |     function logBytes1(bytes1 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
    |     }
    | 
    |     function logBytes2(bytes2 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
    |     }
    | 
    |     function logBytes3(bytes3 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
    |     }
    | 
    |     function logBytes4(bytes4 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
    |     }
    | 
    |     function logBytes5(bytes5 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
    |     }
    | 
    |     function logBytes6(bytes6 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
    |     }
    | 
    |     function logBytes7(bytes7 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
    |     }
    | 
    |     function logBytes8(bytes8 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
    |     }
    | 
    |     function logBytes9(bytes9 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
    |     }
    | 
    |     function logBytes10(bytes10 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
    |     }
    | 
    |     function logBytes11(bytes11 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
    |     }
    | 
    |     function logBytes12(bytes12 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
    |     }
    | 
    |     function logBytes13(bytes13 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
    |     }
    | 
    |     function logBytes14(bytes14 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
    |     }
    | 
    |     function logBytes15(bytes15 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
    |     }
    | 
    |     function logBytes16(bytes16 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
    |     }
    | 
    |     function logBytes17(bytes17 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
    |     }
    | 
    |     function logBytes18(bytes18 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
    |     }
    | 
    |     function logBytes19(bytes19 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
    |     }
    | 
    |     function logBytes20(bytes20 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
    |     }
    | 
    |     function logBytes21(bytes21 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
    |     }
    | 
    |     function logBytes22(bytes22 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
    |     }
    | 
    |     function logBytes23(bytes23 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
    |     }
    | 
    |     function logBytes24(bytes24 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
    |     }
    | 
    |     function logBytes25(bytes25 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
    |     }
    | 
    |     function logBytes26(bytes26 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
    |     }
    | 
    |     function logBytes27(bytes27 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
    |     }
    | 
    |     function logBytes28(bytes28 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
    |     }
    | 
    |     function logBytes29(bytes29 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
    |     }
    | 
    |     function logBytes30(bytes30 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
    |     }
    | 
    |     function logBytes31(bytes31 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
    |     }
    | 
    |     function logBytes32(bytes32 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
    |     }
    | 
    |     function log(uint p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
    |     }
    | 
    |     function log(string memory p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    |     }
    | 
    |     function log(bool p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    |     }
    | 
    |     function log(address p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    |     }
    | 
    |     function log(uint p0, uint p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
    |     }
    | 
    |     function log(uint p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
    |     }
    | 
    |     function log(uint p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
    |     }
    | 
    |     function log(uint p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, uint p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
    |     }
    | 
    |     function log(bool p0, uint p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
    |     }
    | 
    |     function log(bool p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
    |     }
    | 
    |     function log(bool p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
    |     }
    | 
    |     function log(bool p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
    |     }
    | 
    |     function log(address p0, uint p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
    |     }
    | 
    |     function log(address p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
    |     }
    | 
    |     function log(address p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
    |     }
    | 
    |     function log(address p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
    |     }
    | 
    |     function log(uint p0, uint p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, uint p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, uint p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, uint p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, string memory p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, bool p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, address p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, uint p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, uint p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, uint p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    | }

/root/code/hyper/lib/forge-std/src/console2.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.4.22 <0.9.0;
    | 
    | /// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should
    | /// use `int256` and `uint256`. This modified version fixes that. This version is recommended
    | /// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
    | /// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
    | /// Reference: https://github.com/NomicFoundation/hardhat/issues/2178
    | library console2 {
    |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    | 
    |     function _sendLogPayload(bytes memory payload) private view {
    |         uint256 payloadLength = payload.length;
    |         address consoleAddress = CONSOLE_ADDRESS;
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             let payloadStart := add(payload, 32)
    |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
    |         }
    |     }
    | 
    |     function log() internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log()"));
    |     }
    | 
    |     function logInt(int256 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
    |     }
    | 
    |     function logUint(uint256 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
    |     }
    | 
    |     function logString(string memory p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    |     }
    | 
    |     function logBool(bool p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    |     }
    | 
    |     function logAddress(address p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    |     }
    | 
    |     function logBytes(bytes memory p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
    |     }
    | 
    |     function logBytes1(bytes1 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
    |     }
    | 
    |     function logBytes2(bytes2 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
    |     }
    | 
    |     function logBytes3(bytes3 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
    |     }
    | 
    |     function logBytes4(bytes4 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
    |     }
    | 
    |     function logBytes5(bytes5 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
    |     }
    | 
    |     function logBytes6(bytes6 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
    |     }
    | 
    |     function logBytes7(bytes7 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
    |     }
    | 
    |     function logBytes8(bytes8 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
    |     }
    | 
    |     function logBytes9(bytes9 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
    |     }
    | 
    |     function logBytes10(bytes10 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
    |     }
    | 
    |     function logBytes11(bytes11 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
    |     }
    | 
    |     function logBytes12(bytes12 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
    |     }
    | 
    |     function logBytes13(bytes13 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
    |     }
    | 
    |     function logBytes14(bytes14 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
    |     }
    | 
    |     function logBytes15(bytes15 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
    |     }
    | 
    |     function logBytes16(bytes16 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
    |     }
    | 
    |     function logBytes17(bytes17 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
    |     }
    | 
    |     function logBytes18(bytes18 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
    |     }
    | 
    |     function logBytes19(bytes19 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
    |     }
    | 
    |     function logBytes20(bytes20 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
    |     }
    | 
    |     function logBytes21(bytes21 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
    |     }
    | 
    |     function logBytes22(bytes22 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
    |     }
    | 
    |     function logBytes23(bytes23 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
    |     }
    | 
    |     function logBytes24(bytes24 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
    |     }
    | 
    |     function logBytes25(bytes25 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
    |     }
    | 
    |     function logBytes26(bytes26 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
    |     }
    | 
    |     function logBytes27(bytes27 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
    |     }
    | 
    |     function logBytes28(bytes28 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
    |     }
    | 
    |     function logBytes29(bytes29 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
    |     }
    | 
    |     function logBytes30(bytes30 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
    |     }
    | 
    |     function logBytes31(bytes31 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
    |     }
    | 
    |     function logBytes32(bytes32 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
    |     }
    | 
    |     function log(uint256 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
    |     }
    | 
    |     function log(int256 p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
    |     }
    | 
    |     function log(string memory p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    |     }
    | 
    |     function log(bool p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    |     }
    | 
    |     function log(address p0) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
    |     }
    | 
    |     function log(uint256 p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
    |     }
    | 
    |     function log(uint256 p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
    |     }
    | 
    |     function log(uint256 p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, uint256 p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, int256 p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
    |     }
    | 
    |     function log(string memory p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
    |     }
    | 
    |     function log(bool p0, uint256 p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
    |     }
    | 
    |     function log(bool p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
    |     }
    | 
    |     function log(bool p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
    |     }
    | 
    |     function log(bool p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
    |     }
    | 
    |     function log(address p0, uint256 p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
    |     }
    | 
    |     function log(address p0, string memory p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
    |     }
    | 
    |     function log(address p0, bool p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
    |     }
    | 
    |     function log(address p0, address p1) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, bool p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, address p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint256 p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint256 p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint256 p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, uint256 p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(bool p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint256 p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint256 p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint256 p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, uint256 p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, bool p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, uint256 p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, bool p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
    |     }
    | 
    |     function log(address p0, address p1, address p2) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(uint256 p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, uint256 p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(string memory p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, uint256 p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(bool p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, uint256 p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, string memory p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, bool p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint256 p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint256 p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, uint256 p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, string memory p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, bool p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, uint256 p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, string memory p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, bool p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
    |     }
    | 
    |     function log(address p0, address p1, address p2, address p3) internal view {
    |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
    |     }
    | 
    | }

/root/code/hyper/lib/solmate/lib/ds-test/src/test.sol
    | // SPDX-License-Identifier: GPL-3.0-or-later
    | 
    | // This program is free software: you can redistribute it and/or modify
    | // it under the terms of the GNU General Public License as published by
    | // the Free Software Foundation, either version 3 of the License, or
    | // (at your option) any later version.
    | 
    | // This program is distributed in the hope that it will be useful,
    | // but WITHOUT ANY WARRANTY; without even the implied warranty of
    | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    | // GNU General Public License for more details.
    | 
    | // You should have received a copy of the GNU General Public License
    | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
    | 
    | pragma solidity >=0.5.0;
    | 
    | contract DSTest {
    |     event log                    (string);
    |     event logs                   (bytes);
    | 
    |     event log_address            (address);
    |     event log_bytes32            (bytes32);
    |     event log_int                (int);
    |     event log_uint               (uint);
    |     event log_bytes              (bytes);
    |     event log_string             (string);
    | 
    |     event log_named_address      (string key, address val);
    |     event log_named_bytes32      (string key, bytes32 val);
    |     event log_named_decimal_int  (string key, int val, uint decimals);
    |     event log_named_decimal_uint (string key, uint val, uint decimals);
    |     event log_named_int          (string key, int val);
    |     event log_named_uint         (string key, uint val);
    |     event log_named_bytes        (string key, bytes val);
    |     event log_named_string       (string key, string val);
    | 
    |     bool public IS_TEST = true;
    |     bool private _failed;
    | 
    |     address constant HEVM_ADDRESS =
    |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
    | 
    |     modifier mayRevert() { _; }
    |     modifier testopts(string memory) { _; }
    | 
    |     function failed() public returns (bool) {
    |         if (_failed) {
    |             return _failed;
    |         } else {
    |             bool globalFailed = false;
    |             if (hasHEVMContext()) {
    |                 (, bytes memory retdata) = HEVM_ADDRESS.call(
    |                     abi.encodePacked(
    |                         bytes4(keccak256("load(address,bytes32)")),
    |                         abi.encode(HEVM_ADDRESS, bytes32("failed"))
    |                     )
    |                 );
    |                 globalFailed = abi.decode(retdata, (bool));
    |             }
    |             return globalFailed;
    |         }
    |     } 
    | 
    |     function fail() internal {
    |         if (hasHEVMContext()) {
    |             (bool status, ) = HEVM_ADDRESS.call(
    |                 abi.encodePacked(
    |                     bytes4(keccak256("store(address,bytes32,bytes32)")),
    |                     abi.encode(HEVM_ADDRESS, bytes32("failed"), bytes32(uint256(0x01)))
    |                 )
    |             );
    |             status; // Silence compiler warnings
    |         }
    |         _failed = true;
    |     }
    | 
    |     function hasHEVMContext() internal view returns (bool) {
    |         uint256 hevmCodeSize = 0;
    |         assembly {
    |             hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
    |         }
    |         return hevmCodeSize > 0;
    |     }
    | 
    |     modifier logs_gas() {
    |         uint startGas = gasleft();
    |         _;
    |         uint endGas = gasleft();
    |         emit log_named_uint("gas", startGas - endGas);
    |     }
    | 
    |     function assertTrue(bool condition) internal {
    |         if (!condition) {
    |             emit log("Error: Assertion Failed");
    |             fail();
    |         }
    |     }
    | 
    |     function assertTrue(bool condition, string memory err) internal {
    |         if (!condition) {
    |             emit log_named_string("Error", err);
    |             assertTrue(condition);
    |         }
    |     }
    | 
    |     function assertEq(address a, address b) internal {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [address]");
    |             emit log_named_address("  Expected", b);
    |             emit log_named_address("    Actual", a);
    |             fail();
    |         }
    |     }
    |     function assertEq(address a, address b, string memory err) internal {
    |         if (a != b) {
    |             emit log_named_string ("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    | 
    |     function assertEq(bytes32 a, bytes32 b) internal {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [bytes32]");
    |             emit log_named_bytes32("  Expected", b);
    |             emit log_named_bytes32("    Actual", a);
    |             fail();
    |         }
    |     }
    |     function assertEq(bytes32 a, bytes32 b, string memory err) internal {
    |         if (a != b) {
    |             emit log_named_string ("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    |     function assertEq32(bytes32 a, bytes32 b) internal {
    |         assertEq(a, b);
    |     }
    |     function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
    |         assertEq(a, b, err);
    |     }
    | 
    |     function assertEq(int a, int b) internal {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [int]");
    |             emit log_named_int("  Expected", b);
    |             emit log_named_int("    Actual", a);
    |             fail();
    |         }
    |     }
    |     function assertEq(int a, int b, string memory err) internal {
    |         if (a != b) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    |     function assertEq(uint a, uint b) internal {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [uint]");
    |             emit log_named_uint("  Expected", b);
    |             emit log_named_uint("    Actual", a);
    |             fail();
    |         }
    |     }
    |     function assertEq(uint a, uint b, string memory err) internal {
    |         if (a != b) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    |     function assertEqDecimal(int a, int b, uint decimals) internal {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [decimal int]");
    |             emit log_named_decimal_int("  Expected", b, decimals);
    |             emit log_named_decimal_int("    Actual", a, decimals);
    |             fail();
    |         }
    |     }
    |     function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
    |         if (a != b) {
    |             emit log_named_string("Error", err);
    |             assertEqDecimal(a, b, decimals);
    |         }
    |     }
    |     function assertEqDecimal(uint a, uint b, uint decimals) internal {
    |         if (a != b) {
    |             emit log("Error: a == b not satisfied [decimal uint]");
    |             emit log_named_decimal_uint("  Expected", b, decimals);
    |             emit log_named_decimal_uint("    Actual", a, decimals);
    |             fail();
    |         }
    |     }
    |     function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
    |         if (a != b) {
    |             emit log_named_string("Error", err);
    |             assertEqDecimal(a, b, decimals);
    |         }
    |     }
    | 
    |     function assertGt(uint a, uint b) internal {
    |         if (a <= b) {
    |             emit log("Error: a > b not satisfied [uint]");
    |             emit log_named_uint("  Value a", a);
    |             emit log_named_uint("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertGt(uint a, uint b, string memory err) internal {
    |         if (a <= b) {
    |             emit log_named_string("Error", err);
    |             assertGt(a, b);
    |         }
    |     }
    |     function assertGt(int a, int b) internal {
    |         if (a <= b) {
    |             emit log("Error: a > b not satisfied [int]");
    |             emit log_named_int("  Value a", a);
    |             emit log_named_int("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertGt(int a, int b, string memory err) internal {
    |         if (a <= b) {
    |             emit log_named_string("Error", err);
    |             assertGt(a, b);
    |         }
    |     }
    |     function assertGtDecimal(int a, int b, uint decimals) internal {
    |         if (a <= b) {
    |             emit log("Error: a > b not satisfied [decimal int]");
    |             emit log_named_decimal_int("  Value a", a, decimals);
    |             emit log_named_decimal_int("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
    |         if (a <= b) {
    |             emit log_named_string("Error", err);
    |             assertGtDecimal(a, b, decimals);
    |         }
    |     }
    |     function assertGtDecimal(uint a, uint b, uint decimals) internal {
    |         if (a <= b) {
    |             emit log("Error: a > b not satisfied [decimal uint]");
    |             emit log_named_decimal_uint("  Value a", a, decimals);
    |             emit log_named_decimal_uint("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
    |         if (a <= b) {
    |             emit log_named_string("Error", err);
    |             assertGtDecimal(a, b, decimals);
    |         }
    |     }
    | 
    |     function assertGe(uint a, uint b) internal {
    |         if (a < b) {
    |             emit log("Error: a >= b not satisfied [uint]");
    |             emit log_named_uint("  Value a", a);
    |             emit log_named_uint("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertGe(uint a, uint b, string memory err) internal {
    |         if (a < b) {
    |             emit log_named_string("Error", err);
    |             assertGe(a, b);
    |         }
    |     }
    |     function assertGe(int a, int b) internal {
    |         if (a < b) {
    |             emit log("Error: a >= b not satisfied [int]");
    |             emit log_named_int("  Value a", a);
    |             emit log_named_int("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertGe(int a, int b, string memory err) internal {
    |         if (a < b) {
    |             emit log_named_string("Error", err);
    |             assertGe(a, b);
    |         }
    |     }
    |     function assertGeDecimal(int a, int b, uint decimals) internal {
    |         if (a < b) {
    |             emit log("Error: a >= b not satisfied [decimal int]");
    |             emit log_named_decimal_int("  Value a", a, decimals);
    |             emit log_named_decimal_int("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
    |         if (a < b) {
    |             emit log_named_string("Error", err);
    |             assertGeDecimal(a, b, decimals);
    |         }
    |     }
    |     function assertGeDecimal(uint a, uint b, uint decimals) internal {
    |         if (a < b) {
    |             emit log("Error: a >= b not satisfied [decimal uint]");
    |             emit log_named_decimal_uint("  Value a", a, decimals);
    |             emit log_named_decimal_uint("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
    |         if (a < b) {
    |             emit log_named_string("Error", err);
    |             assertGeDecimal(a, b, decimals);
    |         }
    |     }
    | 
    |     function assertLt(uint a, uint b) internal {
    |         if (a >= b) {
    |             emit log("Error: a < b not satisfied [uint]");
    |             emit log_named_uint("  Value a", a);
    |             emit log_named_uint("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertLt(uint a, uint b, string memory err) internal {
    |         if (a >= b) {
    |             emit log_named_string("Error", err);
    |             assertLt(a, b);
    |         }
    |     }
    |     function assertLt(int a, int b) internal {
    |         if (a >= b) {
    |             emit log("Error: a < b not satisfied [int]");
    |             emit log_named_int("  Value a", a);
    |             emit log_named_int("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertLt(int a, int b, string memory err) internal {
    |         if (a >= b) {
    |             emit log_named_string("Error", err);
    |             assertLt(a, b);
    |         }
    |     }
    |     function assertLtDecimal(int a, int b, uint decimals) internal {
    |         if (a >= b) {
    |             emit log("Error: a < b not satisfied [decimal int]");
    |             emit log_named_decimal_int("  Value a", a, decimals);
    |             emit log_named_decimal_int("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
    |         if (a >= b) {
    |             emit log_named_string("Error", err);
    |             assertLtDecimal(a, b, decimals);
    |         }
    |     }
    |     function assertLtDecimal(uint a, uint b, uint decimals) internal {
    |         if (a >= b) {
    |             emit log("Error: a < b not satisfied [decimal uint]");
    |             emit log_named_decimal_uint("  Value a", a, decimals);
    |             emit log_named_decimal_uint("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
    |         if (a >= b) {
    |             emit log_named_string("Error", err);
    |             assertLtDecimal(a, b, decimals);
    |         }
    |     }
    | 
    |     function assertLe(uint a, uint b) internal {
    |         if (a > b) {
    |             emit log("Error: a <= b not satisfied [uint]");
    |             emit log_named_uint("  Value a", a);
    |             emit log_named_uint("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertLe(uint a, uint b, string memory err) internal {
    |         if (a > b) {
    |             emit log_named_string("Error", err);
    |             assertLe(a, b);
    |         }
    |     }
    |     function assertLe(int a, int b) internal {
    |         if (a > b) {
    |             emit log("Error: a <= b not satisfied [int]");
    |             emit log_named_int("  Value a", a);
    |             emit log_named_int("  Value b", b);
    |             fail();
    |         }
    |     }
    |     function assertLe(int a, int b, string memory err) internal {
    |         if (a > b) {
    |             emit log_named_string("Error", err);
    |             assertLe(a, b);
    |         }
    |     }
    |     function assertLeDecimal(int a, int b, uint decimals) internal {
    |         if (a > b) {
    |             emit log("Error: a <= b not satisfied [decimal int]");
    |             emit log_named_decimal_int("  Value a", a, decimals);
    |             emit log_named_decimal_int("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
    |         if (a > b) {
    |             emit log_named_string("Error", err);
    |             assertLeDecimal(a, b, decimals);
    |         }
    |     }
    |     function assertLeDecimal(uint a, uint b, uint decimals) internal {
    |         if (a > b) {
    |             emit log("Error: a <= b not satisfied [decimal uint]");
    |             emit log_named_decimal_uint("  Value a", a, decimals);
    |             emit log_named_decimal_uint("  Value b", b, decimals);
    |             fail();
    |         }
    |     }
    |     function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
    |         if (a > b) {
    |             emit log_named_string("Error", err);
    |             assertGeDecimal(a, b, decimals);
    |         }
    |     }
    | 
    |     function assertEq(string memory a, string memory b) internal {
    |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
    |             emit log("Error: a == b not satisfied [string]");
    |             emit log_named_string("  Expected", b);
    |             emit log_named_string("    Actual", a);
    |             fail();
    |         }
    |     }
    |     function assertEq(string memory a, string memory b, string memory err) internal {
    |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
    |             emit log_named_string("Error", err);
    |             assertEq(a, b);
    |         }
    |     }
    | 
    |     function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
    |         ok = true;
    |         if (a.length == b.length) {
    |             for (uint i = 0; i < a.length; i++) {
    |                 if (a[i] != b[i]) {
    |                     ok = false;
    |                 }
    |             }
    |         } else {
    |             ok = false;
    |         }
    |     }
    |     function assertEq0(bytes memory a, bytes memory b) internal {
    |         if (!checkEq0(a, b)) {
    |             emit log("Error: a == b not satisfied [bytes]");
    |             emit log_named_bytes("  Expected", b);
    |             emit log_named_bytes("    Actual", a);
    |             fail();
    |         }
    |     }
    |     function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
    |         if (!checkEq0(a, b)) {
    |             emit log_named_string("Error", err);
    |             assertEq0(a, b);
    |         }
    |     }
    | }
    | 

/root/code/hyper/lib/solmate/src/tokens/ERC20.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.8.0;
    | 
    | /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
    | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)
    | /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
    | /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
    | abstract contract ERC20 {
    |     /*//////////////////////////////////////////////////////////////
    |                                  EVENTS
    |     //////////////////////////////////////////////////////////////*/
    | 
    |     event Transfer(address indexed from, address indexed to, uint256 amount);
    | 
    |     event Approval(address indexed owner, address indexed spender, uint256 amount);
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                             METADATA STORAGE
    |     //////////////////////////////////////////////////////////////*/
    | 
*   |     string public name;
    | 
*   |     string public symbol;
    | 
*   |     uint8 public immutable decimals;
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                               ERC20 STORAGE
    |     //////////////////////////////////////////////////////////////*/
    | 
*r  |     uint256 public totalSupply;
    | 
*   |     mapping(address => uint256) public balanceOf;
    | 
*   |     mapping(address => mapping(address => uint256)) public allowance;
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                             EIP-2612 STORAGE
    |     //////////////////////////////////////////////////////////////*/
    | 
    |     uint256 internal immutable INITIAL_CHAIN_ID;
    | 
    |     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
    | 
*   |     mapping(address => uint256) public nonces;
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                                CONSTRUCTOR
    |     //////////////////////////////////////////////////////////////*/
    | 
    |     constructor(
    |         string memory _name,
    |         string memory _symbol,
    |         uint8 _decimals
    |     ) {
    |         name = _name;
    |         symbol = _symbol;
    |         decimals = _decimals;
    | 
    |         INITIAL_CHAIN_ID = block.chainid;
    |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    |     }
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                                ERC20 LOGIC
    |     //////////////////////////////////////////////////////////////*/
    | 
*   |     function approve(address spender, uint256 amount) public virtual returns (bool) {
*   |         allowance[msg.sender][spender] = amount;
    | 
*   |         emit Approval(msg.sender, spender, amount);
    | 
*   |         return true;
    |     }
    | 
r   |     function transfer(address to, uint256 amount) public virtual returns (bool) {
r   |         balanceOf[msg.sender] -= amount;
    | 
    |         // Cannot overflow because the sum of all user
    |         // balances can't exceed the max uint256 value.
    |         unchecked {
    |             balanceOf[to] += amount;
    |         }
    | 
    |         emit Transfer(msg.sender, to, amount);
    | 
    |         return true;
    |     }
    | 
r   |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 amount
r   |     ) public virtual returns (bool) {
r   |         uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
    | 
r   |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
    | 
    |         balanceOf[from] -= amount;
    | 
    |         // Cannot overflow because the sum of all user
    |         // balances can't exceed the max uint256 value.
    |         unchecked {
    |             balanceOf[to] += amount;
    |         }
    | 
    |         emit Transfer(from, to, amount);
    | 
    |         return true;
    |     }
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                              EIP-2612 LOGIC
    |     //////////////////////////////////////////////////////////////*/
    | 
r   |     function permit(
    |         address owner,
    |         address spender,
    |         uint256 value,
    |         uint256 deadline,
    |         uint8 v,
    |         bytes32 r,
    |         bytes32 s
    |     ) public virtual {
r   |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
    | 
    |         // Unchecked because the only math done is incrementing
    |         // the owner's nonce which cannot realistically overflow.
    |         unchecked {
r   |             address recoveredAddress = ecrecover(
r   |                 keccak256(
r   |                     abi.encodePacked(
    |                         "\x19\x01",
r   |                         DOMAIN_SEPARATOR(),
r   |                         keccak256(
r   |                             abi.encode(
r   |                                 keccak256(
    |                                     "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    |                                 ),
    |                                 owner,
    |                                 spender,
    |                                 value,
r   |                                 nonces[owner]++,
    |                                 deadline
    |                             )
    |                         )
    |                     )
    |                 ),
    |                 v,
    |                 r,
    |                 s
    |             );
    | 
r   |             require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
    | 
    |             allowance[recoveredAddress][spender] = value;
    |         }
    | 
    |         emit Approval(owner, spender, value);
    |     }
    | 
*r  |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
*r  |         return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
    |     }
    | 
    |     function computeDomainSeparator() internal view virtual returns (bytes32) {
    |         return
    |             keccak256(
    |                 abi.encode(
    |                     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    |                     keccak256(bytes(name)),
    |                     keccak256("1"),
    |                     block.chainid,
    |                     address(this)
    |                 )
    |             );
    |     }
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                         INTERNAL MINT/BURN LOGIC
    |     //////////////////////////////////////////////////////////////*/
    | 
*r  |     function _mint(address to, uint256 amount) internal virtual {
*r  |         totalSupply += amount;
    | 
    |         // Cannot overflow because the sum of all user
    |         // balances can't exceed the max uint256 value.
    |         unchecked {
*r  |             balanceOf[to] += amount;
    |         }
    | 
*r  |         emit Transfer(address(0), to, amount);
    |     }
    | 
r   |     function _burn(address from, uint256 amount) internal virtual {
r   |         balanceOf[from] -= amount;
    | 
    |         // Cannot underflow because a user's balance
    |         // will never be larger than the total supply.
    |         unchecked {
    |             totalSupply -= amount;
    |         }
    | 
    |         emit Transfer(from, address(0), amount);
    |     }
    | }
    | 

/root/code/hyper/lib/solmate/src/tokens/WETH.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.8.0;
    | 
    | import {ERC20} from "./ERC20.sol";
    | 
    | import {SafeTransferLib} from "../utils/SafeTransferLib.sol";
    | 
    | /// @notice Minimalist and modern Wrapped Ether implementation.
    | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)
*r  | /// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)
    | contract WETH is ERC20("Wrapped Ether", "WETH", 18) {
    |     using SafeTransferLib for address;
    | 
    |     event Deposit(address indexed from, uint256 amount);
    | 
    |     event Withdrawal(address indexed to, uint256 amount);
    | 
*r  |     function deposit() public payable virtual {
*r  |         _mint(msg.sender, msg.value);
    | 
*r  |         emit Deposit(msg.sender, msg.value);
    |     }
    | 
r   |     function withdraw(uint256 amount) public virtual {
r   |         _burn(msg.sender, amount);
    | 
    |         emit Withdrawal(msg.sender, amount);
    | 
    |         msg.sender.safeTransferETH(amount);
    |     }
    | 
    |     receive() external payable virtual {
*r  |         deposit();
    |     }
    | }
    | 

/root/code/hyper/lib/solmate/src/utils/FixedPointMathLib.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.8.0;
    | 
    | /// @notice Arithmetic library with operations for fixed-point numbers.
    | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)
    | library FixedPointMathLib {
    |     /*//////////////////////////////////////////////////////////////
    |                     SIMPLIFIED FIXED POINT OPERATIONS
    |     //////////////////////////////////////////////////////////////*/
    | 
*r  |     uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.
    | 
*r  |     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
*r  |         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
    |     }
    | 
    |     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
    |         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
    |     }
    | 
r   |     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
r   |         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
    |     }
    | 
    |     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
    |         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
    |     }
    | 
*r  |     function powWad(int256 x, int256 y) internal pure returns (int256) {
    |         // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)
*r  |         return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.
    |     }
    | 
*r  |     function expWad(int256 x) internal pure returns (int256 r) {
    |         unchecked {
    |             // When the result is < 0.5 we return zero. This happens when
    |             // x <= floor(log(0.5e18) * 1e18) ~ -42e18
*r  |             if (x <= -42139678854452767551) return 0;
    | 
    |             // When the result is > (2**255 - 1) / 1e18 we can not represent it as an
    |             // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.
*r  |             if (x >= 135305999368893231589) revert("EXP_OVERFLOW");
    | 
    |             // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96
    |             // for more intermediate precision and a binary basis. This base conversion
    |             // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
*r  |             x = (x << 78) / 5**18;
    | 
    |             // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers
    |             // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
    |             // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
*r  |             int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;
*r  |             x = x - k * 54916777467707473351141471128;
    | 
    |             // k is in the range [-61, 195].
    | 
    |             // Evaluate using a (6, 7)-term rational approximation.
    |             // p is made monic, we'll multiply by a scale factor later.
*r  |             int256 y = x + 1346386616545796478920950773328;
*r  |             y = ((y * x) >> 96) + 57155421227552351082224309758442;
*r  |             int256 p = y + x - 94201549194550492254356042504812;
*r  |             p = ((p * y) >> 96) + 28719021644029726153956944680412240;
*r  |             p = p * x + (4385272521454847904659076985693276 << 96);
    | 
    |             // We leave p in 2**192 basis so we don't need to scale it back up for the division.
*r  |             int256 q = x - 2855989394907223263936484059900;
*r  |             q = ((q * x) >> 96) + 50020603652535783019961831881945;
*r  |             q = ((q * x) >> 96) - 533845033583426703283633433725380;
*r  |             q = ((q * x) >> 96) + 3604857256930695427073651918091429;
*r  |             q = ((q * x) >> 96) - 14423608567350463180887372962807573;
*r  |             q = ((q * x) >> 96) + 26449188498355588339934803723976023;
    | 
    |             assembly {
    |                 // Div in assembly because solidity adds a zero check despite the unchecked.
    |                 // The q polynomial won't have zeros in the domain as all its roots are complex.
    |                 // No scaling is necessary because p is already 2**96 too large.
*r  |                 r := sdiv(p, q)
    |             }
    | 
    |             // r should be in the range (0.09, 0.25) * 2**96.
    | 
    |             // We now need to multiply r by:
    |             // * the scale factor s = ~6.031367120.
    |             // * the 2**k factor from the range reduction.
    |             // * the 1e18 / 2**96 factor for base conversion.
    |             // We do this all at once, with an intermediate result in 2**213
    |             // basis, so the final right shift is always by a positive amount.
*r  |             r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));
    |         }
    |     }
    | 
*r  |     function lnWad(int256 x) internal pure returns (int256 r) {
    |         unchecked {
*r  |             require(x > 0, "UNDEFINED");
    | 
    |             // We want to convert x from 10**18 fixed point to 2**96 fixed point.
    |             // We do this by multiplying by 2**96 / 10**18. But since
    |             // ln(x * C) = ln(x) + ln(C), we can simply do nothing here
    |             // and add ln(2**96 / 10**18) at the end.
    | 
    |             // Reduce range of x to (1, 2) * 2**96
    |             // ln(2^k * x) = k * ln(2) + ln(x)
*r  |             int256 k = int256(log2(uint256(x))) - 96;
*r  |             x <<= uint256(159 - k);
*r  |             x = int256(uint256(x) >> 159);
    | 
    |             // Evaluate using a (8, 8)-term rational approximation.
    |             // p is made monic, we will multiply by a scale factor later.
*r  |             int256 p = x + 3273285459638523848632254066296;
*r  |             p = ((p * x) >> 96) + 24828157081833163892658089445524;
*r  |             p = ((p * x) >> 96) + 43456485725739037958740375743393;
*r  |             p = ((p * x) >> 96) - 11111509109440967052023855526967;
*r  |             p = ((p * x) >> 96) - 45023709667254063763336534515857;
*r  |             p = ((p * x) >> 96) - 14706773417378608786704636184526;
*r  |             p = p * x - (795164235651350426258249787498 << 96);
    | 
    |             // We leave p in 2**192 basis so we don't need to scale it back up for the division.
    |             // q is monic by convention.
*r  |             int256 q = x + 5573035233440673466300451813936;
*r  |             q = ((q * x) >> 96) + 71694874799317883764090561454958;
*r  |             q = ((q * x) >> 96) + 283447036172924575727196451306956;
*r  |             q = ((q * x) >> 96) + 401686690394027663651624208769553;
*r  |             q = ((q * x) >> 96) + 204048457590392012362485061816622;
*r  |             q = ((q * x) >> 96) + 31853899698501571402653359427138;
*r  |             q = ((q * x) >> 96) + 909429971244387300277376558375;
    |             assembly {
    |                 // Div in assembly because solidity adds a zero check despite the unchecked.
    |                 // The q polynomial is known not to have zeros in the domain.
    |                 // No scaling required because p is already 2**96 too large.
*r  |                 r := sdiv(p, q)
    |             }
    | 
    |             // r is in the range (0, 0.125) * 2**96
    | 
    |             // Finalization, we need to:
    |             // * multiply by the scale factor s = 5.549…
    |             // * add ln(2**96 / 10**18)
    |             // * add k * ln(2)
    |             // * multiply by 10**18 / 2**96 = 5**18 >> 78
    | 
    |             // mul s * 5e18 * 2**96, base is now 5**18 * 2**192
*r  |             r *= 1677202110996718588342820967067443963516166;
    |             // add ln(2) * k * 5e18 * 2**192
*r  |             r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;
    |             // add ln(2**96 / 10**18) * 5e18 * 2**192
*r  |             r += 600920179829731861736702779321621459595472258049074101567377883020018308;
    |             // base conversion: mul 2**18 / 2**192
*r  |             r >>= 174;
    |         }
    |     }
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                     LOW LEVEL FIXED POINT OPERATIONS
    |     //////////////////////////////////////////////////////////////*/
    | 
r   |     function mulDivDown(
    |         uint256 x,
    |         uint256 y,
    |         uint256 denominator
    |     ) internal pure returns (uint256 z) {
    |         assembly {
    |             // Store x * y in z for now.
r   |             z := mul(x, y)
    | 
    |             // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
r   |             if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {
r   |                 revert(0, 0)
    |             }
    | 
    |             // Divide z by the denominator.
r   |             z := div(z, denominator)
    |         }
    |     }
    | 
    |     function mulDivUp(
    |         uint256 x,
    |         uint256 y,
    |         uint256 denominator
    |     ) internal pure returns (uint256 z) {
    |         assembly {
    |             // Store x * y in z for now.
    |             z := mul(x, y)
    | 
    |             // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
    |             if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {
    |                 revert(0, 0)
    |             }
    | 
    |             // First, divide z - 1 by the denominator and add 1.
    |             // We allow z - 1 to underflow if z is 0, because we multiply the
    |             // end result by 0 if z is zero, ensuring we return 0 if z is zero.
    |             z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))
    |         }
    |     }
    | 
    |     function rpow(
    |         uint256 x,
    |         uint256 n,
    |         uint256 scalar
    |     ) internal pure returns (uint256 z) {
    |         assembly {
    |             switch x
    |             case 0 {
    |                 switch n
    |                 case 0 {
    |                     // 0 ** 0 = 1
    |                     z := scalar
    |                 }
    |                 default {
    |                     // 0 ** n = 0
    |                     z := 0
    |                 }
    |             }
    |             default {
    |                 switch mod(n, 2)
    |                 case 0 {
    |                     // If n is even, store scalar in z for now.
    |                     z := scalar
    |                 }
    |                 default {
    |                     // If n is odd, store x in z for now.
    |                     z := x
    |                 }
    | 
    |                 // Shifting right by 1 is like dividing by 2.
    |                 let half := shr(1, scalar)
    | 
    |                 for {
    |                     // Shift n right by 1 before looping to halve it.
    |                     n := shr(1, n)
    |                 } n {
    |                     // Shift n right by 1 each iteration to halve it.
    |                     n := shr(1, n)
    |                 } {
    |                     // Revert immediately if x ** 2 would overflow.
    |                     // Equivalent to iszero(eq(div(xx, x), x)) here.
    |                     if shr(128, x) {
    |                         revert(0, 0)
    |                     }
    | 
    |                     // Store x squared.
    |                     let xx := mul(x, x)
    | 
    |                     // Round to the nearest number.
    |                     let xxRound := add(xx, half)
    | 
    |                     // Revert if xx + half overflowed.
    |                     if lt(xxRound, xx) {
    |                         revert(0, 0)
    |                     }
    | 
    |                     // Set x to scaled xxRound.
    |                     x := div(xxRound, scalar)
    | 
    |                     // If n is even:
    |                     if mod(n, 2) {
    |                         // Compute z * x.
    |                         let zx := mul(z, x)
    | 
    |                         // If z * x overflowed:
    |                         if iszero(eq(div(zx, x), z)) {
    |                             // Revert if x is non-zero.
    |                             if iszero(iszero(x)) {
    |                                 revert(0, 0)
    |                             }
    |                         }
    | 
    |                         // Round to the nearest number.
    |                         let zxRound := add(zx, half)
    | 
    |                         // Revert if zx + half overflowed.
    |                         if lt(zxRound, zx) {
    |                             revert(0, 0)
    |                         }
    | 
    |                         // Return properly scaled zxRound.
    |                         z := div(zxRound, scalar)
    |                     }
    |                 }
    |             }
    |         }
    |     }
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                         GENERAL NUMBER UTILITIES
    |     //////////////////////////////////////////////////////////////*/
    | 
r   |     function sqrt(uint256 x) internal pure returns (uint256 z) {
    |         assembly {
r   |             let y := x // We start y at x, which will help us make our initial estimate.
    | 
r   |             z := 181 // The "correct" value is 1, but this saves a multiplication later.
    | 
    |             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
    |             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
    | 
    |             // We check y >= 2^(k + 8) but shift right by k bits
    |             // each branch to ensure that if x >= 256, then y >= 256.
r   |             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
    |                 y := shr(128, y)
    |                 z := shl(64, z)
    |             }
r   |             if iszero(lt(y, 0x1000000000000000000)) {
    |                 y := shr(64, y)
    |                 z := shl(32, z)
    |             }
r   |             if iszero(lt(y, 0x10000000000)) {
    |                 y := shr(32, y)
    |                 z := shl(16, z)
    |             }
r   |             if iszero(lt(y, 0x1000000)) {
    |                 y := shr(16, y)
    |                 z := shl(8, z)
    |             }
    | 
    |             // Goal was to get z*z*y within a small factor of x. More iterations could
    |             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
    |             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
    |             // That's not possible if x < 256 but we can just verify those cases exhaustively.
    | 
    |             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
    |             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
    |             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
    | 
    |             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
    |             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
    | 
    |             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
    |             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
    | 
    |             // There is no overflow risk here since y < 2^136 after the first branch above.
r   |             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
    | 
    |             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
r   |             z := shr(1, add(z, div(x, z)))
r   |             z := shr(1, add(z, div(x, z)))
r   |             z := shr(1, add(z, div(x, z)))
r   |             z := shr(1, add(z, div(x, z)))
r   |             z := shr(1, add(z, div(x, z)))
r   |             z := shr(1, add(z, div(x, z)))
r   |             z := shr(1, add(z, div(x, z)))
    | 
    |             // If x+1 is a perfect square, the Babylonian method cycles between
    |             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
    |             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
    |             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
    |             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
r   |             z := sub(z, lt(div(x, z), z))
    |         }
    |     }
    | 
*r  |     function log2(uint256 x) internal pure returns (uint256 r) {
*r  |         require(x > 0, "UNDEFINED");
    | 
    |         assembly {
*r  |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
*r  |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
*r  |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
*r  |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
*r  |             r := or(r, shl(3, lt(0xff, shr(r, x))))
*r  |             r := or(r, shl(2, lt(0xf, shr(r, x))))
*r  |             r := or(r, shl(1, lt(0x3, shr(r, x))))
*r  |             r := or(r, lt(0x1, shr(r, x)))
    |         }
    |     }
    | 
    |     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
    |         assembly {
    |             // z will equal 0 if y is 0, unlike in Solidity where it will revert.
    |             z := mod(x, y)
    |         }
    |     }
    | 
    |     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
    |         assembly {
    |             // z will equal 0 if y is 0, unlike in Solidity where it will revert.
    |             z := div(x, y)
    |         }
    |     }
    | 
    |     /// @dev Will return 0 instead of reverting if y is zero.
    |     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
    |         assembly {
    |             // Add 1 to x * y if x % y > 0.
    |             z := add(gt(mod(x, y), 0), div(x, y))
    |         }
    |     }
    | }
    | 

/root/code/hyper/lib/solmate/src/utils/SafeCastLib.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.8.0;
    | 
    | /// @notice Safe unsigned integer casting library that reverts on overflow.
    | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)
    | library SafeCastLib {
    |     function safeCastTo248(uint256 x) internal pure returns (uint248 y) {
    |         require(x < 1 << 248);
    | 
    |         y = uint248(x);
    |     }
    | 
    |     function safeCastTo224(uint256 x) internal pure returns (uint224 y) {
    |         require(x < 1 << 224);
    | 
    |         y = uint224(x);
    |     }
    | 
    |     function safeCastTo192(uint256 x) internal pure returns (uint192 y) {
    |         require(x < 1 << 192);
    | 
    |         y = uint192(x);
    |     }
    | 
    |     function safeCastTo160(uint256 x) internal pure returns (uint160 y) {
    |         require(x < 1 << 160);
    | 
    |         y = uint160(x);
    |     }
    | 
*r  |     function safeCastTo128(uint256 x) internal pure returns (uint128 y) {
*r  |         require(x < 1 << 128);
    | 
*r  |         y = uint128(x);
    |     }
    | 
    |     function safeCastTo96(uint256 x) internal pure returns (uint96 y) {
    |         require(x < 1 << 96);
    | 
    |         y = uint96(x);
    |     }
    | 
    |     function safeCastTo64(uint256 x) internal pure returns (uint64 y) {
    |         require(x < 1 << 64);
    | 
    |         y = uint64(x);
    |     }
    | 
*r  |     function safeCastTo32(uint256 x) internal pure returns (uint32 y) {
*r  |         require(x < 1 << 32);
    | 
    |         y = uint32(x);
    |     }
    | 
    |     function safeCastTo8(uint256 x) internal pure returns (uint8 y) {
    |         require(x < 1 << 8);
    | 
    |         y = uint8(x);
    |     }
    | }
    | 

/root/code/hyper/lib/solmate/src/utils/SafeTransferLib.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity >=0.8.0;
    | 
    | import {ERC20} from "../tokens/ERC20.sol";
    | 
    | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
    | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)
    | /// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.
    | library SafeTransferLib {
    |     /*//////////////////////////////////////////////////////////////
    |                              ETH OPERATIONS
    |     //////////////////////////////////////////////////////////////*/
    | 
    |     function safeTransferETH(address to, uint256 amount) internal {
    |         bool success;
    | 
    |         assembly {
    |             // Transfer the ETH and store if it succeeded or not.
    |             success := call(gas(), to, amount, 0, 0, 0, 0)
    |         }
    | 
    |         require(success, "ETH_TRANSFER_FAILED");
    |     }
    | 
    |     /*//////////////////////////////////////////////////////////////
    |                             ERC20 OPERATIONS
    |     //////////////////////////////////////////////////////////////*/
    | 
r   |     function safeTransferFrom(
    |         ERC20 token,
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal {
r   |         bool success;
    | 
    |         assembly {
    |             // We'll write our calldata to this slot below, but restore it later.
r   |             let memPointer := mload(0x40)
    | 
    |             // Write the abi-encoded calldata into memory, beginning with the function selector.
r   |             mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)
r   |             mstore(4, from) // Append the "from" argument.
r   |             mstore(36, to) // Append the "to" argument.
r   |             mstore(68, amount) // Append the "amount" argument.
    | 
r   |             success := and(
    |                 // Set success to whether the call reverted, if not we check it either
    |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
r   |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
    |                 // We use 100 because that's the total length of our calldata (4 + 32 * 3)
    |                 // Counterintuitively, this call() must be positioned after the or() in the
    |                 // surrounding and() because and() evaluates its arguments from right to left.
r   |                 call(gas(), token, 0, 0, 100, 0, 32)
    |             )
    | 
r   |             mstore(0x60, 0) // Restore the zero slot to zero.
r   |             mstore(0x40, memPointer) // Restore the memPointer.
    |         }
    | 
r   |         require(success, "TRANSFER_FROM_FAILED");
    |     }
    | 
    |     function safeTransfer(
    |         ERC20 token,
    |         address to,
    |         uint256 amount
    |     ) internal {
    |         bool success;
    | 
    |         assembly {
    |             // We'll write our calldata to this slot below, but restore it later.
    |             let memPointer := mload(0x40)
    | 
    |             // Write the abi-encoded calldata into memory, beginning with the function selector.
    |             mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
    |             mstore(4, to) // Append the "to" argument.
    |             mstore(36, amount) // Append the "amount" argument.
    | 
    |             success := and(
    |                 // Set success to whether the call reverted, if not we check it either
    |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
    |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
    |                 // We use 68 because that's the total length of our calldata (4 + 32 * 2)
    |                 // Counterintuitively, this call() must be positioned after the or() in the
    |                 // surrounding and() because and() evaluates its arguments from right to left.
    |                 call(gas(), token, 0, 0, 68, 0, 32)
    |             )
    | 
    |             mstore(0x60, 0) // Restore the zero slot to zero.
    |             mstore(0x40, memPointer) // Restore the memPointer.
    |         }
    | 
    |         require(success, "TRANSFER_FAILED");
    |     }
    | 
    |     function safeApprove(
    |         ERC20 token,
    |         address to,
    |         uint256 amount
    |     ) internal {
    |         bool success;
    | 
    |         assembly {
    |             // We'll write our calldata to this slot below, but restore it later.
    |             let memPointer := mload(0x40)
    | 
    |             // Write the abi-encoded calldata into memory, beginning with the function selector.
    |             mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
    |             mstore(4, to) // Append the "to" argument.
    |             mstore(36, amount) // Append the "amount" argument.
    | 
    |             success := and(
    |                 // Set success to whether the call reverted, if not we check it either
    |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
    |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
    |                 // We use 68 because that's the total length of our calldata (4 + 32 * 2)
    |                 // Counterintuitively, this call() must be positioned after the or() in the
    |                 // surrounding and() because and() evaluates its arguments from right to left.
    |                 call(gas(), token, 0, 0, 68, 0, 32)
    |             )
    | 
    |             mstore(0x60, 0) // Restore the zero slot to zero.
    |             mstore(0x40, memPointer) // Restore the memPointer.
    |         }
    | 
    |         require(success, "APPROVE_FAILED");
    |     }
    | }
    | 

/root/code/hyper/lib/solstat/src/Gaussian.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.13;
    | 
    | import "../../solmate/src/utils/FixedPointMathLib.sol";
    | import "./Units.sol";
    | 
    | /**
    |  * @title Gaussian Math Library.
    |  * @author @alexangelj
    |  *
    |  * @notice Models the normal distribution using the special Complimentary Error Function.
    |  *
    |  * @dev Only implements a distribution with mean (µ) = 0 and variance (σ) = 1.
    |  * Uses Numerical Recipes as a framework and reference C implemenation.
    |  * Numerical Recipes cites the original textbook written by Abramowitz and Stegun,
    |  * "Handbook of Mathematical Functions", which should be read to understand these
    |  * special functions and the implications of their numerical approximations.
    |  *
    |  * @custom:source Handbook of Mathematical Functions https://personal.math.ubc.ca/~cbm/aands/abramowitz_and_stegun.pdf.
    |  * @custom:source Numerical Recipes https://e-maxx.ru/bookz/files/numerical_recipes.pdf.
    |  * @custom:source Inspired by https://github.com/errcw/gaussian.
    |  */
    | library Gaussian {
    |     using FixedPointMathLib for int256;
    |     using FixedPointMathLib for uint256;
    | 
    |     error Infinity();
    |     error NegativeInfinity();
    | 
    |     uint256 internal constant HALF_WAD = 0.5 ether;
    |     uint256 internal constant PI = 3_141592653589793238;
    |     int256 internal constant SQRT_2PI = 2_506628274631000502;
    |     int256 internal constant SIGN = -1;
    |     int256 internal constant SCALAR = 1e18;
    |     int256 internal constant HALF_SCALAR = 1e9;
    |     int256 internal constant SCALAR_SQRD = 1e36;
    |     int256 internal constant HALF = 5e17;
r   |     int256 internal constant ONE = 1e18;
r   |     int256 internal constant TWO = 2e18;
    |     int256 internal constant NEGATIVE_TWO = -2e18;
    |     int256 internal constant SQRT2 = 1_414213562373095048; // √2 with 18 decimals of precision.
    |     int256 internal constant ERFC_A = 1_265512230000000000;
    |     int256 internal constant ERFC_B = 1_000023680000000000;
    |     int256 internal constant ERFC_C = 374091960000000000; // 1e-1
    |     int256 internal constant ERFC_D = 96784180000000000; // 1e-2
    |     int256 internal constant ERFC_E = -186288060000000000; // 1e-1
    |     int256 internal constant ERFC_F = 278868070000000000; // 1e-1
    |     int256 internal constant ERFC_G = -1_135203980000000000;
    |     int256 internal constant ERFC_H = 1_488515870000000000;
    |     int256 internal constant ERFC_I = -822152230000000000; // 1e-1
    |     int256 internal constant ERFC_J = 170872770000000000; // 1e-1
    |     int256 internal constant IERFC_A = -707110000000000000; // 1e-1
    |     int256 internal constant IERFC_B = 2_307530000000000000;
    |     int256 internal constant IERFC_C = 270610000000000000; // 1e-1
    |     int256 internal constant IERFC_D = 992290000000000000; // 1e-1
    |     int256 internal constant IERFC_E = 44810000000000000; // 1e-2
    |     int256 internal constant IERFC_F = 1_128379167095512570;
    | 
    |     /**
    |      * @notice Approximation of the Complimentary Error Function.
    |      * Related to the Error Function: `erfc(x) = 1 - erf(x)`.
    |      * Both cumulative distribution and error functions are integrals
    |      * which cannot be expressed in elementary terms. They are called special functions.
    |      * The error and complimentary error functions have numerical approximations
    |      * which is what is used in this library to compute the cumulative distribution function.
    |      *
    |      * @dev This is a special function with its own identities.
    |      * Identity: `erfc(-x) = 2 - erfc(x)`.
    |      * Special Values:
    |      * erfc(-infinity)	=	2
    |      * erfc(0)      	=	1
    |      * erfc(infinity)	=	0
    |      *
    |      * @custom:epsilon Fractional error less than 1.2e-7.
    |      * @custom:source Numerical Recipes in C 2e p221.
    |      * @custom:source https://mathworld.wolfram.com/Erfc.html.
    |      */
    |     function erfc(int256 input) internal pure returns (int256 output) {
    |         uint256 z = abs(input);
    |         int256 t;
    |         int256 step;
    |         int256 k;
    |         assembly {
    |             let quo := sdiv(mul(z, ONE), TWO) // 1 / (1 + z / 2).
    |             let den := add(ONE, quo)
    |             t := sdiv(SCALAR_SQRD, den)
    | 
    |             function muli(pxn, pxd) -> res {
    |                 res := sdiv(mul(pxn, pxd), ONE)
    |             }
    | 
    |             {
    |                 step := add(
    |                     ERFC_F,
    |                     muli(
    |                         t,
    |                         add(
    |                             ERFC_G,
    |                             muli(
    |                                 t,
    |                                 add(
    |                                     ERFC_H,
    |                                     muli(t, add(ERFC_I, muli(t, ERFC_J)))
    |                                 )
    |                             )
    |                         )
    |                     )
    |                 )
    |             }
    |             {
    |                 step := muli(
    |                     t,
    |                     add(
    |                         ERFC_B,
    |                         muli(
    |                             t,
    |                             add(
    |                                 ERFC_C,
    |                                 muli(
    |                                     t,
    |                                     add(
    |                                         ERFC_D,
    |                                         muli(t, add(ERFC_E, muli(t, step)))
    |                                     )
    |                                 )
    |                             )
    |                         )
    |                     )
    |                 )
    |             }
    | 
    |             k := add(sub(mul(SIGN, muli(z, z)), ERFC_A), step)
    |         }
    | 
    |         int256 expWad = FixedPointMathLib.expWad(k);
    |         int256 r;
    |         assembly {
    |             r := sdiv(mul(t, expWad), ONE)
    |             switch iszero(slt(input, 0))
    |             case 0 {
    |                 output := sub(TWO, r)
    |             }
    |             case 1 {
    |                 output := r
    |             }
    |         }
    |     }
    | 
    |     /**
    |      * @notice Approximation of the Inverse Complimentary Error Function - erfc^(-1).
    |      *
    |      * @dev Equal to `ierfc(erfc(x)) = erfc(ierfc(x))` for 0 < x < 2.
    |      * Related to the Inverse Error Function: `ierfc(1 - x) = ierf(x)`.
    |      * This is a special function with its own identities.
    |      * Domain:      0 < x < 2
    |      * Special values:
    |      * ierfc(0)	=	infinity
    |      * ierfc(1)	=	0
    |      * ierfc(2)	=	-infinity
    |      *
    |      * @custom:source Numerical Recipes 3e p265.
    |      * @custom:source https://mathworld.wolfram.com/InverseErfc.html.
    |      */
    |     function ierfc(int256 x) internal pure returns (int256 z) {
    |         assembly {
    |             // x >= 2, iszero(x < 2 ? 1 : 0) ? 1 : 0.
    |             if iszero(slt(x, TWO)) {
    |                 z := mul(add(not(100), 1), SCALAR)
    |             }
    | 
    |             // x <= 0.
    |             if iszero(sgt(x, 0)) {
    |                 z := mul(100, SCALAR)
    |             }
    |         }
    | 
    |         if (z != 0) return z;
    | 
    |         int256 xx; // (x < ONE) ? x : TWO - x.
    |         assembly {
    |             switch iszero(slt(x, ONE))
    |             case 0 {
    |                 xx := x
    |             }
    |             case 1 {
    |                 xx := sub(TWO, x)
    |             }
    |         }
    | 
    |         int256 logInput = diviWad(xx, TWO);
    |         if (logInput == 0) revert Infinity();
    |         int256 ln = FixedPointMathLib.lnWad(logInput);
    |         uint256 t = uint256(muliWad(NEGATIVE_TWO, ln)).sqrt();
    |         assembly {
    |             t := mul(t, HALF_SCALAR)
    |         }
    | 
    |         int256 r;
    |         assembly {
    |             function muli(pxn, pxd) -> res {
    |                 res := sdiv(mul(pxn, pxd), ONE)
    |             }
    | 
    |             r := muli(
    |                 IERFC_A,
    |                 sub(
    |                     sdiv(
    |                         mul(add(IERFC_B, muli(t, IERFC_C)), ONE),
    |                         add(ONE, muli(t, add(IERFC_D, muli(t, IERFC_E))))
    |                     ),
    |                     t
    |                 )
    |             )
    |         }
    | 
    |         uint256 itr;
    |         while (itr < 2) {
    |             int256 err = erfc(r);
    |             assembly {
    |                 err := sub(err, xx)
    |             }
    | 
    |             int256 input;
    |             assembly {
    |                 input := add(not(sdiv(mul(r, r), ONE)), 1) // -(r * r).
    |             }
    | 
    |             int256 expWad = input.expWad();
    | 
    |             assembly {
    |                 function muli(pxn, pxd) -> res {
    |                     res := sdiv(mul(pxn, pxd), ONE)
    |                 }
    | 
    |                 r := add(
    |                     r,
    |                     sdiv(
    |                         mul(err, ONE),
    |                         sub(muli(IERFC_F, expWad), muli(r, err))
    |                     )
    |                 )
    | 
    |                 itr := add(itr, 1)
    |             }
    |         }
    | 
    |         assembly {
    |             switch iszero(slt(x, ONE)) // x < ONE ? r : -r.
    |             case 0 {
    |                 z := r
    |             }
    |             case 1 {
    |                 z := add(not(r), 1)
    |             }
    |         }
    |     }
    | 
    |     /**
    |      * @notice Approximation of the Cumulative Distribution Function.
    |      *
    |      * @dev Equal to `D(x) = 0.5[ 1 + erf((x - µ) / σ√2)]`.
    |      * Only computes cdf of a distribution with µ = 0 and σ = 1.
    |      *
    |      * @custom:error Maximum error of 1.2e-7.
    |      * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.
    |      */
    |     function cdf(int256 x) internal pure returns (int256 z) {
    |         int256 negated;
    |         assembly {
    |             let res := sdiv(mul(x, ONE), SQRT2)
    |             negated := add(not(res), 1)
    |         }
    | 
    |         int256 _erfc = erfc(negated);
    |         assembly {
    |             z := sdiv(mul(ONE, _erfc), TWO)
    |         }
    |     }
    | 
    |     /**
    |      * @notice Approximation of the Probability Density Function.
    |      *
    |      * @dev Equal to `Z(x) = (1 / σ√2π)e^( (-(x - µ)^2) / 2σ^2 )`.
    |      * Only computes pdf of a distribution with µ = 0 and σ = 1.
    |      *
    |      * @custom:error Maximum error of 1.2e-7.
    |      * @custom:source https://mathworld.wolfram.com/ProbabilityDensityFunction.html.
    |      */
    |     function pdf(int256 x) internal pure returns (int256 z) {
    |         int256 e;
    |         assembly {
    |             e := sdiv(mul(add(not(x), 1), x), TWO) // (-x * x) / 2.
    |         }
    |         e = FixedPointMathLib.expWad(e);
    | 
    |         assembly {
    |             z := sdiv(mul(e, ONE), SQRT_2PI)
    |         }
    |     }
    | 
    |     /**
    |      * @notice Approximation of the Percent Point Function.
    |      *
    |      * @dev Equal to `D(x)^(-1) = µ - σ√2(ierfc(2x))`.
    |      * Only computes ppf of a distribution with µ = 0 and σ = 1.
    |      *
    |      * @custom:error Maximum error of 1.2e-7.
    |      * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.
    |      */
    |     function ppf(int256 x) internal pure returns (int256 z) {
    |         if (x == int256(HALF_WAD)) return int256(0); // returns 3.75e-8, but we know it's zero.
    |         if (x >= ONE) revert Infinity();
    |         if (x == 0) revert NegativeInfinity();
    |         assembly {
    |             x := mul(x, 2)
    |         }
    | 
    |         int256 _ierfc = ierfc(x);
    | 
    |         assembly {
    |             let res := sdiv(mul(SQRT2, _ierfc), ONE)
    |             z := add(not(res), 1) // -res.
    |         }
    |     }
    | }
    | 

/root/code/hyper/lib/solstat/src/Invariant.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity ^0.8.4;
    | 
    | import "./Gaussian.sol";
    | 
    | /**
    |  * @title Invariant of Primitive RMM.
    |  * @author @alexangelj
    |  * @notice Invariant is `k` with the trading function `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.
    |  *
    |  * @dev Terms which can potentially be ambiguous are given discrete names.
    |  * This makes it easier to search for terms and update terms.
    |  * Variables can sometimes not be trusted to be or act like their names.
    |  * This naming scheme avoids this problem using a glossary to define them.
    |  *
    |  * // -------------------- Glossary --------------------- //
    |  *
    |  * `R_x` - Amount of asset token reserves per single unit of liquidity.
    |  * `R_y` - Amount of quote token reserves per single unit of liquidity.
    |  * `stk` - Strike price of the pool. The terminal price of each asset token.
    |  * `vol` - Implied volatility of the pool. Higher vol = higher price impact on swaps.
    |  * `tau` - Time until the pool expires. Amount of seconds until the pool's curve becomes flat around `stk`.
    |  * `inv` - Invariant of the pool. Difference between theoretical $ value and actual $ value per liquidity.
    |  *
    |  * `WAD` - Signed or unsigned fixed point number with up to 18 decimals and up to 256 total bits wide.
    |  * `YEAR`- Equal to the amount of seconds in a year. Used in `invariant` function.
    |  *
    |  * // -------------------- Units ------------------------ //
    |  *
    |  * `R_x` - Units are unsigned WAD. Represents value of tokens, decimals matter.
    |  * `R_y` - Units are unsigned WAD. Represents value of tokens, decimals matter.
    |  * `stk` - Units are unsigned WAD. Represents value of tokens, decimals matter.
    |  * `vol` - Units are unsigned WAD. Represents a percentage in which 100% = WAD.
    |  * `tau` - Units are YEAR. Represents a time unit which `1.0` is equal to YEAR.
    |  * `inv` - Units are signed WAD. Initial value of zero and decreases over time.
    |  *
    |  * // -------------------- Denoted By ----------------- //
    |  *
    |  * `R_x` - Denoted by `x`.
    |  * `R_y` - Denoted by `y`.
    |  * `stk` - Denoted by `K`.
    |  * `vol` - Denoted by `σ`.
    |  * `tau` - Denoted by `τ`.
    |  * `inv` - Denoted by `k`.
    |  *
    |  * // -------------------- Error Bounds ----------------- //
    |  *
    |  * `inv` - Up to 1e-9.
    |  *
    |  * // ------------------------ ~ ------------------------ //
    |  */
    | library Invariant {
    |     using Gaussian for int256; // Uses the `cdf` and `pdf` functions.
    |     using FixedPointMathLib for uint256; // Uses the `sqrt` function.
    | 
*r  |     uint256 internal constant WAD = 1 ether;
    |     uint256 internal constant DOUBLE_WAD = 2 ether;
    |     int256 internal constant ONE = 1 ether;
    |     int256 internal constant YEAR = 31556952;
    |     int256 internal constant HALF_SCALAR = 1e9;
    | 
    |     /**
    |      * @dev Reverts when an input value is out of bounds of its acceptable range.
    |      */
    |     error OOB();
    | 
    |     /**
    |      * @notice Uses reserves `R_x` to compute reserves `R_y`.
    |      *
    |      * @dev Computes `y` in `y = KΦ(Φ⁻¹(1-x) - σ√τ) + k`.
    |      * Primary function use to compute the invariant.
    |      * Simplifies to `K(1 -x) + k` when time to expiry is zero.
    |      * Reverts if `R_x` is greater than one. Units are a fixed point number with 18 decimals.
    |      *
    |      * We handle some special cases, try this:
    |      * `normalcdlower(normalicdlower(1) - 0.1)` in https://keisan.casio.com/calculator
    |      * Gaussian.sol reverts for `ppf(1)` and `ppf(0)`, so we handle those cases.
    |      *
    |      * @param R_x Quantity of token reserve `x` within the bounds of [0, 1].
    |      * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.
    |      * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.
    |      * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.
    |      * @param inv Current invariant given the actual `R_x`. Zero if computing invariant itself.
    |      * @return R_y Quantity of token reserve `y` within the bounds of [0, stk].
    |      *
    |      * @custom:error Technically, none. This is the source of truth for the trading function.
    |      * @custom:source https://primitive.xyz/whitepaper
    |      */
*r  |     function getY(
    |         uint256 R_x,
    |         uint256 stk,
    |         uint256 vol,
    |         uint256 tau,
    |         int256 inv
*r  |     ) internal pure returns (uint256 R_y) {
*r  |         if (R_x > WAD) revert OOB(); // Negative input for `ppf` is invalid.
*r  |         if (R_x == WAD) return uint256(int256(stk) + inv); // For `ppf(0)` case, because 1 - R_x == 0, and `y = K * 1 + k` simplifies to `y = K + k`
*r  |         if (R_x == 0) return uint256(inv); // For `ppf(1)` case, because 1 - 0 == 1, and `y = K * 0 + k` simplifies to `y = k`.
    |         if (tau != 0) {
    |             // Short circuits because tau != 0 is more likely.
    |             uint256 sec;
    |             assembly {
    |                 sec := sdiv(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.
    |             }
    | 
    |             uint256 sdr = sec.sqrt(); // √τ.
    |             assembly {
    |                 sdr := mul(sdr, HALF_SCALAR) // Unit math: sdr * HALF_SCALAR = SCALAR.
    |                 sdr := sdiv(mul(vol, sdr), ONE) // σ√τ.
    |             }
    | 
    |             int256 phi;
    |             assembly {
    |                 phi := sub(ONE, R_x)
    |             }
    |             phi = phi.ppf(); // Φ⁻¹(1-x).
    | 
    |             int256 cdf;
    |             assembly {
    |                 cdf := sub(phi, sdr) // Φ⁻¹(1-x) - σ√τ.
    |             }
    |             cdf = cdf.cdf(); // Φ(Φ⁻¹(1-x) - σ√τ).
    | 
    |             assembly {
    |                 R_y := add(sdiv(mul(stk, cdf), ONE), inv)
    |             }
    |         } else {
    |             assembly {
    |                 R_y := add(sdiv(mul(stk, sub(ONE, R_x)), ONE), inv)
    |             }
    |         }
    |     }
    | 
    |     /**
    |      * @notice Uses reserves `R_y` to compute reserves `R_x`.
    |      *
    |      * @dev Computes `x` in `x = 1 - Φ(Φ⁻¹( (y + k) / K ) + σ√τ)`.
    |      * Not used in invariant function. Used for computing swap outputs.
    |      * Simplifies to `1 - ( (y + k) / K )` when time to expiry is zero.
    |      * Reverts if `R_y` is greater than one. Units are WAD.
    |      *
    |      * Dangerous! There are important bounds to using this function.
    |      *
    |      * @param R_y Quantity of token reserve `y` within the bounds of [0, stk].
    |      * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.
    |      * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.
    |      * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.
    |      * @param inv Current invariant given the actual reserves `R_y`.
    |      * @return R_x Quantity of token reserve `x` within the bounds of [0, 1].
    |      *
    |      * @custom:error Up to 1e-6. This an **approximated** "inverse" of the `getY` function.
    |      * @custom:source https://primitive.xyz/whitepaper
    |      */
    |     function getX(
    |         uint256 R_y,
    |         uint256 stk,
    |         uint256 vol,
    |         uint256 tau,
    |         int256 inv
    |     ) internal pure returns (uint256 R_x) {
    |         // Short circuits because tau != 0 is more likely.
    |         if (tau != 0) {
    |             uint256 sec;
    |             assembly {
    |                 sec := div(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.
    |             }
    | 
    |             uint256 sdr = sec.sqrt(); // √τ.
    |             assembly {
    |                 sdr := mul(sdr, HALF_SCALAR) // Unit math: HALF_SCALAR * HALF_SCALAR = SCALAR.
    |                 sdr := div(mul(vol, sdr), ONE) // σ√τ.
    |             }
    | 
    |             int256 phi;
    |             assembly {
    |                 phi := sdiv(mul(add(R_y, inv), ONE), stk) // (y + k) / K.
    |             }
    | 
    |             if (phi < 0) revert OOB(); // Negative input for `ppf` is invalid.
    |             if (phi > ONE) revert OOB();
    |             if (phi == ONE) return 0; // `x = 1 - Φ(Φ⁻¹( 1 ) + σ√τ)` simplifies to  `x = 0`.
    |             if (phi == 0) return WAD; // `x = 1 - Φ(Φ⁻¹( 0 ) + σ√τ)` simplifies to `x = 1`.
    | 
    |             phi = phi.ppf(); // Φ⁻¹( (y + k) / K ).
    | 
    |             int256 cdf;
    |             assembly {
    |                 cdf := add(phi, sdr) // Φ⁻¹( (y + k) / K ) + σ√τ.
    |             }
    |             cdf = cdf.cdf(); // Φ(Φ⁻¹( (y + k) / K ) + σ√τ).
    | 
    |             assembly {
    |                 R_x := sub(ONE, cdf)
    |             }
    |         } else {
    |             assembly {
    |                 R_x := sub(ONE, sdiv(mul(add(R_y, inv), ONE), stk))
    |             }
    |         }
    |     }
    | 
    |     /**
    |      * @notice Computes the invariant of the RMM trading function.
    |      *
    |      * @dev Computes `k` in `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.
    |      * Used to validate swaps, the most critical function.
    |      *
    |      * @custom:source https://rmm.eth.xyz
    |      */
    |     function invariant(
    |         uint256 R_y,
    |         uint256 R_x,
    |         uint256 stk,
    |         uint256 vol,
    |         uint256 tau
    |     ) internal pure returns (int256 inv) {
    |         uint256 y = getY(R_x, stk, vol, tau, inv); // `inv` is 0 because we are solving `inv`, aka `k`.
    |         assembly {
    |             inv := sub(R_y, y)
    |         }
    |     }
    | }
    | 

/root/code/hyper/lib/solstat/src/Units.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.13;
    | 
    | error Min();
*r  | 
    | function abs(int256 input) pure returns (uint256 output) {
    |     if (input == type(int256).min) revert Min();
*r  |     if (input < 0) {
    |         assembly {
    |             output := add(not(input), 1)
    |         }
    |     } else {
    |         assembly {
    |             output := input
    |         }
    |     }
    | }
    | 
    | /// @dev From solmate@v7, changes last `div` to `sdiv`.
    | function muli(
    |     int256 x,
    |     int256 y,
    |     int256 denominator
    | ) pure returns (int256 z) {
    |     assembly {
    |         // Store x * y in z for now.
    |         z := mul(x, y)
    | 
    |         // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
    |         if iszero(
    |             and(iszero(iszero(denominator)), or(iszero(x), eq(sdiv(z, x), y)))
    |         ) {
    |             revert(0, 0)
    |         }
    | 
    |         // Divide z by the denominator.
    |         z := sdiv(z, denominator)
    |     }
    | }
    | 
    | function muliWad(int256 x, int256 y) pure returns (int256 z) {
    |     z = muli(x, y, 1 ether);
    | }
    | 
    | function diviWad(int256 x, int256 y) pure returns (int256 z) {
    |     z = muli(x, 1 ether, y);
    | }
    | 

/root/code/hyper/test/E2E/InvariantAllocateUnallocate.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/InvariantTargetContract.sol";
    | 
    | contract InvariantAllocateUnallocate is InvariantTargetContract {
    |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
    | 
    |     function allocate(uint deltaLiquidity, uint index) public {
    |         deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);
    | 
    |         // Allocate to a random pool.
    |         // VERY IMPORTANT
    |         setPoolId(ctx.getRandomPoolId(index));
    | 
    |         _assertAllocate(deltaLiquidity);
    |     }
    | 
    |     // avoid stack too deep
    |     uint expectedDeltaAsset;
    |     uint expectedDeltaQuote;
    |     bool transferAssetIn;
    |     bool transferQuoteIn;
    |     int assetCredit;
    |     int quoteCredit;
    |     uint deltaAsset;
    |     uint deltaQuote;
    |     uint userAssetBalance;
    |     uint userQuoteBalance;
    |     uint physicalAssetPayment;
    |     uint physicalQuotePayment;
    | 
    |     HyperState prev;
    |     HyperState post;
    | 
    |     function _assertAllocate(uint deltaLiquidity) internal {
    |         // TODO: cleanup reset of these
    |         transferAssetIn = true;
    |         transferQuoteIn = true;
    | 
    |         // Preconditions
    |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
    |         assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
    |         assertTrue(pool.lastPrice != 0, "Pool not created with a price");
    | 
    |         // Amounts of tokens that will be allocated to pool.
    |         (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(
    |             __poolId__,
    |             int128(uint128(deltaLiquidity))
    |         );
    | 
    |         // If net balance > 0, there are tokens in the contract which are not in a pool or balance.
    |         // They will be credited to the msg.sender of the next call.
    |         assetCredit = __hyper__.getNetBalance(address(__asset__));
    |         quoteCredit = __hyper__.getNetBalance(address(__quote__));
    | 
    |         // Net balances should always be positive outside of execution.
    |         assertTrue(assetCredit >= 0, "negative-net-asset-tokens");
    |         assertTrue(quoteCredit >= 0, "negative-net-quote-tokens");
    | 
    |         // Internal balance of tokens spendable by user.
    |         userAssetBalance = getBalance(address(__hyper__), address(this), address(__asset__));
    |         userQuoteBalance = getBalance(address(__hyper__), address(this), address(__quote__));
    | 
    |         // If there is a net balance, user can use it to pay their cost.
    |         // Total payment the user must make.
    |         physicalAssetPayment = uint(assetCredit) > expectedDeltaAsset ? 0 : expectedDeltaAsset - uint(assetCredit);
    |         physicalQuotePayment = uint(quoteCredit) > expectedDeltaQuote ? 0 : expectedDeltaQuote - uint(quoteCredit);
    | 
    |         physicalAssetPayment = uint(userAssetBalance) > physicalAssetPayment
    |             ? 0
    |             : physicalAssetPayment - uint(userAssetBalance);
    |         physicalQuotePayment = uint(userQuoteBalance) > physicalQuotePayment
    |             ? 0
    |             : physicalQuotePayment - uint(userQuoteBalance);
    | 
    |         // If user can pay for the allocate using their internal balance of tokens, don't need to transfer tokens in.
    |         // Won't need to transfer in tokens if user payment is zero.
    |         if (physicalAssetPayment == 0) transferAssetIn = false;
    |         if (physicalQuotePayment == 0) transferQuoteIn = false;
    | 
    |         // If the user has to pay externally, give them tokens.
    |         if (transferAssetIn) __asset__.mint(address(this), physicalAssetPayment);
    |         if (transferQuoteIn) __quote__.mint(address(this), physicalQuotePayment);
    | 
    |         // Execution
    |         prev = getState();
    |         (deltaAsset, deltaQuote) = __hyper__.allocate(__poolId__, deltaLiquidity);
    |         post = getState();
    | 
    |         // Postconditions
    | 
    |         assertEq(deltaAsset, expectedDeltaAsset, "pool-delta-asset");
    |         assertEq(deltaQuote, expectedDeltaQuote, "pool-delta-quote");
    |         assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, "pool-total-liquidity");
    |         assertTrue(post.totalPoolLiquidity > prev.totalPoolLiquidity, "pool-liquidity-increases");
    |         assertEq(
    |             post.callerPositionLiquidity,
    |             prev.callerPositionLiquidity + deltaLiquidity,
    |             "position-liquidity-increases"
    |         );
    | 
    |         assertEq(post.reserveAsset, prev.reserveAsset + physicalAssetPayment + uint(assetCredit), "reserve-asset");
    |         assertEq(post.reserveQuote, prev.reserveQuote + physicalQuotePayment + uint(quoteCredit), "reserve-quote");
    |         assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + physicalAssetPayment, "physical-asset");
    |         assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + physicalQuotePayment, "physical-quote");
    | 
    |         uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;
    |         uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;
    |         assertTrue(feeDelta0 == feeDelta1, "asset-growth");
    | 
    |         uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;
    |         uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;
    |         assertTrue(feeDelta2 == feeDelta3, "quote-growth");
    | 
    |         emit FinishedCall("Allocate");
    | 
    |         checkVirtualInvariant();
    |     }
    | 
    |     event FinishedCall(string);
    | 
    |     function unallocate(uint deltaLiquidity, uint index) external {
    |         deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);
    | 
    |         // Unallocate from a random pool.
    |         // VERY IMPORTANT
    |         setPoolId(ctx.getRandomPoolId(index));
    | 
    |         _assertUnallocate(deltaLiquidity);
    |     }
    | 
    |     function _assertUnallocate(uint deltaLiquidity) internal {
    |         // TODO: Add use max flag support.
    | 
    |         // Get some liquidity.
    |         HyperPosition memory pos = getPosition(address(__hyper__), address(this), __poolId__);
    |         require(pos.freeLiquidity >= deltaLiquidity, "Not enough liquidity");
    | 
    |         if (pos.freeLiquidity >= deltaLiquidity) {
    |             // Preconditions
    |             HyperPool memory pool = getPool(address(__hyper__), __poolId__);
    |             assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
    |             assertTrue(pool.lastPrice != 0, "Pool not created with a price");
    | 
    |             // Unallocate
    |             uint timestamp = block.timestamp + 4; // todo: fix default jit policy
    |             vm.warp(timestamp);
    |             __hyper__.setTimestamp(uint128(timestamp));
    | 
    |             (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(
    |                 __poolId__,
    |                 -int128(uint128(deltaLiquidity))
    |             );
    |             prev = getState();
    |             (uint unallocatedAsset, uint unallocatedQuote) = __hyper__.unallocate(__poolId__, deltaLiquidity);
    |             HyperState memory end = getState();
    | 
    |             assertEq(unallocatedAsset, expectedDeltaAsset, "asset-delta");
    |             assertEq(unallocatedQuote, expectedDeltaQuote, "quote-delta");
    |             assertEq(end.reserveAsset, prev.reserveAsset - unallocatedAsset, "reserve-asset");
    |             assertEq(end.reserveQuote, prev.reserveQuote - unallocatedQuote, "reserve-quote");
    |             assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity - deltaLiquidity, "total-liquidity");
    |             assertTrue(prev.totalPositionLiquidity >= deltaLiquidity, "total-pos-liq-underflow");
    |             assertTrue(prev.callerPositionLiquidity >= deltaLiquidity, "caller-pos-liq-underflow");
    |             assertEq(
    |                 end.totalPositionLiquidity,
    |                 prev.totalPositionLiquidity - deltaLiquidity,
    |                 "total-position-liquidity"
    |             );
    |             assertEq(
    |                 end.callerPositionLiquidity,
    |                 prev.callerPositionLiquidity - deltaLiquidity,
    |                 "caller-position-liquidity"
    |             );
    |         }
    |         emit FinishedCall("Unallocate");
    | 
    |         checkVirtualInvariant();
    |     }
    | 
    |     function checkVirtualInvariant() internal {
    |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
    |         // TODO: Breaks when we call this function on a pool with zero liquidity...
    |         (uint dAsset, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);
    |         emit log("dAsset", dAsset);
    |         emit log("dQuote", dQuote);
    | 
    |         uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));
    |         uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));
    | 
    |         emit log("bAsset", bAsset);
    |         emit log("bQuote", bQuote);
    | 
    |         int diffAsset = int(bAsset) - int(dAsset);
    |         int diffQuote = int(bQuote) - int(dQuote);
    |         emit log("diffAsset", diffAsset);
    |         emit log("diffQuote", diffQuote);
    | 
    |         assertTrue(bAsset >= dAsset, "invariant-virtual-reserves-asset");
    |         assertTrue(bQuote >= dQuote, "invariant-virtual-reserves-quote");
    | 
    |         emit FinishedCall("Check Virtual Invariant");
    |     }
    | 
    |     event log(string, uint);
    |     event log(string, int);
    | }
    | 

/root/code/hyper/test/E2E/InvariantCreatePool.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "contracts/HyperLib.sol" as HyperTypes;
    | import "contracts/Enigma.sol" as Enigma;
    | import "./setup/InvariantTargetContract.sol";
    | 
    | contract InvariantCreatePool is InvariantTargetContract {
    |     Forwarder forwarder;
    | 
    |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {
    |         forwarder = new Forwarder();
    |     }
    | 
    |     function create_pool(
    |         uint index,
    |         uint128 price,
    |         uint128 strike,
    |         uint24 sigma,
    |         uint32 maturity,
    |         uint32 gamma,
    |         uint32 priorityGamma
    |     ) external {
    |         vm.assume(strike != 0);
    |         vm.assume(sigma != 0);
    | 
    |         maturity = uint32(block.timestamp + bound(maturity, 1, 365 days));
    |         price = uint128(bound(price, 1, 1e36));
    |         gamma = uint32(bound(sigma, 1e4 - HyperTypes.MAX_FEE, 1e4 - HyperTypes.MIN_FEE));
    |         priorityGamma = uint32(bound(sigma, gamma, 1e4 - HyperTypes.MIN_FEE));
    | 
    |         // Random user
    |         address caller = ctx.getRandomUser(index);
    |         address[] memory tokens = new address[](3);
    |         tokens[0] = address(ctx.__asset__());
    |         tokens[1] = address(ctx.__quote__());
    |         //tokens[0] = address(ctx.__weth__());
    | 
    |         address[] memory shuffled = shuffle(index, tokens);
    |         address token0 = shuffled[0];
    |         address token1 = shuffled[1];
    |         assertTrue(token0 != token1, "same-token");
    | 
    |         CreateArgs memory args = CreateArgs(
    |             caller,
    |             token0,
    |             token1,
    |             price,
    |             strike,
    |             sigma,
    |             maturity,
    |             gamma,
    |             priorityGamma
    |         );
    |         _assertCreatePool(args);
    |     }
    | 
    |     function shuffle(uint random, address[] memory array) internal view returns (address[] memory output) {
    |         for (uint256 i = 0; i < array.length; i++) {
    |             uint256 n = i + (random % (array.length - i));
    |             address temp = array[n];
    |             array[n] = array[i];
    |             array[i] = temp;
    |         }
    | 
    |         output = array;
    |     }
    | 
    |     struct CreateArgs {
    |         address caller;
    |         address token0;
    |         address token1;
    |         uint128 price;
    |         uint128 strike;
    |         uint24 sigma;
    |         uint32 maturity;
    |         uint32 gamma;
    |         uint32 priorityGamma;
    |     }
    | 
    |     bytes[] instructions;
    | 
    |     function _assertCreatePool(CreateArgs memory args) internal {
    |         bool isMutable = true;
    |         uint24 pairId = __hyper__.getPairId(args.token0, args.token1);
    |         {
    |             // HyperPair not created? Push a create pair call to the stack.
    |             if (pairId == 0) instructions.push(Enigma.encodeCreatePair(args.token0, args.token1));
    | 
    |             // Push create pool to stack
    |             instructions.push(
    |                 Enigma.encodeCreatePool(
    |                     pairId,
    |                     address(this),
    |                     1, // priorityFee
    |                     1, // fee
    |                     1, // vol
    |                     1, // dur
    |                     5,
    |                     int24(20_000),
    |                     args.price
    |                 )
    |             ); // temp
    |         }
    |         bytes memory payload = Enigma.encodeJumpInstruction(instructions);
    |         vm.prank(args.caller);
    |         console.logBytes(payload);
    |         (bool success, bytes memory reason) = address(__hyper__).call(payload);
    |         assembly {
    |             log0(add(32, reason), mload(reason))
    |         }
    | 
    |         //bool success = forwarder.forward(address(__hyper__), payload); // TODO: Fallback function does not bubble up custom errors.
    |         assertTrue(success, "hyper-call-failed");
    | 
    |         // Refetch the poolId. Current poolId could be "magic" zero variable.
    |         pairId = __hyper__.getPairId(args.token0, args.token1);
    |         assertTrue(pairId != 0, "pair-not-created");
    | 
    |         // todo: make sure we create the last pool...
    |         uint64 poolId = Enigma.encodePoolId(pairId, isMutable, uint32(__hyper__.getPoolNonce()));
    | 
    |         // Add the created pool to the list of pools.
    |         assertTrue(getPool(address(__hyper__), poolId).lastPrice != 0, "pool-price-zero");
    |         ctx.addPoolId(poolId);
    | 
    |         // Reset instructions so we don't use some old payload data...
    |         delete instructions;
    |     }
    | }
    | 
    | interface DoJump {
    |     function doJumpProcess(bytes calldata data) external payable;
    | }
    | 
    | contract Forwarder {
    |     function forward(address hyper, bytes calldata data) external payable returns (bool) {
    |         try DoJump(hyper).doJumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {
    |             assembly {
    |                 revert(add(32, reason), mload(reason))
    |             }
    |         }
    |         return true;
    |     }
    | }
    | 

/root/code/hyper/test/E2E/InvariantDeposit.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/InvariantTargetContract.sol";
    | 
    | contract InvariantDeposit is InvariantTargetContract {
    |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
    | 
    |     function deposit(uint amount, uint index) external {
    |         amount = bound(amount, 1, 1e36);
    | 
    |         address target = ctx.getRandomUser(index);
    | 
    |         vm.deal(target, amount);
    | 
    |         address weth = __hyper__.WETH();
    | 
    |         uint preBal = getBalance(address(__hyper__), target, weth);
    |         uint preRes = getReserve(address(__hyper__), weth);
    |         vm.prank(target);
    |         __hyper__.deposit{value: amount}();
    |         uint postRes = getReserve(address(__hyper__), weth);
    |         uint postBal = getBalance(address(__hyper__), target, weth);
    | 
    |         assertEq(postRes, preRes + amount, "weth-reserve");
    |         assertEq(postBal, preBal + amount, "weth-balance");
    |         assertEq(address(__hyper__).balance, 0, "eth-balance");
    |         assertEq(getPhysicalBalance(address(__hyper__), weth), postRes, "weth-physical");
    |     }
    | }
    | 

/root/code/hyper/test/E2E/InvariantFundDraw.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/InvariantTargetContract.sol";
    | 
    | contract InvariantFundDraw is InvariantTargetContract {
    |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
    | 
    |     function fund_asset(uint amount, uint index) public {
    |         amount = bound(amount, 1, 1e36);
    | 
    |         address target = ctx.getRandomUser(index);
    | 
    |         // If net balance > 0, there are tokens in the contract which are not in a pool or balance.
    |         // They will be credited to the msg.sender of the next call.
    |         int netAssetBalance = __hyper__.getNetBalance(address(__asset__));
    |         int netQuoteBalance = __hyper__.getNetBalance(address(__quote__));
    |         assertTrue(netAssetBalance >= 0, "negative-net-asset-tokens");
    |         assertTrue(netQuoteBalance >= 0, "negative-net-quote-tokens");
    | 
    |         vm.prank(target);
    |         __asset__.approve(address(__hyper__), amount);
    |         deal(address(__asset__), target, amount);
    | 
    |         uint preRes = getReserve(address(__hyper__), address(__asset__));
    |         uint preBal = getBalance(address(__hyper__), target, address(__asset__));
    |         vm.prank(target);
    |         __hyper__.fund(address(__asset__), amount);
    |         uint postRes = getReserve(address(__hyper__), address(__asset__));
    |         uint postBal = getBalance(address(__hyper__), target, address(__asset__));
    | 
    |         assertEq(postBal, preBal + amount + uint(netAssetBalance), "fund-delta-asset-balance");
    |         assertEq(postRes, preRes + amount + uint(netQuoteBalance), "fund-delta-asset-reserve");
    |     }
    | 
    |     function fund_quote(uint amount, uint index) public {
    |         amount = bound(amount, 1, 1e36);
    | 
    |         address target = ctx.getRandomUser(index);
    | 
    |         vm.prank(target);
    |         __quote__.approve(address(__hyper__), amount);
    |         deal(address(__quote__), target, amount);
    | 
    |         uint preRes = getReserve(address(__hyper__), address(__quote__));
    |         uint preBal = getBalance(address(__hyper__), target, address(__quote__));
    |         vm.prank(target);
    |         __hyper__.fund(address(__quote__), amount);
    |         uint postRes = getReserve(address(__hyper__), address(__quote__));
    |         uint postBal = getBalance(address(__hyper__), target, address(__quote__));
    | 
    |         assertEq(postBal, preBal + amount, "fund-delta-quote-balance");
    |         assertEq(postRes, preRes + amount, "fund-delta-quote-reserve");
    |     }
    | }
    | 

/root/code/hyper/test/E2E/InvariantSendTokens.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/InvariantTargetContract.sol";
    | 
    | contract InvariantSendTokens is InvariantTargetContract {
    |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
    | 
    |     event SentTokens(address indexed token, uint amount);
    | 
    |     function sendAssetTokens(uint amount) external {
    |         amount = bound(amount, 1, 2 ** 127);
    |         transfer(__asset__, amount);
    |     }
    | 
    |     function sendQuoteTokens(uint amount) external {
    |         amount = bound(amount, 1, 2 ** 127);
    |         transfer(__quote__, amount);
    |     }
    | 
    |     function transfer(TestERC20 token, uint amount) internal {
    |         token.mint(address(__hyper__), amount);
    |         emit SentTokens(address(token), amount);
    |     }
    | }
    | 

/root/code/hyper/test/E2E/InvariantWarper.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/InvariantTargetContract.sol";
    | 
    | contract InvariantWarper is InvariantTargetContract {
    |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
    | 
    |     function warper(uint amount) external {
    |         ctx.customWarp(block.timestamp + bound(amount, 1, 365 days));
    |     }
    | 
    |     function warpAfterMaturity(uint amount) external {
    |         amount = bound(amount, 1 days, 700 days);
    |         uint tau = HyperTau(address(__hyper__)).computeCurrentTau(__poolId__);
    |         ctx.customWarp(block.timestamp + tau + amount);
    |     }
    | }
    | 
    | interface HyperTau {
    |     function computeCurrentTau(uint64 poolId) external view returns (uint);
    | }
    | 

/root/code/hyper/test/E2E/TestE2EInvariant.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestE2ESetup.sol";
    | import "./setup/TestInvariantSetup.sol";
    | 
    | import {InvariantAllocateUnallocate} from "./InvariantAllocateUnallocate.sol";
    | import {InvariantFundDraw} from "./InvariantFundDraw.sol";
    | import {InvariantDeposit} from "./InvariantDeposit.sol";
    | import {InvariantSendTokens} from "./InvariantSendTokens.sol";
    | import {InvariantWarper} from "./InvariantWarper.sol";
    | import {InvariantCreatePool} from "./InvariantCreatePool.sol";
    | 
    | bytes32 constant SLOT_LOCKED = bytes32(uint(5));
    | 
    | /**
    |  * @dev Most important test suite, verifies the critical invariants of Hyper.
    |  *
    |  * Invariant 1. balanceOf >= getReserve for all tokens.
    |  * Invariant 2. AccountSystem.settled == true.
    |  * Invariant 3. AccountSystem.prepared == false.
    |  * Invariant 4. (balanceOf(asset), balanceOf(quote)) >= hyper.getVirtualReserves, for all pools.
    |  * Invariant 5. ∑ hyper.positions(owner, poolId).freeLiquidity == hyper.pools(poolId).liquidity, for all pools.
    |  */
    | contract TestE2EInvariant is TestInvariantSetup, TestE2ESetup {
    |     InvariantAllocateUnallocate internal _allocateUnallocate;
    |     InvariantFundDraw internal _fundDraw;
    |     InvariantDeposit internal _deposit;
    |     InvariantSendTokens internal _sendTokens;
    |     InvariantWarper internal _warper;
    |     InvariantCreatePool internal _createPool;
    | 
    |     uint64[] public __poolIds__;
    | 
    |     function setUp() public override {
    |         super.setUp();
    | 
    |         (address hyper, address asset, address quote) = (address(__hyper__), address(__asset__), address(__quote__));
    | 
    |         _allocateUnallocate = new InvariantAllocateUnallocate(hyper, asset, quote);
    |         _fundDraw = new InvariantFundDraw(hyper, asset, quote);
    |         _deposit = new InvariantDeposit(hyper, asset, quote);
    |         _sendTokens = new InvariantSendTokens(hyper, asset, quote);
    |         _warper = new InvariantWarper(hyper, asset, quote);
    |         _createPool = new InvariantCreatePool(hyper, asset, quote);
    | 
    |         addTargetContract(address(_allocateUnallocate));
    |         addTargetContract(address(_fundDraw));
    |         addTargetContract(address(_deposit));
    |         addTargetContract(address(_sendTokens));
    |         addTargetContract(address(_warper));
    |         addTargetContract(address(_createPool));
    | 
    |         __users__.push(address(_allocateUnallocate));
    |         __users__.push(address(_fundDraw));
    |         __users__.push(address(_deposit));
    |         __users__.push(address(_sendTokens));
    |         __users__.push(address(_warper));
    |         __users__.push(address(_createPool));
    | 
    |         addPoolId(__poolId__);
    |     }
    | 
    |     function invariant_assert_pools_created() public {
    |         assertTrue(__poolIds__.length > 0);
    |     }
    | 
    |     function invariant_asset_balance_gte_reserves() public {
    |         (uint reserve, uint physical, ) = getBalances(address(__asset__));
    |         assertTrue(physical >= reserve, "invariant-asset-physical-balance");
    |     }
    | 
    |     function invariant_quote_balance_gte_reserves() public {
    |         (uint reserve, uint physical, ) = getBalances(address(__quote__));
    |         assertTrue(physical >= reserve, "invariant-quote-physical-balance");
    |     }
    | 
    |     function invariant_account_settled() public {
    |         (, bool settled) = __hyper__.__account__();
    |         assertTrue(settled, "invariant-settled");
    |     }
    | 
    |     function invariant_account_prepared() public {
    |         (bool prepared, ) = __hyper__.__account__();
    |         assertTrue(!prepared, "invariant-prepared");
    |     }
    | 
    |     function invariant_virtual_pool_asset_reserves() public {
    |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
    | 
    |         if (pool.liquidity > 0) {
    |             (uint dAsset, ) = __hyper__.getVirtualReserves(__poolId__);
    |             uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));
    |             assertTrue(bAsset >= dAsset, "invariant-virtual-reserves-asset");
    |         }
    |     }
    | 
    |     function invariant_virtual_pool_quote_reserves() public {
    |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
    | 
    |         if (pool.liquidity > 0) {
    |             (, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);
    |             uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));
    |             assertTrue(bQuote >= dQuote, "invariant-virtual-reserves-quote");
    |         }
    |     }
    | 
    |     function invariant_liquidity_sum() public {
    |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
    | 
    |         uint sum;
    |         for (uint i; i != __users__.length; ++i) {
    |             HyperPosition memory pos = getPosition(address(__hyper__), __users__[i], __poolId__);
    |             sum += pos.freeLiquidity;
    |         }
    | 
    |         assertTrue(sum == pool.liquidity, "invariant-liquidity-sum");
    |     }
    | 
    |     function invariant_reentrancy() public {
    |         bytes32 locked = vm.load(address(__hyper__), SLOT_LOCKED);
    |         assertEq(uint(locked), 1, "invariant-locked");
    | 
    |         uint balance = address(__hyper__).balance;
    |         assertEq(balance, 0, "invariant-ether");
    |     }
    | 
    |     function getBalances(address token) internal view returns (uint reserve, uint physical, uint balances) {
    |         reserve = getReserve(address(__hyper__), token);
    |         physical = getPhysicalBalance(address(__hyper__), token);
    |         balances = getBalanceSum(address(__hyper__), token, __users__);
    |     }
    | 
    |     function addPoolId(uint64 poolId) public {
    |         assertTrue(poolId != 0, "zero poolId");
    |         __poolIds__.push(poolId);
    |     }
    | 
    |     function getRandomUser(uint id) public returns (address) {
    |         assertTrue(__users__.length > 0);
    |         uint index = id % __users__.length;
    |         address user = __users__[index];
    |         return user;
    |     }
    | 
    |     function getRandomPoolId(uint id) public returns (uint64) {
    |         assertTrue(__poolIds__.length > 0);
    |         uint index = id % __poolIds__.length;
    |         uint64 poolId = __poolIds__[index];
    |         return poolId;
    |     }
    | }
    | 

/root/code/hyper/test/E2E/TestInvariantBasic.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "forge-std/Test.sol";
    | import "./setup/TestInvariantSetup.sol";
    | 
    | /** @dev Example invariant testing contract, for reference only. https://github.com/foundry-rs/foundry/pull/1572#discussion_r869737535 */
    | contract InvariantBreaker is Test {
    |     bool public flag0 = true;
    |     bool public flag1 = true;
    | 
    |     function set0(int val) public returns (bool) {
    |         if (val % 100 == 0) flag0 = false;
    |         return flag0;
    |     }
    | 
    |     function set1(int val) public returns (bool) {
    |         if (val % 10 == 0 && !flag0) flag1 = false;
    |         return flag1;
    |     }
    | }
    | 
    | /** @dev Example invariant test. Always fails! */
    | contract TestInvariantBasic is TestInvariantSetup, Test {
    |     InvariantBreaker inv;
    | 
    |     function setUp() public {
    |         inv = new InvariantBreaker();
    |         addTargetContract(address(inv));
    |     }
    | 
    |     function invariant_neverFalse() public view {
    |         // note: uncomment to test invariant testing
    |         // require(inv.flag1());
    |     }
    | }
    | 

/root/code/hyper/test/E2E/setup/InvariantTargetContract.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "forge-std/Test.sol";
    | import "test/helpers/HelperHyperView.sol";
    | import {HyperPool, HyperPosition, HyperTimeOverride, TestERC20} from "test/helpers/HyperTestOverrides.sol";
    | 
    | interface Context {
    |     function users() external view returns (address[] memory);
    | 
    |     function getRandomPoolId(uint id) external view returns (uint64);
    | 
    |     function setPoolId(uint64 poolId) external;
    | 
    |     function addPoolId(uint64 poolId) external;
    | 
    |     function customWarp(uint time) external;
    | 
    |     function getRandomUser(uint id) external view returns (address);
    | 
    |     function __weth__() external view returns (TestERC20);
    | 
    |     function __asset__() external view returns (TestERC20);
    | 
    |     function __quote__() external view returns (TestERC20);
    | }
    | 
    | /** @dev Target contract must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */
    | contract InvariantTargetContract is HelperHyperView, Test {
    |     Context ctx;
    | 
    |     uint64 public __poolId__ = 0x0000010000000001;
    |     HyperTimeOverride public __hyper__; // Actual contract
    |     TestERC20 public __quote__;
    |     TestERC20 public __asset__;
    | 
    |     constructor(address hyper_, address asset_, address quote_) {
    |         ctx = Context(msg.sender);
    |         __hyper__ = HyperTimeOverride(payable(hyper_));
    |         __asset__ = TestERC20(asset_);
    |         __quote__ = TestERC20(quote_);
    | 
    |         __asset__.approve(hyper_, type(uint).max);
    |         __quote__.approve(hyper_, type(uint).max);
    |     }
    | 
    |     /** @dev Uses the initialized context for the getState function. */
    |     function getState() internal view returns (HyperState memory) {
    |         return getState(address(__hyper__), __poolId__, address(this), ctx.users());
    |     }
    | 
    |     function setPoolId(uint64 poolId) internal {
    |         ctx.setPoolId(poolId); // TODO: duplicating for now...
    | 
    |         HyperPair memory pair = getPair(address(__hyper__), Processor.decodePairIdFromPoolId(poolId));
    |         __asset__ = TestERC20(pair.tokenAsset);
    |         __quote__ = TestERC20(pair.tokenQuote);
    |     }
    | }
    | 

/root/code/hyper/test/E2E/setup/TestE2ESetup.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "solmate/tokens/WETH.sol";
    | import "contracts/HyperLib.sol";
    | import "contracts/libraries/Price.sol";
    | 
    | import "forge-std/Test.sol";
    | import {TestERC20, HyperTimeOverride, FixedPointMathLib} from "test/helpers/HyperTestOverrides.sol";
    | 
    | import "test/helpers/HelperHyperActions.sol";
    | import "test/helpers/HelperHyperInvariants.sol";
    | import "test/helpers/HelperHyperProfiles.sol";
    | import "test/helpers/HelperHyperView.sol";
    | 
    | uint constant STARTING_BALANCE = 0;
    | 
    | contract Helpers is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView {}
    | 
    | /** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */
    | contract TestE2ESetup is Helpers, Test {
    |     using FixedPointMathLib for uint256;
    |     using FixedPointMathLib for int256;
    | 
    |     // ===== Global Variables ===== //
    |     uint64 public __poolId__ = 0x0000010000000001;
    |     address[] public __users__;
    | 
    |     WETH public __weth__;
    |     TestERC20 public __quote__;
    |     TestERC20 public __asset__;
    |     HyperTimeOverride public __hyper__; // Actual contract
    | 
    |     // ===== Set up ===== //
    | 
    |     function setUp() public virtual {
    |         initContracts();
    |         initUsers();
    |         initScenarios();
    |         initPrerequisites();
    |         afterSetUp();
    |     }
    | 
    |     /** @dev Requires tokens to be spent and spenders to be approved. */
    |     function initPrerequisites() internal {
    |         approveTokens();
    |     }
    | 
    |     /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */
    |     receive() external payable {
    |         receiveOverride();
    |     }
    | 
    |     /** @dev Uses the initialized context for the getState function. */
    |     function getState() internal view virtual returns (HyperState memory) {
    |         return getState(address(__hyper__), __poolId__, address(this), __users__);
    |     }
    | 
    |     /** @dev Hook to run after test setup. */
    |     function afterSetUp() public virtual {}
    | 
    |     /** @dev Replace receive ether logic. */
    |     function receiveOverride() public virtual {}
    | 
    |     // ===== Contracts Context ===== //
    |     function initContracts() internal {
    |         __weth__ = new WETH();
    |         __hyper__ = new HyperTimeOverride(address(__weth__));
    |         __quote__ = new TestERC20("USD Coin", "USDC", 6);
    |         __asset__ = new TestERC20("18 Decimals", "18DEC", 18);
    | 
    |         setLabels();
    |     }
    | 
    |     function setLabels() internal {
    |         vm.label(address(this), "Self");
    |         vm.label(address(__weth__), "Weth");
    |         vm.label(address(__hyper__), "HyperTimeOverride");
    |         vm.label(address(__quote__), "QuoteToken");
    |         vm.label(address(__asset__), "AssetToken");
    |     }
    | 
    |     // ===== Users ===== //
    | 
    |     function users() public view virtual returns (address[] memory) {
    |         return __users__;
    |     }
    | 
    |     function initUsers() internal {
    |         address self = address(this);
    |         address alicent = address(0x0001);
    |         address boba = address(0x0002);
    | 
    |         addUser(self, "Self");
    |         addUser(alicent, "Alicent");
    |         addUser(boba, "Boba");
    |     }
    | 
    |     function addUser(address user, string memory label) public {
    |         vm.label(user, label);
    |         __users__.push(user);
    |     }
    | 
    |     // ===== Test Scenarios ===== //
    | 
    |     function initScenarios() internal {
    |         __hyper__.setTimestamp(uint128(block.timestamp)); // Important
    |         // Create default pool
    |         bytes memory data = createPool(
    |             address(__asset__),
    |             address(__quote__),
    |             address(0),
    |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
    |             uint16(1e4 - DEFAULT_GAMMA),
    |             uint16(DEFAULT_SIGMA),
    |             uint16(DEFAULT_DURATION_DAYS),
    |             DEFAULT_JIT,
    |             DEFAULT_TICK,
    |             DEFAULT_PRICE
    |         );
    | 
    |         (bool success, ) = address(__hyper__).call(data);
    |         assertTrue(success, "create pool call failed");
    |     }
    | 
    |     // ===== Utils ===== //
    | 
    |     /** @dev Does not include weth. */
    |     function approveTokens() internal {
    |         for (uint z; z != __users__.length; ++z) {
    |             vm.prank(__users__[z]); // Sets caller
    |             __asset__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
    |             __quote__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
    |         }
    |     }
    | 
    |     /** @dev Does not include weth. */
    |     function fundUsers(uint deltaAsset, uint deltaQuote) internal {
    |         for (uint i; i != __users__.length; ++i) {
    |             deal(address(__asset__), __users__[i], deltaAsset); // TODO: Use regular ERC20, since we can deal.
    |             deal(address(__quote__), __users__[i], deltaQuote); // TODO: Use regular ERC20, since we can deal.
    |         }
    |     }
    | 
    |     function customWarp(uint time) public virtual {
    |         vm.warp(time);
    |         __hyper__.setTimestamp(uint128(time));
    |     }
    | 
    |     event SetNewPoolId(uint64);
    | 
    |     /** @dev Sets the pool id and assets in TestE2ESetup state. Affects all tests! */
    |     function setPoolId(uint64 poolId) public {
    |         __poolId__ = poolId;
    | 
    |         HyperPair memory pair = getPair(address(__hyper__), Enigma.decodePairIdFromPoolId(poolId));
    |         __asset__ = TestERC20(pair.tokenAsset);
    |         __quote__ = TestERC20(pair.tokenQuote);
    | 
    |         emit SetNewPoolId(poolId);
    |     }
    | }
    | 

/root/code/hyper/test/E2E/setup/TestInvariantSetup.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | /** @dev Invariant tests must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */
    | contract TestInvariantSetup {
    |     address[] private _targetContracts;
    | 
    |     function addTargetContract(address target) internal {
    |         _targetContracts.push(target);
    |     }
    | 
    |     function targetContracts() public view returns (address[] memory) {
    |         require(_targetContracts.length != uint(0), "no-target-contracts");
    |         return _targetContracts;
    |     }
    | }
    | 

/root/code/hyper/test/crytic/TestE2EHyper.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | /* import "./setup/TestEchidnaSetup.sol"; */
    | 
    | contract TestE2EHyper {
    |     event AssertionFailed();
    | 
    |     function echidna_jit_policy() public returns (bool) {
    |         if (5 != 4) emit AssertionFailed();
    |     }
    | }
    | 

/root/code/hyper/test/crytic/setup/TestEchidnaSetup.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "solmate/tokens/WETH.sol";
    | import "contracts/libraries/Price.sol";
    | import "contracts/HyperLib.sol";
    | import "test/helpers/HelperHyperActions.sol";
    | import "test/helpers/HelperHyperInvariants.sol";
    | import "test/helpers/HelperHyperProfiles.sol";
    | import "test/helpers/HelperHyperView.sol";
    | 
    | import {TestERC20, HyperTimeOverride} from "test/helpers/HyperTestOverrides.sol";
    | 
    | uint constant STARTING_BALANCE = 4000e18;
    | 
    | contract TestEchidnaEvents {
    |     event AssertionFailed();
    |     event AssertionFailed(uint);
    |     event AssertionFailed(uint, uint);
    |     event AssertionFailed(uint, uint, uint);
    |     event AssertionFailed(string, uint);
    |     event AssertionFailed(bytes);
    |     event AssertionFailed(int);
    | }
    | 
    | contract Addresses {
    |     User public __user__;
    |     WETH public __weth__;
    |     HyperTimeOverride public __hyper__;
    |     TestERC20 public __usdc__;
    |     TestERC20 public __token_18__;
    | }
    | 
    | contract User {}
    | 
    | contract TestEchidnaSetup is
    |     TestEchidnaEvents,
    |     HelperHyperActions,
    |     HelperHyperInvariants,
    |     HelperHyperProfiles,
    |     HelperHyperView,
    |     Addresses
    | {
    |     using FixedPointMathLib for uint256;
    |     using FixedPointMathLib for int256;
    | 
    |     constructor() {
    |         initContracts();
    |         fundUsers();
    |         approveSpenders();
    | 
    |         afterSetUp();
    |     }
    | 
    |     function initContracts() internal {
    |         __user__ = new User();
    |         __weth__ = new WETH();
    | 
    |         // --- Hyper Contracts --- //
    |         __hyper__ = new HyperTimeOverride(address(__weth__));
    | 
    |         // --- Tokens --- //
    |         __usdc__ = new TestERC20("USD Coin", "USDC", 6);
    |         __token_18__ = new TestERC20("18 Decimals", "18DEC", 18);
    |     }
    | 
    |     /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */
    |     receive() external payable {
    |         receiveOverride();
    |     }
    | 
    |     /** @dev Hook to run after test setup. */
    |     function afterSetUp() public virtual {}
    | 
    |     /** @dev Hook to implement to handle receive differently. */
    |     function receiveOverride() public virtual {}
    | 
    |     function deal(TestERC20 token, address to, uint amount) internal {
    |         token.mint(to, amount);
    |     }
    | 
    |     /** @dev Does not include weth. */
    |     function fundUsers() internal {
    |         deal(__token_18__, address(__user__), STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.
    |         deal(__usdc__, address(__user__), STARTING_BALANCE);
    |     }
    | 
    |     /** @dev Does not include weth. */
    |     function approveSpenders() internal {
    |         TestERC20(__token_18__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
    |         TestERC20(__usdc__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperAllocate.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import {HyperPool, JUST_IN_TIME_LIQUIDITY_POLICY, HyperPair} from "contracts/HyperLib.sol";
    | import "./setup/TestHyperSetup.sol";
    | 
    | struct Amounts {
    |     uint expectedDelta0;
    |     uint expectedDelta1;
    |     uint computedDelta0;
    |     uint computedDelta1;
    |     uint prevReserve0;
    |     uint prevReserve1;
    |     uint postReserve0;
    |     uint postReserve1;
    | }
    | 
    | contract TestHyperAllocate is TestHyperSetup {
    |     using SafeCastLib for uint;
    | 
    |     Amounts _amounts;
    | 
    |     modifier afterTest() {
    |         _;
    |         delete _amounts;
    |     }
    | 
    |     function testAllocateNonStandardDecimals() public postTestInvariantChecks afterTest {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         assertTrue(pool.lastTimestamp != 0, "pool-created");
    | 
    |         HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40));
    | 
    |         address hyper = address(__hyperTestingContract__);
    |         uint64 poolId = defaultScenario.poolId;
    | 
    |         uint128 liquidity = DEFAULT_LIQUIDITY;
    |         (_amounts.computedDelta0, _amounts.computedDelta1) = pool.getAmountsWad(); // one liquidity wad
    | 
    |         (_amounts.expectedDelta0, _amounts.expectedDelta1) = (
    |             Assembly.scaleFromWadDown(_amounts.computedDelta0, pair.decimalsAsset),
    |             Assembly.scaleFromWadDown(_amounts.computedDelta1, pair.decimalsQuote)
    |         );
    | 
    |         (_amounts.prevReserve0, _amounts.prevReserve1) = (
    |             getReserve(hyper, pair.tokenAsset),
    |             getReserve(hyper, pair.tokenQuote)
    |         );
    | 
    |         __hyperTestingContract__.allocate(poolId, liquidity);
    | 
    |         (_amounts.postReserve0, _amounts.postReserve1) = (
    |             getReserve(hyper, pair.tokenAsset),
    |             getReserve(hyper, pair.tokenQuote)
    |         );
    | 
    |         assertEq(_amounts.postReserve0, _amounts.prevReserve0 + _amounts.expectedDelta0, "asset-reserves");
    |         assertEq(_amounts.postReserve1, _amounts.prevReserve1 + _amounts.expectedDelta1, "quote-reserves");
    |     }
    | 
    |     function testAllocateFull() public postTestInvariantChecks {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         assertTrue(pool.lastTimestamp != 0, "pool-created");
    | 
    |         uint256 price = pool.lastPrice;
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId));
    |         HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40));
    | 
    |         uint tau = pool.lastTau(); // seconds
    | 
    |         uint256 theoreticalR2 = Price.getXWithPrice(
    |             price,
    |             Price.computePriceWithTick(pool.params.maxTick),
    |             pool.params.volatility,
    |             tau
    |         );
    | 
    |         uint delLiquidity = 4_000_000;
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, delLiquidity);
    | 
    |         uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    |         uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    |         assertTrue(globalR1 > 0);
    |         assertTrue(globalR2 > 0);
    |         assertApproxEqAbs(globalR2, (theoreticalR2 * delLiquidity) / 1e18, 1, "asset-reserve-theoretic");
    |     }
    | 
    |     function testAllocateUseMax() public postTestInvariantChecks {
    |         uint assetBalance = defaultScenario.asset.balanceOf(address(this));
    |         uint quoteBalance = defaultScenario.quote.balanceOf(address(this));
    |         uint maxLiquidity = __hyperTestingContract__.getMaxLiquidity(
    |             defaultScenario.poolId,
    |             assetBalance,
    |             quoteBalance
    |         );
    | 
    |         (address asset, address quote) = (address(defaultScenario.asset), address(defaultScenario.quote));
    | 
    |         __hyperTestingContract__.fund(asset, assetBalance);
    |         __hyperTestingContract__.fund(quote, quoteBalance);
    | 
    |         assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);
    |         quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);
    |         maxLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, assetBalance, quoteBalance);
    | 
    |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getLiquidityDeltas(
    |             defaultScenario.poolId,
    |             -int128(maxLiquidity.safeCastTo128()) // negative delta rounds output amounts down
    |         );
    | 
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, type(uint256).max);
    | 
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);
    |         quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);
    |         (uint128 reserveAsset, uint128 reserveQuote) = pool.getVirtualReserves();
    | 
    |         assertEq(deltaAsset, reserveAsset, "delta-asset");
    |         assertEq(deltaQuote, reserveQuote, "delta-quote");
    |         assertEq(maxLiquidity, pool.liquidity, "delta-liquidity");
    |         assertEq(
    |             assetBalance,
    |             getReserve(address(__hyperTestingContract__), asset) - (deltaAsset + 1), // round up
    |             "asset-balance"
    |         );
    |         assertEq(
    |             quoteBalance,
    |             getReserve(address(__hyperTestingContract__), quote) - (deltaQuote + 1), // round up
    |             "quote-balance"
    |         );
    |     }
    | 
    |     /**
    |      * note: Found an interesting overflow bug!
    |      * 170141183460469231731687303715884105728 is equal to 2^127.
    |      * Values between 2^127 and 2^128 will break allocate, because of the implicit conversion
    |      * from uint128 to int128 causing an overflow.
    |      */
    |     function testFuzzAllocateUnallocateSuccessful(uint128 deltaLiquidity) public postTestInvariantChecks {
    |         vm.assume(deltaLiquidity != 0);
    |         vm.assume(deltaLiquidity < (2 ** 126 - 1e36)); // note: if its 2^127, it could still overflow since liquidity is multiplied against token amounts in getLiquidityDeltas.
    |         // TODO: Add use max flag support.
    |         _assertAllocate(deltaLiquidity);
    |     }
    | 
    |     /** @dev ALlocates then asserts the invariants. */
    |     function _assertAllocate(uint128 deltaLiquidity) internal {
    |         // Preconditions
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
    |         assertTrue(pool.lastPrice != 0, "Pool not created with a price");
    | 
    |         (uint expectedDeltaAsset, uint expectedDeltaQuote) = __hyperTestingContract__.getLiquidityDeltas(
    |             defaultScenario.poolId,
    |             int128(deltaLiquidity)
    |         );
    |         defaultScenario.asset.mint(address(this), expectedDeltaAsset);
    |         defaultScenario.quote.mint(address(this), expectedDeltaQuote);
    | 
    |         // Execution
    |         HyperState memory prev = getState();
    |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.allocate(defaultScenario.poolId, deltaLiquidity);
    |         HyperState memory post = getState();
    | 
    |         // Postconditions
    |         {
    |             assertEq(deltaAsset, expectedDeltaAsset, "pool-delta-asset");
    |             assertEq(deltaQuote, expectedDeltaQuote, "pool-delta-quote");
    |             assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, "pool-total-liquidity");
    |             assertTrue(post.totalPoolLiquidity > prev.totalPoolLiquidity, "pool-liquidity-increases");
    |             assertEq(
    |                 post.callerPositionLiquidity,
    |                 prev.callerPositionLiquidity + deltaLiquidity,
    |                 "position-liquidity-increases"
    |             );
    | 
    |             assertEq(post.reserveAsset, prev.reserveAsset + expectedDeltaAsset, "reserve-asset");
    |             assertEq(post.reserveQuote, prev.reserveQuote + expectedDeltaQuote, "reserve-quote");
    |             assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + expectedDeltaAsset, "physical-asset");
    |             assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + expectedDeltaQuote, "physical-quote");
    | 
    |             uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;
    |             uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;
    |             assertTrue(feeDelta0 == feeDelta1, "asset-growth");
    | 
    |             uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;
    |             uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;
    |             assertTrue(feeDelta2 == feeDelta3, "quote-growth");
    |         }
    | 
    |         // Unallocate
    |         customWarp(block.timestamp + JUST_IN_TIME_LIQUIDITY_POLICY); // TODO: make this public function.
    |         (uint unallocatedAsset, uint unallocatedQuote) = __hyperTestingContract__.unallocate(
    |             defaultScenario.poolId,
    |             deltaLiquidity
    |         );
    | 
    |         // remove all credits, since unallocate will increase this amount.
    |         __hyperTestingContract__.draw(
    |             address(defaultScenario.asset),
    |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),
    |             address(this)
    |         );
    |         __hyperTestingContract__.draw(
    |             address(defaultScenario.quote),
    |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),
    |             address(this)
    |         );
    | 
    |         {
    |             HyperState memory end = getState();
    |             assertApproxEqAbs(unallocatedAsset, deltaAsset, 1, "unallocate-delta-asset");
    |             assertApproxEqAbs(unallocatedQuote, deltaQuote, 1, "unallocate-delta-quote");
    |             assertApproxEqAbs(end.reserveAsset, prev.reserveAsset, 1, "unallocate-reserve-asset");
    |             assertApproxEqAbs(end.reserveQuote, prev.reserveQuote, 1, "unallocate-reserve-quote");
    |             assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity, "unallocate-pool-liquidity");
    |             assertEq(end.totalPositionLiquidity, prev.totalPositionLiquidity, "unallocate-sum-position-liquidity");
    |             assertEq(end.callerPositionLiquidity, prev.callerPositionLiquidity, "unallocate-caller-position-liquidity");
    |         }
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperClaim.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperClaim is TestHyperSetup {
    |     using FixedPointMathLib for uint;
    | 
    |     function testClaimNoPosition_reverts() public {
    |         vm.expectRevert(abi.encodeWithSelector(NonExistentPosition.selector, address(this), defaultScenario.poolId));
    |         __hyperTestingContract__.claim(defaultScenario.poolId, 0, 0);
    |     }
    | 
    |     function testClaim_successful_PositionOwedAmountsReturnsZero() public {
    |         basicAllocate();
    |         basicSwap();
    | 
    |         // Has asset tokens owed
    | 
    |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
    |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
    |         uint tokensOwed = Assembly
    |             .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)
    |             .mulWadDown(pool.liquidity);
    | 
    |         uint pre = _getBalance(hx(), address(this), (defaultScenario.asset));
    |         __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);
    |         uint post = _getBalance(hx(), address(this), (defaultScenario.asset));
    | 
    |         pos = _getPosition(hs(), address(this), defaultScenario.poolId);
    | 
    |         assertEq(post, pre + tokensOwed, "delta");
    |         assertEq(post, tokensOwed, "claimed-bal");
    |         assertEq(pos.tokensOwedAsset, 0, "zero-claim");
    |     }
    | 
    |     function testClaimGetBalanceReturnsFeeAmount_asset() public {
    |         basicAllocate();
    |         basicSwap();
    | 
    |         // Has asset tokens owed
    | 
    |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
    |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
    |         uint tokensOwed = Assembly
    |             .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)
    |             .mulWadDown(pool.liquidity);
    | 
    |         __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);
    |         uint post = _getBalance(hx(), address(this), (defaultScenario.asset));
    |         assertEq(post, tokensOwed, "claimed-bal");
    |     }
    | 
    |     function testClaimGetBalanceReturnsFeeAmount_quote() public {
    |         basicAllocate();
    |         basicSwapQuoteIn();
    | 
    |         // Has asset tokens owed
    | 
    |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
    |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
    |         uint tokensOwed = Assembly
    |             .computeCheckpointDistance(pool.feeGrowthGlobalQuote, pos.feeGrowthQuoteLast)
    |             .mulWadDown(pool.liquidity);
    | 
    |         __hyperTestingContract__.claim(defaultScenario.poolId, 0, tokensOwed);
    |         uint post = _getBalance(hx(), address(this), defaultScenario.quote);
    |         assertEq(post, tokensOwed, "claimed-bal");
    |     }
    | 
    |     function testClaimGetBalanceReturnsFeeAmount_reward() public {
    |         // Rewards only accrue to controlled pools
    |         createControlledPool();
    | 
    |         TestScenario memory scenario = scenarios[1]; // assumes it was the second one...
    |         assertTrue(
    |             keccak256(abi.encodePacked(scenario.label)) == keccak256(abi.encodePacked("Controlled")),
    |             "not controlled?"
    |         );
    | 
    |         __weth__.deposit{value: 0.01 ether}();
    |         __weth__.approve(address(__hyperTestingContract__), type(uint256).max);
    | 
    |         _alloc(scenario.poolId);
    |         __hyperTestingContract__.stake(scenario.poolId, 1 ether);
    | 
    |         // pass some time for staking
    |         customWarp(__hyperTestingContract__.timestamp() + 1);
    | 
    |         _swap(scenario.poolId); // swapping in controlled pool should increment reward token (weth)
    | 
    |         // Has asset tokens owed
    | 
    |         HyperPosition memory pos = _getPosition(hs(), address(this), scenario.poolId);
    |         HyperPool memory pool = _getPool(hs(), scenario.poolId);
    |         uint tokensOwed = Assembly
    |             .computeCheckpointDistance(pool.feeGrowthGlobalReward, pos.feeGrowthRewardLast)
    |             .mulWadDown(pool.liquidity);
    | 
    |         __hyperTestingContract__.claim(scenario.poolId, 0, 0);
    |         uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
    |         assertEq(post, tokensOwed, "claimed-bal");
    |     }
    | 
    |     function testClaimCreditsAssetBalance() public postTestInvariantChecks {
    |         basicAllocate();
    |         basicSwap(); // swaps __asset__ in, so pays fees in asset.
    | 
    |         HyperPool memory pool = defaultPool();
    |         uint real0 = _getReserve(hx(), defaultScenario.asset);
    |         uint real1 = _getReserve(hx(), defaultScenario.quote);
    |         (uint res0, uint res1) = pool.getVirtualReserves();
    | 
    |         basicUnallocate();
    |         maxDraw(); // zero balance to ensure we aren't paying ourself.
    | 
    |         HyperPosition memory pos = defaultPosition();
    |         pool = defaultPool();
    |         (uint fee0, uint fee1) = (pos.tokensOwedAsset, pos.tokensOwedQuote);
    |         assertTrue(fee0 > 0, "fee0-zero");
    |         assertTrue(pool.liquidity == 0, "non-zero-liquidity");
    | 
    |         // Claim
    |         uint prevReserve = _getReserve(hx(), defaultScenario.asset);
    |         uint prevBalance = _getBalance(hx(), address(this), defaultScenario.asset);
    |         __hyperTestingContract__.claim(defaultScenario.poolId, fee0, fee1);
    |         uint nextBalance = _getBalance(hx(), address(this), defaultScenario.asset);
    | 
    |         maxDraw(); // clear reserve
    | 
    |         uint nextReserve = _getReserve(hx(), defaultScenario.asset);
    |         assertTrue(nextBalance > prevBalance, "no fee claimed");
    |         assertTrue(nextReserve < prevReserve, "no fee removed");
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperCreate.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "forge-std/Vm.sol";
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperCreate is TestHyperSetup {
    |     function testFuzzCreatePol(
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 jit,
    |         uint16 duration,
    |         uint16 volatility,
    |         int24 maxTick,
    |         uint128 price
    |     ) public {
    |         fee = uint16(bound(fee, MIN_FEE, MAX_FEE));
    |         priorityFee = uint16(bound(priorityFee, 1, fee));
    |         jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));
    |         duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));
    |         volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    |         maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));
    |         vm.assume(price > 0);
    |         vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.
    |         bytes memory data = Enigma.encodeCreatePool(
    |             uint24(1),
    |             address(this),
    |             priorityFee,
    |             fee,
    |             volatility,
    |             duration,
    |             jit,
    |             maxTick,
    |             price
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(2));
    | 
    |         HyperPool memory pool = _getPool(hs(), poolId);
    |         HyperCurve memory actual = pool.params;
    | 
    |         assertTrue(success, "fuzz create pool failed");
    |         assertEq(pool.controller, address(this), "controller");
    |         assertEq(actual.priorityFee, priorityFee, "priorityFee");
    |         assertEq(actual.fee, fee, "fee");
    |         assertEq(actual.volatility, volatility, "volatility");
    |         assertEq(actual.duration, duration, "duration");
    |         assertEq(actual.jit, jit, "jit");
    |         assertEq(actual.maxTick, maxTick, "maxTick");
    |     }
    | 
    |     function testCreatePoolNonControlledHasDefaultJit() public {
    |         __hyperTestingContract__.setJitPolicy(JUST_IN_TIME_LIQUIDITY_POLICY); // for assertion below.
    |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(0), 1, 100, 100, 100, 100, 100, 100);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "create failed");
    |         assertEq(_getPool(hs(), defaultScenario.poolId + 1).params.jit, JUST_IN_TIME_LIQUIDITY_POLICY);
    |     }
    | 
    |     function testCreatePoolZeroPriceReverts() public {
    |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 1, 1, 1, 1, 1, 1, 0);
    |         vm.expectRevert(ZeroPrice.selector);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success);
    |     }
    | 
    |     function testCreatePoolPriorityFeeInvalidFeeReverts() public {
    |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 0, 1, 1, 1, 1, 1, 1);
    |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, 0));
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success);
    |     }
    | 
    |     function testFuzzChangeParameters(
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 jit,
    |         uint16 duration,
    |         uint16 volatility,
    |         int24 maxTick
    |     ) public {
    |         uint64 poolId = _createDefaultPool();
    |         fee = uint16(bound(fee, MIN_FEE, MAX_FEE));
    |         priorityFee = uint16(bound(priorityFee, 1, fee));
    |         jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));
    |         duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));
    |         volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
    |         maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));
    |         vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.
    | 
    |         __hyperTestingContract__.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
    |         HyperCurve memory actual = _getPool(hs(), poolId).params;
    |         assertEq(actual.priorityFee, priorityFee, "priorityFee");
    |         assertEq(actual.fee, fee, "fee");
    |         assertEq(actual.volatility, volatility, "volatility");
    |         assertEq(actual.duration, duration, "duration");
    |         assertEq(actual.jit, jit, "jit");
    |         assertEq(actual.maxTick, maxTick, "maxTick");
    |     }
    | 
    |     function testChangeParametersPriorityFeeSuccess() public {
    |         uint64 poolId = _createDefaultPool();
    |         uint16 prev = _getPool(hs(), poolId).params.priorityFee;
    |         __hyperTestingContract__.changeParameters(poolId, DEFAULT_FEE + 10, DEFAULT_FEE + 20, 0, 0, 0, 0);
    |         uint16 post = _getPool(hs(), poolId).params.priorityFee;
    |         assertEq(post, prev + 10, "priority-fee-change");
    |     }
    | 
    |     function testChangeParametersSuccessKeepsPoolSolvency() public {
    |         uint64 poolId = _createDefaultPool();
    |         (uint prev0, uint prev1) = __hyperTestingContract__.getVirtualReserves(poolId);
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             0,
    |             0,
    |             DEFAULT_VOLATILITY * 2,
    |             DEFAULT_DURATION + 30,
    |             0,
    |             DEFAULT_TICK + 500
    |         );
    |         (uint post0, uint post1) = __hyperTestingContract__.getVirtualReserves(poolId);
    |         assertEq(post0, prev0, "virtual-asset-balance-altered");
    |         assertEq(post1, prev1, "virtual-quote-balance-altered");
    |     }
    | 
    |     function testChangeParametersNotControllerReverts() public {
    |         uint64 poolId = _createDefaultPool();
    |         uint16 failureArg = 1;
    |         vm.expectRevert(NotController.selector);
    |         vm.prank(address(0x0006));
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             DEFAULT_VOLATILITY,
    |             DEFAULT_DURATION,
    |             DEFAULT_JIT,
    |             DEFAULT_TICK
    |         );
    |     }
    | 
    |     function testChangeParametersInvalidVolatilityReverts() public {
    |         uint64 poolId = _createDefaultPool();
    |         uint16 failureArg = 1;
    |         vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             1,
    |             DEFAULT_DURATION,
    |             DEFAULT_JIT,
    |             DEFAULT_TICK
    |         );
    |     }
    | 
    |     function testChangeParametersInvalidDurationReverts() public {
    |         uint64 poolId = _createDefaultPool();
    |         uint16 failureArg = 5000;
    |         vm.expectRevert(abi.encodeWithSelector(InvalidDuration.selector, failureArg));
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             DEFAULT_VOLATILITY,
    |             5000,
    |             DEFAULT_JIT,
    |             DEFAULT_TICK
    |         );
    |     }
    | 
    |     function testChangeParametersInvalidTickReverts() public {
    |         uint64 poolId = _createDefaultPool();
    |         int24 failureArg = 1000000;
    |         vm.expectRevert(abi.encodeWithSelector(InvalidTick.selector, uint24(failureArg)));
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             DEFAULT_VOLATILITY,
    |             DEFAULT_DURATION,
    |             DEFAULT_JIT,
    |             failureArg
    |         );
    |     }
    | 
    |     function testChangeParametersInvalidJitReverts() public {
    |         uint64 poolId = _createDefaultPool();
    |         uint16 failureArg = 10000;
    |         vm.expectRevert(abi.encodeWithSelector(InvalidJit.selector, failureArg));
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             DEFAULT_VOLATILITY,
    |             DEFAULT_DURATION,
    |             failureArg,
    |             DEFAULT_TICK
    |         );
    |     }
    | 
    |     function testChangeParametersPriorityFeeAboveFeeReverts() public {
    |         uint64 poolId = _createDefaultPool();
    |         HyperCurve memory curve = HyperCurve({
    |             maxTick: DEFAULT_TICK,
    |             jit: DEFAULT_JIT,
    |             fee: 55,
    |             duration: DEFAULT_DURATION,
    |             volatility: DEFAULT_VOLATILITY,
    |             priorityFee: 56,
    |             createdAt: 100000000
    |         });
    |         (, bytes memory revertData) = curve.checkParameters();
    |         assertEq(revertData, abi.encodeWithSelector(InvalidFee.selector, curve.priorityFee));
    |         vm.expectRevert(revertData);
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             curve.priorityFee,
    |             curve.fee,
    |             curve.volatility,
    |             curve.duration,
    |             curve.jit,
    |             curve.maxTick
    |         );
    |     }
    | 
    |     function testChangeParametersInvalidFeeReverts() public {
    |         uint16 failureArg = 2 ** 16 - 10;
    |         uint64 poolId = _createDefaultPool();
    |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
    |         __hyperTestingContract__.changeParameters(
    |             poolId,
    |             DEFAULT_FEE,
    |             failureArg,
    |             DEFAULT_VOLATILITY,
    |             DEFAULT_DURATION,
    |             DEFAULT_JIT,
    |             DEFAULT_TICK
    |         );
    |     }
    | 
    |     function _createDefaultPool() internal returns (uint64 poolId) {
    |         uint24 pairId = uint24(1);
    |         bytes memory createData = Enigma.encodeCreatePool(
    |             pairId, // assumes first pair is created
    |             address(this),
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             DEFAULT_VOLATILITY,
    |             DEFAULT_DURATION,
    |             DEFAULT_JIT,
    |             DEFAULT_TICK,
    |             DEFAULT_PRICE
    |         );
    |         bool success = __revertCatcher__.process(createData);
    |         assertTrue(success, "did not create pool");
    | 
    |         poolId = Enigma.encodePoolId(pairId, true, uint32(2));
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperDeploy.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "forge-std/Vm.sol";
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperDeploy is TestHyperSetup {
    |     event Deployed(string, address);
    | 
    |     function testDeploy() public {
    |         address weth = address(new WETH());
    |         address usdc = address(new TestERC20("USDC", "USD Coin", 6));
    |         Hyper hyper = new Hyper(weth);
    | 
    |         emit Deployed("Deployed weth at: ", weth);
    |         emit Deployed("Deployed hyper at: ", address(hyper));
    |         emit Deployed("Deployed usdc at: ", usdc);
    | 
    |         assertEq(hyper.WETH(), weth, "weth address");
    |         (, bool settled) = hyper.__account__();
    |         assertTrue(settled, "settled");
    |         // todo: fix version
    |         //assertTrue(bytes32(abi.encodePacked(hyper.VERSION())) == bytes32(abi.encodePacked("beta-v0.0.1")));
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperDeposit.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "forge-std/Vm.sol";
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperDeposit is TestHyperSetup {
    |     function testDepositMsgValueZero_reverts() public {
    |         vm.expectRevert(ZeroValue.selector);
    |         __hyperTestingContract__.deposit{value: 0}();
    |     }
    | 
    |     function testDepositWethTotalSupplyReturnsMsgValue() public {
    |         uint pre = __weth__.totalSupply();
    |         __hyperTestingContract__.deposit{value: 100}();
    |         uint post = __weth__.totalSupply();
    |         uint delta = post - pre;
    |         assertEq(post, 100, "ts");
    |         assertEq(delta, 100, "del");
    |     }
    | 
    |     function testDepositCallersBalanceReturnsMsgValue() public {
    |         uint pre = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
    |         __hyperTestingContract__.deposit{value: 100}();
    |         uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
    |         uint delta = post - pre;
    |         assertEq(post, 100, "ts");
    |         assertEq(delta, 100, "del");
    |     }
    | 
    |     function testDepositEtherBalanceReturnsZero() public {
    |         __hyperTestingContract__.deposit{value: 100}();
    |         uint actual = address(__hyperTestingContract__).balance;
    |         assertEq(actual, 0, "balance");
    |     }
    | 
    |     function testDepositWethReservesReturnsMsgValue() public {
    |         uint pre = getReserve(address(__hyperTestingContract__), address(__weth__));
    |         __hyperTestingContract__.deposit{value: 100}();
    |         uint post = getReserve(address(__hyperTestingContract__), address(__weth__));
    |         uint delta = post - pre;
    |         assertEq(post, 100, "ts");
    |         assertEq(delta, 100, "del");
    |     }
    | 
    |     function testDepositBalanceOfWethReturnsMsgValue() public {
    |         __hyperTestingContract__.deposit{value: 100}();
    |         uint actual = __weth__.balanceOf(address(__hyperTestingContract__));
    |         assertEq(actual, 100, "balance");
    |     }
    | 
    |     function testDepositWrapsEther() public postTestInvariantChecks {
    |         uint prevWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));
    |         uint prevBalance = address(this).balance;
    |         __hyperTestingContract__.deposit{value: 4000}();
    |         uint nextBalance = address(this).balance;
    |         uint nextWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));
    | 
    |         assertTrue(nextBalance < prevBalance);
    |         assertTrue(nextWethBalance > prevWethBalance);
    |     }
    | 
    |     function testDepositIncreasesUserBalance() public postTestInvariantChecks {
    |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
    |         __hyperTestingContract__.deposit{value: 4000}();
    |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
    | 
    |         assertTrue(nextBalance > prevBalance, "balance-not-increased");
    |     }
    | 
    |     event Deposit(address indexed account, uint amount);
    | 
    |     function testDepositWrapsEther_emit_Deposit() public {
    |         vm.expectEmit(true, true, false, true, address(__hyperTestingContract__));
    |         emit Deposit(address(this), 4000);
    |         __hyperTestingContract__.deposit{value: 4000}();
    |     }
    | 
    |     event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);
    | 
    |     function testDepositWrapsEther_emit_IncreaseUserBalance() public {
    |         vm.expectEmit(true, true, true, true, address(__hyperTestingContract__));
    |         emit IncreaseUserBalance(address(this), address(__weth__), 4000);
    |         __hyperTestingContract__.deposit{value: 4000}();
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperDraw.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperDraw is TestHyperSetup {
    |     function testDrawReducesBalance() public postTestInvariantChecks {
    |         // Fund the account
    |         __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);
    | 
    |         // Draw
    |         uint prevReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    |         __hyperTestingContract__.draw(address(defaultScenario.asset), 4000, address(this));
    |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    |         uint nextReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    | 
    |         assertTrue(nextBalance == 0);
    |         assertTrue(nextBalance < prevBalance);
    |         assertTrue(nextReserve < prevReserve);
    |     }
    | 
    |     function testDrawRevertsWithDrawBalance() public {
    |         vm.expectRevert(DrawBalance.selector);
    |         __hyperTestingContract__.draw(address(defaultScenario.asset), 1e18, address(this));
    |     }
    | 
    |     function testDrawFromWethTransfersEther() public postTestInvariantChecks {
    |         // First fund the account
    |         __hyperTestingContract__.deposit{value: 4000}();
    | 
    |         // Draw
    |         uint prevBalance = address(this).balance;
    |         __hyperTestingContract__.draw(address(__weth__), 4000, address(this));
    |         uint nextBalance = address(this).balance;
    | 
    |         assertTrue(nextBalance > prevBalance);
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperFund.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperFund is TestHyperSetup {
    |     function testFundIncreasesBalance() public postTestInvariantChecks {
    |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    |         __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);
    |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    | 
    |         assertTrue(nextBalance > prevBalance, "increase-internal-bal");
    |     }
    | 
    |     function testFuzzFundDrawSuccessful(uint128 amount) public {
    |         vm.assume(amount > 0);
    |         _assertFundDraw(amount);
    |     }
    | 
    |     function _assertFundDraw(uint amount) internal {
    |         // Preconditions
    |         defaultScenario.asset.approve(address(__hyperTestingContract__), amount);
    |         deal(address(defaultScenario.asset), address(this), amount);
    | 
    |         // Execution
    |         uint preBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    |         HyperState memory prev = getState();
    |         __hyperTestingContract__.fund(address(defaultScenario.asset), amount);
    |         HyperState memory post = getState();
    |         uint postBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    | 
    |         // Post conditions
    |         assertTrue(postBal > preBal, "bal-increase");
    |         assertEq(postBal, preBal + amount, "bal-increase-exact");
    |         assertEq(post.reserveAsset, prev.reserveAsset + amount, "reserve-increase");
    |         assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + amount, "physical-increase");
    |         assertEq(post.totalBalanceAsset, prev.totalBalanceAsset + amount, "total-bal-increase");
    | 
    |         __hyperTestingContract__.draw(address(defaultScenario.asset), amount, address(this));
    |         HyperState memory end = getState();
    |         uint endBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    | 
    |         assertEq(endBal, preBal, "reverse-exact-bal");
    |         assertEq(end.reserveAsset, prev.reserveAsset, "reverse-exact-reserve");
    |         assertEq(end.physicalBalanceAsset, prev.physicalBalanceAsset, "reverse-exact-physical");
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestHyperProcessing.t.sol
    | // SPDX-License-Identifier: UNLICENSED
    | pragma solidity 0.8.13;
    | 
    | import "contracts/HyperLib.sol" as HyperTypes;
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperProcessing is TestHyperSetup {
    |     using SafeCastLib for uint;
    | 
    |     function afterSetUp() public override {
    |         assertTrue(
    |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp != 0,
    |             "Pool not created"
    |         );
    |         assertTrue(
    |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick != 0,
    |             "Pool not initialized with price"
    |         );
    |         assertTrue(
    |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity == 0,
    |             "Pool initialized with liquidity"
    |         );
    |     }
    | 
    |     // ===== Getters ===== //
    | 
    |     function testGetAmounts() public {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         HyperCurve memory curve = pool.params;
    |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getAmounts(defaultScenario.poolId);
    |         uint maxDelta = 0.001 ether; // 1ether = 100%, 0.001 ether = 0.10%
    |         assertApproxEqRel(
    |             deltaAsset,
    |             Assembly.scaleFromWadDown(DEFAULT_ASSET_RESERVE, pool.pair.decimalsAsset),
    |             maxDelta,
    |             "asset-reserve"
    |         ); // todo: fix default amounts
    |         assertApproxEqRel(
    |             deltaQuote,
    |             Assembly.scaleFromWadDown(DEFAULT_QUOTE_RESERVE, pool.pair.decimalsQuote),
    |             maxDelta,
    |             "quote-reserve"
    |         );
    |     }
    | 
    |     function testGetLiquidityMinted() public {
    |         uint deltaLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, 1, 1e19);
    |     }
    | 
    |     // ===== Enigma ===== //
    | 
    |     function testJumpProcessCreatesPair() public {
    |         bytes[] memory instructions = new bytes[](1);
    |         instructions[0] = (Enigma.encodeCreatePair(address(__token_8__), address(defaultScenario.quote)));
    |         bytes memory data = Enigma.encodeJumpInstruction(instructions);
    |         bool success = __revertCatcher__.jumpProcess(data);
    |         assertTrue(success);
    | 
    |         uint24 pairId = uint16(__hyperTestingContract__.getPairNonce());
    |         HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);
    |         assertTrue(pair.tokenAsset != address(0));
    |         assertTrue(pair.tokenQuote != address(0));
    |     }
    | 
    |     function testProcessRevertsWithInvalidInstructionZeroOpcode() public {
    |         vm.expectRevert(InvalidInstruction.selector);
    |         __revertCatcher__.process(hex"00");
    |     }
    | 
    |     function testProcessRevertsWithInvalidInstruction() public {
    |         vm.expectRevert(InvalidInstruction.selector);
    |         __revertCatcher__.process(hex"44");
    |     }
    | 
    |     // ===== Effects ===== //
    | 
    |     // --- Swap --- //
    | 
    |     function testSwapExactInNonExistentPoolIdReverts() public {
    |         uint64 failureArg = uint64(0x01);
    |         bytes memory data = Enigma.encodeSwap(0, failureArg, 0x01, 0x01, 0x01, 0x01, 0);
    |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success);
    |     }
    | 
    |     function testSwapExactInZeroSwapAmountReverts() public {
    |         uint128 failureArg = 0;
    |         bytes memory data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, failureArg, 0x01, 0x01, 0);
    |         vm.expectRevert(ZeroInput.selector);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success);
    |     }
    | 
    |     function testSwapExactInPoolPriceUpdated() public postTestInvariantChecks {
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |         // move some time
    |         customWarp(block.timestamp + 1);
    | 
    |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
    | 
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
    |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
    |         assertTrue(next != prev);
    |     }
    | 
    |     /* function testSwapExactInPoolSlotIndexUpdated() public {
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |         // move some time
    |         customWarp(block.timestamp + 1);
    | 
    |         int256 prev = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;
    | 
    |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
    |         data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x12, 0x02, 0x1f, 0x01, 0);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         int256 next = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;
    |         assertTrue(next != prev);
    |     } */
    | 
    |     function testSwapUseMax() public postTestInvariantChecks {
    |         uint amount = type(uint256).max;
    |         uint limit = amount;
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         // move some time
    |         customWarp(block.timestamp + 1);
    |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
    |         bool direction = true;
    |         __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));
    | 
    |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
    |         assertTrue(next == prev);
    |     }
    | 
    |     function testSwapInQuote() public postTestInvariantChecks {
    |         uint limit = type(uint256).max;
    |         uint amount = 2222;
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         // move some time
    |         customWarp(block.timestamp + 1);
    |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
    |         bool direction = false;
    |         __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));
    | 
    |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
    |         assertTrue(next == prev);
    |     }
    | 
    |     function testSwapReverse() public {
    |         bool direction = true;
    |         uint limit = type(uint256).max;
    |         uint amount = 17e16;
    |         // Add liquidity first
    |         /* bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success); */
    |         allocatePool(address(__hyperTestingContract__), defaultScenario.poolId, 10e19);
    | 
    |         // deposit first
    |         __hyperTestingContract__.fund(address(defaultScenario.asset), amount);
    |         uint256 prev = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    | 
    |         (uint output, ) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             direction,
    |             amount,
    |             getMaxSwapLimit(direction)
    |         );
    |         direction = false;
    |         (uint input, ) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             direction,
    |             output,
    |             getMaxSwapLimit(direction)
    |         );
    | 
    |         uint256 next = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
    |         assertTrue(next <= prev, "invalid-user-gained-balance");
    |         assertTrue(input < amount, "invalid-invariant-got-more-out");
    |     }
    | 
    |     function testSwapExpiredPoolReverts() public {
    |         uint limit = type(uint256).max;
    |         uint amount = 2222;
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         // move some time beyond maturity
    |         customWarp(
    |             block.timestamp +
    |                 getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(
    |                     __hyperTestingContract__.timestamp()
    |                 ) +
    |                 1
    |         );
    | 
    |         vm.expectRevert(PoolExpired.selector);
    |         __hyperTestingContract__.swap(defaultScenario.poolId, false, amount, limit);
    |     }
    | 
    |     function testSwapExactInPoolLiquidityUnchanged() public postTestInvariantChecks {
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |         // move some time
    |         customWarp(block.timestamp + 1);
    |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
    | 
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
    |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
    |         assertTrue(next == prev);
    |     }
    | 
    |     function testSwapExactInPoolTimestampUpdated() public postTestInvariantChecks {
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity, note: 0x0a amount breaks test? todo: handle case where insufficient liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |         // move some time
    |         customWarp(block.timestamp + 1);
    | 
    |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    | 
    |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
    |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;
    |         assertTrue(next != prev);
    |     }
    | 
    |     function testSwapExactInGlobalAssetBalanceIncreases() public postTestInvariantChecks {
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |         // move some time
    |         customWarp(block.timestamp + 1);
    | 
    |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    | 
    |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    |         assertTrue(next > prev);
    |     }
    | 
    |     function testSwapExactInGlobalQuoteBalanceDecreases() public postTestInvariantChecks {
    |         // Add liquidity first
    |         bytes memory data = Enigma.encodeAllocate(
    |             0,
    |             defaultScenario.poolId,
    |             0x13, // 19 zeroes, so 10e19 liquidity
    |             0x01
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |         // move some time
    |         customWarp(block.timestamp + 1);
    | 
    |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    | 
    |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success, "swap failed");
    | 
    |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    |         assertTrue(next == prev, "reserves-changed");
    |     }
    | 
    |     // --- Allocate --- //
    | 
    |     function testAllocateNonExistentPoolIdReverts() public {
    |         uint64 failureArg = uint64(48);
    |         bytes memory data = Enigma.encodeAllocate(0, failureArg, 0x01, 0x01);
    |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success, "forwarder call failed");
    |     }
    | 
    |     function testAllocateZeroLiquidityReverts() public {
    |         uint8 failureArg = 0;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, 0x00, failureArg);
    |         vm.expectRevert(ZeroLiquidity.selector);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success, "forwarder call failed");
    |     }
    | 
    |     function testProcessAllocateFull() public postTestInvariantChecks {
    |         uint256 price = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), (defaultScenario.poolId));
    |         uint tau = getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(
    |             __hyperTestingContract__.timestamp()
    |         );
    |         uint strike = Price.computePriceWithTick(curve.maxTick);
    |         console.log(tau, strike, curve.volatility);
    |         uint256 theoreticalR2 = Price.getXWithPrice(price, strike, curve.volatility, tau);
    | 
    |         uint8 power = uint8(0x06); // 6 zeroes
    |         uint8 amount = uint8(0x04); // 4 with 6 zeroes = 4_000_000 wei
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    | 
    |         __revertCatcher__.process(data);
    | 
    |         uint delLiquidity = 4_000_000;
    |         uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    |         uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    |         assertTrue(globalR1 > 0);
    |         assertTrue(globalR2 > 0);
    |         uint expected = (theoreticalR2 * delLiquidity) / 1e18;
    |         console.log("expected", expected);
    |         console.log("globalR2", globalR2);
    |         // todo: fix this test
    |         assertApproxEqAbs(globalR2, expected, 1e2, "asset-reserve-theoretic"); // todo: fix, should it be this far?
    |     }
    | 
    |     function testAllocatePositionTimestampUpdated() public postTestInvariantChecks {
    |         uint64 positionId = defaultScenario.poolId;
    | 
    |         uint256 prevPositionTimestamp = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).lastTimestamp;
    | 
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint256 nextPositionTimestamp = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).lastTimestamp;
    | 
    |         assertTrue(prevPositionTimestamp == 0);
    |         assertTrue(nextPositionTimestamp > prevPositionTimestamp && nextPositionTimestamp == block.timestamp);
    |     }
    | 
    |     function testAllocatePositionfreeLiquidityIncreases() public postTestInvariantChecks {
    |         uint64 positionId = defaultScenario.poolId;
    | 
    |         uint256 prevPositionfreeLiquidity = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).freeLiquidity;
    | 
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint256 nextPositionfreeLiquidity = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).freeLiquidity;
    | 
    |         assertTrue(prevPositionfreeLiquidity == 0);
    |         assertTrue(nextPositionfreeLiquidity > prevPositionfreeLiquidity);
    |     }
    | 
    |     function testAllocateGlobalAssetIncreases() public postTestInvariantChecks {
    |         uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    | 
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    |         assertTrue(nextGlobal != 0, "next globalReserves is zero");
    |         assertTrue(nextGlobal > prevGlobal, "globalReserves did not change");
    |     }
    | 
    |     function testAllocateGlobalQuoteIncreases() public postTestInvariantChecks {
    |         uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    | 
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    |         assertTrue(nextGlobal != 0, "next globalReserves is zero");
    |         assertTrue(nextGlobal > prevGlobal, "globalReserves did not change");
    |     }
    | 
    |     // --- Remove Liquidity --- //
    | 
    |     function testUnallocateZeroLiquidityReverts() public {
    |         bytes memory data = Enigma.encodeUnallocate(0, defaultScenario.poolId, 0x00, 0x00);
    |         vm.expectRevert(ZeroLiquidity.selector);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success);
    |     }
    | 
    |     function testUnallocateNonExistentPoolReverts() public {
    |         uint64 failureArg = 42;
    |         bytes memory data = Enigma.encodeUnallocate(0, 42, 0x01, 0x01);
    |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success);
    |     }
    | 
    |     // needs a mutable pool, or a pool with a non-zero jit policy
    |     function testUnallocatePositionJitPolicyReverts() public postTestInvariantChecks {
    |         uint16 jit = 99;
    |         bytes memory createData = Enigma.encodeCreatePool(
    |             uint24(1), // pairId
    |             address(this), // controller
    |             DEFAULT_FEE,
    |             DEFAULT_FEE,
    |             uint16(DEFAULT_SIGMA),
    |             DEFAULT_DURATION_DAYS,
    |             jit,
    |             DEFAULT_TICK,
    |             DEFAULT_PRICE
    |         );
    | 
    |         bool success = __revertCatcher__.process(createData);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint64 poolId = Enigma.encodePoolId(uint24(0x01), true, uint32(__hyperTestingContract__.getPoolNonce()));
    | 
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, poolId, power, amount);
    |         success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         // Set the distance for the position by warping in time.
    |         uint256 distance = 22;
    |         uint256 warpTimestamp = block.timestamp + distance;
    |         customWarp(warpTimestamp);
    | 
    |         data = Enigma.encodeUnallocate(0, poolId, power, amount);
    | 
    |         vm.expectRevert(abi.encodeWithSelector(JitLiquidity.selector, distance));
    |         success = __revertCatcher__.process(data);
    |         assertTrue(!success, "Should not suceed in testUnllocatePositionJit");
    |     }
    | 
    |     function testUnallocatePositionTimestampUpdated() public postTestInvariantChecks {
    |         int24 hiTick = DEFAULT_TICK;
    |         int24 loTick = DEFAULT_TICK - 256;
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint64 positionId = defaultScenario.poolId;
    |         uint256 prevPositionTimestamp = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).lastTimestamp;
    | 
    |         uint256 warpTimestamp = block.timestamp + 1;
    |         customWarp(warpTimestamp);
    | 
    |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 nextPositionTimestamp = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).lastTimestamp;
    | 
    |         assertTrue(nextPositionTimestamp > prevPositionTimestamp && nextPositionTimestamp == warpTimestamp);
    |     }
    | 
    |     function testUnallocatePositionfreeLiquidityDecreases() public postTestInvariantChecks {
    |         int24 hiTick = DEFAULT_TICK;
    |         int24 loTick = DEFAULT_TICK - 256;
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "forwarder call failed");
    | 
    |         uint64 positionId = defaultScenario.poolId;
    |         uint256 prevPositionLiquidity = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).freeLiquidity;
    | 
    |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 nextPositionLiquidity = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).freeLiquidity;
    | 
    |         assertTrue(nextPositionLiquidity < prevPositionLiquidity);
    |     }
    | 
    |     function testUnallocateGlobalAssetDecreases() public postTestInvariantChecks {
    |         uint8 amount = 0x01;
    |         uint8 power = 0x05; // if this is low enough, it will revert because token amounts rounded down to zero.
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    | 
    |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
    |         assertTrue(next == prev, "reserves-changed"); // unallocated amounts are credited to user
    |     }
    | 
    |     /// @dev IMPORTANT TEST. For low token decimals, be very aware of the amount of liquidity involved in each tx.
    |     function testUnallocateGlobalQuoteDecreases() public postTestInvariantChecks {
    |         uint8 amount = 0x01;
    |         uint8 power = 0x0c; // 1e12 liquidity
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    | 
    |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
    |         assertTrue(next == prev, "reserves-changed"); // unallocated amounts are credited to user
    |     }
    | 
    |     // --- Stake Position --- //
    | 
    |     function testStakeExternalEpochIncrements() public {
    |         uint8 amount = 0x05;
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, amount);
    | 
    |         uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
    |             .stakeTimestamp;
    |         __hyperTestingContract__.stake(defaultScenario.poolId, amount);
    |         uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
    |             .stakeTimestamp;
    | 
    |         assertTrue(nextId != prevId);
    |     }
    | 
    |     function testStakePositionStakedUpdated() public postTestInvariantChecks {
    |         int24 lo = DEFAULT_TICK - 256;
    |         int24 hi = DEFAULT_TICK;
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint64 positionId = defaultScenario.poolId;
    | 
    |         bool prevPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
    |             .stakeTimestamp != 0;
    | 
    |         data = Enigma.encodeStakePosition(positionId, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         bool nextPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
    |             .stakeTimestamp != 0;
    | 
    |         assertTrue(nextPositionStaked != prevPositionStaked, "Position staked did not update.");
    |         assertTrue(nextPositionStaked, "Position staked is not true.");
    |     }
    | 
    |     function testStakePoolStakedLiquidityUpdated() public postTestInvariantChecks {
    |         int24 lo = DEFAULT_TICK - 256;
    |         int24 hi = DEFAULT_TICK;
    |         uint8 amount = 0x01;
    |         uint8 power = 0x01;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)
    |             .stakedLiquidity;
    | 
    |         uint64 positionId = defaultScenario.poolId;
    |         data = Enigma.encodeStakePosition(positionId, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)
    |             .stakedLiquidity;
    | 
    |         if (
    |             lo <= getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick &&
    |             hi > getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick
    |         ) {
    |             assertTrue(nextPoolStakedLiquidity > prevPoolStakedLiquidity, "Pool staked liquidity did not increase.");
    |             assertTrue(
    |                 nextPoolStakedLiquidity ==
    |                     getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
    |                         .freeLiquidity,
    |                 "Pool staked liquidity not equal to liquidity of staked position."
    |             );
    |         } else {
    |             assertTrue(
    |                 nextPoolStakedLiquidity == prevPoolStakedLiquidity,
    |                 "Pool staked liquidity changed even though position staked out of range."
    |             );
    |         }
    |     }
    | 
    |     function testStakeNonExistentPoolIdReverts() public {
    |         uint64 failureArg = uint64(3214);
    |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
    |         __hyperTestingContract__.stake(failureArg, 100);
    |     }
    | 
    |     function testStakeZeroLiquidityRevertsWithInsufficientPosition() public {
    |         vm.expectRevert(abi.encodeWithSelector(InsufficientPosition.selector, defaultScenario.poolId));
    |         __hyperTestingContract__.stake(defaultScenario.poolId, 100);
    |     }
    | 
    |     // --- Unstake Position --- //
    | 
    |     function testUnstakeExternalEpochIncrements() public {
    |         uint8 amount = 0x05;
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, amount);
    |         __hyperTestingContract__.stake(defaultScenario.poolId, amount);
    | 
    |         uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
    |             .unstakeTimestamp;
    | 
    |         customWarp(prevId + 1);
    |         __hyperTestingContract__.unstake(defaultScenario.poolId, amount);
    |         uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
    |             .unstakeTimestamp;
    | 
    |         // todo: add better tests
    |         //assertTrue(nextId != prevId);
    |     }
    | 
    |     function testUnstakePositionStakedUpdated() public postTestInvariantChecks {
    |         uint8 amount = 0x01;
    |         uint8 power = 0x0f;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint128 stakeAmount = uint128(amount * 10 ** power);
    | 
    |         uint64 positionId = defaultScenario.poolId;
    |         data = Enigma.encodeStakePosition(positionId, stakeAmount);
    |         success = __revertCatcher__.process(data);
    | 
    |         HyperPosition memory pos = getPosition(
    |             address(__hyperTestingContract__),
    |             address(this),
    |             defaultScenario.poolId
    |         );
    | 
    |         // touch pool to update it so we know how much staked liquidity the position has
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x09, 0x01, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    | 
    |         HyperPosition memory revertCatcherPos = defaultRevertCatcherPosition();
    | 
    |         uint256 prevPositionStaked = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).unstakeTimestamp;
    | 
    |         uint prevStaked = revertCatcherPos.stakedLiquidity;
    | 
    |         data = Enigma.encodeUnstakePosition(positionId, stakeAmount);
    |         customWarp(prevPositionStaked + 1);
    |         success = __revertCatcher__.process(data);
    |         revertCatcherPos = defaultRevertCatcherPosition();
    | 
    |         uint256 nextPositionStaked = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             positionId
    |         ).unstakeTimestamp;
    | 
    |         uint postStaked = revertCatcherPos.stakedLiquidity;
    |         assertEq(postStaked, prevStaked - stakeAmount, "stake-liquidity-decreases");
    |         assertTrue(postStaked < prevStaked, "stake-did-not-decrease");
    |         //assertTrue(nextPositionStaked != prevPositionStaked, "Position staked did not update.");
    |         //assertTrue(nextPositionStaked != 0, "Position staked is true.");
    |     }
    | 
    |     // note: some unintended side effects most likely from update/sync pool messing with price
    |     // it creates a discrepency in the contract where the contract holds more tokens than the sum
    |     // of all claims is entitled to.
    |     function testUnstakePoolStakedLiquidityUpdated() public postTestInvariantChecks {
    |         uint8 amount = 0x01;
    |         uint8 power = 0x0f;
    |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    | 
    |         uint64 positionId = defaultScenario.poolId;
    |         data = Enigma.encodeStakePosition(positionId, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         // touch pool to update it so we know how much staked liquidity the position has
    |         uint8 useMax = 0;
    |         uint8 direction = 0;
    |         uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();
    |         data = Enigma.encodeSwap(useMax, positionId, 0x09, 0x01, 0x0, limit, direction);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), positionId).stakedLiquidity;
    | 
    |         HyperPosition memory pos = defaultRevertCatcherPosition();
    |         customWarp(pos.unstakeTimestamp + 1);
    |         data = Enigma.encodeUnstakePosition(positionId, amount);
    |         success = __revertCatcher__.process(data);
    | 
    |         pos = defaultRevertCatcherPosition();
    |         customWarp((pos.unstakeTimestamp + 1) * 2);
    | 
    |         // TODO: FIX FAILING TEST
    | 
    |         // touch pool to update it so we know how much staked liquidity the position has
    |         // data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, 0x01, 0x15, 0x01, 0);
    |         // success = __revertCatcher__.process(data);
    |         //
    |         // // todo: currently fails because unstaking does not change staked liquidity.
    |         // uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__),defaultScenario.poolId).stakedLiquidity;
    |         //
    |         // if (lo <= getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick && hi > getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick) {
    |         //     assertTrue(nextPoolStakedLiquidity < prevPoolStakedLiquidity, "Pool staked liquidity did not increase.");
    |         //     assertTrue(nextPoolStakedLiquidity == 0, "Pool staked liquidity does not equal 0 after unstake.");
    |         // } else {
    |         //     assertTrue(
    |         //         nextPoolStakedLiquidity == prevPoolStakedLiquidity,
    |         //         "Pool staked liquidity changed even though position staked out of range."
    |         //     );
    |         // }
    |     }
    | 
    |     function testUnstakeNonExistentPoolIdReverts() public {
    |         uint64 failureArg = 1224;
    |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
    |         __hyperTestingContract__.unstake(failureArg, 555);
    |     }
    | 
    |     function testUnstakeNotStakedReverts() public {
    |         vm.expectRevert(abi.encodeWithSelector(PositionNotStaked.selector, defaultScenario.poolId));
    |         __hyperTestingContract__.unstake(defaultScenario.poolId, 555);
    |     }
    | 
    |     // --- Create HyperPair --- //
    | 
    |     function testCreatePairSameTokensReverts() public {
    |         address token = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(token, token);
    |         vm.expectRevert(SameTokenError.selector);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(!success, "forwarder call failed");
    |     }
    | 
    |     function testCreatePairPairExistsReverts() public {
    |         bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.asset), address(defaultScenario.quote));
    |         vm.expectRevert(abi.encodeWithSelector(PairExists.selector, 1));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreatePairLowerDecimalBoundsAssetReverts() public {
    |         address token0 = address(new TestERC20("t", "t", 5));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreatePairLowerDecimalBoundsQuoteReverts() public {
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 5));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreatePairUpperDecimalBoundsAssetReverts() public {
    |         address token0 = address(new TestERC20("t", "t", 24));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreatePairUpperDecimalBoundsQuoteReverts() public {
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 24));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreatePairPairNonceIncrementedReturnsOneAdded() public {
    |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         bool success = __revertCatcher__.process(data);
    |         uint256 nonce = __hyperTestingContract__.getPairNonce();
    |         assertEq(nonce, prevNonce + 1);
    |     }
    | 
    |     function testCreatePairFetchesPairIdReturnsNonZero() public {
    |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         bool success = __revertCatcher__.process(data);
    |         uint256 pairId = __hyperTestingContract__.getPairId(token0, token1);
    |         assertTrue(pairId != 0);
    |     }
    | 
    |     function testCreatePairFetchesPairDataReturnsAddresses() public {
    |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         bool success = __revertCatcher__.process(data);
    |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
    |         HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);
    |         assertEq(pair.tokenAsset, token0);
    |         assertEq(pair.tokenQuote, token1);
    |         assertEq(pair.decimalsAsset, 18);
    |         assertEq(pair.decimalsQuote, 18);
    |     }
    | 
    |     /* // --- Create Curve --- //
    | 
    |     function testCreateCurveCurveExistsReverts() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         vm.expectRevert(abi.encodeWithSelector(CurveExists.selector, 1));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreateCurveFeeParameterOutsideBoundsReverts() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         uint16 failureArg = 5e4;
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma,
    |             curve.maturity,
    |             failureArg,
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreateCurvePriorityFeeParameterOutsideBoundsReverts() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         uint16 failureArg = 5e4;
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             failureArg,
    |             curve.strike
    |         );
    |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreateCurveRMMPoolZeroSigmaReverts() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         uint24 failureArg = 0;
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             failureArg,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreateCurveRMMPoolZeroStrikeReverts() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         uint128 failureArg = 0;
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             failureArg
    |         );
    |         vm.expectRevert(abi.encodeWithSelector(InvalidStrike.selector, failureArg));
    |         bool success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreateCurveCurveNonceIncrementReturnsOne() public {
    |         uint256 prevNonce = __hyperTestingContract__.getCurveNonce();
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma + 1,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         uint256 nextNonce = __hyperTestingContract__.getCurveNonce();
    |         assertEq(prevNonce, nextNonce - 1);
    |     }
    | 
    |     function testCreateCurveFetchesCurveIdReturnsNonZero() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma + 1,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         bytes32 rawCurveId = Enigma.toBytes32(
    |             abi.encodePacked(
    |                 curve.sigma + 1,
    |                 curve.maturity,
    |                 uint16(1e4 - curve.gamma),
    |                 uint16(1e4 - curve.priorityGamma),
    |                 curve.strike
    |             )
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
    |         assertTrue(curveId != 0);
    |     }
    | 
    |     function testCreateCurveFetchesCurveDataReturnsParametersSet() public {
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         bytes memory data = Enigma.encodeCreateCurve(
    |             curve.sigma + 1,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         bytes32 rawCurveId = Enigma.toBytes32(
    |             abi.encodePacked(
    |                 curve.sigma + 1,
    |                 curve.maturity,
    |                 uint16(1e4 - curve.gamma),
    |                 uint16(1e4 - curve.priorityGamma),
    |                 curve.strike
    |             )
    |         );
    |         bool success = __revertCatcher__.process(data);
    |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
    |         HyperCurve memory newCurve = getCurve(address(__hyperTestingContract__), curveId);
    |         assertEq(newCurve.sigma, curve.sigma + 1);
    |         assertEq(newCurve.maturity, curve.maturity);
    |         assertEq(newCurve.gamma, curve.gamma);
    |         assertEq(newCurve.priorityGamma, curve.priorityGamma);
    |         assertEq(newCurve.strike, curve.strike);
    |     } */
    | 
    |     // --- Create Pool --- //
    |     // todo: fix
    | 
    |     /* function testCreatePoolZeroPriceParameterReverts() public {
    |         uint128 failureArg = 0;
    |         bytes memory data = Enigma.encodeCreatePool(1, failureArg);
    |         vm.expectRevert(ZeroPrice.selector);
    |         bool success = __revertCatcher__.process(data);
    |     } */
    | 
    |     // todo: fix
    |     /* function testCreatePoolExistentPoolReverts() public {
    |         uint64 failureArg = defaultScenario.poolId;
    |         bytes memory data = Enigma.encodeCreatePool(failureArg, 1);
    |         vm.expectRevert(PoolExists.selector);
    |         bool success = __revertCatcher__.process(data);
    |     } */
    | 
    |     // todo: fix
    |     /* function testCreatePoolMagicPairId() public {
    |         // Create a new curve to increment the nonce to 2
    |         bytes memory data = Enigma.encodeCreateCurve(4, type(uint32).max - 1, 4, 4, 4);
    |         __revertCatcher__.process(data);
    | 
    |         uint64 magicVariable = 0x000000000002;
    |         data = Enigma.encodeCreatePool(magicVariable, 1);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |     } */
    |     /* 
    |     function testCreatePoolMagicCurveId() public {
    |         // Create a new pair to increment the nonce to 2
    |         bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.quote), address(__weth__));
    |         __revertCatcher__.process(data);
    | 
    |         uint64 magicVariable = 0x000200000000;
    |         data = Enigma.encodeCreatePool(magicVariable, 1);
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success);
    |     }
    | 
    |     function testCreatePoolRMMPoolExpiredReverts() public {
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         bool success = __revertCatcher__.process(data);
    |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
    | 
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         data = Enigma.encodeCreateCurve(
    |             curve.sigma + 1,
    |             uint32(0),
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         bytes32 rawCurveId = Enigma.toBytes32(
    |             abi.encodePacked(curve.sigma + 1, uint32(0), uint16(1e4 - curve.gamma), curve.strike)
    |         );
    |         success = __revertCatcher__.process(data);
    | 
    |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
    |         uint64 id = Enigma.encodePoolId(pairId, curveId);
    |         data = Enigma.encodeCreatePool(id, 1_000);
    |         vm.expectRevert(PoolExpired.selector);
    |         success = __revertCatcher__.process(data);
    |     }
    | 
    |     function testCreatePoolFetchesPoolDataReturnsNonZeroBlockTimestamp() public {
    |         address token0 = address(new TestERC20("t", "t", 18));
    |         address token1 = address(new TestERC20("t", "t", 18));
    |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
    |         bool success = __revertCatcher__.process(data);
    |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
    | 
    |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
    |         data = Enigma.encodeCreateCurve(
    |             curve.sigma + 1,
    |             curve.maturity,
    |             uint16(1e4 - curve.gamma),
    |             uint16(1e4 - curve.priorityGamma),
    |             curve.strike
    |         );
    |         bytes32 rawCurveId = Enigma.toBytes32(
    |             abi.encodePacked(
    |                 curve.sigma + 1,
    |                 curve.maturity,
    |                 uint16(1e4 - curve.gamma),
    |                 uint16(1e4 - curve.priorityGamma),
    |                 curve.strike
    |             )
    |         );
    |         success = __revertCatcher__.process(data);
    | 
    |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
    |         uint64 id = Enigma.encodePoolId(pairId, curveId);
    |         data = Enigma.encodeCreatePool(id, 1_000);
    |         success = __revertCatcher__.process(data);
    | 
    |         uint256 time = getPool(address(__hyperTestingContract__), id).lastTimestamp;
    |         assertTrue(time != 0);
    |     } */
    | }
    | 

/root/code/hyper/test/foundry/TestHyperSwap.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "contracts/HyperLib.sol" as HyperTypes;
    | import "./setup/TestHyperSetup.sol";
    | import "test/helpers/HelperHyperProfiles.sol";
    | 
    | contract TestHyperSwap is TestHyperSetup {
    |     modifier allocateFirst() {
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, 10 ether);
    |         _;
    |     }
    | 
    |     function testSwap_should_succeed() public allocateFirst {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    | 
    |         uint input = DEFAULT_SWAP_INPUT;
    |         uint expected = DEFAULT_SWAP_OUTPUT; // 6 decimals
    |         (uint out, ) = pool.getAmountOut(
    |             getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40)),
    |             true,
    |             input,
    |             0
    |         );
    | 
    |         (uint output, uint remainder) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             true,
    |             input,
    |             0 // limit
    |         );
    | 
    |         assertEq(output, expected, "expected-output");
    | 
    |         (uint amount0, uint amount1) = pool.getAmounts();
    |         console.log("amounts", amount0, amount1);
    |         console.log("outputs, actual, expected", output, out);
    |     }
    | 
    |     function testSwap_back_and_forth_outputs_less() public allocateFirst {
    |         uint256 start = 10000;
    | 
    |         bool direction = false;
    |         (uint output, ) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             direction,
    |             start,
    |             direction ? 0 : type(uint128).max
    |         );
    | 
    |         direction = true;
    |         (uint finalOutput, ) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             direction,
    |             output,
    |             direction ? 0 : type(uint128).max
    |         );
    | 
    |         assertGt(start, finalOutput);
    |     }
    | 
    |     function testSwap_revert_PoolExpired() public allocateFirst {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         uint end = pool.params.createdAt + Assembly.convertDaysToSeconds(pool.params.duration);
    |         customWarp(end + 1);
    |         vm.expectRevert(PoolExpired.selector);
    |         __hyperTestingContract__.swap(defaultScenario.poolId, false, 10000, type(uint128).max);
    |     }
    | 
    |     function testSwap_revert_ZeroInput() public {
    |         vm.expectRevert(ZeroInput.selector);
    |         __hyperTestingContract__.swap(defaultScenario.poolId, true, 0, 0);
    |     }
    | 
    |     /*
    |     function testSwap_revert_NonExistentPool() public {
    |         vm.expectRevert(NonExistentPool.selector);
    |         __hyperTestingContract__.swap(
    |             42,
    |             true,
    |             1,
    |             0
    |         );
    |     }
    |     */
    | }
    | 

/root/code/hyper/test/foundry/TestHyperUnallocate.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestHyperSetup.sol";
    | 
    | contract TestHyperUnallocate is TestHyperSetup {
    |     function testUnallocateUseMax() public postTestInvariantChecks {
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
    | 
    |         uint maxLiquidity = getPosition(address(__hyperTestingContract__), msg.sender, defaultScenario.poolId)
    |             .freeLiquidity;
    | 
    |         __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint256).max);
    | 
    |         assertEq(0, getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity);
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestPriceComputePrice.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestPriceSetup.sol";
    | 
    | contract TestPriceComputePrice is TestPriceSetup {
    |     using Price for Price.RMM;
    | 
    |     function testComputedPriceWithDefaultAssetReserve() public {
    |         uint actual = cases[0].getPriceWithX(DEFAULT_ASSET_RESERVE);
    |         uint err = 1e4; // TODO: Fix for error...
    |         assertTrue(actual <= DEFAULT_PRICE + err && actual >= DEFAULT_PRICE - err);
    |     }
    | 
    |     // ===== Raw ===== //
    | 
    |     function testComputePriceWithZeroChangeInTauReturnsPrice() public {
    |         uint price = DEFAULT_PRICE;
    |         uint actual = cases[0].computePriceWithChangeInTau(price, 0);
    |         assertEq(actual, price);
    |     }
    | 
    |     function testComputePriceWithEpsilonEqualsTauReturnsStrike() public {
    |         Price.RMM memory info = cases[0];
    |         uint price = DEFAULT_PRICE;
    |         uint epsilon = info.tau;
    |         uint actual = info.computePriceWithChangeInTau(price, epsilon);
    |         assertEq(actual, info.strike);
    |     }
    | 
    |     function testFuzzComputePriceWithChangeInTau(uint32 epsilon) public {
    |         Price.RMM memory info = cases[0];
    |         // Fuzzing Filters
    |         vm.assume(epsilon > 0); // Fuzzing non-zero test cases only.
    |         vm.assume(epsilon < info.tau); // Epsilon > tau is the same as epsilon == tau.
    | 
    |         // Behavior: as epsilon gets larger, tau gets smaller, price increases, reaches inflection, price tends to strike after inflection point.
    |         uint price = DEFAULT_PRICE;
    |         uint actual = info.computePriceWithChangeInTau(price, epsilon);
    |         uint actualDiff = actual - info.strike;
    |         uint expectedDiff = price - info.strike;
    |         assertTrue(actualDiff > expectedDiff); // maybe? As tau gets smaller, price should increase until epsilon >= tau.
    |     }
    | 
    |     function testComputePriceWithEpsilonChangeEqualToTauReturnsPrice() public {
    |         uint price = DEFAULT_PRICE;
    |         uint actual = cases[0].computePriceWithChangeInTau(price, cases[0].tau);
    |         assertEq(actual, price);
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestPriceComputeReserves.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestPriceSetup.sol";
    | 
    | contract TestPriceComputeReserves is TestPriceSetup {
    |     using Price for Price.RMM;
    | 
    |     function testComputedAssetReserveWithDefaultPrice() public {
    |         uint actual = cases[0].getXWithPrice(DEFAULT_PRICE);
    |         assertEq(actual, DEFAULT_ASSET_RESERVE);
    |     }
    | 
    |     function testComputedQuoteReserveWithDefaultAssetReserve() public {
    |         uint actual = cases[0].getYWithX(DEFAULT_ASSET_RESERVE);
    |         assertEq(actual, DEFAULT_QUOTE_RESERVE);
    |     }
    | 
    |     function testComputedAssetReserveWithDefaultQuoteReserve() public {
    |         uint actual = cases[0].getXWithY(DEFAULT_QUOTE_RESERVE);
    |         assertEq(actual, DEFAULT_ASSET_RESERVE);
    |     }
    | 
    |     function testComputedReservesWithDefaultPrice() public {
    |         (uint actualQuoteReserve, uint actualAssetReserve) = cases[0].computeReserves(DEFAULT_PRICE);
    |         assertEq(actualQuoteReserve, DEFAULT_QUOTE_RESERVE);
    |         assertEq(actualAssetReserve, DEFAULT_ASSET_RESERVE);
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestPriceInvariant.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestPriceSetup.sol";
    | 
    | contract TestPriceInvariant is TestPriceSetup {
    |     using Price for Price.RMM;
    | 
    |     function testInvariantReturnsZeroWithDefaultPool() public {
    |         int actual = cases[0].invariantOf(DEFAULT_QUOTE_RESERVE, DEFAULT_ASSET_RESERVE);
    |         assertEq(actual, 0);
    |     }
    | }
    | 

/root/code/hyper/test/foundry/TestPriceUtils.t.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "./setup/TestPriceSetup.sol";
    | 
    | contract TestPriceUtils is TestPriceSetup {
    |     // ===== Utils ===== //
    | 
    |     function testConvertPercentageReturnsOne() public {
    |         uint percentage = Price.PERCENTAGE;
    |         uint expected = Price.WAD;
    |         uint converted = Price.convertPercentageToWad(percentage);
    |         assertEq(converted, expected);
    |     }
    | 
    |     function testFuzzConvertPercentageReturnsComputedValue(uint percentage) public {
    |         vm.assume(percentage < type(uint64).max);
    |         uint expected = (percentage * Price.WAD) / Price.PERCENTAGE;
    |         uint converted = Price.convertPercentageToWad(percentage);
    |         assertEq(converted, expected);
    |     }
    | }
    | 

/root/code/hyper/test/foundry/setup/TestHyperSetup.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "solmate/tokens/WETH.sol";
    | import "solmate/utils/SafeCastLib.sol";
    | import "contracts/HyperLib.sol";
    | import "contracts/libraries/Price.sol";
    | 
    | import "forge-std/Test.sol";
    | import {TestERC20, Hyper, HyperTimeOverride, HyperCatchReverts, RevertCatcher, FixedPointMathLib} from "test/helpers/HyperTestOverrides.sol";
    | 
    | import "test/helpers/HelperHyperActions.sol";
    | import "test/helpers/HelperHyperInvariants.sol";
    | import "test/helpers/HelperHyperProfiles.sol";
    | import "test/helpers/HelperHyperView.sol";
    | 
    | uint constant STARTING_BALANCE = 4000e18;
    | 
    | struct TestScenario {
    |     TestERC20 asset;
    |     TestERC20 quote;
    |     uint64 poolId;
    |     string label;
    | }
    | 
    | /** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */
    | contract TestHyperSetup is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView, Test {
    |     using FixedPointMathLib for uint256;
    |     using FixedPointMathLib for int256;
    |     using SafeCastLib for uint;
    | 
    |     WETH public __weth__;
    |     Hyper public __hyper__; // Actual contract
    |     HyperTimeOverride public __hyperTimeOverride__; // Inherits Hyper, adds block.timestamp and jit policy overrides
    |     HyperCatchReverts public __hyperTestingContract__; // Inherits HyperTimeOverrides, adds endpoints to process functions.
    |     RevertCatcher public __revertCatcher__;
    | 
    |     TestERC20 public __usdc__;
    |     TestERC20 public __token_8__;
    |     TestERC20 public __token_18__;
    |     TestERC20 public __badToken__;
    | 
    |     address[] public __contracts__;
    |     address[] public __users__;
    |     address[] public __tokens__;
    | 
    |     TestScenario public defaultScenario;
    |     TestScenario[] public scenarios;
    | 
    |     modifier postTestInvariantChecks() virtual {
    |         _;
    |         assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.asset), __users__);
    |         assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.quote), __users__);
    |     }
    | 
    |     function setUp() public {
    |         initContracts();
    |         initUsers();
    |         initScenarios();
    |         initPrerequisites();
    |         afterSetUp();
    |     }
    | 
    |     function getState() public view returns (HyperState memory) {
    |         return getState(address(__hyperTestingContract__), defaultScenario.poolId, address(this), __users__);
    |     }
    | 
    |     /** Hook to override receive. Defaults to just accepting ether sent to this test contract. */
    |     receive() external payable {
    |         receiveOverride();
    |     }
    | 
    |     /** @dev Hook to run after test setup. */
    |     function afterSetUp() public virtual {}
    | 
    |     function receiveOverride() public virtual {}
    | 
    |     function initContracts() internal {
    |         __weth__ = new WETH();
    | 
    |         // --- Hyper Contracts --- //
    |         __hyper__ = new Hyper(address(__weth__));
    |         __hyperTimeOverride__ = new HyperTimeOverride(address(__weth__));
    |         __hyperTestingContract__ = new HyperCatchReverts(address(__weth__));
    |         __revertCatcher__ = new RevertCatcher(address(__hyperTestingContract__));
    |         __contracts__.push(address(__hyper__));
    |         __contracts__.push(address(__hyperTimeOverride__));
    |         __contracts__.push(address(__hyperTestingContract__));
    |         __contracts__.push(address(__revertCatcher__));
    | 
    |         __usdc__ = new TestERC20("USD Coin", "USDC", 6);
    |         __token_8__ = new TestERC20("8 Decimals", "8DEC", 8);
    |         __token_18__ = new TestERC20("18 Decimals", "18DEC", 18);
    |         __badToken__ = new TestERC20("Non-standard ERC20", "BAD", 18); // TODO: Add proper bad token.
    |         __tokens__.push(address(__usdc__));
    |         __tokens__.push(address(__token_8__));
    |         __tokens__.push(address(__token_18__));
    |         __tokens__.push(address(__badToken__));
    | 
    |         setLabels();
    |     }
    | 
    |     function initUsers() internal {
    |         address self = address(this);
    |         address alicent = address(0x0001);
    |         address boba = address(0x0002);
    |         address revertCatcher = address(__revertCatcher__);
    | 
    |         vm.label(self, "Self");
    |         vm.label(alicent, "Alicent");
    |         vm.label(boba, "Boba");
    | 
    |         __users__.push(self);
    |         __users__.push(alicent);
    |         __users__.push(boba);
    |         __users__.push(revertCatcher);
    |     }
    | 
    |     function initScenarios() internal {
    |         __hyperTestingContract__.setTimestamp(uint128(block.timestamp)); // Important
    |         // Create default pool
    |         bytes memory data = createPool(
    |             address(__token_18__),
    |             address(__usdc__),
    |             address(0),
    |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
    |             uint16(1e4 - DEFAULT_GAMMA),
    |             uint16(DEFAULT_SIGMA),
    |             uint16(DEFAULT_DURATION_DAYS),
    |             DEFAULT_JIT,
    |             DEFAULT_TICK,
    |             DEFAULT_PRICE
    |         );
    | 
    |         bool success = __revertCatcher__.jumpProcess(data);
    |         assertTrue(success, "__revertCatcher__ call failed");
    | 
    |         // Create default scenario and add to all scenarios.
    |         defaultScenario = TestScenario(__token_18__, __usdc__, FIRST_POOL, "Default");
    |         scenarios.push(defaultScenario);
    |     }
    | 
    |     uint64 public constant FIRST_POOL = 0x0000010000000001;
    |     uint64 public constant SECOND_POOL_FIRST_PAIR = 0x0000010000000002;
    | 
    |     /** @dev Requires tokens to be spent and spenders to be approved. */
    |     function initPrerequisites() internal {
    |         fundUsers();
    |         approveTokens();
    |     }
    | 
    |     /** @dev Does not include weth. */
    |     function approveTokens() internal {
    |         for (uint x; x != __tokens__.length; ++x) {
    |             for (uint y; y != __contracts__.length; ++y) {
    |                 for (uint z; z != __users__.length; ++z) {
    |                     vm.prank(__users__[z]); // Sets caller
    |                     TestERC20(__tokens__[x]).approve(__contracts__[y], type(uint256).max); // Approves test contracts to spend tokens.
    |                 }
    |             }
    |         }
    |     }
    | 
    |     /** @dev Does not include weth. */
    |     function fundUsers() internal {
    |         for (uint i; i != __users__.length; ++i) {
    |             for (uint j; j != __tokens__.length; ++j) {
    |                 deal(__tokens__[j], __users__[i], STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.
    |             }
    |         }
    |     }
    | 
    |     function setLabels() internal {
    |         vm.label(address(this), "Self");
    |         vm.label(address(__weth__), "Weth");
    |         vm.label(address(__revertCatcher__), "RevertCatcher");
    |         vm.label(address(__hyper__), "DefaultHyper");
    |         vm.label(address(__hyperTimeOverride__), "HyperTimeOverride");
    |         vm.label(address(__hyperTestingContract__), "HyperCatchReverts");
    |         vm.label(address(__usdc__), "USDC");
    |         vm.label(address(__token_8__), "Token8Decimals");
    |         vm.label(address(__token_18__), "Token18Decimals");
    |         vm.label(address(__badToken__), "BadToken");
    |     }
    | 
    |     function customWarp(uint time) internal {
    |         vm.warp(time);
    |         __hyperTestingContract__.setTimestamp(uint128(time));
    |     }
    | 
    |     function createControlledPool() internal {
    |         bytes memory data = Enigma.encodeCreatePool(
    |             uint24(1), // first pair, is it good in this test?
    |             address(this),
    |             100,
    |             DEFAULT_FEE,
    |             DEFAULT_VOLATILITY,
    |             DEFAULT_DURATION,
    |             DEFAULT_JIT,
    |             DEFAULT_MAX_TICK,
    |             DEFAULT_PRICE
    |         );
    | 
    |         bool success = __revertCatcher__.process(data);
    |         assertTrue(success, "controlled pool not created");
    | 
    |         // assumes second pool has not been created...
    |         // can be fixed by getting pool nonce and encoding pool id.
    |         uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(__hyperTestingContract__.getPoolNonce()));
    |         scenarios.push(TestScenario(__token_18__, __usdc__, poolId, "Controlled"));
    |     }
    | 
    |     function basicSwap() internal {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         (uint output, ) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             true,
    |             (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether,
    |             1
    |         );
    | 
    |         assertTrue(output > 0, "no swap happened!");
    |     }
    | 
    |     function _swap(uint64 id) internal {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), id);
    |         (uint output, ) = __hyperTestingContract__.swap(id, true, (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether, 1);
    |         assertTrue(output > 0, "no swap happened!");
    |     }
    | 
    |     function basicSwapQuoteIn() internal {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         (uint output, ) = __hyperTestingContract__.swap(
    |             defaultScenario.poolId,
    |             false,
    |             (pool.getMaxSwapQuoteInWad() * 1 ether) / 2 ether,
    |             type(uint256).max
    |         );
    | 
    |         assertTrue(output > 0, "no swap happened!");
    |     }
    | 
    |     function basicAllocate() internal {
    |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
    |     }
    | 
    |     function _alloc(uint64 id) internal {
    |         __hyperTestingContract__.allocate(id, 1 ether);
    |     }
    | 
    |     function basicUnallocate() internal {
    |         __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint).max); // max
    |     }
    | 
    |     function maxDraw() internal {
    |         __hyperTestingContract__.draw(
    |             address(defaultScenario.asset),
    |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),
    |             address(this)
    |         );
    |         __hyperTestingContract__.draw(
    |             address(defaultScenario.quote),
    |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),
    |             address(this)
    |         );
    |     }
    | 
    |     function defaultPool() internal view returns (HyperPool memory) {
    |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
    |         return pool;
    |     }
    | 
    |     function defaultRevertCatcherPosition() internal view returns (HyperPosition memory) {
    |         HyperPosition memory pos = getPosition(
    |             address(__hyperTestingContract__),
    |             address(__revertCatcher__),
    |             defaultScenario.poolId
    |         );
    |         return pos;
    |     }
    | 
    |     function defaultPosition() internal view returns (HyperPosition memory) {
    |         HyperPosition memory pos = getPosition(
    |             address(__hyperTestingContract__),
    |             address(this),
    |             defaultScenario.poolId
    |         );
    |         return pos;
    |     }
    | 
    |     /** @dev Casted to returns structs as memory */
    |     function hs() internal view returns (IHyperStruct) {
    |         return IHyperStruct(address(__hyperTestingContract__));
    |     }
    | 
    |     function hx() internal view returns (HyperLike) {
    |         return HyperLike(address(__hyperTestingContract__));
    |     }
    | }
    | 

/root/code/hyper/test/foundry/setup/TestPriceSetup.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "forge-std/Test.sol";
    | import "contracts/libraries/Price.sol";
    | import "test/helpers/HelperHyperProfiles.sol";
    | 
    | contract TestPriceSetup is HelperHyperProfiles, Test {
    |     Price.RMM[] cases;
    | 
    |     function setUp() public {
    |         addTestCase(DEFAULT_STRIKE, DEFAULT_SIGMA, DEFAULT_MATURITY);
    |     }
    | 
    |     function addTestCase(uint strike, uint sigma, uint tau) internal returns (Price.RMM memory) {
    |         Price.RMM memory info = Price.RMM(strike, sigma, tau);
    |         cases.push(info);
    |         return info;
    |     }
    | }
    | 

/root/code/hyper/test/helpers/HelperHyperActions.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "contracts/Enigma.sol" as ProcessingLib;
    | import "./HelperHyperProfiles.sol";
    | 
    | contract HelperHyperActions {
    |     /** @dev Encodes jump process for creating a pair + curve + pool in one tx. */
    |     function createPool(
    |         address token0,
    |         address token1,
    |         address controller,
    |         uint16 priorityFee,
    |         uint16 fee,
    |         uint16 volatility,
    |         uint16 duration,
    |         uint16 jit,
    |         int24 maxTick,
    |         uint128 price
    |     ) internal pure returns (bytes memory data) {
    |         bytes[] memory instructions = new bytes[](2);
    |         uint24 magicPoolId = 0x000000;
    |         instructions[0] = (ProcessingLib.encodeCreatePair(token0, token1));
    |         instructions[1] = (
    |             ProcessingLib.encodeCreatePool(
    |                 magicPoolId, // magic variable
    |                 controller,
    |                 priorityFee,
    |                 fee,
    |                 volatility,
    |                 duration,
    |                 jit,
    |                 maxTick,
    |                 price
    |             )
    |         );
    |         data = ProcessingLib.encodeJumpInstruction(instructions);
    |     }
    | 
    |     function allocatePool(address hyper, uint64 poolId, uint amount) internal {
    |         bytes memory data = ProcessingLib.encodeAllocate(
    |             0, // useMax = false
    |             poolId,
    |             0x0, // amount multiplier = 10^0 = 1
    |             uint128(amount)
    |         );
    |         (bool success, ) = hyper.call{value: 0}(data);
    |         require(success, "failed to allocate");
    |     }
    | }
    | 

/root/code/hyper/test/helpers/HelperHyperInvariants.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import {HyperLike} from "./HelperHyperView.sol";
    | 
    | interface ERC20Like {
    |     function balanceOf(address) external view returns (uint);
    | }
    | 
    | contract HelperHyperInvariants {
    |     error SettlementInvariantInvalid(uint, uint);
    | 
    |     function assertSettlementInvariant(
    |         address hyper,
    |         address token,
    |         address[] memory accounts
    |     ) internal view returns (bool) {
    |         uint reserve = HyperLike(hyper).getReserve(token);
    |         uint physical = ERC20Like(token).balanceOf(hyper);
    |         if (reserve > physical) revert SettlementInvariantInvalid(physical, reserve);
    |         return true;
    |     }
    | }
    | 

/root/code/hyper/test/helpers/HelperHyperProfiles.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | uint128 constant DEFAULT_STRIKE = 10e18;
    | uint24 constant DEFAULT_SIGMA = 1e4;
    | uint32 constant DEFAULT_MATURITY = 31556953; // adds 1
    | uint16 constant DEFAULT_FEE = 100; // 100 bps = 1%
    | uint32 constant DEFAULT_GAMMA = 9900;
    | uint32 constant DEFAULT_PRIORITY_GAMMA = 9950;
    | uint16 constant DEFAULT_DURATION_DAYS = 365;
    | uint128 constant DEFAULT_QUOTE_RESERVE = 3085375116376210650;
    | uint128 constant DEFAULT_ASSET_RESERVE = 308537516918601823; // 308596235182
    | uint128 constant DEFAULT_LIQUIDITY = 1e18;
    | uint128 constant DEFAULT_PRICE = 10e18;
    | int24 constant DEFAULT_TICK = int24(23027); // 10e18, rounded up! pay attention
    | uint constant DEFAULT_SWAP_INPUT = 0.1 ether;
    | uint constant DEFAULT_SWAP_OUTPUT = 97_627 wei;
    | uint16 constant DEFAULT_JIT = 4;
    | uint16 constant DEFAULT_VOLATILITY = 10_000;
    | uint16 constant DEFAULT_DURATION = 365;
    | int24 constant DEFAULT_MAX_TICK = int24(23027);
    | 
    | contract HelperHyperProfiles {}
    | 

/root/code/hyper/test/helpers/HelperHyperView.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "contracts/Enigma.sol" as Processor;
    | import "contracts/OS.sol" as Operating;
    | import {HyperPair, HyperCurve, HyperPool, HyperPosition} from "contracts/HyperLib.sol";
    | import {TestERC20} from "contracts/test/TestERC20.sol";
    | 
    | interface IHyperStruct {
    |     function pairs(uint24 pairId) external view returns (HyperPair memory);
    | 
    |     function positions(address owner, uint64 positionId) external view returns (HyperPosition memory);
    | 
    |     function pools(uint64 poolId) external view returns (HyperPool memory);
    | }
    | 
    | interface HyperLike {
    |     function getReserve(address) external view returns (uint);
    | 
    |     function getBalance(address, address) external view returns (uint);
    | 
    |     function getPairNonce() external view returns (uint16);
    | }
    | 
    | struct HyperState {
    |     uint reserveAsset; // getReserve
    |     uint reserveQuote; // getReserve
    |     uint physicalBalanceAsset; // balanceOf
    |     uint physicalBalanceQuote; // balanceOf
    |     uint totalBalanceAsset; // sum of all balances from getBalance
    |     uint totalBalanceQuote; // sum of all balances from getBalance
    |     uint totalPositionLiquidity; // sum of all position liquidity
    |     uint callerPositionLiquidity; // position.freeLiquidity
    |     uint totalPoolLiquidity; // pool.liquidity
    |     uint feeGrowthAssetPool; // getPool
    |     uint feeGrowthQuotePool; // getPool
    |     uint feeGrowthAssetPosition; // getPosition
    |     uint feeGrowthQuotePosition; // getPosition
    | }
    | 
    | interface TokenLike {
    |     function balanceOf(address) external view returns (uint);
    | }
    | 
    | contract HelperHyperView {
    |     function getPool(address hyper, uint64 poolId) internal view returns (HyperPool memory) {
    |         return IHyperStruct(hyper).pools(poolId);
    |     }
    | 
    |     function getCurve(address hyper, uint64 poolId) internal view returns (HyperCurve memory) {
    |         HyperPool memory pool = getPool(hyper, poolId);
    |         return pool.params;
    |     }
    | 
*   |     function getPair(address hyper, uint24 pairId) internal view returns (HyperPair memory) {
*   |         return IHyperStruct(hyper).pairs(pairId);
    |     }
    | 
    |     function getPosition(address hyper, address owner, uint64 positionId) internal view returns (HyperPosition memory) {
    |         return IHyperStruct(hyper).positions(owner, positionId);
    |     }
    | 
*   |     function getReserve(address hyper, address token) internal view returns (uint) {
*   |         return HyperLike(hyper).getReserve(token);
    |     }
    | 
    |     function getBalance(address hyper, address owner, address token) internal view returns (uint) {
    |         return HyperLike(hyper).getBalance(owner, token);
    |     }
    | 
    |     function _getPool(IHyperStruct hyper, uint64 poolId) internal view returns (HyperPool memory) {
    |         return (hyper).pools(poolId);
    |     }
    | 
    |     function _getPosition(
    |         IHyperStruct hyper,
    |         address owner,
    |         uint64 positionId
    |     ) internal view returns (HyperPosition memory) {
    |         return hyper.positions(owner, positionId);
    |     }
    | 
    |     function _getReserve(HyperLike hyper, TestERC20 token) internal view returns (uint) {
    |         return hyper.getReserve(address(token));
    |     }
    | 
    |     function _getBalance(HyperLike hyper, address owner, TestERC20 token) internal view returns (uint) {
    |         return hyper.getBalance(owner, address(token));
    |     }
    | 
    |     /** @dev Fetches pool state and account state for a single pool's tokens. */
    |     function getState(
    |         address hyper,
    |         uint64 poolId,
    |         address caller,
    |         address[] memory owners
    |     ) internal view returns (HyperState memory) {
    |         HyperPair memory pair = getPair(hyper, Processor.decodePairIdFromPoolId(poolId));
    |         address asset = pair.tokenAsset;
    |         address quote = pair.tokenQuote;
    | 
    |         HyperPool memory pool = getPool(hyper, poolId);
    |         HyperPosition memory position = getPosition(hyper, caller, poolId);
    | 
    |         HyperState memory state = HyperState(
    |             getReserve(hyper, asset),
    |             getReserve(hyper, quote),
    |             getPhysicalBalance(hyper, asset),
    |             getPhysicalBalance(hyper, quote),
    |             getBalanceSum(hyper, asset, owners),
    |             getBalanceSum(hyper, quote, owners),
    |             getPositionLiquiditySum(hyper, poolId, owners),
    |             position.freeLiquidity,
    |             pool.liquidity,
    |             pool.feeGrowthGlobalAsset,
    |             pool.feeGrowthGlobalQuote,
    |             position.feeGrowthAssetLast,
    |             position.feeGrowthQuoteLast
    |         );
    | 
    |         return state;
    |     }
    | 
    |     function getPhysicalBalance(address hyper, address token) internal view returns (uint) {
    |         return Operating.__balanceOf__(token, hyper);
    |     }
    | 
    |     function getVirtualBalance(address hyper, address token, address[] memory owners) internal view returns (uint) {
    |         uint sum = getReserve(hyper, token) + getBalanceSum(hyper, token, owners);
    |         return sum;
    |     }
    | 
    |     function getBalanceSum(address hyper, address token, address[] memory owners) internal view returns (uint) {
    |         uint sum;
    |         for (uint x; x != owners.length; ++x) {
    |             sum += getBalance(hyper, owners[x], token);
    |         }
    | 
    |         return sum;
    |     }
    | 
    |     function getPositionLiquiditySum(address hyper, uint64 poolId, address[] memory owners) internal view returns (uint) {
    |         uint sum;
    |         for (uint i; i != owners.length; ++i) {
    |             sum += getPosition(hyper, owners[i], poolId).freeLiquidity;
    |         }
    | 
    |         return sum;
    |     }
    | 
    |     function getMaxSwapLimit(bool sellAsset) internal pure returns (uint) {
    |         if (sellAsset) {
    |             // price goes down
    |             return 0;
    |         } else {
    |             // price goes up
    |             return type(uint).max;
    |         }
    |     }
    | }
    | 

/root/code/hyper/test/helpers/HyperTestOverrides.sol
    | // SPDX-License-Identifier: GPL-3.0-only
    | pragma solidity ^0.8.0;
    | 
    | import "contracts/Hyper.sol";
    | import "contracts/HyperLib.sol";
    | import "contracts/test/TestERC20.sol";
    | 
    | contract HyperTimeOverride is Hyper {
    |     constructor(address weth) Hyper(weth) {}
    | 
    |     function _blockTimestamp() internal view override returns (uint128) {
    |         return uint128(timestamp);
    |     }
    | 
    |     function _liquidityPolicy() internal view override returns (uint) {
    |         return jitDelay;
    |     }
    | 
    |     // ===== Added ==== //
    | 
    |     uint public timestamp;
    |     uint public jitDelay;
    | 
    |     function setJitPolicy(uint delay) public {
    |         jitDelay = delay;
    |     }
    | 
    |     function setTimestamp(uint128 time) public {
    |         timestamp = time;
    |     }
    | 
    |     /** @dev Temp jump override for invariant tests. */
    |     function doJumpProcess(bytes calldata data) external payable lock interactions {
    |         Enigma._jumpProcess(data, super._process);
    |     }
    | }
    | 
    | /** @dev To catch reverts, external functions can be called by a contract that has a try-cactch. */
    | contract HyperCatchReverts is HyperTimeOverride {
    |     constructor(address weth) HyperTimeOverride(weth) {}
    | 
    |     // ===== Added ===== //
    | 
    |     /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */
    |     function jumpProcess(bytes calldata data) external payable lock interactions {
    |         Enigma._jumpProcess(data, super._process);
    |     }
    | 
    |     /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */
    |     function process(bytes calldata data) external payable lock interactions {
    |         super._process(data);
    |     }
    | 
    |     /** @dev Solidity does not support error catching with the fallback function, so we use this external function. */
    |     function mockFallback(bytes calldata data) external payable lock interactions {
    |         if (data[0] != Enigma.INSTRUCTION_JUMP) super._process(data);
    |         else Enigma._jumpProcess(data, super._process);
    |     }
    | }
    | 
    | contract RevertCatcher {
    |     HyperCatchReverts public hyper;
    | 
    |     constructor(address hyper_) {
    |         hyper = HyperCatchReverts(payable(hyper_));
    |     }
    | 
    |     receive() external payable {}
    | 
    |     function approve(address token, address spender) external {
    |         TestERC20(token).approve(spender, type(uint256).max);
    |     }
    | 
    |     function mockFallback(bytes calldata data) external payable returns (bool) {
    |         try hyper.mockFallback{value: msg.value}(data) {} catch (bytes memory reason) {
    |             assembly {
    |                 revert(add(32, reason), mload(reason))
    |             }
    |         }
    |         return true;
    |     }
    | 
    |     /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */
    |     function process(bytes calldata data) external payable returns (bool) {
    |         try hyper.process{value: msg.value}(data) {} catch (bytes memory reason) {
    |             assembly {
    |                 revert(add(32, reason), mload(reason))
    |             }
    |         }
    |         return true;
    |     }
    | 
    |     /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */
    |     function jumpProcess(bytes calldata data) external payable returns (bool) {
    |         try hyper.jumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {
    |             assembly {
    |                 revert(add(32, reason), mload(reason))
    |             }
    |         }
    |         return true;
    |     }
    | }
    | 
