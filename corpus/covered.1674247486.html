<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/root/code/hyper/contracts/Assembly.sol</b>
<code>
   1 | *r  | <span class='executed'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>  -------------</span>
   7 |     | <span class='neutral'>  </span>
   8 |     | <span class='neutral'>  Using yul to handle low-level coversions</span>
   9 |     | <span class='neutral'>  can easily be a foot shotgun.</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>  We like the gas reductions.</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>  -------------</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>  Primitive™</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'> */</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>error CastOverflow(uint);</span>
  20 |     | <span class='neutral'>error InvalidLiquidity();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>uint constant SECONDS_PER_DAY = 86_400 seconds;</span>
  23 | *   | <span class='executed'>uint8 constant MIN_DECIMALS = 6;</span>
  24 | *r  | <span class='executed'>uint8 constant MAX_DECIMALS = 18;</span>
  25 | *   | <span class='executed'></span>
  26 | *   | <span class='executed'>function isBetween(uint256 value, uint256 lower, uint256 upper) pure returns (bool valid) {</span>
  27 | *   | <span class='executed'>    return __between(int256(value), int256(lower), int256(upper));</span>
  28 |     | <span class='neutral'>}</span>
  29 | *   | <span class='executed'></span>
  30 | *   | <span class='executed'>function __between(int256 value, int256 lower, int256 upper) pure returns (bool valid) {</span>
  31 |     | <span class='neutral'>    assembly {</span>
  32 |     | <span class='neutral'>        // Is `val` btwn lo and hi, inclusive?</span>
  33 | *   | <span class='executed'>        function isValid(val, lo, hi) -&gt; btwn {</span>
  34 | *   | <span class='executed'>            btwn := iszero(sgt(mul(sub(val, lo), sub(val, hi)), 0)) // iszero(x &gt; amount ? 1 : 0) ? true : false, (n - a) * (n - b) &lt;= 0, n = amount, a = lower, b = upper</span>
  35 |     | <span class='neutral'>        }</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>        valid := isValid(value, lower, upper)</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'>}</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>/** </span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    @dev Reference:</span>
  44 |     | <span class='neutral'>    </span>
  45 |     | <span class='neutral'>    if (delta &lt; 0) {</span>
  46 |     | <span class='neutral'>        output = input - uint128(-delta);</span>
  47 |     | <span class='neutral'>        if (output &gt;= input) revert InvalidLiquidity();</span>
  48 |     | <span class='neutral'>    } else {</span>
  49 |     | <span class='neutral'>        output = input + uint128(delta);</span>
  50 |     | <span class='neutral'>        if (output &lt; input) revert InvalidLiquidity();</span>
  51 |     | <span class='neutral'>    }</span>
  52 | *r  | <span class='executed'>*/</span>
  53 | r   | <span class='reverted'>function addSignedDelta(uint128 input, int128 delta) pure returns (uint128 output) {</span>
  54 | r   | <span class='reverted'>    bytes memory revertData = abi.encodeWithSelector(InvalidLiquidity.selector);</span>
  55 | *r  | <span class='executed'>    assembly {</span>
  56 | *r  | <span class='executed'>        switch slt(delta, 0) // delta &lt; 0 ? 1 : 0</span>
  57 |     | <span class='neutral'>        // negative delta</span>
  58 | r   | <span class='reverted'>        case 1 {</span>
  59 | r   | <span class='reverted'>            output := sub(input, add(not(delta), 1))</span>
  60 | r   | <span class='reverted'>            switch slt(output, input) // output &lt; input ? 1 : 0</span>
  61 | r   | <span class='reverted'>            case 0 {</span>
  62 |     | <span class='neutral'>                // not less than</span>
  63 |     | <span class='unexecuted'>                revert(add(32, revertData), mload(revertData)) // 0x1fff9681</span>
  64 |     | <span class='neutral'>            }</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>        // position delta</span>
  67 | r   | <span class='reverted'>        case 0 {</span>
  68 | r   | <span class='reverted'>            output := add(input, delta)</span>
  69 | r   | <span class='reverted'>            switch slt(output, input) // (output &lt; input ? 1 : 0) == 0 ? 1 : 0</span>
  70 | r   | <span class='reverted'>            case 1 {</span>
  71 |     | <span class='neutral'>                // less than</span>
  72 |     | <span class='unexecuted'>                revert(add(32, revertData), mload(revertData)) // 0x1fff9681</span>
  73 |     | <span class='neutral'>            }</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'>}</span>
  77 |     | <span class='unexecuted'></span>
  78 |     | <span class='neutral'>function computeCheckpoint(uint256 present, uint256 delta) pure returns (uint256 checkpoint) {</span>
  79 |     | <span class='unexecuted'>    checkpoint = present;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    if (delta != 0) {</span>
  82 |     | <span class='neutral'>        // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.</span>
  83 |     | <span class='neutral'>        assembly {</span>
  84 |     | <span class='unexecuted'>            checkpoint := add(present, delta)</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'>}</span>
  88 | r   | <span class='reverted'></span>
  89 |     | <span class='neutral'>function computeCheckpointDistance(uint256 present, uint256 past) pure returns (uint256 distance) {</span>
  90 |     | <span class='neutral'>    // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.</span>
  91 |     | <span class='neutral'>    assembly {</span>
  92 | r   | <span class='reverted'>        distance := sub(present, past)</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'>}</span>
  95 | *r  | <span class='executed'></span>
  96 |     | <span class='neutral'>function convertDaysToSeconds(uint amountDays) pure returns (uint amountSeconds) {</span>
  97 |     | <span class='neutral'>    assembly {</span>
  98 | *r  | <span class='executed'>        amountSeconds := mul(amountDays, SECONDS_PER_DAY)</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>function toBytes32(bytes memory raw) pure returns (bytes32 data) {</span>
 103 |     | <span class='neutral'>    assembly {</span>
 104 |     | <span class='neutral'>        data := mload(add(raw, 32))</span>
 105 |     | <span class='neutral'>        let shift := mul(sub(32, mload(raw)), 8)</span>
 106 |     | <span class='neutral'>        data := shr(shift, data)</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'>}</span>
 109 | r   | <span class='reverted'></span>
 110 |     | <span class='neutral'>function toBytes16(bytes memory raw) pure returns (bytes16 data) {</span>
 111 |     | <span class='neutral'>    assembly {</span>
 112 | r   | <span class='reverted'>        data := mload(add(raw, 32))</span>
 113 | r   | <span class='reverted'>        let shift := mul(sub(16, mload(raw)), 8)</span>
 114 | r   | <span class='reverted'>        data := shr(shift, data)</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'>}</span>
 117 | *r  | <span class='executed'></span>
 118 |     | <span class='neutral'>function separate(bytes1 data) pure returns (bytes1 upper, bytes1 lower) {</span>
 119 | *r  | <span class='executed'>    upper = data &gt;&gt; 4;</span>
 120 | *r  | <span class='executed'>    lower = data &amp; 0x0f;</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='unexecuted'></span>
 123 |     | <span class='neutral'>function pack(bytes1 upper, bytes1 lower) pure returns (bytes1 data) {</span>
 124 |     | <span class='unexecuted'>    data = (upper &lt;&lt; 4) | lower;</span>
 125 |     | <span class='neutral'>}</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>/**</span>
 128 |     | <span class='neutral'> * @dev             Converts an array of bytes into an uint128, the array must adhere</span>
 129 |     | <span class='neutral'> *                  to the the following format:</span>
 130 |     | <span class='neutral'> *                  - First byte: Amount of trailing zeros.</span>
 131 |     | <span class='neutral'> *                  - Rest of the array: A hexadecimal number.</span>
 132 | *r  | <span class='executed'> */</span>
 133 | *r  | <span class='executed'>function toAmount(bytes calldata raw) pure returns (uint128 amount) {</span>
 134 | r   | <span class='reverted'>    uint8 power = uint8(raw[0]);</span>
 135 | r   | <span class='reverted'>    amount = uint128(toBytes16(raw[1:raw.length]));</span>
 136 | *r  | <span class='executed'>    if (power != 0) amount = amount * uint128(10 ** power);</span>
 137 |     | <span class='neutral'>}</span>
 138 | *r  | <span class='executed'></span>
 139 | *r  | <span class='executed'>function computeScalar(uint decimals) pure returns (uint scalar) {</span>
 140 | *r  | <span class='executed'>    return 10 ** (MAX_DECIMALS - decimals); // can revert on underflow</span>
 141 |     | <span class='neutral'>}</span>
 142 | r   | <span class='reverted'></span>
 143 | r   | <span class='reverted'>function scaleToWad(uint amountDec, uint decimals) pure returns (uint outputWad) {</span>
 144 | r   | <span class='reverted'>    uint factor = computeScalar(decimals);</span>
 145 |     | <span class='neutral'>    assembly {</span>
 146 | r   | <span class='reverted'>        outputWad := mul(amountDec, factor)</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='unexecuted'></span>
 150 |     | <span class='unexecuted'>function scaleFromWadUp(uint amountWad, uint decimals) pure returns (uint outputDec) {</span>
 151 |     | <span class='unexecuted'>    uint factor = computeScalar(decimals);</span>
 152 |     | <span class='neutral'>    assembly {</span>
 153 |     | <span class='unexecuted'>        outputDec := add(div(amountWad, factor), 1)</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>}</span>
 156 | *r  | <span class='executed'></span>
 157 | *r  | <span class='executed'>function scaleFromWadDown(uint amountWad, uint decimals) pure returns (uint outputDec) {</span>
 158 | *r  | <span class='executed'>    uint factor = computeScalar(decimals);</span>
 159 |     | <span class='neutral'>    assembly {</span>
 160 | *r  | <span class='executed'>        outputDec := div(amountWad, factor)</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>}</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>function scaleFromWadUpSigned(int amountWad, uint decimals) pure returns (int outputDec) {</span>
 165 |     | <span class='neutral'>    uint factor = computeScalar(decimals);</span>
 166 |     | <span class='neutral'>    assembly {</span>
 167 |     | <span class='neutral'>        outputDec := add(sdiv(amountWad, factor), 1)</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>}</span>
 170 |     | <span class='unexecuted'></span>
 171 |     | <span class='unexecuted'>function scaleFromWadDownSigned(int amountWad, uint decimals) pure returns (int outputDec) {</span>
 172 |     | <span class='unexecuted'>    uint factor = computeScalar(decimals);</span>
 173 |     | <span class='neutral'>    assembly {</span>
 174 |     | <span class='unexecuted'>        outputDec := sdiv(amountWad, factor)</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'>}</span>
 177 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/Enigma.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>  -------------</span>
   7 |     | <span class='neutral'>  </span>
   8 |     | <span class='neutral'>  This is called the Enigma, it&#39;s an alternative ABI.</span>
   9 |     | <span class='neutral'>  Originally, it was designed to compress calldata and therefore</span>
  10 |     | <span class='neutral'>  save gas on optimistic rollup networks.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>  There are levels to the optimizations that can be made for it,</span>
  13 |     | <span class='neutral'>  but this one focuses on the alternative multicall: jump process.</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>  Multicalls will pad all calls to a full bytes32.</span>
  16 |     | <span class='neutral'>  This means two calls are at least 64 bytes.</span>
  17 |     | <span class='neutral'>  This alternative multicall can process over 10 calls in the same 64 bytes.</span>
  18 |     | <span class='neutral'>  The smallest bytes provided by a call is for allocate and unallocate, at 11 bytes.</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>  Multicalls also process transactions sequentially.</span>
  21 |     | <span class='neutral'>  State cannot be carried over transiently between transactions.</span>
  22 |     | <span class='neutral'>  With Enigma, we can transiently set state (only specific state),</span>
  23 |     | <span class='neutral'>  and use it across &quot;instructions&quot;.</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>  Without jump instruction, this alternative encoding is overkill.</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>  Be aware of function selector hash collisions.</span>
  28 |     | <span class='neutral'>  Data is delivered via the `fallback` function.</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>  -------------</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>  Primitive™</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>import &quot;./Assembly.sol&quot; as Assembly;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>uint8 constant JUMP_PROCESS_START_POINTER = 2;</span>
  39 |     | <span class='neutral'>bytes1 constant UNKNOWN = 0x00;</span>
  40 |     | <span class='neutral'>bytes1 constant ALLOCATE = 0x01;</span>
  41 |     | <span class='neutral'>bytes1 constant UNSET00 = 0x02;</span>
  42 |     | <span class='neutral'>bytes1 constant UNALLOCATE = 0x03;</span>
  43 |     | <span class='neutral'>bytes1 constant UNSET01 = 0x04;</span>
  44 |     | <span class='neutral'>bytes1 constant SWAP = 0x05;</span>
  45 |     | <span class='neutral'>bytes1 constant STAKE_POSITION = 0x06;</span>
  46 |     | <span class='neutral'>bytes1 constant UNSTAKE_POSITION = 0x07;</span>
  47 |     | <span class='neutral'>bytes1 constant UNSET02 = 0x08;</span>
  48 |     | <span class='neutral'>bytes1 constant UNSET03 = 0x09;</span>
  49 |     | <span class='neutral'>bytes1 constant CREATE_POOL = 0x0B;</span>
  50 |     | <span class='neutral'>bytes1 constant CREATE_PAIR = 0x0C;</span>
  51 |     | <span class='neutral'>bytes1 constant UNSET04 = 0x0D;</span>
  52 |     | <span class='neutral'>bytes1 constant INSTRUCTION_JUMP = 0xAA;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>error InvalidJump(uint256 pointer); // 0x80f63bd1</span>
  55 |     | <span class='neutral'>error InvalidBytesLength(uint256 expected, uint256 length); // 0xe19dc95e</span>
  56 | *r  | <span class='executed'></span>
  57 |     | <span class='neutral'>function __startProcess__(function(bytes calldata) _process) {</span>
  58 | *r  | <span class='executed'>    if (msg.data[0] != INSTRUCTION_JUMP) _process(msg.data);</span>
  59 |     | <span class='unexecuted'>    else _jumpProcess(msg.data, _process);</span>
  60 |     | <span class='neutral'>}</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>/** @dev  [jump instruction, instructions.length, pointer, ...instruction, pointer, ...etc] */</span>
  63 |     | <span class='neutral'>function _jumpProcess(bytes calldata data, function(bytes calldata) _process) {</span>
  64 |     | <span class='unexecuted'>    uint8 length = uint8(data[1]);</span>
  65 |     | <span class='unexecuted'>    uint8 pointer = JUMP_PROCESS_START_POINTER;</span>
  66 |     | <span class='neutral'>    uint256 start;</span>
  67 |     | <span class='neutral'>    // For each instruction set...</span>
  68 |     | <span class='unexecuted'>    for (uint256 i; i != length; ++i) {</span>
  69 |     | <span class='neutral'>        // Start at the index of the first byte of the next instruction.</span>
  70 |     | <span class='unexecuted'>        start = pointer;</span>
  71 |     | <span class='neutral'>        // Set the new pointer to the next instruction, located at the pointer.</span>
  72 |     | <span class='unexecuted'>        pointer = uint8(data[pointer]);</span>
  73 |     | <span class='neutral'>        // The `start:` includes the pointer byte, while the `:end` `pointer` is excluded.</span>
  74 |     | <span class='unexecuted'>        if (pointer &gt; data.length) revert InvalidJump(pointer);</span>
  75 |     | <span class='unexecuted'>        bytes calldata instruction = data[start:pointer];</span>
  76 |     | <span class='neutral'>        // Process the instruction.</span>
  77 |     | <span class='unexecuted'>        _process(instruction[1:]); // note: Removes the pointer to the next instruction.</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'>}</span>
  80 |     | <span class='unexecuted'></span>
  81 |     | <span class='unexecuted'>function encodeJumpInstruction(bytes[] memory instructions) pure returns (bytes memory) {</span>
  82 |     | <span class='neutral'>    uint8 nextPointer;</span>
  83 |     | <span class='unexecuted'>    uint8 len = uint8(instructions.length);</span>
  84 |     | <span class='unexecuted'>    bytes memory payload = bytes.concat(INSTRUCTION_JUMP, bytes1(len));</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    // for each instruction set...</span>
  87 |     | <span class='unexecuted'>    for (uint i; i != len; ++i) {</span>
  88 |     | <span class='unexecuted'>        bytes memory instruction = instructions[i];</span>
  89 |     | <span class='unexecuted'>        uint8 size = uint8(instruction.length);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // Using instruction and index of instruction in list, we create a new array with a pointer to the next instruction in front of the instruction payload.</span>
  92 |     | <span class='unexecuted'>        if (i == 0) {</span>
  93 |     | <span class='unexecuted'>            nextPointer = size + 3; // [added0, instruction, added1, nextPointer]</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 |     | <span class='unexecuted'>            nextPointer = nextPointer + size + 1; // [currentPointer, instruction, nextPointer]</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>        bytes memory edited = bytes.concat(bytes1(nextPointer), instruction);</span>
  99 |     | <span class='unexecuted'>        payload = bytes.concat(payload, edited);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    return payload;</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>function decodePairIdFromPoolId(uint64 poolId) pure returns (uint24) {</span>
 106 | r   | <span class='reverted'>    return uint24(poolId &gt;&gt; 40);</span>
 107 |     | <span class='neutral'>}</span>
 108 | *   | <span class='executed'></span>
 109 | *   | <span class='executed'>function encodePoolId(uint24 pairId, bool isMutable, uint32 poolNonce) pure returns (uint64) {</span>
 110 | *   | <span class='executed'>    return uint64(bytes8(abi.encodePacked(pairId, isMutable ? uint8(1) : uint8(0), poolNonce)));</span>
 111 |     | <span class='neutral'>}</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>function decodePoolId(</span>
 114 |     | <span class='neutral'>    bytes calldata data</span>
 115 |     | <span class='neutral'>) pure returns (uint64 poolId, uint24 pairId, uint8 isMutable, uint32 poolNonce) {</span>
 116 |     | <span class='neutral'>    if (data.length != 8) revert InvalidBytesLength(8, data.length);</span>
 117 |     | <span class='neutral'>    poolId = uint64(bytes8(data));</span>
 118 |     | <span class='neutral'>    pairId = uint16(bytes2(data[:3]));</span>
 119 |     | <span class='neutral'>    isMutable = uint8(bytes1(data[3:4]));</span>
 120 |     | <span class='neutral'>    poolNonce = uint32(bytes4(data[4:]));</span>
 121 |     | <span class='neutral'>}</span>
 122 | *   | <span class='executed'></span>
 123 | *   | <span class='executed'>function encodeCreatePair(address token0, address token1) pure returns (bytes memory data) {</span>
 124 | *   | <span class='executed'>    data = abi.encodePacked(CREATE_PAIR, token0, token1);</span>
 125 |     | <span class='neutral'>}</span>
 126 | *   | <span class='executed'></span>
 127 | *   | <span class='executed'>function decodeCreatePair(bytes calldata data) pure returns (address tokenAsset, address tokenQuote) {</span>
 128 | *   | <span class='executed'>    if (data.length != 41) revert InvalidBytesLength(41, data.length);</span>
 129 | *   | <span class='executed'>    tokenAsset = address(bytes20(data[1:21]));</span>
 130 | *   | <span class='executed'>    tokenQuote = address(bytes20(data[21:]));</span>
 131 |     | <span class='neutral'>}</span>
 132 | *   | <span class='executed'></span>
 133 |     | <span class='neutral'>function encodeCreatePool(</span>
 134 |     | <span class='neutral'>    uint24 pairId,</span>
 135 |     | <span class='neutral'>    address controller,</span>
 136 |     | <span class='neutral'>    uint16 priorityFee,</span>
 137 |     | <span class='neutral'>    uint16 fee,</span>
 138 |     | <span class='neutral'>    uint16 vol,</span>
 139 |     | <span class='neutral'>    uint16 dur,</span>
 140 |     | <span class='neutral'>    uint16 jit,</span>
 141 |     | <span class='neutral'>    int24 max,</span>
 142 |     | <span class='neutral'>    uint128 price</span>
 143 | *   | <span class='executed'>) pure returns (bytes memory data) {</span>
 144 | *   | <span class='executed'>    data = abi.encodePacked(CREATE_POOL, pairId, controller, priorityFee, fee, vol, dur, jit, max, price);</span>
 145 |     | <span class='neutral'>}</span>
 146 | *   | <span class='executed'></span>
 147 |     | <span class='neutral'>function decodeCreatePool(</span>
 148 |     | <span class='neutral'>    bytes calldata data</span>
 149 |     | <span class='neutral'>)</span>
 150 |     | <span class='neutral'>    pure</span>
 151 |     | <span class='neutral'>    returns (</span>
 152 | *   | <span class='executed'>        uint24 pairId,</span>
 153 |     | <span class='neutral'>        address controller,</span>
 154 |     | <span class='neutral'>        uint16 priorityFee,</span>
 155 |     | <span class='neutral'>        uint16 fee,</span>
 156 |     | <span class='neutral'>        uint16 vol,</span>
 157 |     | <span class='neutral'>        uint16 dur,</span>
 158 |     | <span class='neutral'>        uint16 jit,</span>
 159 |     | <span class='neutral'>        int24 max,</span>
 160 |     | <span class='neutral'>        uint128 price</span>
 161 |     | <span class='neutral'>    )</span>
 162 |     | <span class='neutral'>{</span>
 163 | *   | <span class='executed'>    if (data.length != 53) revert InvalidBytesLength(53, data.length);</span>
 164 | *   | <span class='executed'>    pairId = uint24(bytes3(data[1:4]));</span>
 165 | *   | <span class='executed'>    controller = address(bytes20(data[4:24]));</span>
 166 | *   | <span class='executed'>    priorityFee = uint16(bytes2(data[24:26]));</span>
 167 | *   | <span class='executed'>    fee = uint16(bytes2(data[26:28]));</span>
 168 | *   | <span class='executed'>    vol = uint16(bytes2(data[28:30]));</span>
 169 | *   | <span class='executed'>    dur = uint16(bytes2(data[30:32]));</span>
 170 | *   | <span class='executed'>    jit = uint16(bytes2(data[32:34]));</span>
 171 | *   | <span class='executed'>    max = int24(uint24(bytes3(data[34:37])));</span>
 172 | *   | <span class='executed'>    price = uint128(bytes16(data[37:]));</span>
 173 |     | <span class='neutral'>}</span>
 174 |     | <span class='unexecuted'></span>
 175 |     | <span class='unexecuted'>function encodeAllocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {</span>
 176 |     | <span class='unexecuted'>    data = abi.encodePacked(Assembly.pack(bytes1(useMax), ALLOCATE), poolId, power, amount);</span>
 177 |     | <span class='neutral'>}</span>
 178 | r   | <span class='reverted'></span>
 179 | r   | <span class='reverted'>function decodeAllocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {</span>
 180 | r   | <span class='reverted'>    if (data.length &lt; 9) revert InvalidBytesLength(9, data.length);</span>
 181 |     | <span class='unexecuted'>    (bytes1 maxFlag, ) = Assembly.separate(data[0]);</span>
 182 |     | <span class='unexecuted'>    useMax = uint8(maxFlag);</span>
 183 |     | <span class='unexecuted'>    poolId = uint64(bytes8(data[1:9]));</span>
 184 | r   | <span class='reverted'>    deltaLiquidity = Assembly.toAmount(data[9:]);</span>
 185 |     | <span class='neutral'>}</span>
 186 |     | <span class='unexecuted'></span>
 187 |     | <span class='unexecuted'>function encodeUnallocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {</span>
 188 |     | <span class='unexecuted'>    data = abi.encodePacked(Assembly.pack(bytes1(useMax), UNALLOCATE), poolId, power, amount);</span>
 189 |     | <span class='neutral'>}</span>
 190 | *r  | <span class='executed'></span>
 191 | r   | <span class='reverted'>function decodeUnallocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {</span>
 192 | r   | <span class='reverted'>    if (data.length &lt; 9) revert InvalidBytesLength(9, data.length);</span>
 193 | r   | <span class='reverted'>    useMax = uint8(data[0] &gt;&gt; 4);</span>
 194 | r   | <span class='reverted'>    poolId = uint64(bytes8(data[1:9]));</span>
 195 | *r  | <span class='executed'>    deltaLiquidity = uint128(Assembly.toAmount(data[9:]));</span>
 196 |     | <span class='neutral'>}</span>
 197 |     | <span class='unexecuted'></span>
 198 |     | <span class='neutral'>function encodeSwap(</span>
 199 |     | <span class='neutral'>    uint8 useMax,</span>
 200 |     | <span class='neutral'>    uint64 poolId,</span>
 201 |     | <span class='neutral'>    uint8 power0,</span>
 202 |     | <span class='neutral'>    uint128 amount0,</span>
 203 |     | <span class='neutral'>    uint8 power1,</span>
 204 |     | <span class='neutral'>    uint128 amount1,</span>
 205 |     | <span class='neutral'>    uint8 direction</span>
 206 |     | <span class='neutral'>) pure returns (bytes memory data) {</span>
 207 |     | <span class='neutral'>    //    pointerToAmount1 = instruction, poolId, pointer, power0, amount0, power1 {pointer}-&gt;</span>
 208 |     | <span class='neutral'>    uint8 pointerToAmount1 = 0x01 + 0x08 + 0x01 + 0x10 + 0x01;</span>
 209 |     | <span class='unexecuted'>    data = abi.encodePacked(</span>
 210 |     | <span class='neutral'>        Assembly.pack(bytes1(useMax), SWAP),</span>
 211 |     | <span class='neutral'>        poolId,</span>
 212 |     | <span class='neutral'>        pointerToAmount1,</span>
 213 |     | <span class='neutral'>        power0,</span>
 214 |     | <span class='neutral'>        amount0,</span>
 215 |     | <span class='neutral'>        power1,</span>
 216 |     | <span class='neutral'>        amount1,</span>
 217 |     | <span class='neutral'>        direction</span>
 218 |     | <span class='neutral'>    );</span>
 219 |     | <span class='neutral'>}</span>
 220 | r   | <span class='reverted'></span>
 221 |     | <span class='neutral'>function decodeSwap(</span>
 222 |     | <span class='neutral'>    bytes calldata data</span>
 223 | r   | <span class='reverted'>) pure returns (uint8 useMax, uint64 poolId, uint128 input, uint128 limit, uint8 direction) {</span>
 224 | r   | <span class='reverted'>    useMax = uint8(data[0] &gt;&gt; 4);</span>
 225 | r   | <span class='reverted'>    poolId = uint64(bytes8(data[1:9]));</span>
 226 |     | <span class='unexecuted'>    uint8 pointer = uint8(data[9]);</span>
 227 |     | <span class='unexecuted'>    input = uint128(Assembly.toAmount(data[10:pointer]));</span>
 228 |     | <span class='unexecuted'>    limit = uint128(Assembly.toAmount(data[pointer:data.length - 1]));</span>
 229 |     | <span class='unexecuted'>    direction = uint8(data[data.length - 1]);</span>
 230 |     | <span class='neutral'>}</span>
 231 |     | <span class='unexecuted'></span>
 232 |     | <span class='unexecuted'>function encodeStakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {</span>
 233 |     | <span class='unexecuted'>    data = abi.encodePacked(STAKE_POSITION, poolId, deltaLiquidity);</span>
 234 |     | <span class='neutral'>}</span>
 235 | *r  | <span class='executed'></span>
 236 | r   | <span class='reverted'>function decodeStakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {</span>
 237 | r   | <span class='reverted'>    if (data.length &lt; 9) revert InvalidBytesLength(9, data.length);</span>
 238 |     | <span class='unexecuted'>    poolId = uint64(bytes8(data[1:9]));</span>
 239 | *r  | <span class='executed'>    deltaLiquidity = uint128(Assembly.toAmount(data[9:]));</span>
 240 |     | <span class='neutral'>}</span>
 241 |     | <span class='unexecuted'></span>
 242 |     | <span class='unexecuted'>function encodeUnstakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {</span>
 243 |     | <span class='unexecuted'>    data = abi.encodePacked(UNSTAKE_POSITION, poolId, deltaLiquidity);</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>function decodeUnstakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {</span>
 247 |     | <span class='neutral'>    if (data.length &lt; 9) revert InvalidBytesLength(9, data.length);</span>
 248 |     | <span class='neutral'>    poolId = uint64(bytes8(data[1:9]));</span>
 249 |     | <span class='neutral'>    deltaLiquidity = uint128(Assembly.toAmount(data[9:]));</span>
 250 |     | <span class='neutral'>}</span>
 251 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/Hyper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>  ------------------------------------</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>  Hyper is a replicating market maker.</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>  ------------------------------------</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>  Primitive™</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>import &quot;./HyperLib.sol&quot;;</span>
  17 |     | <span class='neutral'>import &quot;./interfaces/IWETH.sol&quot;;</span>
  18 |     | <span class='neutral'>import &quot;./interfaces/IHyper.sol&quot;;</span>
  19 |     | <span class='neutral'>import &quot;./interfaces/IERC20.sol&quot;;</span>
  20 | *r  | <span class='executed'></span>
  21 |     | <span class='neutral'>contract Hyper is IHyper {</span>
  22 |     | <span class='neutral'>    using Price for Price.RMM;</span>
  23 |     | <span class='neutral'>    using SafeCastLib for uint;</span>
  24 |     | <span class='neutral'>    using FixedPointMathLib for int256;</span>
  25 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  26 |     | <span class='neutral'>    using {Assembly.isBetween} for uint8;</span>
  27 |     | <span class='neutral'>    using {Assembly.scaleFromWadDownSigned} for int;</span>
  28 |     | <span class='neutral'>    using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;</span>
  29 |     | <span class='neutral'></span>
  30 | *r  | <span class='executed'>    function VERSION() public pure returns (string memory) {</span>
  31 |     | <span class='neutral'>        assembly {</span>
  32 |     | <span class='neutral'>            // Load 0x20 (32) in memory at slot 0x00, this corresponds to the</span>
  33 |     | <span class='neutral'>            // offset location of the next data.</span>
  34 | *   | <span class='executed'>            mstore(0x00, 0x20)</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>            // Then we load both the length of our string (11 bytes, 0x0b in hex) and its</span>
  37 |     | <span class='neutral'>            // actual hex value (0x626574612d76302e302e31) using the offset 0x2b. Using this</span>
  38 |     | <span class='neutral'>            // particular offset value will right pad the length at the end of the slot</span>
  39 |     | <span class='neutral'>            // and left pad the string at the beginning of the next slot, assuring the</span>
  40 |     | <span class='neutral'>            // right ABI format to return a string.</span>
  41 | *   | <span class='executed'>            mstore(0x2b, 0x0b626574612d76302e302e31) // &quot;beta-v0.0.1&quot;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>            // Return all the 96 bytes (0x60) of data that was loaded into the memory.</span>
  44 | *   | <span class='executed'>            return(0x00, 0x60)</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 | *r  | <span class='executed'>    OS.AccountSystem public __account__;</span>
  49 |     | <span class='neutral'></span>
  50 | *r  | <span class='executed'>    address public immutable WETH;</span>
  51 | *r  | <span class='executed'>    uint256 public getPairNonce;</span>
  52 | *r  | <span class='executed'>    uint256 public getPoolNonce;</span>
  53 |     | <span class='neutral'></span>
  54 | *r  | <span class='executed'>    mapping(uint24 =&gt; HyperPair) public pairs;</span>
  55 | *r  | <span class='executed'>    mapping(uint64 =&gt; HyperPool) public pools;</span>
  56 | *r  | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; uint24)) public getPairId;</span>
  57 | *r  | <span class='executed'>    mapping(address =&gt; mapping(uint64 =&gt; HyperPosition)) public positions;</span>
  58 |     | <span class='neutral'></span>
  59 | *r  | <span class='executed'>    uint256 public locked = 1;</span>
  60 |     | <span class='neutral'>    Payment[] private _payments;</span>
  61 |     | <span class='neutral'>    SwapState private _state;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    modifier lock() {</span>
  64 | *r  | <span class='executed'>        if (locked != 1) revert InvalidReentrancy();</span>
  65 |     | <span class='neutral'></span>
  66 | *r  | <span class='executed'>        locked = 2;</span>
  67 |     | <span class='neutral'>        _;</span>
  68 | *r  | <span class='executed'>        locked = 1;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /** @dev Used on every external operation that touches tokens. */</span>
  72 |     | <span class='neutral'>    modifier interactions() {</span>
  73 | *r  | <span class='executed'>        if (__account__.prepared) revert InvalidReentrancy();</span>
  74 | *r  | <span class='executed'>        __account__.__wrapEther__(WETH); // Deposits msg.value ether, this contract receives WETH.</span>
  75 | *r  | <span class='executed'>        __account__.prepared = false;</span>
  76 |     | <span class='neutral'>        _;</span>
  77 | *r  | <span class='executed'>        __account__.prepared = true;</span>
  78 |     | <span class='neutral'></span>
  79 | *r  | <span class='executed'>        _settlement();</span>
  80 |     | <span class='neutral'></span>
  81 | *r  | <span class='executed'>        if (!__account__.settled) revert InvalidSettlement();</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    constructor(address weth) {</span>
  85 |     | <span class='unexecuted'>        WETH = weth;</span>
  86 |     | <span class='unexecuted'>        __account__.settled = true;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    receive() external payable {</span>
  90 | *r  | <span class='executed'>        if (msg.sender != WETH) revert();</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**  @dev Alternative entrypoint to process operations using encoded calldata transferred directly as `msg.data`. */</span>
  94 |     | <span class='neutral'>    fallback() external payable lock interactions {</span>
  95 | *r  | <span class='executed'>        Enigma.__startProcess__(_process);</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /** @dev balanceOf(token) - getReserve(token). If negative, you win. */</span>
  99 | *r  | <span class='executed'>    function getNetBalance(address token) public view returns (int256) {</span>
 100 | *r  | <span class='executed'>        return __account__.getNetBalance(token, address(this));</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /** @dev Virtual balance of `token`. */</span>
 104 | *r  | <span class='executed'>    function getReserve(address token) public view returns (uint) {</span>
 105 | *r  | <span class='executed'>        return __account__.reserves[token];</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /** @dev Internal balance of `owner` of `token`. */</span>
 109 | *r  | <span class='executed'>    function getBalance(address owner, address token) public view returns (uint) {</span>
 110 | *r  | <span class='executed'>        return __account__.balances[owner][token];</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'>    </span>
 113 |     | <span class='neutral'>    /** @dev Transient stored tokens */</span>
 114 | *r  | <span class='executed'>    function getWarm() public view returns (address[] memory warm) {</span>
 115 | *   | <span class='executed'>        return __account__.warm;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    // ===== Actions ===== //</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 122 | *r  | <span class='executed'>    function allocate(</span>
 123 |     | <span class='neutral'>        uint64 poolId,</span>
 124 |     | <span class='neutral'>        uint amount</span>
 125 | *r  | <span class='executed'>    ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {</span>
 126 | *r  | <span class='executed'>        bool useMax = amount == type(uint).max;</span>
 127 | *r  | <span class='executed'>        (deltaAsset, deltaQuote) = _allocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 131 | r   | <span class='reverted'>    function unallocate(</span>
 132 |     | <span class='neutral'>        uint64 poolId,</span>
 133 |     | <span class='neutral'>        uint amount</span>
 134 | r   | <span class='reverted'>    ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {</span>
 135 | r   | <span class='reverted'>        bool useMax = amount == type(uint).max;</span>
 136 | r   | <span class='reverted'>        (deltaAsset, deltaQuote) = _unallocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 140 | *r  | <span class='executed'>    function stake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {</span>
 141 | *r  | <span class='executed'>        _stake(poolId, deltaLiquidity);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 145 | r   | <span class='reverted'>    function unstake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {</span>
 146 | r   | <span class='reverted'>        _unstake(poolId, deltaLiquidity);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 150 | r   | <span class='reverted'>    function swap(</span>
 151 |     | <span class='neutral'>        uint64 poolId,</span>
 152 |     | <span class='neutral'>        bool sellAsset,</span>
 153 |     | <span class='neutral'>        uint amount,</span>
 154 |     | <span class='neutral'>        uint limit</span>
 155 | r   | <span class='reverted'>    ) external lock interactions returns (uint output, uint remainder) {</span>
 156 | r   | <span class='reverted'>        if (limit == type(uint256).max) limit = type(uint128).max;</span>
 157 | r   | <span class='reverted'>        bool useMax = amount == type(uint256).max; // magic variable.</span>
 158 | r   | <span class='reverted'>        uint128 input = useMax ? type(uint128).max : amount.safeCastTo128();</span>
 159 | r   | <span class='reverted'>        (, remainder, , output) = _swapExactIn(</span>
 160 | r   | <span class='reverted'>            Order({</span>
 161 | r   | <span class='reverted'>                useMax: useMax ? 1 : 0,</span>
 162 | r   | <span class='reverted'>                poolId: poolId,</span>
 163 | r   | <span class='reverted'>                input: input,</span>
 164 | r   | <span class='reverted'>                limit: limit.safeCastTo128(),</span>
 165 | r   | <span class='reverted'>                direction: sellAsset ? 0 : 1</span>
 166 |     | <span class='neutral'>            })</span>
 167 |     | <span class='neutral'>        );</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 171 | *r  | <span class='executed'>    function draw(address token, uint256 amount, address to) external lock interactions {</span>
 172 | *r  | <span class='executed'>        if (to == address(this)) revert InvalidTransfer(); // todo: Investigate attack vectors if this was not here.</span>
 173 | *r  | <span class='executed'>        if (amount &gt; getBalance(msg.sender, token)) revert DrawBalance();</span>
 174 |     | <span class='neutral'></span>
 175 | *r  | <span class='executed'>        _applyDebit(token, amount);</span>
 176 | *r  | <span class='executed'>        _decreaseReserves(token, amount);</span>
 177 |     | <span class='neutral'></span>
 178 | *r  | <span class='executed'>        if (token == WETH) OS.__dangerousUnwrapEther__(WETH, to, amount);</span>
 179 | *r  | <span class='executed'>        else OS.SafeTransferLib.safeTransfer(OS.ERC20(token), to, amount);</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 183 | *r  | <span class='executed'>    function fund(address token, uint256 amount) external override lock interactions {</span>
 184 | *r  | <span class='executed'>        __account__.dangerousFund(token, address(this), amount); // transferFrom(msg.sender)</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /// @inheritdoc IHyperActions</span>
 188 | *r  | <span class='executed'>    function deposit() external payable override lock interactions {</span>
 189 | *r  | <span class='executed'>        if (msg.value == 0) revert ZeroValue();</span>
 190 | *   | <span class='executed'>        emit Deposit(msg.sender, msg.value);</span>
 191 |     | <span class='neutral'>        // interactions modifier does the work.</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    // todo: test</span>
 195 | *r  | <span class='executed'>    function claim(uint64 poolId, uint deltaAsset, uint deltaQuote) external lock interactions {</span>
 196 | r   | <span class='reverted'>        HyperPool memory pool = pools[poolId];</span>
 197 | r   | <span class='reverted'>        HyperPosition storage pos = positions[msg.sender][poolId];</span>
 198 | *r  | <span class='executed'>        if (pos.lastTimestamp == 0) revert NonExistentPosition(msg.sender, poolId);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        pos.syncPositionFees(pool.liquidity, pool.feeGrowthGlobalAsset, pool.feeGrowthGlobalQuote);</span>
 201 |     | <span class='unexecuted'>        pos.tokensOwedAsset -= deltaAsset.safeCastTo128();</span>
 202 |     | <span class='unexecuted'>        pos.tokensOwedQuote -= deltaQuote.safeCastTo128();</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        if (deltaAsset &gt; 0) _applyCredit(pool.pair.tokenAsset, deltaAsset); // todo: problem, what balance do fees accrue to?</span>
 205 |     | <span class='unexecuted'>        if (deltaQuote &gt; 0) _applyCredit(pool.pair.tokenQuote, deltaQuote); // todo: add debit to this contract?</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>        pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward);</span>
 208 |     | <span class='unexecuted'>        uint128 deltaReward = pos.tokensOwedReward;</span>
 209 |     | <span class='unexecuted'>        pos.tokensOwedReward -= deltaReward;</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>        // todo: a hack that utilizes Hyper contract as a fee bucket for priority swaps.</span>
 212 |     | <span class='neutral'>        // Currently uses WETH as the reward token. However, these priority fees</span>
 213 |     | <span class='neutral'>        // are paid based on liquidity.</span>
 214 |     | <span class='neutral'>        // If 1 WAD of liquidity is worth a small amount, the priority fee cost</span>
 215 |     | <span class='neutral'>        // a lot relative to the liquidity&#39;s value.</span>
 216 |     | <span class='neutral'>        // A better change is making this reward token configurable.</span>
 217 |     | <span class='unexecuted'>        if (deltaReward &gt; 0) {</span>
 218 |     | <span class='unexecuted'>            _applyCredit(WETH, deltaReward); // gift to `msg.sender`.</span>
 219 |     | <span class='unexecuted'>            if (getBalance(address(this), WETH) &lt; deltaReward) revert InvalidReward();</span>
 220 |     | <span class='unexecuted'>            __account__.debit(address(this), WETH, deltaReward); // only place hyper&#39;s balance is used</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>        emit Collect(</span>
 224 |     | <span class='neutral'>            poolId,</span>
 225 |     | <span class='unexecuted'>            msg.sender,</span>
 226 |     | <span class='neutral'>            deltaAsset,</span>
 227 |     | <span class='unexecuted'>            pool.pair.tokenAsset,</span>
 228 |     | <span class='neutral'>            deltaQuote,</span>
 229 |     | <span class='unexecuted'>            pool.pair.tokenQuote,</span>
 230 |     | <span class='neutral'>            deltaReward,</span>
 231 |     | <span class='unexecuted'>            WETH</span>
 232 |     | <span class='neutral'>        );</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    // ===== Effects ===== //</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /** @dev Increases virtal reserves and liquidity. Debits `msg.sender`. */</span>
 238 | *r  | <span class='executed'>    function _allocate(</span>
 239 |     | <span class='neutral'>        bool useMax,</span>
 240 |     | <span class='neutral'>        uint64 poolId,</span>
 241 |     | <span class='neutral'>        uint128 deltaLiquidity</span>
 242 | *r  | <span class='executed'>    ) internal returns (uint256 deltaAsset, uint256 deltaQuote) {</span>
 243 | *r  | <span class='executed'>        HyperPool memory pool = pools[poolId];</span>
 244 | *r  | <span class='executed'>        if (!pool.exists()) revert NonExistentPool(poolId);</span>
 245 |     | <span class='neutral'></span>
 246 | *r  | <span class='executed'>        if (useMax) {</span>
 247 |     | <span class='unexecuted'>            deltaLiquidity = pool.getMaxLiquidity({</span>
 248 |     | <span class='unexecuted'>                deltaAsset: getBalance(msg.sender, pool.pair.tokenAsset),</span>
 249 |     | <span class='unexecuted'>                deltaQuote: getBalance(msg.sender, pool.pair.tokenQuote)</span>
 250 |     | <span class='neutral'>            });</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'></span>
 253 | *r  | <span class='executed'>        if (deltaLiquidity == 0) revert ZeroLiquidity();</span>
 254 | r   | <span class='reverted'>        (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(toInt128(deltaLiquidity)); // note: rounds up.</span>
 255 |     | <span class='neutral'></span>
 256 | r   | <span class='reverted'>        ChangeLiquidityParams memory args = ChangeLiquidityParams({</span>
 257 | r   | <span class='reverted'>            owner: msg.sender,</span>
 258 |     | <span class='neutral'>            poolId: poolId,</span>
 259 |     | <span class='unexecuted'>            timestamp: _blockTimestamp(),</span>
 260 | r   | <span class='reverted'>            deltaAsset: deltaAsset,</span>
 261 | r   | <span class='reverted'>            deltaQuote: deltaQuote,</span>
 262 | r   | <span class='reverted'>            tokenAsset: pool.pair.tokenAsset,</span>
 263 | r   | <span class='reverted'>            tokenQuote: pool.pair.tokenQuote,</span>
 264 | r   | <span class='reverted'>            deltaLiquidity: toInt128(deltaLiquidity)</span>
 265 |     | <span class='neutral'>        });</span>
 266 |     | <span class='neutral'></span>
 267 | r   | <span class='reverted'>        _changeLiquidity(args);</span>
 268 | r   | <span class='reverted'>        emit Allocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    /** @dev Reduces virtual reserves and liquidity. Credits `msg.sender`. */</span>
 272 | r   | <span class='reverted'>    function _unallocate(</span>
 273 |     | <span class='neutral'>        bool useMax,</span>
 274 |     | <span class='neutral'>        uint64 poolId,</span>
 275 |     | <span class='neutral'>        uint128 deltaLiquidity</span>
 276 | r   | <span class='reverted'>    ) internal returns (uint deltaAsset, uint deltaQuote) {</span>
 277 | r   | <span class='reverted'>        if (useMax) deltaLiquidity = positions[msg.sender][poolId].freeLiquidity;</span>
 278 | r   | <span class='reverted'>        if (deltaLiquidity == 0) revert ZeroLiquidity();</span>
 279 |     | <span class='neutral'></span>
 280 | r   | <span class='reverted'>        HyperPool memory pool = pools[poolId];</span>
 281 | r   | <span class='reverted'>        if (!pool.exists()) revert NonExistentPool(poolId);</span>
 282 |     | <span class='neutral'></span>
 283 | r   | <span class='reverted'>        (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(-toInt128(deltaLiquidity)); // rounds down</span>
 284 |     | <span class='neutral'></span>
 285 | r   | <span class='reverted'>        ChangeLiquidityParams memory args = ChangeLiquidityParams({</span>
 286 | r   | <span class='reverted'>            owner: msg.sender,</span>
 287 |     | <span class='neutral'>            poolId: poolId,</span>
 288 |     | <span class='unexecuted'>            timestamp: _blockTimestamp(),</span>
 289 | r   | <span class='reverted'>            deltaAsset: deltaAsset,</span>
 290 | r   | <span class='reverted'>            deltaQuote: deltaQuote,</span>
 291 | r   | <span class='reverted'>            tokenAsset: pool.pair.tokenAsset,</span>
 292 | r   | <span class='reverted'>            tokenQuote: pool.pair.tokenQuote,</span>
 293 | r   | <span class='reverted'>            deltaLiquidity: -toInt128(deltaLiquidity)</span>
 294 |     | <span class='neutral'>        });</span>
 295 |     | <span class='neutral'></span>
 296 | r   | <span class='reverted'>        _changeLiquidity(args);</span>
 297 |     | <span class='unexecuted'>        emit Unallocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 | r   | <span class='reverted'>    function _changeLiquidity(ChangeLiquidityParams memory args) internal returns (uint feeAsset, uint feeQuote) {</span>
 301 | r   | <span class='reverted'>        (HyperPool storage pool, HyperPosition storage pos) = (pools[args.poolId], positions[args.owner][args.poolId]);</span>
 302 |     | <span class='neutral'></span>
 303 | r   | <span class='reverted'>        (feeAsset, feeQuote) = pos.syncPositionFees(</span>
 304 | r   | <span class='reverted'>            pool.liquidity,</span>
 305 | r   | <span class='reverted'>            pool.feeGrowthGlobalAsset,</span>
 306 | r   | <span class='reverted'>            pool.feeGrowthGlobalQuote</span>
 307 |     | <span class='neutral'>        );</span>
 308 |     | <span class='neutral'></span>
 309 | r   | <span class='reverted'>        _changePosition(args);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    /** @dev Changes position liquidity and timestamp. */</span>
 313 | r   | <span class='reverted'>    function _changePosition(ChangeLiquidityParams memory args) internal {</span>
 314 | r   | <span class='reverted'>        HyperPosition storage position = positions[args.owner][args.poolId];</span>
 315 |     | <span class='neutral'></span>
 316 | r   | <span class='reverted'>        if (args.deltaLiquidity &lt; 0) {</span>
 317 | r   | <span class='reverted'>            uint distance = position.getTimeSinceChanged(_blockTimestamp());</span>
 318 | r   | <span class='reverted'>            if (pools[args.poolId].params.jit &gt; distance) revert JitLiquidity(distance);</span>
 319 |     | <span class='neutral'>        }</span>
 320 |     | <span class='neutral'></span>
 321 | r   | <span class='reverted'>        position.changePositionLiquidity(args.timestamp, args.deltaLiquidity);</span>
 322 |     | <span class='neutral'></span>
 323 | r   | <span class='reverted'>        _changePool(args);</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    /** @dev Changes virtual reserves and pool liquidity. Does not update timestamp of pool. */</span>
 327 | r   | <span class='reverted'>    function _changePool(ChangeLiquidityParams memory args) internal {</span>
 328 | r   | <span class='reverted'>        (address asset, address quote) = (args.tokenAsset, args.tokenQuote);</span>
 329 |     | <span class='neutral'></span>
 330 | r   | <span class='reverted'>        pools[args.poolId].changePoolLiquidity(args.deltaLiquidity);</span>
 331 |     | <span class='neutral'></span>
 332 | r   | <span class='reverted'>        if (args.deltaLiquidity &lt; 0) {</span>
 333 | r   | <span class='reverted'>            _decreaseReserves(asset, args.deltaAsset);</span>
 334 | r   | <span class='reverted'>            _decreaseReserves(quote, args.deltaQuote);</span>
 335 |     | <span class='neutral'>        } else {</span>
 336 |     | <span class='neutral'>            // note: Reserves are used at the end of instruction processing to interactions transactions.</span>
 337 | r   | <span class='reverted'>            _increaseReserves(asset, args.deltaAsset);</span>
 338 | r   | <span class='reverted'>            _increaseReserves(quote, args.deltaQuote);</span>
 339 |     | <span class='neutral'>        }</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 | r   | <span class='reverted'>    function _stake(uint64 poolId, uint128 deltaLiquidity) internal {</span>
 343 | r   | <span class='reverted'>        HyperPool storage pool = pools[poolId];</span>
 344 | r   | <span class='reverted'>        if (!pool.exists()) revert NonExistentPool(poolId);</span>
 345 |     | <span class='neutral'></span>
 346 | r   | <span class='reverted'>        HyperPosition memory pos = positions[msg.sender][poolId];</span>
 347 | r   | <span class='reverted'>        if (deltaLiquidity == 0) revert ZeroLiquidity();</span>
 348 | r   | <span class='reverted'>        if (pos.freeLiquidity &lt; deltaLiquidity) revert InsufficientPosition(poolId);</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='unexecuted'>        uint feeEarned = _changeStake(poolId, toInt128(deltaLiquidity));</span>
 351 |     | <span class='unexecuted'>        pool.stakedLiquidityDelta += toInt128(deltaLiquidity);</span>
 352 |     | <span class='unexecuted'>        emit Stake(poolId, msg.sender, deltaLiquidity);</span>
 353 |     | <span class='neutral'>    }</span>
 354 |     | <span class='neutral'></span>
 355 | r   | <span class='reverted'>    function _unstake(uint64 poolId, uint128 deltaLiquidity) internal returns (uint feeEarned) {</span>
 356 | r   | <span class='reverted'>        HyperPool storage pool = pools[poolId];</span>
 357 | r   | <span class='reverted'>        if (!pool.exists()) revert NonExistentPool(poolId);</span>
 358 |     | <span class='neutral'></span>
 359 | r   | <span class='reverted'>        uint timestamp = _blockTimestamp();</span>
 360 | r   | <span class='reverted'>        HyperPosition memory pos = positions[msg.sender][poolId];</span>
 361 | r   | <span class='reverted'>        if (pos.stakeTimestamp == 0) revert PositionNotStaked(poolId);</span>
 362 |     | <span class='unexecuted'>        if (pos.unstakeTimestamp &gt; timestamp) revert StakeNotMature(poolId); // todo: Investigate if its okay to unstake whenever.</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='unexecuted'>        feeEarned = _changeStake(poolId, -toInt128(deltaLiquidity));</span>
 365 |     | <span class='unexecuted'>        pool.stakedLiquidityDelta -= toInt128(deltaLiquidity);</span>
 366 |     | <span class='unexecuted'>        emit Unstake(poolId, msg.sender, deltaLiquidity);</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='unexecuted'>    function _changeStake(uint64 poolId, int128 deltaLiquidity) internal returns (uint feeEarned) {</span>
 370 |     | <span class='unexecuted'>        uint timestamp = _blockTimestamp();</span>
 371 |     | <span class='unexecuted'>        HyperPool memory pool = pools[poolId];</span>
 372 |     | <span class='unexecuted'>        HyperPosition storage pos = positions[msg.sender][poolId];</span>
 373 |     | <span class='unexecuted'>        if (pos.stakeTimestamp == 0) pos.stakeTimestamp = timestamp.safeCastTo32();</span>
 374 |     | <span class='unexecuted'>        if (pos.unstakeTimestamp == 0) pos.unstakeTimestamp = pool.params.maturity();</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='unexecuted'>        feeEarned = pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward); // must apply before liquidity changes.</span>
 377 |     | <span class='unexecuted'>        pos.changePositionLiquidity(timestamp, -deltaLiquidity);</span>
 378 |     | <span class='unexecuted'>        pos.stakedLiquidity = Assembly.addSignedDelta(pos.stakedLiquidity, deltaLiquidity);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    // ===== Swaps ===== //</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>    /** * @dev Swaps in direction (0 or 1) exact input of tokens (0 = asset, 1 = quote) for output of tokens (0 = quote, 1 = asset) up to limit price. */</span>
 384 | r   | <span class='reverted'>    function _swapExactIn(</span>
 385 |     | <span class='neutral'>        Order memory args</span>
 386 | r   | <span class='reverted'>    ) internal returns (uint64 poolId, uint256 remainder, uint256 input, uint256 output) {</span>
 387 | r   | <span class='reverted'>        if (args.input == 0) revert ZeroInput();</span>
 388 |     | <span class='neutral'></span>
 389 | r   | <span class='reverted'>        HyperPool storage pool = pools[args.poolId];</span>
 390 | r   | <span class='reverted'>        if (!pool.exists()) revert NonExistentPool(args.poolId);</span>
 391 |     | <span class='neutral'></span>
 392 | r   | <span class='reverted'>        _state.sell = args.direction == 0; // 0: asset -&gt; quote, 1: quote -&gt; asset</span>
 393 | r   | <span class='reverted'>        _state.fee = msg.sender == pool.controller ? pool.params.priorityFee : uint(pool.params.fee);</span>
 394 | r   | <span class='reverted'>        _state.feeGrowthGlobal = _state.sell ? pool.feeGrowthGlobalAsset : pool.feeGrowthGlobalQuote;</span>
 395 | r   | <span class='reverted'>        _state.tokenInput = _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote;</span>
 396 | r   | <span class='reverted'>        _state.tokenOutput = _state.sell ? pool.pair.tokenQuote : pool.pair.tokenAsset;</span>
 397 |     | <span class='neutral'></span>
 398 | r   | <span class='reverted'>        Price.RMM memory rmm = Price.RMM({strike: pool.params.strike(), sigma: pool.params.volatility, tau: 0});</span>
 399 | r   | <span class='reverted'>        Iteration memory _swap;</span>
 400 | r   | <span class='reverted'>        {</span>
 401 | r   | <span class='reverted'>            (uint256 price, int24 tick, uint updatedTau) = _computeSyncedPrice(args.poolId);</span>
 402 | r   | <span class='reverted'>            rmm.tau = updatedTau;</span>
 403 |     | <span class='neutral'></span>
 404 | r   | <span class='reverted'>            uint internalBalance = getBalance(msg.sender, _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote);</span>
 405 | r   | <span class='reverted'>            remainder = args.useMax == 1 ? internalBalance : args.input;</span>
 406 | r   | <span class='reverted'>            remainder = remainder.scaleToWad(_state.sell ? pool.pair.decimalsAsset : pool.pair.decimalsQuote); // WAD</span>
 407 | r   | <span class='reverted'>            _swap = Iteration({</span>
 408 | r   | <span class='reverted'>                price: price,</span>
 409 | r   | <span class='reverted'>                tick: tick,</span>
 410 | r   | <span class='reverted'>                feeAmount: 0,</span>
 411 | r   | <span class='reverted'>                remainder: remainder,</span>
 412 | r   | <span class='reverted'>                liquidity: pool.liquidity,</span>
 413 | r   | <span class='reverted'>                input: 0,</span>
 414 | r   | <span class='reverted'>                output: 0</span>
 415 |     | <span class='neutral'>            });</span>
 416 |     | <span class='neutral'>        }</span>
 417 | r   | <span class='reverted'>        if (rmm.tau == 0) revert PoolExpired();</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>        // =---= Effects =---= //</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>        // These are WAD values.</span>
 422 |     | <span class='unexecuted'>        uint256 liveIndependent;</span>
 423 |     | <span class='neutral'>        uint256 nextIndependent;</span>
 424 |     | <span class='neutral'>        uint256 liveDependent;</span>
 425 |     | <span class='neutral'>        uint256 nextDependent;</span>
 426 |     | <span class='neutral'>        uint priorityFeeAmount;</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>        {</span>
 429 |     | <span class='neutral'>            uint256 maxInput;</span>
 430 |     | <span class='neutral'>            uint256 deltaInput;</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>            // Virtual reserves</span>
 433 |     | <span class='unexecuted'>            if (_state.sell) {</span>
 434 |     | <span class='unexecuted'>                (liveDependent, liveIndependent) = rmm.computeReserves(_swap.price);</span>
 435 | *r  | <span class='executed'>                maxInput = (FixedPointMathLib.WAD - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.</span>
 436 |     | <span class='neutral'>            } else {</span>
 437 |     | <span class='unexecuted'>                (liveIndependent, liveDependent) = rmm.computeReserves(_swap.price);</span>
 438 |     | <span class='unexecuted'>                maxInput = (rmm.strike - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.</span>
 439 |     | <span class='neutral'>            }</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='unexecuted'>            priorityFeeAmount = msg.sender == pool.controller ? (pool.liquidity * _state.fee) / 10_000 : 0;</span>
 442 |     | <span class='unexecuted'>            _swap.feeAmount = priorityFeeAmount != 0</span>
 443 |     | <span class='unexecuted'>                ? 0</span>
 444 |     | <span class='unexecuted'>                : ((_swap.remainder &gt; maxInput ? maxInput : _swap.remainder) * _state.fee) / 10_000;</span>
 445 |     | <span class='unexecuted'>            _state.feeGrowthGlobal = FixedPointMathLib.divWadDown(_swap.feeAmount, _swap.liquidity);</span>
 446 |     | <span class='unexecuted'>            if (priorityFeeAmount != 0) _state.priorityFeeGrowthGlobal = priorityFeeAmount.divWadDown(_swap.liquidity); // todo: change to staked liquidity</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='unexecuted'>            if (_swap.remainder &gt; maxInput) {</span>
 449 |     | <span class='unexecuted'>                deltaInput = maxInput - _swap.feeAmount;</span>
 450 |     | <span class='unexecuted'>                nextIndependent = liveIndependent + deltaInput.divWadDown(_swap.liquidity);</span>
 451 |     | <span class='unexecuted'>                _swap.remainder -= (deltaInput + _swap.feeAmount);</span>
 452 |     | <span class='neutral'>            } else {</span>
 453 |     | <span class='unexecuted'>                deltaInput = _swap.remainder - _swap.feeAmount;</span>
 454 |     | <span class='unexecuted'>                nextIndependent = liveIndependent + deltaInput.divWadDown(_swap.liquidity);</span>
 455 |     | <span class='unexecuted'>                deltaInput = _swap.remainder; // Swap input amount including the fee payment.</span>
 456 |     | <span class='unexecuted'>                _swap.remainder = 0; // Clear the remainder to zero, as the order has been filled.</span>
 457 |     | <span class='neutral'>            }</span>
 458 |     | <span class='neutral'></span>
 459 |     | <span class='neutral'>            // Compute the output of the swap by computing the difference between the dependent reserves.</span>
 460 |     | <span class='unexecuted'>            if (_state.sell) nextDependent = rmm.getYWithX(nextIndependent);</span>
 461 |     | <span class='unexecuted'>            else nextDependent = rmm.getXWithY(nextIndependent);</span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='unexecuted'>            _swap.input += deltaInput;</span>
 464 |     | <span class='unexecuted'>            _swap.output += (liveDependent - nextDependent);</span>
 465 |     | <span class='neutral'>        }</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>        {</span>
 468 |     | <span class='unexecuted'>            uint256 nextPrice;</span>
 469 |     | <span class='unexecuted'>            uint256 limitPrice = args.limit;</span>
 470 |     | <span class='neutral'>            int256 liveInvariantWad;</span>
 471 |     | <span class='neutral'>            int256 nextInvariantWad;</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='unexecuted'>            if (_state.sell) {</span>
 474 |     | <span class='unexecuted'>                liveInvariantWad = rmm.invariantOf(liveDependent, liveIndependent);</span>
 475 |     | <span class='unexecuted'>                nextInvariantWad = rmm.invariantOf(nextDependent, nextIndependent);</span>
 476 |     | <span class='unexecuted'>                nextPrice = rmm.getPriceWithX(nextIndependent);</span>
 477 |     | <span class='neutral'>            } else {</span>
 478 |     | <span class='unexecuted'>                liveInvariantWad = rmm.invariantOf(liveIndependent, liveDependent);</span>
 479 |     | <span class='unexecuted'>                nextInvariantWad = rmm.invariantOf(nextIndependent, nextDependent);</span>
 480 |     | <span class='unexecuted'>                nextPrice = rmm.getPriceWithX(nextDependent);</span>
 481 |     | <span class='neutral'>            }</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='unexecuted'>            if (!_state.sell &amp;&amp; nextPrice &gt; limitPrice) revert SwapLimitReached();</span>
 484 |     | <span class='unexecuted'>            if (_state.sell &amp;&amp; limitPrice &gt; nextPrice) revert SwapLimitReached();</span>
 485 |     | <span class='neutral'></span>
 486 |     | <span class='unexecuted'>            liveInvariantWad = liveInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote); // invariant is denominated in quote token.</span>
 487 |     | <span class='unexecuted'>            nextInvariantWad = nextInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote);</span>
 488 |     | <span class='unexecuted'>            if (nextInvariantWad &lt; liveInvariantWad) revert InvalidInvariant(liveInvariantWad, nextInvariantWad);</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>            _swap.price = (nextPrice * 10_000_001) / 10_000_000; // todo: this prevents failure in fuzz tests, investigate further. Related to precision.</span>
 491 |     | <span class='neutral'>        }</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='unexecuted'>        {</span>
 494 |     | <span class='unexecuted'>            uint inputDec;</span>
 495 |     | <span class='neutral'>            uint outputDec;</span>
 496 |     | <span class='unexecuted'>            if (_state.sell) {</span>
 497 |     | <span class='unexecuted'>                inputDec = pool.pair.decimalsAsset;</span>
 498 |     | <span class='unexecuted'>                outputDec = pool.pair.decimalsQuote;</span>
 499 |     | <span class='neutral'>            } else {</span>
 500 |     | <span class='unexecuted'>                inputDec = pool.pair.decimalsQuote;</span>
 501 |     | <span class='unexecuted'>                outputDec = pool.pair.decimalsAsset;</span>
 502 |     | <span class='neutral'>            }</span>
 503 |     | <span class='neutral'></span>
 504 |     | <span class='unexecuted'>            _swap.input = _swap.input.scaleFromWadUp(inputDec);</span>
 505 |     | <span class='unexecuted'>            _swap.output = _swap.output.scaleFromWadDown(outputDec);</span>
 506 |     | <span class='neutral'>        }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='neutral'>        // Apply pool effects.</span>
 509 |     | <span class='unexecuted'>        _syncPool(</span>
 510 |     | <span class='unexecuted'>            args.poolId,</span>
 511 |     | <span class='unexecuted'>            Price.computeTickWithPrice(_swap.price),</span>
 512 |     | <span class='unexecuted'>            _swap.price,</span>
 513 |     | <span class='unexecuted'>            _swap.liquidity,</span>
 514 |     | <span class='unexecuted'>            _state.sell ? _state.feeGrowthGlobal : 0,</span>
 515 |     | <span class='unexecuted'>            _state.sell ? 0 : _state.feeGrowthGlobal,</span>
 516 |     | <span class='unexecuted'>            _state.priorityFeeGrowthGlobal</span>
 517 |     | <span class='neutral'>        );</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='unexecuted'>        _increaseReserves(_state.tokenInput, _swap.input);</span>
 520 |     | <span class='unexecuted'>        _decreaseReserves(_state.tokenOutput, _swap.output);</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>        // Apply reserve effects.</span>
 523 |     | <span class='unexecuted'>        if (priorityFeeAmount != 0) {</span>
 524 |     | <span class='neutral'>            // Uses hyper&#39;s internal balance as a fee bucket for priority swaps.</span>
 525 |     | <span class='neutral'>            // todo: investigate two different pools accruing priority rewards in the same bucket,</span>
 526 |     | <span class='neutral'>            // and if it&#39;s possible to &quot;steal&quot; another pool&#39;s accrued priority rewards.</span>
 527 |     | <span class='unexecuted'>            _increaseReserves(WETH, priorityFeeAmount);</span>
 528 |     | <span class='unexecuted'>            emit IncreaseUserBalance(address(this), WETH, priorityFeeAmount);</span>
 529 |     | <span class='unexecuted'>            __account__.credit(address(this), WETH, priorityFeeAmount);</span>
 530 |     | <span class='neutral'>        }</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='unexecuted'>        emit Swap(args.poolId, _swap.price, _state.tokenInput, _swap.input, _state.tokenOutput, _swap.output);</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='unexecuted'>        delete _state;</span>
 535 |     | <span class='unexecuted'>        return (args.poolId, _swap.remainder, _swap.input, _swap.output);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    /**</span>
 539 |     | <span class='neutral'>     * @dev Computes the price of the pool, which changes over time.</span>
 540 |     | <span class='neutral'>     *</span>
 541 |     | <span class='neutral'>     * @custom:reverts Underflows if the reserve of the input token is lower than the next one, after the next price movement.</span>
 542 |     | <span class='neutral'>     * @custom:reverts Underflows if current reserves of output token is less then next reserves.</span>
 543 |     | <span class='neutral'>     */</span>
 544 | *r  | <span class='executed'>    function _computeSyncedPrice(uint64 poolId) internal view returns (uint256 price, int24 tick, uint updatedTau) {</span>
 545 | *r  | <span class='executed'>        HyperPool memory pool = pools[poolId];</span>
 546 | *r  | <span class='executed'>        if (!pool.exists()) revert NonExistentPool(poolId);</span>
 547 |     | <span class='neutral'></span>
 548 | *r  | <span class='executed'>        (price, tick, updatedTau) = (pool.lastPrice, pool.lastTick, pool.tau(_blockTimestamp()));</span>
 549 |     | <span class='neutral'></span>
 550 | *r  | <span class='executed'>        uint passed = getTimePassed(poolId);</span>
 551 | *r  | <span class='executed'>        if (passed &gt; 0) {</span>
 552 | *r  | <span class='executed'>            uint256 lastTau = pool.lastTau(); // pool.params.maturity() - pool.lastTimestamp.</span>
 553 | *r  | <span class='executed'>            (price, tick) = pool.computePriceChangeWithTime(lastTau, passed);</span>
 554 |     | <span class='neutral'>        }</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>    /**</span>
 558 |     | <span class='neutral'>     * @dev Effects on a Pool after a successful swap order condition has been met.</span>
 559 |     | <span class='neutral'>     */</span>
 560 |     | <span class='unexecuted'>    function _syncPool(</span>
 561 |     | <span class='neutral'>        uint64 poolId,</span>
 562 |     | <span class='neutral'>        int24 tick,</span>
 563 |     | <span class='neutral'>        uint256 price,</span>
 564 |     | <span class='neutral'>        uint256 liquidity,</span>
 565 |     | <span class='neutral'>        uint256 feeGrowthGlobalAsset,</span>
 566 |     | <span class='neutral'>        uint256 feeGrowthGlobalQuote,</span>
 567 |     | <span class='neutral'>        uint256 feeGrowthGlobalReward</span>
 568 |     | <span class='unexecuted'>    ) internal returns (uint256 timeDelta) {</span>
 569 |     | <span class='unexecuted'>        HyperPool storage pool = pools[poolId];</span>
 570 |     | <span class='neutral'></span>
 571 |     | <span class='unexecuted'>        uint256 timestamp = _blockTimestamp();</span>
 572 |     | <span class='unexecuted'>        timeDelta = getTimePassed(poolId);</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>        // todo: better configuration of this value?</span>
 575 |     | <span class='unexecuted'>        uint requiredTimePassedForStake = 1;</span>
 576 |     | <span class='unexecuted'>        if (timeDelta &gt;= requiredTimePassedForStake) {</span>
 577 |     | <span class='unexecuted'>            pool.stakedLiquidity = Assembly.addSignedDelta(pool.stakedLiquidity, pool.stakedLiquidityDelta);</span>
 578 |     | <span class='unexecuted'>            pool.stakedLiquidityDelta = 0;</span>
 579 |     | <span class='neutral'>        }</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='unexecuted'>        if (pool.lastTick != tick) pool.lastTick = tick;</span>
 582 |     | <span class='unexecuted'>        if (pool.lastPrice != price) pool.lastPrice = price.safeCastTo128();</span>
 583 |     | <span class='unexecuted'>        if (pool.liquidity != liquidity) pool.liquidity = liquidity.safeCastTo128();</span>
 584 |     | <span class='unexecuted'>        if (pool.lastTimestamp != timestamp) pool.syncPoolTimestamp(timestamp);</span>
 585 |     | <span class='neutral'></span>
 586 |     | <span class='unexecuted'>        pool.feeGrowthGlobalAsset = Assembly.computeCheckpoint(pool.feeGrowthGlobalAsset, feeGrowthGlobalAsset);</span>
 587 |     | <span class='unexecuted'>        pool.feeGrowthGlobalQuote = Assembly.computeCheckpoint(pool.feeGrowthGlobalQuote, feeGrowthGlobalQuote);</span>
 588 |     | <span class='unexecuted'>        pool.feeGrowthGlobalReward = Assembly.computeCheckpoint(pool.feeGrowthGlobalReward, feeGrowthGlobalReward);</span>
 589 |     | <span class='neutral'>    }</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>    // ===== Initializing Pools ===== //</span>
 592 |     | <span class='neutral'></span>
 593 | *   | <span class='executed'>    function _createPair(address asset, address quote) internal returns (uint24 pairId) {</span>
 594 | *   | <span class='executed'>        if (asset == quote) revert SameTokenError();</span>
 595 |     | <span class='neutral'></span>
 596 | *   | <span class='executed'>        pairId = getPairId[asset][quote];</span>
 597 | *   | <span class='executed'>        if (pairId != 0) revert PairExists(pairId);</span>
 598 |     | <span class='neutral'></span>
 599 | *   | <span class='executed'>        (uint8 decimalsAsset, uint8 decimalsQuote) = (IERC20(asset).decimals(), IERC20(quote).decimals());</span>
 600 | *   | <span class='executed'>        if (!decimalsAsset.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))</span>
 601 | *   | <span class='executed'>            revert InvalidDecimals(decimalsAsset);</span>
 602 | *   | <span class='executed'>        if (!decimalsQuote.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))</span>
 603 |     | <span class='unexecuted'>            revert InvalidDecimals(decimalsQuote);</span>
 604 |     | <span class='neutral'></span>
 605 |     | <span class='neutral'>        unchecked {</span>
 606 | *   | <span class='executed'>            pairId = uint24(++getPairNonce);</span>
 607 |     | <span class='neutral'>        }</span>
 608 |     | <span class='neutral'></span>
 609 | *   | <span class='executed'>        getPairId[asset][quote] = pairId; // note: order of tokens matters!</span>
 610 | *   | <span class='executed'>        pairs[pairId] = HyperPair({</span>
 611 |     | <span class='neutral'>            tokenAsset: asset,</span>
 612 |     | <span class='neutral'>            decimalsAsset: decimalsAsset,</span>
 613 |     | <span class='neutral'>            tokenQuote: quote,</span>
 614 |     | <span class='neutral'>            decimalsQuote: decimalsQuote</span>
 615 |     | <span class='neutral'>        });</span>
 616 |     | <span class='neutral'></span>
 617 | *   | <span class='executed'>        emit CreatePair(pairId, asset, quote, decimalsAsset, decimalsQuote);</span>
 618 |     | <span class='neutral'>    }</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='neutral'>    /** @dev If pairId == 0, its a magic variable that uses current pair nonce. */</span>
 621 | *   | <span class='executed'>    function _createPool(</span>
 622 |     | <span class='neutral'>        uint24 pairId,</span>
 623 |     | <span class='neutral'>        address controller,</span>
 624 |     | <span class='neutral'>        uint16 priorityFee,</span>
 625 |     | <span class='neutral'>        uint16 fee,</span>
 626 |     | <span class='neutral'>        uint16 vol,</span>
 627 |     | <span class='neutral'>        uint16 dur,</span>
 628 |     | <span class='neutral'>        uint16 jit,</span>
 629 |     | <span class='neutral'>        int24 max,</span>
 630 |     | <span class='neutral'>        uint128 price</span>
 631 | *   | <span class='executed'>    ) internal returns (uint64 poolId) {</span>
 632 | *   | <span class='executed'>        if (price == 0) revert ZeroPrice(); </span>
 633 |     | <span class='neutral'></span>
 634 | *   | <span class='executed'>        uint32 timestamp = uint(_blockTimestamp()).safeCastTo32();</span>
 635 | *   | <span class='executed'>        HyperPool memory pool;</span>
 636 | *   | <span class='executed'>        pool.controller = controller;</span>
 637 | *   | <span class='executed'>        pool.lastTimestamp = timestamp;</span>
 638 | *   | <span class='executed'>        pool.lastPrice = price;</span>
 639 | *   | <span class='executed'>        pool.lastTick = Price.computeTickWithPrice(pool.lastPrice);</span>
 640 | *   | <span class='executed'>        bool hasController = pool.controller != address(0);</span>
 641 | *   | <span class='executed'>        if (hasController &amp;&amp; priorityFee == 0) revert InvalidFee(priorityFee); // Cannot set priority to 0.</span>
 642 |     | <span class='neutral'></span>
 643 | *   | <span class='executed'>        uint24 pairNonce = pairId == 0 ? uint24(getPairNonce) : pairId; // magic variable todo: fix, possible to set 0 pairId if getPairNonce is 0</span>
 644 | *   | <span class='executed'>        pool.pair = pairs[pairNonce];</span>
 645 |     | <span class='neutral'></span>
 646 | *   | <span class='executed'>        HyperCurve memory params = HyperCurve({</span>
 647 |     | <span class='neutral'>            maxTick: max,</span>
 648 | *   | <span class='executed'>            jit: hasController ? jit : uint8(_liquidityPolicy()),</span>
 649 | *   | <span class='executed'>            fee: fee,</span>
 650 | *   | <span class='executed'>            duration: dur,</span>
 651 | *   | <span class='executed'>            volatility: vol,</span>
 652 | *   | <span class='executed'>            priorityFee: hasController ? priorityFee : 0, // min fee</span>
 653 | *   | <span class='executed'>            createdAt: timestamp</span>
 654 |     | <span class='neutral'>        });</span>
 655 | *   | <span class='executed'>        params.validateParameters();</span>
 656 | *   | <span class='executed'>        pool.params = params;</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='neutral'>        uint32 poolNonce;</span>
 659 |     | <span class='neutral'>        unchecked {</span>
 660 | *   | <span class='executed'>            poolNonce = uint32(++getPoolNonce);</span>
 661 |     | <span class='neutral'>        }</span>
 662 |     | <span class='neutral'></span>
 663 | *   | <span class='executed'>        poolId = Enigma.encodePoolId(pairNonce, hasController, poolNonce);</span>
 664 | *   | <span class='executed'>        if (pools[poolId].exists()) revert PoolExists(); // todo: poolNonce always increments, so this never gets hit, remove</span>
 665 |     | <span class='neutral'></span>
 666 | *   | <span class='executed'>        pools[poolId] = pool; // effect</span>
 667 |     | <span class='neutral'></span>
 668 | *   | <span class='executed'>        emit CreatePool(poolId, hasController, pool.pair.tokenAsset, pool.pair.tokenQuote, price);</span>
 669 |     | <span class='neutral'>    }</span>
 670 |     | <span class='neutral'></span>
 671 | r   | <span class='reverted'>    function changeParameters(</span>
 672 |     | <span class='neutral'>        uint64 poolId,</span>
 673 |     | <span class='neutral'>        uint16 priorityFee,</span>
 674 |     | <span class='neutral'>        uint16 fee,</span>
 675 |     | <span class='neutral'>        uint16 volatility,</span>
 676 |     | <span class='neutral'>        uint16 duration,</span>
 677 |     | <span class='neutral'>        uint16 jit,</span>
 678 |     | <span class='neutral'>        int24 maxTick</span>
 679 |     | <span class='neutral'>    ) external lock interactions {</span>
 680 | r   | <span class='reverted'>        HyperPool storage pool = pools[poolId];</span>
 681 | r   | <span class='reverted'>        if (pool.controller != msg.sender) revert NotController();</span>
 682 |     | <span class='neutral'></span>
 683 |     | <span class='unexecuted'>        HyperCurve memory modified = pool.params;</span>
 684 |     | <span class='unexecuted'>        if (jit != 0) modified.jit = jit;</span>
 685 |     | <span class='unexecuted'>        if (maxTick != 0) modified.maxTick = maxTick;</span>
 686 |     | <span class='unexecuted'>        if (fee != 0) modified.fee = fee;</span>
 687 |     | <span class='unexecuted'>        if (volatility != 0) modified.volatility = volatility;</span>
 688 |     | <span class='unexecuted'>        if (duration != 0) modified.duration = duration;</span>
 689 |     | <span class='unexecuted'>        if (priorityFee != 0) modified.priorityFee = priorityFee;</span>
 690 |     | <span class='neutral'></span>
 691 |     | <span class='unexecuted'>        pool.changePoolParameters(modified);</span>
 692 |     | <span class='neutral'></span>
 693 |     | <span class='unexecuted'>        emit ChangeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);</span>
 694 |     | <span class='neutral'>    }</span>
 695 |     | <span class='neutral'></span>
 696 |     | <span class='neutral'>    /** @dev Overridable in tests.  */</span>
 697 | r   | <span class='reverted'>    function _blockTimestamp() internal view virtual returns (uint128) {</span>
 698 | *r  | <span class='executed'>        return uint128(block.timestamp);</span>
 699 |     | <span class='neutral'>    }</span>
 700 |     | <span class='neutral'></span>
 701 |     | <span class='neutral'>    /** @dev Overridable in tests.  */</span>
 702 |     | <span class='neutral'>    function _liquidityPolicy() internal view virtual returns (uint256) {</span>
 703 |     | <span class='neutral'>        return JUST_IN_TIME_LIQUIDITY_POLICY;</span>
 704 |     | <span class='neutral'>    }</span>
 705 |     | <span class='neutral'></span>
 706 |     | <span class='neutral'>    // ===== Accounting System ===== //</span>
 707 |     | <span class='neutral'>    /**</span>
 708 |     | <span class='neutral'>     * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.</span>
 709 |     | <span class='neutral'>     *</span>
 710 |     | <span class='neutral'>     * @custom:security Directly manipulates reserves.</span>
 711 |     | <span class='neutral'>     */</span>
 712 | r   | <span class='reverted'>    function _increaseReserves(address token, uint256 amount) internal {</span>
 713 | r   | <span class='reverted'>        __account__.increase(token, amount);</span>
 714 | r   | <span class='reverted'>        emit IncreaseReserveBalance(token, amount);</span>
 715 |     | <span class='neutral'>    }</span>
 716 |     | <span class='neutral'></span>
 717 |     | <span class='neutral'>    /**</span>
 718 |     | <span class='neutral'>     * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.</span>
 719 |     | <span class='neutral'>     *</span>
 720 |     | <span class='neutral'>     * @custom:security Directly manipulates reserves.</span>
 721 |     | <span class='neutral'>     * @custom:reverts With `InsufficientReserve` if current reserve balance for `token` iss less than `amount`.</span>
 722 |     | <span class='neutral'>     */</span>
 723 | *r  | <span class='executed'>    function _decreaseReserves(address token, uint256 amount) internal {</span>
 724 | *r  | <span class='executed'>        __account__.decrease(token, amount);</span>
 725 | *r  | <span class='executed'>        emit DecreaseReserveBalance(token, amount);</span>
 726 |     | <span class='neutral'>    }</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>    /**</span>
 729 |     | <span class='neutral'>     * @dev A positive credit is a receivable paid to the `msg.sender` internal balance.</span>
 730 |     | <span class='neutral'>     *      Positive credits are only applied to the internal balance of the account.</span>
 731 |     | <span class='neutral'>     *      Therefore, it does not require a state change for the global reserves.</span>
 732 |     | <span class='neutral'>     *</span>
 733 |     | <span class='neutral'>     * @custom:security Directly manipulates intrernal balances.</span>
 734 |     | <span class='neutral'>     */</span>
 735 | *r  | <span class='executed'>    function _applyCredit(address token, uint256 amount) internal {</span>
 736 |     | <span class='unexecuted'>        __account__.credit(msg.sender, token, amount);</span>
 737 | *r  | <span class='executed'>        emit IncreaseUserBalance(msg.sender, token, amount);</span>
 738 |     | <span class='neutral'>    }</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>    /**</span>
 741 |     | <span class='neutral'>     * @dev A positive debit is a cost that must be paid for a transaction to be processed.</span>
 742 |     | <span class='neutral'>     *      If a balance exists for the token for the internal balance of `msg.sender`,</span>
 743 |     | <span class='neutral'>     *      it will be used to pay the debit. Else, the contract expects tokens to be transferred in.</span>
 744 |     | <span class='neutral'>     *</span>
 745 |     | <span class='neutral'>     * @custom:security Directly manipulates intrernal balances.</span>
 746 |     | <span class='neutral'>     */</span>
 747 | *r  | <span class='executed'>    function _applyDebit(address token, uint256 amount) internal {</span>
 748 | *r  | <span class='executed'>        __account__.debit(msg.sender, token, amount);</span>
 749 | *r  | <span class='executed'>        emit DecreaseUserBalance(msg.sender, token, amount);</span>
 750 |     | <span class='neutral'>    }</span>
 751 |     | <span class='neutral'></span>
 752 |     | <span class='neutral'>    /**</span>
 753 |     | <span class='neutral'>     * @dev Alternative entrypoint to execute functions.</span>
 754 |     | <span class='neutral'>     * @param data Encoded Enigma data. First byte must be an Enigma instruction.</span>
 755 |     | <span class='neutral'>     */</span>
 756 | *r  | <span class='executed'>    function _process(bytes calldata data) internal {</span>
 757 | *r  | <span class='executed'>        (, bytes1 instruction) = Assembly.separate(data[0]); // Upper byte is useMax, lower byte is instruction.</span>
 758 |     | <span class='neutral'></span>
 759 | *r  | <span class='executed'>        if (instruction == Enigma.ALLOCATE) {</span>
 760 | r   | <span class='reverted'>            (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeAllocate(data);</span>
 761 |     | <span class='unexecuted'>            _allocate(useMax == 1, poolId, deltaLiquidity);</span>
 762 | *r  | <span class='executed'>        } else if (instruction == Enigma.UNALLOCATE) {</span>
 763 | r   | <span class='reverted'>            (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnallocate(data);</span>
 764 | r   | <span class='reverted'>            _unallocate(useMax == 1, poolId, deltaLiquidity);</span>
 765 | *r  | <span class='executed'>        } else if (instruction == Enigma.SWAP) {</span>
 766 |     | <span class='neutral'>            Order memory args;</span>
 767 | r   | <span class='reverted'>            (args.useMax, args.poolId, args.input, args.limit, args.direction) = Enigma.decodeSwap(data);</span>
 768 |     | <span class='unexecuted'>            _swapExactIn(args);</span>
 769 | *r  | <span class='executed'>        } else if (instruction == Enigma.STAKE_POSITION) {</span>
 770 | r   | <span class='reverted'>            (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeStakePosition(data);</span>
 771 | *r  | <span class='executed'>            _stake(poolId, deltaLiquidity);</span>
 772 | *r  | <span class='executed'>        } else if (instruction == Enigma.UNSTAKE_POSITION) {</span>
 773 |     | <span class='unexecuted'>            (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnstakePosition(data);</span>
 774 | *r  | <span class='executed'>            _unstake(poolId, deltaLiquidity);</span>
 775 | *r  | <span class='executed'>        } else if (instruction == Enigma.CREATE_POOL) {</span>
 776 | *   | <span class='executed'>            (</span>
 777 | *   | <span class='executed'>                uint24 pairId,</span>
 778 | *   | <span class='executed'>                address controller,</span>
 779 | *   | <span class='executed'>                uint16 priorityFee,</span>
 780 | *   | <span class='executed'>                uint16 fee,</span>
 781 | *   | <span class='executed'>                uint16 vol,</span>
 782 | *   | <span class='executed'>                uint16 dur,</span>
 783 | *   | <span class='executed'>                uint16 jit,</span>
 784 | *   | <span class='executed'>                int24 max,</span>
 785 | *   | <span class='executed'>                uint128 price</span>
 786 | *   | <span class='executed'>            ) = Enigma.decodeCreatePool(data);</span>
 787 | *   | <span class='executed'>            _createPool(pairId, controller, priorityFee, fee, vol, dur, jit, max, price);</span>
 788 | *r  | <span class='executed'>        } else if (instruction == Enigma.CREATE_PAIR) {</span>
 789 | *   | <span class='executed'>            (address asset, address quote) = Enigma.decodeCreatePair(data);</span>
 790 | *   | <span class='executed'>            _createPair(asset, quote);</span>
 791 |     | <span class='neutral'>        } else {</span>
 792 | r   | <span class='reverted'>            revert InvalidInstruction();</span>
 793 |     | <span class='neutral'>        }</span>
 794 |     | <span class='neutral'>    }</span>
 795 |     | <span class='neutral'></span>
 796 |     | <span class='neutral'>    /**</span>
 797 |     | <span class='neutral'></span>
 798 |     | <span class='neutral'>        Be aware of these settlement invariants:</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='neutral'>        Invariant 1. Every token that is interacted with is cached and exists.</span>
 801 |     | <span class='neutral'>        Invariant 2. Tokens are removed from cache, and cache is empty by end of settlement.</span>
 802 |     | <span class='neutral'>        Invariant 3. Cached tokens cannot be carried over from previous transactions.</span>
 803 |     | <span class='neutral'>        Invariant 4. Execution does not exit during the loops prematurely.</span>
 804 |     | <span class='neutral'>        Invariant 5. Account `settled` bool is set to true at end of `settlement`.</span>
 805 |     | <span class='neutral'>        Invariant 6. Debits reduce `reserves` of `token`.</span>
 806 |     | <span class='neutral'></span>
 807 |     | <span class='neutral'>     */</span>
 808 | *r  | <span class='executed'>    function _settlement() internal {</span>
 809 | *r  | <span class='executed'>        if (!__account__.prepared) revert OS.NotPreparedToSettle();</span>
 810 |     | <span class='neutral'></span>
 811 | *r  | <span class='executed'>        address[] memory tokens = __account__.warm;</span>
 812 | *r  | <span class='executed'>        uint256 loops = tokens.length;</span>
 813 | *r  | <span class='executed'>        if (loops == 0) return __account__.reset(); // exit early.</span>
 814 |     | <span class='neutral'></span>
 815 | *r  | <span class='executed'>        uint x;</span>
 816 | *r  | <span class='executed'>        uint i = loops;</span>
 817 | *r  | <span class='executed'>        do {</span>
 818 |     | <span class='neutral'>            // Loop backwards to pop tokens off.</span>
 819 | *r  | <span class='executed'>            address token = tokens[i - 1];</span>
 820 |     | <span class='neutral'>            // Apply credits or debits to net balance.</span>
 821 | *r  | <span class='executed'>            (uint credited, uint debited, uint remainder) = __account__.settle(token, address(this));</span>
 822 |     | <span class='neutral'>            // Reserves were increased, we paid a debit, therefore need to decrease reserves by `debited` amount.</span>
 823 | *r  | <span class='executed'>            if (debited &gt; 0) {</span>
 824 |     | <span class='unexecuted'>                emit DecreaseUserBalance(msg.sender, token, debited);</span>
 825 |     | <span class='unexecuted'>                emit DecreaseReserveBalance(token, debited);</span>
 826 |     | <span class='neutral'>            }</span>
 827 |     | <span class='neutral'>            // Reserves were not tracking some tokens, increase the reserves to account for them.</span>
 828 | *r  | <span class='executed'>            if (credited &gt; 0) {</span>
 829 | *   | <span class='executed'>                emit IncreaseUserBalance(msg.sender, token, credited);</span>
 830 | *   | <span class='executed'>                emit IncreaseReserveBalance(token, credited);</span>
 831 |     | <span class='neutral'>            }</span>
 832 |     | <span class='neutral'>            // Outstanding amount must be transferred in.</span>
 833 | *r  | <span class='executed'>            if (remainder &gt; 0) _payments.push(Payment({token: token, amount: remainder}));</span>
 834 |     | <span class='neutral'>            // Token accounted for.</span>
 835 | *r  | <span class='executed'>            __account__.warm.pop();</span>
 836 |     | <span class='neutral'>            unchecked {</span>
 837 | *r  | <span class='executed'>                --i;</span>
 838 | *r  | <span class='executed'>                ++x;</span>
 839 |     | <span class='neutral'>            }</span>
 840 | *r  | <span class='executed'>        } while (i != 0);</span>
 841 |     | <span class='neutral'></span>
 842 | *r  | <span class='executed'>        Payment[] memory payments = _payments;</span>
 843 |     | <span class='neutral'></span>
 844 | *r  | <span class='executed'>        uint px = payments.length;</span>
 845 | *r  | <span class='executed'>        while (px != 0) {</span>
 846 | r   | <span class='reverted'>            uint index = px - 1;</span>
 847 | r   | <span class='reverted'>            OS.__dangerousTransferFrom__(payments[index].token, address(this), payments[index].amount);</span>
 848 |     | <span class='neutral'>            unchecked {</span>
 849 | r   | <span class='reverted'>                --px;</span>
 850 |     | <span class='neutral'>            }</span>
 851 |     | <span class='neutral'>        }</span>
 852 |     | <span class='neutral'></span>
 853 | *r  | <span class='executed'>        __account__.reset();</span>
 854 | *r  | <span class='executed'>        delete _payments;</span>
 855 |     | <span class='neutral'>    }</span>
 856 |     | <span class='neutral'></span>
 857 |     | <span class='neutral'>    // ===== View ===== //</span>
 858 |     | <span class='neutral'></span>
 859 |     | <span class='neutral'>    /** @dev Can be manipulated. */</span>
 860 | *r  | <span class='executed'>    function getLatestPrice(uint64 poolId) public view returns (uint price) {</span>
 861 | *r  | <span class='executed'>        (price, , ) = _computeSyncedPrice(poolId);</span>
 862 |     | <span class='neutral'>    }</span>
 863 |     | <span class='neutral'></span>
 864 | *r  | <span class='executed'>    function getTimePassed(uint64 poolId) public view returns (uint) {</span>
 865 | *r  | <span class='executed'>        return _blockTimestamp() - pools[poolId].lastTimestamp;</span>
 866 |     | <span class='neutral'>    }</span>
 867 |     | <span class='neutral'></span>
 868 | *r  | <span class='executed'>    function getVirtualReserves(uint64 poolId) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {</span>
 869 | *   | <span class='executed'>        return pools[poolId].getVirtualReserves();</span>
 870 |     | <span class='neutral'>    }</span>
 871 |     | <span class='neutral'></span>
 872 | *r  | <span class='executed'>    function getMaxLiquidity(</span>
 873 |     | <span class='neutral'>        uint64 poolId,</span>
 874 |     | <span class='neutral'>        uint deltaAsset,</span>
 875 |     | <span class='neutral'>        uint deltaQuote</span>
 876 | *r  | <span class='executed'>    ) public view override returns (uint128 deltaLiquidity) {</span>
 877 | *r  | <span class='executed'>        return pools[poolId].getMaxLiquidity(deltaAsset, deltaQuote);</span>
 878 |     | <span class='neutral'>    }</span>
 879 |     | <span class='neutral'></span>
 880 | *r  | <span class='executed'>    function getLiquidityDeltas(</span>
 881 |     | <span class='neutral'>        uint64 poolId,</span>
 882 |     | <span class='neutral'>        int128 deltaLiquidity</span>
 883 | *r  | <span class='executed'>    ) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {</span>
 884 | *r  | <span class='executed'>        return pools[poolId].getLiquidityDeltas(deltaLiquidity);</span>
 885 |     | <span class='neutral'>    }</span>
 886 |     | <span class='neutral'></span>
 887 | *r  | <span class='executed'>    function getAmounts(uint64 poolId) public view override returns (uint256 deltaAsset, uint256 deltaQuote) {</span>
 888 | *   | <span class='executed'>        return pools[poolId].getAmounts();</span>
 889 |     | <span class='neutral'>    }</span>
 890 |     | <span class='neutral'></span>
 891 | r   | <span class='reverted'>    function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) public view returns (uint output) {</span>
 892 | r   | <span class='reverted'>        uint24 pairId = Enigma.decodePairIdFromPoolId(poolId);</span>
 893 | r   | <span class='reverted'>        HyperPool memory pool = pools[poolId];</span>
 894 | r   | <span class='reverted'>        (output, ) = pool.getAmountOut({</span>
 895 | r   | <span class='reverted'>            pair: pairs[pairId],</span>
 896 | r   | <span class='reverted'>            sellAsset: sellAsset,</span>
 897 | r   | <span class='reverted'>            amountIn: amountIn,</span>
 898 | r   | <span class='reverted'>            timeSinceUpdate: _blockTimestamp() - pool.lastTimestamp // invariant: should not underflow.</span>
 899 |     | <span class='neutral'>        });</span>
 900 |     | <span class='neutral'>    }</span>
 901 |     | <span class='neutral'>}</span>
 902 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/HyperLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>  -------------</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>  Comprehensive library with all structs, errors,</span>
   9 |     | <span class='neutral'>  constants, and utils for Hyper.</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>  -------------</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>  Primitive™</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>import &quot;solmate/utils/SafeCastLib.sol&quot;;</span>
  18 |     | <span class='neutral'>import &quot;./libraries/Price.sol&quot;;</span>
  19 |     | <span class='neutral'>import &quot;./Assembly.sol&quot; as Assembly;</span>
  20 |     | <span class='neutral'>import &quot;./Enigma.sol&quot; as Enigma;</span>
  21 |     | <span class='neutral'>import &quot;./OS.sol&quot; as OS;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>using Price for Price.RMM;</span>
  24 |     | <span class='neutral'>using SafeCastLib for uint;</span>
  25 |     | <span class='neutral'>using FixedPointMathLib for uint;</span>
  26 |     | <span class='neutral'>using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;</span>
  27 |     | <span class='neutral'>using {checkParameters, maturity, strike, validateParameters} for HyperCurve global;</span>
  28 |     | <span class='neutral'>using {changePositionLiquidity, syncPositionFees, getTimeSinceChanged, syncPositionStakedFees} for HyperPosition global;</span>
  29 |     | <span class='neutral'>using {</span>
  30 |     | <span class='neutral'>    changePoolLiquidity,</span>
  31 |     | <span class='neutral'>    changePoolParameters,</span>
  32 |     | <span class='neutral'>    computePriceChangeWithTime,</span>
  33 |     | <span class='neutral'>    exists,</span>
  34 |     | <span class='neutral'>    getAmounts,</span>
  35 |     | <span class='neutral'>    getAmountOut,</span>
  36 |     | <span class='neutral'>    getAmountsWad,</span>
  37 |     | <span class='neutral'>    getLiquidityDeltas,</span>
  38 |     | <span class='neutral'>    getMaxLiquidity,</span>
  39 |     | <span class='neutral'>    getMaxSwapAssetInWad,</span>
  40 |     | <span class='neutral'>    getMaxSwapQuoteInWad,</span>
  41 |     | <span class='neutral'>    getRMM,</span>
  42 |     | <span class='neutral'>    getVirtualReserves,</span>
  43 |     | <span class='neutral'>    isMutable,</span>
  44 |     | <span class='neutral'>    syncPoolTimestamp,</span>
  45 |     | <span class='neutral'>    lastTau,</span>
  46 |     | <span class='neutral'>    tau</span>
  47 |     | <span class='neutral'>} for HyperPool global;</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>int24 constant MAX_TICK = 887272;</span>
  50 |     | <span class='neutral'>uint256 constant BUFFER = 300 seconds;</span>
  51 | *   | <span class='executed'>uint256 constant MIN_FEE = 1; // 0.01%</span>
  52 | *   | <span class='executed'>uint256 constant MAX_FEE = 1000; // 10%</span>
  53 | *   | <span class='executed'>uint256 constant MIN_VOLATILITY = 100; // 1%</span>
  54 | *   | <span class='executed'>uint256 constant MAX_VOLATILITY = 25_000; // 250%</span>
  55 | *   | <span class='executed'>uint256 constant MIN_DURATION = 1; // days, but without units</span>
  56 | *   | <span class='executed'>uint256 constant MAX_DURATION = 500; // days, but without units</span>
  57 | *   | <span class='executed'>uint256 constant JUST_IN_TIME_MAX = 600 seconds;</span>
  58 | *   | <span class='executed'>uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>// todo: add selectors for debugging?</span>
  61 |     | <span class='neutral'>error DrawBalance();</span>
  62 |     | <span class='neutral'>error InsufficientPosition(uint64 poolId);</span>
  63 |     | <span class='neutral'>error InvalidDecimals(uint8 decimals);</span>
  64 |     | <span class='neutral'>error InvalidDuration(uint16);</span>
  65 |     | <span class='neutral'>error InvalidFee(uint16 fee);</span>
  66 |     | <span class='neutral'>error InvalidInstruction();</span>
  67 |     | <span class='neutral'>error InvalidInvariant(int256 prev, int256 next);</span>
  68 |     | <span class='neutral'>error InvalidJit(uint16);</span>
  69 |     | <span class='neutral'>error InvalidReentrancy();</span>
  70 |     | <span class='neutral'>error InvalidReward();</span>
  71 |     | <span class='neutral'>error InvalidSettlement();</span>
  72 |     | <span class='neutral'>error InvalidStrike(uint128 strike);</span>
  73 |     | <span class='neutral'>error InvalidTick(int24);</span>
  74 |     | <span class='neutral'>error InvalidTransfer();</span>
  75 |     | <span class='neutral'>error InvalidVolatility(uint24 sigma); // todo: fix, use uint16 type.</span>
  76 |     | <span class='neutral'>error JitLiquidity(uint256 distance);</span>
  77 |     | <span class='neutral'>error MaxFee(uint16 fee);</span>
  78 |     | <span class='neutral'>error NotController();</span>
  79 |     | <span class='neutral'>error NonExistentPool(uint64 poolId);</span>
  80 |     | <span class='neutral'>error NonExistentPosition(address owner, uint64 poolId);</span>
  81 |     | <span class='neutral'>error PairExists(uint24 pairId);</span>
  82 |     | <span class='neutral'>error PerLiquidityError(uint256 deltaAsset);</span>
  83 |     | <span class='neutral'>error PoolExists();</span>
  84 |     | <span class='neutral'>error PoolExpired();</span>
  85 |     | <span class='neutral'>error PositionStaked(uint96 positionId);</span>
  86 |     | <span class='neutral'>error PositionZeroLiquidity(uint96 positionId);</span>
  87 |     | <span class='neutral'>error PositionNotStaked(uint96 positionId);</span>
  88 |     | <span class='neutral'>error SameTokenError();</span>
  89 |     | <span class='neutral'>error StakeNotMature(uint64 poolId);</span>
  90 |     | <span class='neutral'>error SwapLimitReached();</span>
  91 |     | <span class='neutral'>error ZeroInput();</span>
  92 |     | <span class='neutral'>error ZeroLiquidity();</span>
  93 |     | <span class='neutral'>error ZeroPrice();</span>
  94 |     | <span class='neutral'>error ZeroValue();</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>struct HyperPair {</span>
  97 |     | <span class='neutral'>    address tokenAsset;</span>
  98 |     | <span class='neutral'>    uint8 decimalsAsset;</span>
  99 |     | <span class='neutral'>    address tokenQuote;</span>
 100 |     | <span class='neutral'>    uint8 decimalsQuote;</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>struct HyperCurve {</span>
 104 |     | <span class='neutral'>    // single slot</span>
 105 |     | <span class='neutral'>    int24 maxTick;</span>
 106 |     | <span class='neutral'>    uint16 jit;</span>
 107 |     | <span class='neutral'>    uint16 fee;</span>
 108 |     | <span class='neutral'>    uint16 duration;</span>
 109 |     | <span class='neutral'>    uint16 volatility;</span>
 110 |     | <span class='neutral'>    uint16 priorityFee;</span>
 111 |     | <span class='neutral'>    uint32 createdAt;</span>
 112 |     | <span class='neutral'>}</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>struct HyperPool {</span>
 115 |     | <span class='neutral'>    int24 lastTick;</span>
 116 |     | <span class='neutral'>    uint32 lastTimestamp; // updated on swaps.</span>
 117 |     | <span class='neutral'>    address controller;</span>
 118 |     | <span class='neutral'>    uint256 feeGrowthGlobalReward;</span>
 119 |     | <span class='neutral'>    uint256 feeGrowthGlobalAsset;</span>
 120 |     | <span class='neutral'>    uint256 feeGrowthGlobalQuote;</span>
 121 |     | <span class='neutral'>    uint128 lastPrice;</span>
 122 |     | <span class='neutral'>    uint128 liquidity; // available liquidity to remove</span>
 123 |     | <span class='neutral'>    uint128 stakedLiquidity; // locked liquidity</span>
 124 |     | <span class='neutral'>    int128 stakedLiquidityDelta; // liquidity to be added or removed</span>
 125 |     | <span class='neutral'>    HyperCurve params;</span>
 126 |     | <span class='neutral'>    HyperPair pair;</span>
 127 |     | <span class='neutral'>}</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>// todo: optimize slot</span>
 130 |     | <span class='neutral'>struct HyperPosition {</span>
 131 |     | <span class='neutral'>    uint128 freeLiquidity;</span>
 132 |     | <span class='neutral'>    uint128 stakedLiquidity;</span>
 133 |     | <span class='neutral'>    uint256 lastTimestamp;</span>
 134 |     | <span class='neutral'>    uint256 stakeTimestamp;</span>
 135 |     | <span class='neutral'>    uint256 unstakeTimestamp;</span>
 136 |     | <span class='neutral'>    uint256 feeGrowthRewardLast;</span>
 137 |     | <span class='neutral'>    uint256 feeGrowthAssetLast;</span>
 138 |     | <span class='neutral'>    uint256 feeGrowthQuoteLast;</span>
 139 |     | <span class='neutral'>    uint128 tokensOwedAsset;</span>
 140 |     | <span class='neutral'>    uint128 tokensOwedQuote;</span>
 141 |     | <span class='neutral'>    uint128 tokensOwedReward;</span>
 142 |     | <span class='neutral'>}</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>struct ChangeLiquidityParams {</span>
 145 |     | <span class='neutral'>    address owner;</span>
 146 |     | <span class='neutral'>    uint64 poolId;</span>
 147 |     | <span class='neutral'>    uint256 timestamp;</span>
 148 |     | <span class='neutral'>    uint256 deltaAsset;</span>
 149 |     | <span class='neutral'>    uint256 deltaQuote;</span>
 150 |     | <span class='neutral'>    address tokenAsset;</span>
 151 |     | <span class='neutral'>    address tokenQuote;</span>
 152 |     | <span class='neutral'>    int128 deltaLiquidity;</span>
 153 |     | <span class='neutral'>}</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>struct Order {</span>
 156 |     | <span class='neutral'>    uint8 useMax;</span>
 157 |     | <span class='neutral'>    uint64 poolId;</span>
 158 |     | <span class='neutral'>    uint128 input;</span>
 159 |     | <span class='neutral'>    uint128 limit;</span>
 160 |     | <span class='neutral'>    uint8 direction;</span>
 161 |     | <span class='neutral'>}</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>struct Iteration {</span>
 164 |     | <span class='neutral'>    int24 tick;</span>
 165 |     | <span class='neutral'>    uint256 price;</span>
 166 |     | <span class='neutral'>    uint256 remainder;</span>
 167 |     | <span class='neutral'>    uint256 feeAmount;</span>
 168 |     | <span class='neutral'>    uint256 liquidity;</span>
 169 |     | <span class='neutral'>    uint256 input;</span>
 170 |     | <span class='neutral'>    uint256 output;</span>
 171 |     | <span class='neutral'>}</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>struct SwapState {</span>
 174 |     | <span class='neutral'>    bool sell;</span>
 175 |     | <span class='neutral'>    address tokenInput;</span>
 176 |     | <span class='neutral'>    address tokenOutput;</span>
 177 |     | <span class='neutral'>    uint256 fee;</span>
 178 |     | <span class='neutral'>    uint256 feeGrowthGlobal;</span>
 179 |     | <span class='neutral'>    uint256 priorityFeeGrowthGlobal;</span>
 180 |     | <span class='neutral'>}</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>struct Payment {</span>
 183 |     | <span class='neutral'>    address token;</span>
 184 |     | <span class='neutral'>    uint amount;</span>
 185 |     | <span class='neutral'>}</span>
 186 | r   | <span class='reverted'></span>
 187 |     | <span class='neutral'>function changePoolLiquidity(HyperPool storage self, int128 liquidityDelta) {</span>
 188 | r   | <span class='reverted'>    self.liquidity = Assembly.addSignedDelta(self.liquidity, liquidityDelta);</span>
 189 |     | <span class='neutral'>}</span>
 190 |     | <span class='unexecuted'></span>
 191 |     | <span class='neutral'>function syncPoolTimestamp(HyperPool storage self, uint timestamp) {</span>
 192 |     | <span class='unexecuted'>    self.lastTimestamp = SafeCastLib.safeCastTo32(timestamp);</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='unexecuted'></span>
 195 |     | <span class='neutral'>function changePoolParameters(HyperPool storage self, HyperCurve memory updated) {</span>
 196 |     | <span class='unexecuted'>    (bool success, ) = updated.validateParameters();</span>
 197 |     | <span class='unexecuted'>    self.params = updated;</span>
 198 |     | <span class='unexecuted'>    assert(success);</span>
 199 |     | <span class='neutral'>}</span>
 200 | r   | <span class='reverted'></span>
 201 |     | <span class='neutral'>function changePositionLiquidity(HyperPosition storage self, uint256 timestamp, int128 liquidityDelta) {</span>
 202 | r   | <span class='reverted'>    self.lastTimestamp = timestamp;</span>
 203 | r   | <span class='reverted'>    self.freeLiquidity = Assembly.addSignedDelta(self.freeLiquidity, liquidityDelta);</span>
 204 |     | <span class='neutral'>}</span>
 205 |     | <span class='neutral'></span>
 206 | r   | <span class='reverted'>/** @dev Liquidity must be altered after syncing positions and not before. */</span>
 207 |     | <span class='neutral'>function syncPositionFees(</span>
 208 |     | <span class='neutral'>    HyperPosition storage self,</span>
 209 |     | <span class='neutral'>    uint liquidity,</span>
 210 |     | <span class='neutral'>    uint feeGrowthAsset,</span>
 211 |     | <span class='neutral'>    uint feeGrowthQuote</span>
 212 | r   | <span class='reverted'>) returns (uint feeAssetEarned, uint feeQuoteEarned) {</span>
 213 | r   | <span class='reverted'>    uint checkpointAsset = Assembly.computeCheckpointDistance(feeGrowthAsset, self.feeGrowthAssetLast);</span>
 214 | r   | <span class='reverted'>    uint checkpointQuote = Assembly.computeCheckpointDistance(feeGrowthQuote, self.feeGrowthQuoteLast);</span>
 215 |     | <span class='neutral'></span>
 216 | r   | <span class='reverted'>    feeAssetEarned = FixedPointMathLib.mulWadDown(checkpointAsset, liquidity);</span>
 217 | r   | <span class='reverted'>    feeQuoteEarned = FixedPointMathLib.mulWadDown(checkpointQuote, liquidity);</span>
 218 |     | <span class='neutral'></span>
 219 | r   | <span class='reverted'>    self.feeGrowthAssetLast = feeGrowthAsset;</span>
 220 | r   | <span class='reverted'>    self.feeGrowthQuoteLast = feeGrowthQuote;</span>
 221 |     | <span class='neutral'></span>
 222 | r   | <span class='reverted'>    self.tokensOwedAsset += SafeCastLib.safeCastTo128(feeAssetEarned);</span>
 223 | r   | <span class='reverted'>    self.tokensOwedQuote += SafeCastLib.safeCastTo128(feeQuoteEarned);</span>
 224 |     | <span class='neutral'>}</span>
 225 |     | <span class='unexecuted'></span>
 226 |     | <span class='unexecuted'>function syncPositionStakedFees(HyperPosition storage self, uint liquidity, uint feeGrowth) returns (uint feeEarned) {</span>
 227 |     | <span class='unexecuted'>    uint checkpoint = Assembly.computeCheckpointDistance(feeGrowth, self.feeGrowthRewardLast);</span>
 228 |     | <span class='unexecuted'>    feeEarned = FixedPointMathLib.mulWadDown(checkpoint, liquidity);</span>
 229 |     | <span class='unexecuted'>    self.feeGrowthRewardLast = feeEarned;</span>
 230 |     | <span class='unexecuted'>    self.tokensOwedReward += SafeCastLib.safeCastTo128(feeEarned);</span>
 231 |     | <span class='neutral'>}</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>// ===== View ===== //</span>
 234 | *   | <span class='executed'></span>
 235 | *   | <span class='executed'>function getVirtualReserves(HyperPool memory self) view returns (uint128 reserveAsset, uint128 reserveQuote) {</span>
 236 | *   | <span class='executed'>    return self.getLiquidityDeltas(-int128(self.liquidity)); // rounds down</span>
 237 |     | <span class='neutral'>}</span>
 238 | *r  | <span class='executed'></span>
 239 |     | <span class='neutral'>function getMaxLiquidity(</span>
 240 |     | <span class='neutral'>    HyperPool memory self,</span>
 241 |     | <span class='neutral'>    uint deltaAsset,</span>
 242 |     | <span class='neutral'>    uint deltaQuote</span>
 243 | *r  | <span class='executed'>) view returns (uint128 deltaLiquidity) {</span>
 244 | *r  | <span class='executed'>    (uint amountAsset, uint amountQuote) = self.getAmounts();</span>
 245 | *r  | <span class='executed'>    uint liquidity0 = deltaAsset.divWadDown(amountAsset);</span>
 246 | *r  | <span class='executed'>    uint liquidity1 = deltaQuote.divWadDown(amountQuote);</span>
 247 | *   | <span class='executed'>    deltaLiquidity = (liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1).safeCastTo128();</span>
 248 |     | <span class='neutral'>}</span>
 249 |     | <span class='neutral'></span>
 250 | *r  | <span class='executed'>/** @dev Rounds positive deltas up. Rounds negative deltas down. */</span>
 251 |     | <span class='neutral'>function getLiquidityDeltas(</span>
 252 |     | <span class='neutral'>    HyperPool memory self,</span>
 253 |     | <span class='neutral'>    int128 deltaLiquidity</span>
 254 | *r  | <span class='executed'>) view returns (uint128 deltaAsset, uint128 deltaQuote) {</span>
 255 | *r  | <span class='executed'>    if (deltaLiquidity == 0) return (deltaAsset, deltaQuote);</span>
 256 | *r  | <span class='executed'>    (uint amountAsset, uint amountQuote) = self.getAmounts();</span>
 257 |     | <span class='neutral'></span>
 258 | *r  | <span class='executed'>    uint delta;</span>
 259 | *r  | <span class='executed'>    if (deltaLiquidity &gt; 0) {</span>
 260 | *r  | <span class='executed'>        delta = uint128(deltaLiquidity);</span>
 261 | *r  | <span class='executed'>        deltaAsset = amountAsset.mulWadUp(delta).safeCastTo128();</span>
 262 | *r  | <span class='executed'>        deltaQuote = amountQuote.mulWadUp(delta).safeCastTo128();</span>
 263 |     | <span class='neutral'>    } else {</span>
 264 | *r  | <span class='executed'>        delta = uint128(-deltaLiquidity);</span>
 265 | *r  | <span class='executed'>        deltaAsset = amountAsset.mulWadDown(delta).safeCastTo128();</span>
 266 | *r  | <span class='executed'>        deltaQuote = amountQuote.mulWadDown(delta).safeCastTo128();</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'>}</span>
 269 |     | <span class='neutral'></span>
 270 | *r  | <span class='executed'>/** @dev Decimal amounts per WAD of liquidity, rounded down... */</span>
 271 | *r  | <span class='executed'>function getAmounts(HyperPool memory self) view returns (uint amountAssetDec, uint amountQuoteDec) {</span>
 272 | *r  | <span class='executed'>    (uint amountAssetWad, uint amountQuoteWad) = self.getAmountsWad();</span>
 273 | *r  | <span class='executed'>    amountAssetDec = amountAssetWad.scaleFromWadDown(self.pair.decimalsAsset);</span>
 274 | *r  | <span class='executed'>    amountQuoteDec = amountQuoteWad.scaleFromWadDown(self.pair.decimalsQuote);</span>
 275 |     | <span class='neutral'>}</span>
 276 |     | <span class='neutral'></span>
 277 | *r  | <span class='executed'>/** @dev WAD Amounts per WAD of liquidity. */</span>
 278 | *r  | <span class='executed'>function getAmountsWad(HyperPool memory self) view returns (uint amountAssetWad, uint amountQuoteWad) {</span>
 279 | *r  | <span class='executed'>    Price.RMM memory rmm = self.getRMM();</span>
 280 | *r  | <span class='executed'>    amountAssetWad = rmm.getXWithPrice(self.lastPrice);</span>
 281 | *r  | <span class='executed'>    amountQuoteWad = rmm.getYWithX(amountAssetWad);</span>
 282 |     | <span class='neutral'>}</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>// ===== Derived ===== //</span>
 285 | *r  | <span class='executed'></span>
 286 |     | <span class='neutral'>function computePriceChangeWithTime(</span>
 287 |     | <span class='neutral'>    HyperPool memory self,</span>
 288 |     | <span class='neutral'>    uint timeRemaining,</span>
 289 |     | <span class='neutral'>    uint epsilon</span>
 290 | *r  | <span class='executed'>) pure returns (uint price, int24 tick) {</span>
 291 | *r  | <span class='executed'>    uint maxPrice = Price.computePriceWithTick(self.params.maxTick);</span>
 292 | *r  | <span class='executed'>    price = Price.computePriceWithChangeInTau(maxPrice, self.params.volatility, self.lastPrice, timeRemaining, epsilon);</span>
 293 | *r  | <span class='executed'>    tick = Price.computeTickWithPrice(price);</span>
 294 |     | <span class='neutral'>}</span>
 295 | r   | <span class='reverted'></span>
 296 | r   | <span class='reverted'>function getTimeSinceChanged(HyperPosition memory self, uint timestamp) view returns (uint distance) {</span>
 297 | r   | <span class='reverted'>    return timestamp - self.lastTimestamp;</span>
 298 |     | <span class='neutral'>}</span>
 299 | *r  | <span class='executed'></span>
 300 |     | <span class='neutral'>function exists(HyperPool memory self) view returns (bool) {</span>
 301 | *r  | <span class='executed'>    return self.lastTimestamp != 0;</span>
 302 |     | <span class='neutral'>}</span>
 303 | *   | <span class='executed'></span>
 304 |     | <span class='neutral'>function isMutable(HyperPool memory self) view returns (bool) {</span>
 305 | *r  | <span class='executed'>    return self.controller != address(0);</span>
 306 |     | <span class='neutral'>}</span>
 307 | *r  | <span class='executed'></span>
 308 | *r  | <span class='executed'>function getRMM(HyperPool memory self) view returns (Price.RMM memory) {</span>
 309 | *r  | <span class='executed'>    return Price.RMM({strike: self.params.strike(), sigma: self.params.volatility, tau: self.lastTau()});</span>
 310 |     | <span class='neutral'>}</span>
 311 | *r  | <span class='executed'></span>
 312 | *r  | <span class='executed'>function lastTau(HyperPool memory self) view returns (uint) {</span>
 313 | *r  | <span class='executed'>    return self.tau(self.lastTimestamp);</span>
 314 |     | <span class='neutral'>}</span>
 315 | *r  | <span class='executed'></span>
 316 | *r  | <span class='executed'>function tau(HyperPool memory self, uint timestamp) view returns (uint) {</span>
 317 | *r  | <span class='executed'>    uint end = self.params.maturity();</span>
 318 | *r  | <span class='executed'>    if (timestamp &gt; end) return 0;</span>
 319 | *r  | <span class='executed'>    return end - timestamp;</span>
 320 |     | <span class='neutral'>}</span>
 321 | *r  | <span class='executed'></span>
 322 | *r  | <span class='executed'>function strike(HyperCurve memory self) view returns (uint) {</span>
 323 | *r  | <span class='executed'>    return Price.computePriceWithTick(self.maxTick);</span>
 324 |     | <span class='neutral'>}</span>
 325 | *r  | <span class='executed'></span>
 326 | *r  | <span class='executed'>function maturity(HyperCurve memory self) view returns (uint32 endTimestamp) {</span>
 327 | *r  | <span class='executed'>    return (Assembly.convertDaysToSeconds(self.duration) + self.createdAt).safeCastTo32();</span>
 328 |     | <span class='neutral'>}</span>
 329 | *   | <span class='executed'></span>
 330 | *   | <span class='executed'>function validateParameters(HyperCurve memory self) view returns (bool, bytes memory) {</span>
 331 | *   | <span class='executed'>    (bool success, bytes memory reason) = self.checkParameters();</span>
 332 | *   | <span class='executed'>    if (!success) {</span>
 333 |     | <span class='neutral'>        assembly {</span>
 334 |     | <span class='unexecuted'>            revert(add(32, reason), mload(reason))</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 | *   | <span class='executed'>    return (success, reason);</span>
 339 |     | <span class='neutral'>}</span>
 340 |     | <span class='neutral'></span>
 341 | *   | <span class='executed'>/** @dev Invalid parameters should revert. */</span>
 342 | *   | <span class='executed'>function checkParameters(HyperCurve memory self) view returns (bool, bytes memory) {</span>
 343 | *   | <span class='executed'>    if (!Assembly.isBetween(self.volatility, MIN_VOLATILITY, MAX_VOLATILITY))</span>
 344 |     | <span class='unexecuted'>        return (false, abi.encodeWithSelector(InvalidVolatility.selector, self.volatility));</span>
 345 | *   | <span class='executed'>    if (!Assembly.isBetween(self.duration, MIN_DURATION, MAX_DURATION))</span>
 346 |     | <span class='unexecuted'>        return (false, abi.encodeWithSelector(InvalidDuration.selector, self.duration));</span>
 347 | *   | <span class='executed'>    if (self.maxTick &gt;= MAX_TICK) return (false, abi.encodeWithSelector(InvalidTick.selector, self.maxTick)); //  todo: fix, min tick check?</span>
 348 | *   | <span class='executed'>    if (self.jit &gt; JUST_IN_TIME_MAX) return (false, abi.encodeWithSelector(InvalidJit.selector, self.jit));</span>
 349 | *   | <span class='executed'>    if (!Assembly.isBetween(self.fee, MIN_FEE, MAX_FEE))</span>
 350 |     | <span class='unexecuted'>        return (false, abi.encodeWithSelector(InvalidFee.selector, self.fee));</span>
 351 |     | <span class='neutral'>    // 0 priority fee == no controller, impossible to set to zero unless default from non controlled pools.</span>
 352 | *   | <span class='executed'>    if (!Assembly.isBetween(self.priorityFee, 0, self.fee))</span>
 353 |     | <span class='unexecuted'>        return (false, abi.encodeWithSelector(InvalidFee.selector, self.priorityFee));</span>
 354 |     | <span class='neutral'></span>
 355 | *   | <span class='executed'>    return (true, &quot;&quot;);</span>
 356 |     | <span class='neutral'>}</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>// ===== Swaps ===== //</span>
 359 |     | <span class='unexecuted'></span>
 360 |     | <span class='unexecuted'>function getMaxSwapAssetInWad(HyperPool memory self) view returns (uint) {</span>
 361 |     | <span class='unexecuted'>    Price.RMM memory rmm = self.getRMM();</span>
 362 |     | <span class='unexecuted'>    (, uint res1) = rmm.computeReserves(self.lastPrice);</span>
 363 |     | <span class='unexecuted'>    uint maxInput = FixedPointMathLib.WAD - res1;</span>
 364 |     | <span class='unexecuted'>    maxInput = maxInput.mulWadDown(self.liquidity);</span>
 365 |     | <span class='unexecuted'>    return maxInput.scaleFromWadDown(self.pair.decimalsAsset);</span>
 366 |     | <span class='neutral'>}</span>
 367 |     | <span class='unexecuted'></span>
 368 |     | <span class='unexecuted'>function getMaxSwapQuoteInWad(HyperPool memory self) view returns (uint) {</span>
 369 |     | <span class='unexecuted'>    Price.RMM memory rmm = self.getRMM();</span>
 370 |     | <span class='unexecuted'>    (uint res0, ) = rmm.computeReserves(self.lastPrice);</span>
 371 |     | <span class='unexecuted'>    uint maxInput = rmm.strike - res0;</span>
 372 |     | <span class='unexecuted'>    maxInput = maxInput.mulWadDown(self.liquidity);</span>
 373 |     | <span class='unexecuted'>    return maxInput.scaleFromWadDown(self.pair.decimalsQuote);</span>
 374 |     | <span class='neutral'>}</span>
 375 | r   | <span class='reverted'></span>
 376 |     | <span class='neutral'>function getAmountOut(</span>
 377 |     | <span class='neutral'>    HyperPool memory self,</span>
 378 |     | <span class='neutral'>    HyperPair memory pair,</span>
 379 |     | <span class='neutral'>    bool sellAsset,</span>
 380 |     | <span class='neutral'>    uint amountIn,</span>
 381 |     | <span class='neutral'>    uint timeSinceUpdate</span>
 382 | r   | <span class='reverted'>) view returns (uint, uint) {</span>
 383 | r   | <span class='reverted'>    Iteration memory data;</span>
 384 | r   | <span class='reverted'>    Price.RMM memory rmm = self.getRMM();</span>
 385 | r   | <span class='reverted'>    (data.price, data.tick) = self.computePriceChangeWithTime(self.lastTau(), timeSinceUpdate);</span>
 386 | r   | <span class='reverted'>    data.remainder = amountIn.scaleToWad(sellAsset ? pair.decimalsAsset : pair.decimalsQuote);</span>
 387 | r   | <span class='reverted'>    data.liquidity = self.liquidity;</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    uint prevInd;</span>
 390 |     | <span class='neutral'>    uint prevDep;</span>
 391 |     | <span class='neutral'>    uint nextInd;</span>
 392 |     | <span class='neutral'>    uint nextDep;</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>    {</span>
 395 |     | <span class='neutral'>        uint maxInput;</span>
 396 |     | <span class='neutral'>        uint delInput;</span>
 397 |     | <span class='neutral'></span>
 398 | r   | <span class='reverted'>        if (sellAsset) {</span>
 399 | r   | <span class='reverted'>            (prevDep, prevInd) = rmm.computeReserves(data.price);</span>
 400 | r   | <span class='reverted'>            maxInput = (FixedPointMathLib.WAD - prevInd).mulWadDown(self.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.</span>
 401 |     | <span class='neutral'>        } else {</span>
 402 | r   | <span class='reverted'>            (prevInd, prevDep) = rmm.computeReserves(data.price);</span>
 403 | r   | <span class='reverted'>            maxInput = (rmm.strike - prevInd).mulWadDown(self.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'></span>
 406 | r   | <span class='reverted'>        data.feeAmount = ((data.remainder &gt; maxInput ? maxInput : data.remainder) * self.params.fee) / 10_000;</span>
 407 |     | <span class='neutral'></span>
 408 | r   | <span class='reverted'>        if (data.remainder &gt; maxInput) {</span>
 409 | r   | <span class='reverted'>            delInput = maxInput - data.feeAmount;</span>
 410 | r   | <span class='reverted'>            nextInd = prevInd + delInput.divWadDown(data.liquidity);</span>
 411 |     | <span class='unexecuted'>            data.remainder -= (delInput + data.feeAmount);</span>
 412 |     | <span class='neutral'>        } else {</span>
 413 |     | <span class='unexecuted'>            delInput = data.remainder - data.feeAmount;</span>
 414 |     | <span class='unexecuted'>            nextInd = prevInd + delInput.divWadDown(data.liquidity);</span>
 415 |     | <span class='unexecuted'>            delInput = data.remainder; // Swap input amount including the fee payment.</span>
 416 |     | <span class='unexecuted'>            data.remainder = 0; // Clear the remainder to zero, as the order has been filled.</span>
 417 |     | <span class='neutral'>        }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>        // Compute the output of the swap by computing the difference between the dependent reserves.</span>
 420 |     | <span class='unexecuted'>        if (sellAsset) nextDep = rmm.getYWithX(nextInd);</span>
 421 |     | <span class='unexecuted'>        else nextDep = rmm.getXWithY(nextInd);</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='unexecuted'>        data.input += delInput;</span>
 424 |     | <span class='unexecuted'>        data.output += (prevDep - nextDep);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>    {</span>
 428 |     | <span class='neutral'>        // Scale down amounts from WAD.</span>
 429 |     | <span class='unexecuted'>        uint inputDec;</span>
 430 |     | <span class='neutral'>        uint outputDec;</span>
 431 |     | <span class='unexecuted'>        if (sellAsset) {</span>
 432 |     | <span class='unexecuted'>            inputDec = pair.decimalsAsset;</span>
 433 |     | <span class='unexecuted'>            outputDec = pair.decimalsQuote;</span>
 434 |     | <span class='neutral'>        } else {</span>
 435 |     | <span class='unexecuted'>            inputDec = pair.decimalsQuote;</span>
 436 |     | <span class='unexecuted'>            outputDec = pair.decimalsAsset;</span>
 437 |     | <span class='neutral'>        }</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='unexecuted'>        data.input = data.input.scaleFromWadUp(inputDec);</span>
 440 |     | <span class='unexecuted'>        data.output = data.output.scaleFromWadDown(outputDec);</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='unexecuted'>    return (data.output, data.remainder);</span>
 444 |     | <span class='neutral'>}</span>
 445 | r   | <span class='reverted'></span>
 446 | r   | <span class='reverted'>function toInt128(uint128 a) pure returns (int128 b) {</span>
 447 |     | <span class='neutral'>    assembly {</span>
 448 | r   | <span class='reverted'>        if gt(a, 0x7fffffffffffffffffffffffffffffff) {</span>
 449 |     | <span class='unexecuted'>            revert(0, 0)</span>
 450 |     | <span class='neutral'>        }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>        b := a</span>
 453 |     | <span class='neutral'>    }</span>
 454 |     | <span class='neutral'>}</span>
 455 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/OS.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>  -------------</span>
   7 |     | <span class='neutral'>  </span>
   8 |     | <span class='neutral'>  This is a custom account system to support Enigma&#39;s</span>
   9 |     | <span class='neutral'>  jump processing. Without jump processing, the benefits </span>
  10 |     | <span class='neutral'>  are marginal at best. Combining the two reduces the </span>
  11 |     | <span class='neutral'>  marginal cost of aditional operations to only ~20% of a single operation. </span>
  12 |     | <span class='neutral'>  This is by design, in order to support a system that interacts with a lot</span>
  13 |     | <span class='neutral'>  of different parameters, tokens, actors, and pools.</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>  -------------</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>  Glossary:</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>  Virtual Reserves  - Expected balance of tokens.</span>
  20 |     | <span class='neutral'>  Physical Reserves - Actual balance of tokens.</span>
  21 |     | <span class='neutral'>  Net Balance       - Difference of physical reserve and virtual reserve.</span>
  22 |     | <span class='neutral'>  Credit            - Increase (+) spendable tokens.</span>
  23 |     | <span class='neutral'>  Debit             - Decrease (-) spendable tokens.</span>
  24 |     | <span class='neutral'>  Settle            - Apply net balance (+/-) as credit (+) or debit (-) to user.</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>  -------------</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>  Primitive™</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'> */</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>import &quot;solmate/utils/SafeTransferLib.sol&quot;;</span>
  33 |     | <span class='neutral'>import &quot;./interfaces/IWETH.sol&quot;;</span>
  34 |     | <span class='neutral'>import &quot;./interfaces/IERC20.sol&quot;;</span>
  35 |     | <span class='neutral'>import &quot;./Assembly.sol&quot; as Assembly;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>using {</span>
  38 |     | <span class='neutral'>    __wrapEther__,</span>
  39 |     | <span class='neutral'>    dangerousFund,</span>
  40 |     | <span class='neutral'>    cache,</span>
  41 |     | <span class='neutral'>    credit,</span>
  42 |     | <span class='neutral'>    debit,</span>
  43 |     | <span class='neutral'>    decrease,</span>
  44 |     | <span class='neutral'>    increase,</span>
  45 |     | <span class='neutral'>    reset,</span>
  46 |     | <span class='neutral'>    settle,</span>
  47 |     | <span class='neutral'>    touch,</span>
  48 |     | <span class='neutral'>    getNetBalance</span>
  49 |     | <span class='neutral'>} for AccountSystem global;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>error EtherTransferFail(); // 0x75f42683</span>
  52 |     | <span class='neutral'>error InsufficientReserve(uint amount, uint delta); // 0x315276c9</span>
  53 |     | <span class='neutral'>error InvalidBalance(); // 0xc52e3eff</span>
  54 |     | <span class='neutral'>error NotPreparedToSettle(); // 0xf7cede50</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>struct AccountSystem {</span>
  57 |     | <span class='neutral'>    // user -&gt; token -&gt; internal balance.</span>
  58 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint)) balances;</span>
  59 |     | <span class='neutral'>    // token -&gt; virtual reserve.</span>
  60 |     | <span class='neutral'>    mapping(address =&gt; uint) reserves;</span>
  61 |     | <span class='neutral'>    // token -&gt; cached status. todo: make this a bitmap</span>
  62 |     | <span class='neutral'>    mapping(address =&gt; bool) cached;</span>
  63 |     | <span class='neutral'>    // Transiently stored cached tokens, must be length zero outside of execution.</span>
  64 |     | <span class='neutral'>    address[] warm;</span>
  65 |     | <span class='neutral'>    // Must be `false` outside of execution.</span>
  66 |     | <span class='neutral'>    bool prepared;</span>
  67 |     | <span class='neutral'>    // Must be `true` outside of execution.</span>
  68 |     | <span class='neutral'>    bool settled;</span>
  69 |     | <span class='neutral'>}</span>
  70 |     | <span class='neutral'></span>
  71 | *r  | <span class='executed'>/** @dev Gas optimized. */</span>
  72 | *r  | <span class='executed'>function __balanceOf__(address token, address account) view returns (uint256) {</span>
  73 | *r  | <span class='executed'>    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, account));</span>
  74 | *r  | <span class='executed'>    if (!success || data.length != 32) revert InvalidBalance();</span>
  75 | *r  | <span class='executed'>    return abi.decode(data, (uint256));</span>
  76 |     | <span class='neutral'>}</span>
  77 |     | <span class='neutral'></span>
  78 | *r  | <span class='executed'>/** @dev Must validate `weth` is real weth. */</span>
  79 |     | <span class='neutral'>function __wrapEther__(AccountSystem storage self, address weth) {</span>
  80 | *r  | <span class='executed'>    if (msg.value &gt; 0) {</span>
  81 | *r  | <span class='executed'>        self.touch(weth);</span>
  82 | *r  | <span class='executed'>        IWETH(weth).deposit{value: msg.value}();</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'>}</span>
  85 |     | <span class='neutral'></span>
  86 | *   | <span class='executed'>/** @dev Dangerously sends ether to `to` in a low-level call. */</span>
  87 |     | <span class='neutral'>function __dangerousUnwrapEther__(address weth, address to, uint256 amount) {</span>
  88 | *   | <span class='executed'>    IWETH(weth).withdraw(amount);</span>
  89 | *   | <span class='executed'>    __dangerousTransferEther__(to, amount);</span>
  90 |     | <span class='neutral'>}</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>/** @dev Dangerously sends ether to `to` in a low-level call. */</span>
  93 |     | <span class='neutral'>function __dangerousTransferEther__(address to, uint256 value) {</span>
  94 | *   | <span class='executed'>    (bool success, ) = to.call{value: value}(new bytes(0));</span>
  95 | *   | <span class='executed'>    if (!success) revert EtherTransferFail();</span>
  96 |     | <span class='neutral'>}</span>
  97 |     | <span class='neutral'></span>
  98 | *r  | <span class='executed'>/** @dev External call to the `to` address is dangerous. */</span>
  99 |     | <span class='neutral'>function __dangerousTransferFrom__(address token, address to, uint amount) {</span>
 100 | *r  | <span class='executed'>    SafeTransferLib.safeTransferFrom(ERC20(token), msg.sender, to, amount);</span>
 101 |     | <span class='neutral'>}</span>
 102 |     | <span class='neutral'></span>
 103 | *r  | <span class='executed'>/** @dev External call to the `to` address is dangerous. */</span>
 104 |     | <span class='neutral'>function dangerousFund(AccountSystem storage self, address token, address to, uint amount) {</span>
 105 | *r  | <span class='executed'>    self.touch(token);</span>
 106 | *r  | <span class='executed'>    __dangerousTransferFrom__(token, to, amount); // Settlement gifts tokens to msg.sender.</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>
 109 | *r  | <span class='executed'>/** @dev Increases an `owner`&#39;s spendable balance. */</span>
 110 |     | <span class='neutral'>function credit(AccountSystem storage self, address owner, address token, uint amount) {</span>
 111 | *   | <span class='executed'>    self.touch(token);</span>
 112 | *r  | <span class='executed'>    self.balances[owner][token] += amount;</span>
 113 |     | <span class='neutral'>}</span>
 114 |     | <span class='neutral'></span>
 115 | *r  | <span class='executed'>/** @dev Decreases an `owner`&#39;s spendable balance. */</span>
 116 |     | <span class='neutral'>function debit(</span>
 117 |     | <span class='neutral'>    AccountSystem storage self,</span>
 118 |     | <span class='neutral'>    address owner,</span>
 119 |     | <span class='neutral'>    address token,</span>
 120 |     | <span class='neutral'>    uint256 owed</span>
 121 | *r  | <span class='executed'>) returns (uint paid, uint remainder) {</span>
 122 | *r  | <span class='executed'>    self.touch(token);</span>
 123 | *r  | <span class='executed'>    uint balance = self.balances[owner][token];</span>
 124 | *r  | <span class='executed'>    if (balance &gt;= owed) {</span>
 125 | *r  | <span class='executed'>        paid = owed;</span>
 126 | *r  | <span class='executed'>        self.balances[owner][token] -= paid;</span>
 127 | *r  | <span class='executed'>        remainder = 0;</span>
 128 |     | <span class='neutral'>    } else {</span>
 129 | r   | <span class='reverted'>        paid = balance;</span>
 130 | r   | <span class='reverted'>        self.balances[owner][token] -= paid;</span>
 131 | r   | <span class='reverted'>        remainder = owed - paid;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>
 135 | r   | <span class='reverted'>/** @dev Actives a token and increases the reserves. Settlement will pick up this activated token. */</span>
 136 |     | <span class='neutral'>function increase(AccountSystem storage self, address token, uint amount) {</span>
 137 | r   | <span class='reverted'>    self.touch(token);</span>
 138 | r   | <span class='reverted'>    self.reserves[token] += amount;</span>
 139 |     | <span class='neutral'>}</span>
 140 |     | <span class='neutral'></span>
 141 | *r  | <span class='executed'>/** @dev Actives a token and decreases the reserves. Settlement will pick up this activated token. */</span>
 142 |     | <span class='neutral'>function decrease(AccountSystem storage self, address token, uint amount) {</span>
 143 | *r  | <span class='executed'>    uint balance = self.reserves[token];</span>
 144 | *r  | <span class='executed'>    if (amount &gt; balance) revert InsufficientReserve(balance, amount);</span>
 145 |     | <span class='neutral'></span>
 146 | *r  | <span class='executed'>    self.touch(token);</span>
 147 | *r  | <span class='executed'>    self.reserves[token] -= amount;</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>
 150 | *r  | <span class='executed'>/** @notice Settles the difference in balance between virtual tokens and physically held tokens. */</span>
 151 |     | <span class='neutral'>function settle(</span>
 152 |     | <span class='neutral'>    AccountSystem storage self,</span>
 153 |     | <span class='neutral'>    address token,</span>
 154 |     | <span class='neutral'>    address account</span>
 155 | *r  | <span class='executed'>) returns (uint credited, uint debited, uint remainder) {</span>
 156 | *r  | <span class='executed'>    int net = self.getNetBalance(token, account);</span>
 157 | *r  | <span class='executed'>    if (net &gt; 0) {</span>
 158 | *   | <span class='executed'>        credited = uint(net);</span>
 159 |     | <span class='neutral'>        // unaccounted for tokens, e.g. transferred directly into Hyper.</span>
 160 | *   | <span class='executed'>        self.credit(msg.sender, token, uint(net)); // gift to `msg.sender`.</span>
 161 | *   | <span class='executed'>        self.reserves[token] += uint(net); // add the difference back to reserves, so net is zero.</span>
 162 | *r  | <span class='executed'>    } else if (net &lt; 0) {</span>
 163 |     | <span class='neutral'>        // missing tokens that must be paid for or transferred in.</span>
 164 | r   | <span class='reverted'>        remainder = uint(-net);</span>
 165 | r   | <span class='reverted'>        (debited, remainder) = self.debit(msg.sender, token, remainder);</span>
 166 | *r  | <span class='executed'>        if (debited &gt; 0) self.reserves[token] -= debited; // using a balance means tokens are in contract already.</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 | *r  | <span class='executed'>    delete self.cached[token]; // Note: Assumes this token is completely paid for by the end of the transaction.</span>
 170 |     | <span class='neutral'>}</span>
 171 |     | <span class='neutral'></span>
 172 | *r  | <span class='executed'>/** @dev Interacting with a token will activate it, adding it to an array of interacted tokens for settlement to loop through. */</span>
 173 |     | <span class='neutral'>function touch(AccountSystem storage self, address token) {</span>
 174 | *r  | <span class='executed'>    if (self.settled) self.settled = false; // If tokens are warm, they are not settled.</span>
 175 | *r  | <span class='executed'>    if (!self.cached[token]) {</span>
 176 | *r  | <span class='executed'>        self.warm.push(token);</span>
 177 |     | <span class='neutral'>        self.cache(token, true);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>    // do nothing if already cached.</span>
 180 |     | <span class='neutral'>}</span>
 181 |     | <span class='neutral'></span>
 182 | *r  | <span class='executed'>/** @dev Account system is reset after settlement is successful. */</span>
 183 |     | <span class='neutral'>function reset(AccountSystem storage self) {</span>
 184 | *r  | <span class='executed'>    assert(self.warm.length == 0); // todo: this is a valid assertion, but should we use assert?</span>
 185 | *r  | <span class='executed'>    self.settled = true;</span>
 186 | *r  | <span class='executed'>    delete self.warm;</span>
 187 | *r  | <span class='executed'>    delete self.prepared;</span>
 188 |     | <span class='neutral'>}</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>/** @dev Used to check if a token was already activated after being interacted with again. */</span>
 191 |     | <span class='neutral'>function cache(AccountSystem storage self, address token, bool status) {</span>
 192 | *r  | <span class='executed'>    self.cached[token] = status;</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='neutral'></span>
 195 | *r  | <span class='executed'>/** @dev Computes surplus (positive) or deficit (negative) in actual tokens compared to tracked amounts. */</span>
 196 | *r  | <span class='executed'>function getNetBalance(AccountSystem storage self, address token, address account) view returns (int256 net) {</span>
 197 | *r  | <span class='executed'>    uint256 internalBalance = self.reserves[token];</span>
 198 | *r  | <span class='executed'>    uint256 physicalBalance = __balanceOf__(token, account);</span>
 199 | *r  | <span class='executed'>    net = int256(physicalBalance) - int256(internalBalance);</span>
 200 |     | <span class='neutral'>}</span>
 201 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/echidna/EchidnaE2E.sol</b>
<code>
    1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>import &quot;./Helper.sol&quot;;</span>
    4 |     | <span class='neutral'>import &quot;solmate/tokens/WETH.sol&quot;;</span>
    5 |     | <span class='neutral'>import &quot;../test/EchidnaERC20.sol&quot;;</span>
    6 |     | <span class='neutral'>import &quot;../Hyper.sol&quot;;</span>
    7 |     | <span class='neutral'>import &quot;../Enigma.sol&quot; as ProcessingLib;</span>
    8 |     | <span class='neutral'>import &quot;../../test/helpers/HelperHyperProfiles.sol&quot; as DefaultValues;</span>
    9 |     | <span class='neutral'>import &quot;../../test/helpers/HelperHyperView.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;./EchidnaStateHandling.sol&quot;;</span>
   11 | *r  | <span class='executed'></span>
   12 |     | <span class='neutral'>contract EchidnaE2E is HelperHyperView, Helper, EchidnaStateHandling {</span>
   13 |     | <span class='neutral'>    WETH _weth;</span>
   14 |     | <span class='neutral'>    Hyper _hyper;</span>
   15 |     | <span class='neutral'></span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='unexecuted'>    constructor() public {</span>
   18 |     | <span class='unexecuted'>        _weth = new WETH();</span>
   19 |     | <span class='unexecuted'>        _hyper = new Hyper(address(_weth));</span>
   20 |     | <span class='unexecuted'>        EchidnaERC20 _asset = create_token(&quot;Asset Token&quot;, &quot;ADEC6&quot;, 6);</span>
   21 |     | <span class='unexecuted'>        EchidnaERC20 _quote = create_token(&quot;Quote Token&quot;, &quot;QDEC18&quot;, 18);</span>
   22 |     | <span class='neutral'>        add_created_hyper_token(_asset);</span>
   23 |     | <span class='neutral'>        add_created_hyper_token(_quote);</span>
   24 |     | <span class='neutral'>    }</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>    OS.AccountSystem hyperAccount;</span>
   27 |     | <span class='neutral'></span>
   28 |     | <span class='neutral'>    // ******************** Check Proper System Deployment ********************</span>
   29 | *   | <span class='executed'>    function check_proper_deployment() public {</span>
   30 | *   | <span class='executed'>        assert(address(_weth) != address(0));</span>
   31 | *   | <span class='executed'>        assert(address(_hyper) != address(0));</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>        // Note: This invariant may break with tokens on hooks.</span>
   34 | *   | <span class='executed'>        assert(_hyper.locked() == 1);</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>        // Retrieve the OS.__account__</span>
   37 | *   | <span class='executed'>        (bool prepared, bool settled) = _hyper.__account__();</span>
   38 | *   | <span class='executed'>        assert(!prepared);</span>
   39 | *   | <span class='executed'>        assert(settled);</span>
   40 |     | <span class='neutral'></span>
   41 | *   | <span class='executed'>        address[] memory warmTokens = _hyper.getWarm();</span>
   42 | *   | <span class='executed'>        assert(warmTokens.length == 0);</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    // ******************** System wide Invariants ********************</span>
   46 |     | <span class='neutral'>    // The token balance of Hyper should be greater or equal to the reserve for all tokens</span>
   47 |     | <span class='neutral'>    // Note: assumption that pairs are created through create_pair invariant test</span>
   48 |     | <span class='neutral'>    // which will add the token to the hyperTokens list</span>
   49 |     | <span class='neutral'>    // this function is built so that extending the creation of new pairs should not require code changes here</span>
   50 | *   | <span class='executed'>    function global_token_balance_greater_or_equal_reserves() public {</span>
   51 | *   | <span class='executed'>        uint256 reserveBalance = 0;</span>
   52 | *   | <span class='executed'>        uint256 tokenBalance = 0;</span>
   53 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; EchidnaStateHandling.hyperTokens.length; i++) {</span>
   54 | *   | <span class='executed'>            EchidnaERC20 token = EchidnaStateHandling.get_token_at_index(i);</span>
   55 |     | <span class='neutral'></span>
   56 |     | <span class='neutral'>            // retrieve reserves of the token and add to tracked reserve balance</span>
   57 | *   | <span class='executed'>            reserveBalance = getReserve(address(_hyper), address(token));</span>
   58 |     | <span class='neutral'></span>
   59 |     | <span class='neutral'>            // get token balance and add to tracked token balance</span>
   60 | *   | <span class='executed'>            tokenBalance = token.balanceOf(address(_hyper));</span>
   61 |     | <span class='neutral'></span>
   62 | *   | <span class='executed'>            assert(tokenBalance &gt;= reserveBalance);</span>
   63 |     | <span class='neutral'>        }</span>
   64 |     | <span class='neutral'>    }</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    // ---------- HyperPair Properties -------</span>
   67 | *r  | <span class='executed'>    function pair_asset_never_equal_to_quote(uint256 id) public {</span>
   68 | *r  | <span class='executed'>        uint24 pairId = retrieve_created_pair(id);</span>
   69 |     | <span class='neutral'></span>
   70 | *   | <span class='executed'>        HyperPair memory pair = getPair(address(_hyper), pairId);</span>
   71 | *   | <span class='executed'>        assert(pair.tokenAsset != pair.tokenQuote);</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 | *r  | <span class='executed'>    function pair_decimals_never_exceed_bounds(uint256 id) public {</span>
   75 | *r  | <span class='executed'>        uint24 pairId = retrieve_created_pair(id);</span>
   76 |     | <span class='neutral'></span>
   77 | *r  | <span class='executed'>        HyperPair memory pair = getPair(address(_hyper), pairId);</span>
   78 | *r  | <span class='executed'>        assert(pair.decimalsAsset == EchidnaERC20(pair.tokenAsset).decimals());</span>
   79 | *r  | <span class='executed'>        assert(pair.decimalsAsset &gt;= 6);</span>
   80 | *r  | <span class='executed'>        assert(pair.decimalsAsset &lt;= 18);</span>
   81 |     | <span class='neutral'></span>
   82 | *r  | <span class='executed'>        assert(pair.decimalsQuote == EchidnaERC20(pair.tokenQuote).decimals());</span>
   83 | *   | <span class='executed'>        assert(pair.decimalsQuote &gt;= 6);</span>
   84 | *r  | <span class='executed'>        assert(pair.decimalsQuote &lt;= 18);</span>
   85 |     | <span class='neutral'>    }</span>
   86 |     | <span class='neutral'></span>
   87 |     | <span class='neutral'>    // ---------- Pool Properties -------</span>
   88 | *   | <span class='executed'>    function pool_fee_growth_greater_than_position_fee_growth() public {</span>
   89 | *   | <span class='executed'>        for (uint8 i = 0; i&lt;poolIds.length; i++) {</span>
   90 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
   91 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper),poolId);</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>        }</span>
   95 |     | <span class='neutral'>    }</span>
   96 | *r  | <span class='executed'>    function pool_non_zero_priority_fee_if_controlled(uint64 id) public {</span>
   97 | *r  | <span class='executed'>        (HyperPool memory pool, , , ) = retrieve_random_pool_and_tokens(id);</span>
   98 |     | <span class='neutral'>        // if the pool has a controller, the priority fee should never be zero</span>
   99 | *   | <span class='executed'>        emit LogBool(&quot;is mutable&quot;, pool.isMutable());</span>
  100 | *   | <span class='executed'>        if (pool.controller != address(0)) {</span>
  101 | *   | <span class='executed'>            if (pool.params.priorityFee == 0) {</span>
  102 |     | <span class='unexecuted'>                emit LogUint256(&quot;priority feel value&quot;, pool.params.priorityFee);</span>
  103 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG: Mutable pool has a non zero priority fee.&quot;);</span>
  104 |     | <span class='neutral'>            }</span>
  105 |     | <span class='neutral'>        }</span>
  106 |     | <span class='neutral'>    }</span>
  107 |     | <span class='neutral'></span>
  108 | *r  | <span class='executed'>    function pool_last_price_not_greater_than_strike() public {</span>
  109 | *r  | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  110 | r   | <span class='reverted'>            uint64 poolId = poolIds[i];</span>
  111 | r   | <span class='reverted'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  112 | r   | <span class='reverted'>            HyperCurve memory curve = pool.params;</span>
  113 |     | <span class='neutral'></span>
  114 | r   | <span class='reverted'>            emit LogUint256(&quot;pool&#39;s last price&quot;, pool.lastPrice);</span>
  115 | r   | <span class='reverted'>            emit LogUint256(&quot;strike price&quot;, curve.strike());</span>
  116 |     | <span class='neutral'></span>
  117 | r   | <span class='reverted'>            assert(pool.lastPrice &lt;= curve.strike());</span>
  118 |     | <span class='neutral'>        }</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    // Strike price for a pool should never be zero.</span>
  122 |     | <span class='neutral'>    // If it is, it suggests the mispricing and/or incorrect rounding of assets.</span>
  123 | *r  | <span class='executed'>    function pool_strike_price_non_zero() public {</span>
  124 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  125 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  126 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  127 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  128 |     | <span class='neutral'></span>
  129 | *   | <span class='executed'>            emit LogUint256(&quot;pool&#39;s last price&quot;, pool.lastPrice);</span>
  130 | *   | <span class='executed'>            emit LogUint256(&quot;strike price&quot;, curve.strike());</span>
  131 |     | <span class='neutral'></span>
  132 | *   | <span class='executed'>            if (curve.strike() == 0) {</span>
  133 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG: Strike price should never be 0.&quot;);</span>
  134 |     | <span class='neutral'>            }</span>
  135 |     | <span class='neutral'>        }</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 | *   | <span class='executed'>    function pool_maturity_never_less_last_timestamp() public {</span>
  139 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  140 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  141 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  142 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  143 |     | <span class='neutral'></span>
  144 | *   | <span class='executed'>            emit LogUint256(&quot;hyper pool last timestamp: &quot;, pool.lastTimestamp);</span>
  145 | *   | <span class='executed'>            emit LogUint256(&quot;maturity&quot;, curve.maturity());</span>
  146 |     | <span class='neutral'></span>
  147 | *   | <span class='executed'>            if (curve.maturity() &lt; pool.lastTimestamp) {</span>
  148 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG: curve maturity is less than last timestamp&quot;);</span>
  149 |     | <span class='neutral'>            }</span>
  150 |     | <span class='neutral'>        }</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 | *   | <span class='executed'>    function pool_non_zero_last_price_never_zero_liquidity() public {</span>
  154 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  155 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  156 |     | <span class='neutral'></span>
  157 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  158 | *   | <span class='executed'>            emit LogUint256(&quot;last timestamp&quot;,uint256(pool.lastTimestamp));</span>
  159 |     | <span class='neutral'></span>
  160 | *   | <span class='executed'>            if (pool.lastPrice != 0) {</span>
  161 | *   | <span class='executed'>                emit LogUint256(&quot;pool&#39;s last price&quot;, pool.lastPrice);</span>
  162 | *   | <span class='executed'>                if (pool.liquidity == 0) {</span>
  163 | *   | <span class='executed'>                    emit AssertionFailed(&quot;BUG: non zero last price should have a non zero liquidity&quot;);</span>
  164 |     | <span class='neutral'>                }</span>
  165 |     | <span class='neutral'>            }</span>
  166 |     | <span class='neutral'>            //TODO: if pool.lastPrice == 0; pool.liquidity == 0?</span>
  167 |     | <span class='neutral'>        }</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    // TODO: remove if it&#39;s a false invariant</span>
  171 |     | <span class='neutral'>    // TODO: Add to iterate over all created-pools</span>
  172 |     | <span class='neutral'></span>
  173 | *r  | <span class='executed'>    function pool_liquidity_delta_never_returns_zeroes(uint256 id, int128 deltaLiquidity) public {</span>
  174 | *r  | <span class='executed'>        require(deltaLiquidity != 0);</span>
  175 | *r  | <span class='executed'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 quote, EchidnaERC20 asset) = retrieve_random_pool_and_tokens(id);</span>
  176 |     | <span class='neutral'></span>
  177 | *r  | <span class='executed'>        emit LogInt128(&quot;deltaLiquidity&quot;, deltaLiquidity);</span>
  178 |     | <span class='neutral'></span>
  179 | *r  | <span class='executed'>        (uint128 deltaAsset, uint128 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidity);</span>
  180 | *   | <span class='executed'>        emit LogUint256(&quot;deltaAsset&quot;, deltaAsset);</span>
  181 | *   | <span class='executed'>        if (deltaAsset == 0) {</span>
  182 | *   | <span class='executed'>            emit AssertionFailed(&quot;BUG: getLiquidityDeltas returned 0 for deltaAsset&quot;);</span>
  183 |     | <span class='neutral'>        }</span>
  184 | *   | <span class='executed'>        emit LogUint256(&quot;deltaQuote&quot;, deltaQuote);</span>
  185 | *   | <span class='executed'>        if (deltaQuote == 0) {</span>
  186 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: getLiquidityDeltas returned 0 for deltaQuote&quot;);</span>
  187 |     | <span class='neutral'>        }</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 |     | <span class='neutral'>    // TODO: Find a better name here with `pool_` at the beginning</span>
  191 |     | <span class='neutral'></span>
  192 | *   | <span class='executed'>    function check_hyper_curve_assumptions() public {</span>
  193 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  194 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  195 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  196 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  197 |     | <span class='neutral'></span>
  198 | *   | <span class='executed'>            assert(curve.fee != 0);</span>
  199 | *   | <span class='executed'>            assert(curve.priorityFee &lt;= curve.fee);</span>
  200 | *   | <span class='executed'>            assert(curve.duration != 0);</span>
  201 | *   | <span class='executed'>            assert(curve.volatility &gt;= MIN_VOLATILITY);</span>
  202 | *   | <span class='executed'>            assert(curve.createdAt != 0);</span>
  203 |     | <span class='neutral'>        }</span>
  204 |     | <span class='neutral'>    }</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    // TODO: Find a better name here with `pool_` at the beginning</span>
  207 | *   | <span class='executed'>    function check_hyper_pool_assumptions() public {</span>
  208 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  209 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  210 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  211 | *   | <span class='executed'>            HyperPair memory pair = pool.pair;</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>            // The `getVirtualReserves` method always returns values less than Hyper’s respective `getReserve` function for each token of the pool’s pair.</span>
  214 |     | <span class='neutral'></span>
  215 |     | <span class='neutral'>            // `getVirtualReserves method`</span>
  216 | *   | <span class='executed'>            (uint128 deltaAsset, uint128 deltaQuote) = _hyper.getVirtualReserves(poolId);</span>
  217 |     | <span class='neutral'></span>
  218 |     | <span class='neutral'>            // Hyper&#39;s `getReserve` function for each of the pool&#39;s pair</span>
  219 | *   | <span class='executed'>            uint256 assetReserves = _hyper.getReserve(pair.tokenAsset);</span>
  220 | *   | <span class='executed'>            uint256 quoteReserves = _hyper.getReserve(pair.tokenQuote);</span>
  221 |     | <span class='neutral'></span>
  222 | *   | <span class='executed'>            if (deltaAsset &gt; assetReserves) {</span>
  223 |     | <span class='unexecuted'>                emit LogUint256(&quot;deltaAsset&quot;, deltaAsset);</span>
  224 |     | <span class='unexecuted'>                emit LogUint256(&quot;assetReserves&quot;, assetReserves);</span>
  225 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG (`asset`): virtualReserves returned more than getReserve function&quot;);</span>
  226 |     | <span class='neutral'>            }</span>
  227 | *   | <span class='executed'>            if (deltaQuote &gt; quoteReserves) {</span>
  228 |     | <span class='unexecuted'>                emit LogUint256(&quot;deltaQuote&quot;, deltaQuote);</span>
  229 |     | <span class='unexecuted'>                emit LogUint256(&quot;quoteReserves&quot;, quoteReserves);</span>
  230 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG (`asset`): virtualReserves returned more than getReserve function&quot;);</span>
  231 |     | <span class='neutral'>            }</span>
  232 |     | <span class='neutral'>        }</span>
  233 |     | <span class='neutral'>    }</span>
  234 |     | <span class='neutral'></span>
  235 | *r  | <span class='executed'>    function pool_get_amounts_wad_returns_safe_bounds() public {</span>
  236 |     | <span class='neutral'>        // The `getAmountsWad` method always returns less than `1e18` for `amountAssetWad` and `pool.params.strike()` for `amountQuoteWad`.</span>
  237 |     | <span class='neutral'></span>
  238 | *   | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  239 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  240 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  241 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  242 |     | <span class='neutral'></span>
  243 | *   | <span class='executed'>            (uint256 amountAssetWad, uint256 amountQuoteWad) = pool.getAmountsWad();</span>
  244 |     | <span class='neutral'></span>
  245 | *   | <span class='executed'>            if (amountAssetWad &gt; 1e18) {</span>
  246 |     | <span class='unexecuted'>                emit LogUint256(&quot;amountAssetWad&quot;, amountAssetWad);</span>
  247 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG amountAssetWad is greater than 1e18&quot;);</span>
  248 |     | <span class='neutral'>            }</span>
  249 |     | <span class='neutral'>            // Inclusive of strike price?</span>
  250 | *   | <span class='executed'>            if (amountQuoteWad &gt; curve.strike()) {</span>
  251 |     | <span class='unexecuted'>                emit LogUint256(&quot;amountQuoteWad&quot;, amountQuoteWad);</span>
  252 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG amountQuoteWad is greater than strike&quot;);</span>
  253 |     | <span class='neutral'>            }</span>
  254 |     | <span class='neutral'>        }</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 | *r  | <span class='executed'>    function pool_get_amounts_returns_less_than_get_amounts_wad() public {</span>
  258 |     | <span class='neutral'>        // The `getAmounts` method always returns values less than or equal to `getAmountsWad`.</span>
  259 |     | <span class='neutral'></span>
  260 | *r  | <span class='executed'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
  261 | *   | <span class='executed'>            uint64 poolId = poolIds[i];</span>
  262 | *   | <span class='executed'>            HyperPool memory pool = getPool(address(_hyper), poolId);</span>
  263 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  264 |     | <span class='neutral'></span>
  265 | *   | <span class='executed'>            (uint256 amountAssetDec, uint256 amountQuoteDec) = pool.getAmounts();</span>
  266 |     | <span class='neutral'></span>
  267 | *   | <span class='executed'>            (uint256 amountAssetWad, uint256 amountQuoteWad) = pool.getAmountsWad();</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>            // Assumes inclusivity of bounds (i.e: equivalence is okay)</span>
  270 | *   | <span class='executed'>            if (amountAssetDec &gt; amountAssetWad) {</span>
  271 |     | <span class='unexecuted'>                emit LogUint256(&quot;amountAssetDec&quot;, amountAssetDec);</span>
  272 |     | <span class='unexecuted'>                emit LogUint256(&quot;amountAssetWad&quot;, amountAssetWad);</span>
  273 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG (asset): getAmounts returned more than getAmountsWad&quot;);</span>
  274 |     | <span class='neutral'>            }</span>
  275 |     | <span class='neutral'>            // Assumes inclusivity of bounds (i.e: equivalence is okay)</span>
  276 | *   | <span class='executed'>            if (amountQuoteDec &gt; amountQuoteWad) {</span>
  277 |     | <span class='unexecuted'>                emit LogUint256(&quot;amountQuoteDec&quot;, amountQuoteDec);</span>
  278 |     | <span class='unexecuted'>                emit LogUint256(&quot;amountQuoteWad&quot;, amountQuoteWad);</span>
  279 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG (quote): getAmounts returned more than getAmountsWad&quot;);</span>
  280 |     | <span class='neutral'>            }</span>
  281 |     | <span class='neutral'>        }</span>
  282 |     | <span class='neutral'>    }</span>
  283 |     | <span class='neutral'></span>
  284 |     | <span class='neutral'>    // ******************** Create Pairs ********************</span>
  285 |     | <span class='neutral'>    /**</span>
  286 |     | <span class='neutral'>     * Future Invariant: This assumes that there is a single pair of _asset and _quote token</span>
  287 |     | <span class='neutral'>     *      - In the future, can be extended to deploy tokens from here and save the address in a list</span>
  288 |     | <span class='neutral'>     * 			which allows echidna to test against different pairs.</span>
  289 |     | <span class='neutral'>     * 			- Assumption: 1 pair for now.</span>
  290 |     | <span class='neutral'>     */</span>
  291 | *   | <span class='executed'>    function create_token(</span>
  292 |     | <span class='neutral'>        string memory tokenName,</span>
  293 |     | <span class='neutral'>        string memory shortform,</span>
  294 |     | <span class='neutral'>        uint8 decimals</span>
  295 | *   | <span class='executed'>    ) public returns (EchidnaERC20 token) {</span>
  296 | *   | <span class='executed'>        token = new EchidnaERC20(tokenName, shortform, decimals,address(_hyper));</span>
  297 | *   | <span class='executed'>        assert(token.decimals() == decimals);</span>
  298 | *   | <span class='executed'>        if (decimals &gt;= 6 &amp;&amp; decimals &lt;= 18) {</span>
  299 | *   | <span class='executed'>            add_created_hyper_token(token);</span>
  300 |     | <span class='neutral'>        }</span>
  301 |     | <span class='neutral'>        return token;</span>
  302 |     | <span class='neutral'>    }</span>
  303 |     | <span class='neutral'></span>
  304 |     | <span class='neutral'>    /* Future Invariant: This could be extended to create arbitrary pairs. </span>
  305 |     | <span class='neutral'>    For now for complexity, I am leaving as is. </span>
  306 |     | <span class='neutral'>    Test overlapping token pairs</span>
  307 |     | <span class='neutral'>    */</span>
  308 | *r  | <span class='executed'>    function create_pair_with_safe_preconditions(uint256 id1, uint256 id2) public {</span>
  309 |     | <span class='neutral'>        // retrieve an existing rpair of tokens that wee created with 6-18 decimals</span>
  310 | *r  | <span class='executed'>        (EchidnaERC20 asset, EchidnaERC20 quote) = get_hyper_tokens(id1, id2);</span>
  311 | *r  | <span class='executed'>        emit LogUint256(&quot;decimals asset&quot;, asset.decimals());</span>
  312 | *r  | <span class='executed'>        emit LogUint256(&quot;decimals quote&quot;, quote.decimals());</span>
  313 | *r  | <span class='executed'>        emit LogUint256(&quot;pair ID&quot;, uint256(_hyper.getPairId(address(asset), address(quote))));</span>
  314 |     | <span class='neutral'></span>
  315 | *r  | <span class='executed'>        require(asset.decimals() &gt;= 6 &amp;&amp; asset.decimals() &lt;= 18);</span>
  316 | *r  | <span class='executed'>        require(quote.decimals() &gt;= 6 &amp;&amp; quote.decimals() &lt;= 18);</span>
  317 | *r  | <span class='executed'>        require(asset != quote);</span>
  318 |     | <span class='neutral'>        // require that this pair ID does not exist yet</span>
  319 | *   | <span class='executed'>        if (_hyper.getPairId(address(asset), address(quote)) != 0) {</span>
  320 | *   | <span class='executed'>            return;</span>
  321 |     | <span class='neutral'>        }</span>
  322 |     | <span class='neutral'>        // without this, Echidna may decide to call the EchidnaERC20.setDecimals</span>
  323 | *   | <span class='executed'>        uint256 preCreationNonce = _hyper.getPairNonce();</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>        // encode createPair arguments and call hyper contract</span>
  326 | *   | <span class='executed'>        bytes memory createPairData = ProcessingLib.encodeCreatePair(address(asset), address(quote));</span>
  327 | *   | <span class='executed'>        (bool success, bytes memory err) = address(_hyper).call(createPairData);</span>
  328 | *   | <span class='executed'>        if (!success) {</span>
  329 |     | <span class='unexecuted'>            emit LogBytes(&quot;error&quot;, err);</span>
  330 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;FAILED&quot;);</span>
  331 |     | <span class='neutral'>        }</span>
  332 |     | <span class='neutral'></span>
  333 | *   | <span class='executed'>        pair_id_saved_properly(address(asset), address(quote));</span>
  334 |     | <span class='neutral'></span>
  335 | *   | <span class='executed'>        uint256 pairNonce = _hyper.getPairNonce();</span>
  336 | *   | <span class='executed'>        assert(pairNonce == preCreationNonce + 1);</span>
  337 |     | <span class='neutral'>    }</span>
  338 |     | <span class='neutral'></span>
  339 |     | <span class='neutral'>    /**</span>
  340 |     | <span class='neutral'>     * Future Invariant: This can likely be extended to ensure that pairID&#39;s must always match backwards to the tokens saved</span>
  341 |     | <span class='neutral'>     */</span>
  342 | *   | <span class='executed'>    function pair_id_saved_properly(address asset, address quote) private {</span>
  343 |     | <span class='neutral'>        // retrieve recently created pair ID</span>
  344 | *   | <span class='executed'>        uint24 pairId = _hyper.getPairId(address(asset), address(quote));</span>
  345 | *   | <span class='executed'>        if (pairId == 0) {</span>
  346 |     | <span class='unexecuted'>            emit LogUint256(&quot;PairId Exists&quot;, uint256(pairId));</span>
  347 | *   | <span class='executed'>            assert(false);</span>
  348 |     | <span class='neutral'>        }</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>        // retrieve pair information and ensure pair was saved</span>
  351 | *   | <span class='executed'>        HyperPair memory pair = getPair(address(_hyper), pairId);</span>
  352 | *   | <span class='executed'>        assert(pair.tokenAsset == address(asset));</span>
  353 | *   | <span class='executed'>        assert(pair.decimalsAsset == EchidnaERC20(asset).decimals());</span>
  354 | *   | <span class='executed'>        assert(pair.tokenQuote == address(quote));</span>
  355 | *   | <span class='executed'>        assert(pair.decimalsQuote == EchidnaERC20(quote).decimals());</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>        // save internal Echidna state to test against</span>
  358 | *   | <span class='executed'>        save_pair_id(pairId);</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 | *r  | <span class='executed'>    function create_same_pair_should_fail() public {</span>
  362 | *   | <span class='executed'>        EchidnaERC20 quote = create_token(&quot;Create same pair asset fail&quot;, &quot;CSPF&quot;, 18);</span>
  363 | *   | <span class='executed'>        bytes memory createPairData = ProcessingLib.encodeCreatePair(address(quote), address(quote));</span>
  364 | *   | <span class='executed'>        (bool success, ) = address(_hyper).call(createPairData);</span>
  365 | *   | <span class='executed'>        assert(!success);</span>
  366 |     | <span class='neutral'>    }</span>
  367 |     | <span class='neutral'></span>
  368 | *r  | <span class='executed'>    function create_pair_with_less_than_min_decimals_should_fail(uint256 decimals) public {</span>
  369 | *   | <span class='executed'>        decimals = uint8(between(decimals, 0, 5));</span>
  370 | *   | <span class='executed'>        EchidnaERC20 testToken = create_token(&quot;create less min decimals asset fail&quot;, &quot;CLMDF&quot;, uint8(decimals));</span>
  371 | *   | <span class='executed'>        EchidnaERC20 quote = create_token(&quot;create less min decimals quote&quot;, &quot;CLMDQ&quot;, 18);</span>
  372 |     | <span class='neutral'>        bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(quote));</span>
  373 |     | <span class='neutral'>        (bool success, ) = address(_hyper).call(createPairData);</span>
  374 |     | <span class='neutral'>        assert(!success);</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 | *   | <span class='executed'>    function create_pair_with_more_than_max_decimals_should_fail(uint256 decimals) public {</span>
  378 | *   | <span class='executed'>        decimals = uint8(between(decimals, 19, type(uint8).max));</span>
  379 | *   | <span class='executed'>        EchidnaERC20 testToken = create_token(&quot;Create more than max decimals fail&quot;, &quot;CMTMF&quot;, uint8(decimals));</span>
  380 | *   | <span class='executed'>        EchidnaERC20 quote = create_token(&quot;Create more than max decimals fail quote&quot;, &quot;CMTMF2&quot;, 18);</span>
  381 | *   | <span class='executed'>        bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(quote));</span>
  382 | *   | <span class='executed'>        (bool success, ) = address(_hyper).call(createPairData);</span>
  383 | *   | <span class='executed'>        assert(!success);</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    // ******************** Create Pool ********************</span>
  387 |     | <span class='neutral'>    // Create a non controlled pool (controller address is 0) with default pair</span>
  388 |     | <span class='neutral'>    // Note: This function can be extended to choose from any created pair and create a pool on top of it</span>
  389 | *r  | <span class='executed'>    function create_non_controlled_pool(</span>
  390 |     | <span class='neutral'>        uint256 id,</span>
  391 |     | <span class='neutral'>        uint16 fee,</span>
  392 |     | <span class='neutral'>        int24 maxTick,</span>
  393 |     | <span class='neutral'>        uint16 volatility,</span>
  394 |     | <span class='neutral'>        uint16 duration,</span>
  395 |     | <span class='neutral'>        uint128 price</span>
  396 | *r  | <span class='executed'>    ) public {</span>
  397 | *r  | <span class='executed'>        uint24 pairId = retrieve_created_pair(uint256(id));</span>
  398 |     | <span class='neutral'>        {</span>
  399 | *r  | <span class='executed'>            (, fee, maxTick, volatility, duration, , price) = clam_safe_create_bounds(</span>
  400 | *r  | <span class='executed'>                0,</span>
  401 | *r  | <span class='executed'>                fee,</span>
  402 | *r  | <span class='executed'>                maxTick,</span>
  403 | *r  | <span class='executed'>                volatility,</span>
  404 | *r  | <span class='executed'>                duration,</span>
  405 | *r  | <span class='executed'>                0,</span>
  406 | *r  | <span class='executed'>                price</span>
  407 |     | <span class='neutral'>            );</span>
  408 |     | <span class='neutral'>        }</span>
  409 | *   | <span class='executed'>        bytes memory createPoolData = ProcessingLib.encodeCreatePool(</span>
  410 | *   | <span class='executed'>            pairId,</span>
  411 |     | <span class='neutral'>            address(0), // no controller</span>
  412 |     | <span class='neutral'>            0, // no priority fee</span>
  413 |     | <span class='neutral'>            fee,</span>
  414 |     | <span class='neutral'>            volatility,</span>
  415 |     | <span class='neutral'>            duration,</span>
  416 |     | <span class='neutral'>            0, // no jit</span>
  417 |     | <span class='neutral'>            maxTick,</span>
  418 |     | <span class='neutral'>            price</span>
  419 |     | <span class='neutral'>        );</span>
  420 | *r  | <span class='executed'>        {</span>
  421 | *   | <span class='executed'>            (HyperPool memory pool, uint64 poolId) = execute_create_pool(pairId, createPoolData, false);</span>
  422 | *   | <span class='executed'>            assert(!pool.isMutable());</span>
  423 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  424 | *   | <span class='executed'>            assert(pool.lastTimestamp == block.timestamp);</span>
  425 | *   | <span class='executed'>            assert(pool.lastPrice == price);</span>
  426 | *   | <span class='executed'>            assert(curve.createdAt == block.timestamp);</span>
  427 | *   | <span class='executed'>            assert(pool.controller == address(0));</span>
  428 | *   | <span class='executed'>            assert(curve.priorityFee == 0);</span>
  429 | *   | <span class='executed'>            assert(curve.fee == fee);</span>
  430 | *   | <span class='executed'>            assert(curve.volatility == volatility);</span>
  431 | *   | <span class='executed'>            assert(curve.duration == duration);</span>
  432 | *   | <span class='executed'>            assert(curve.jit == JUST_IN_TIME_LIQUIDITY_POLICY);</span>
  433 | *r  | <span class='executed'>            assert(curve.maxTick == maxTick);</span>
  434 |     | <span class='neutral'>        }</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function create_controlled_pool(</span>
  438 |     | <span class='neutral'>        uint256 id,</span>
  439 |     | <span class='neutral'>        uint16 priorityFee,</span>
  440 |     | <span class='neutral'>        uint16 fee,</span>
  441 |     | <span class='neutral'>        int24 maxTick,</span>
  442 |     | <span class='neutral'>        uint16 volatility,</span>
  443 |     | <span class='neutral'>        uint16 duration,</span>
  444 |     | <span class='neutral'>        uint16 jit,</span>
  445 |     | <span class='neutral'>        uint128 price</span>
  446 |     | <span class='neutral'>    ) public {</span>
  447 |     | <span class='neutral'>        uint24 pairId = retrieve_created_pair(id);</span>
  448 |     | <span class='neutral'>        {</span>
  449 |     | <span class='neutral'>            (priorityFee, fee, maxTick, volatility, duration, jit, price) = clam_safe_create_bounds(</span>
  450 |     | <span class='neutral'>                priorityFee,</span>
  451 |     | <span class='neutral'>                fee,</span>
  452 |     | <span class='neutral'>                maxTick,</span>
  453 |     | <span class='neutral'>                volatility,</span>
  454 |     | <span class='neutral'>                duration,</span>
  455 |     | <span class='neutral'>                jit,</span>
  456 |     | <span class='neutral'>                price</span>
  457 |     | <span class='neutral'>            );</span>
  458 |     | <span class='neutral'>        }</span>
  459 |     | <span class='neutral'>        bytes memory createPoolData = ProcessingLib.encodeCreatePool(</span>
  460 |     | <span class='neutral'>            pairId,</span>
  461 |     | <span class='neutral'>            address(this), //controller</span>
  462 |     | <span class='neutral'>            priorityFee, // no priority fee</span>
  463 |     | <span class='neutral'>            fee,</span>
  464 |     | <span class='neutral'>            volatility,</span>
  465 |     | <span class='neutral'>            duration,</span>
  466 |     | <span class='neutral'>            jit, // no jit</span>
  467 |     | <span class='neutral'>            maxTick,</span>
  468 |     | <span class='neutral'>            price</span>
  469 |     | <span class='neutral'>        );</span>
  470 |     | <span class='neutral'>        {</span>
  471 |     | <span class='neutral'>            (HyperPool memory pool, uint64 poolId) = execute_create_pool(pairId, createPoolData, true);</span>
  472 |     | <span class='neutral'>            assert(pool.isMutable());</span>
  473 |     | <span class='neutral'>            HyperCurve memory curve = pool.params;</span>
  474 |     | <span class='neutral'>            assert(pool.lastTimestamp == block.timestamp);</span>
  475 |     | <span class='neutral'>            assert(curve.createdAt == block.timestamp);</span>
  476 |     | <span class='neutral'>            assert(pool.controller == address(this));</span>
  477 |     | <span class='neutral'>            assert(curve.priorityFee == priorityFee);</span>
  478 |     | <span class='neutral'>            assert(curve.fee == fee);</span>
  479 |     | <span class='neutral'>            assert(curve.volatility == volatility);</span>
  480 |     | <span class='neutral'>            assert(curve.duration == duration);</span>
  481 |     | <span class='neutral'>            assert(curve.jit == jit);</span>
  482 |     | <span class='neutral'>            assert(curve.maxTick == maxTick);</span>
  483 |     | <span class='neutral'>        }</span>
  484 |     | <span class='neutral'>    }</span>
  485 |     | <span class='neutral'></span>
  486 | *r  | <span class='executed'>    function create_controlled_pool_with_zero_priority_fee_should_fail(</span>
  487 |     | <span class='neutral'>        uint256 id,</span>
  488 |     | <span class='neutral'>        uint16 fee,</span>
  489 |     | <span class='neutral'>        int24 maxTick,</span>
  490 |     | <span class='neutral'>        uint16 volatility,</span>
  491 |     | <span class='neutral'>        uint16 duration,</span>
  492 |     | <span class='neutral'>        uint16 jit,</span>
  493 |     | <span class='neutral'>        uint128 price</span>
  494 |     | <span class='neutral'>    ) public {</span>
  495 | *r  | <span class='executed'>        uint24 pairId = retrieve_created_pair(id);</span>
  496 | *r  | <span class='executed'>        uint16 priorityFee = 0;</span>
  497 |     | <span class='neutral'>        {</span>
  498 | *r  | <span class='executed'>            (, fee, maxTick, volatility, duration, jit, price) = clam_safe_create_bounds(</span>
  499 | *r  | <span class='executed'>                priorityFee,</span>
  500 | *r  | <span class='executed'>                fee,</span>
  501 | *r  | <span class='executed'>                maxTick,</span>
  502 | *r  | <span class='executed'>                volatility,</span>
  503 | *r  | <span class='executed'>                duration,</span>
  504 | *r  | <span class='executed'>                jit,</span>
  505 | *r  | <span class='executed'>                price</span>
  506 |     | <span class='neutral'>            );</span>
  507 |     | <span class='neutral'>        }</span>
  508 | *   | <span class='executed'>        bytes memory createPoolData = ProcessingLib.encodeCreatePool(</span>
  509 | *   | <span class='executed'>            pairId,</span>
  510 | *   | <span class='executed'>            address(this), //controller</span>
  511 | *   | <span class='executed'>            priorityFee, // no priority fee</span>
  512 |     | <span class='neutral'>            fee,</span>
  513 |     | <span class='neutral'>            volatility,</span>
  514 |     | <span class='neutral'>            duration,</span>
  515 |     | <span class='neutral'>            jit, // no jit</span>
  516 |     | <span class='neutral'>            maxTick,</span>
  517 |     | <span class='neutral'>            price</span>
  518 |     | <span class='neutral'>        );</span>
  519 | *   | <span class='executed'>        (bool success, ) = address(_hyper).call(createPoolData);</span>
  520 | *   | <span class='executed'>        assert(!success);</span>
  521 |     | <span class='neutral'>    }</span>
  522 |     | <span class='neutral'></span>
  523 | *r  | <span class='executed'>    function create_pool_with_negative_max_tick_as_bounds(</span>
  524 |     | <span class='neutral'>        uint256 id,</span>
  525 |     | <span class='neutral'>        uint16 priorityFee,</span>
  526 |     | <span class='neutral'>        uint16 fee,</span>
  527 |     | <span class='neutral'>        int24 maxTick,</span>
  528 |     | <span class='neutral'>        uint16 volatility,</span>
  529 |     | <span class='neutral'>        uint16 duration,</span>
  530 |     | <span class='neutral'>        uint16 jit,</span>
  531 |     | <span class='neutral'>        uint128 price</span>
  532 | *   | <span class='executed'>    ) public {</span>
  533 | *r  | <span class='executed'>        uint24 pairId = retrieve_created_pair(id);</span>
  534 |     | <span class='neutral'>        {</span>
  535 | *   | <span class='executed'>            (priorityFee, fee, maxTick, volatility, duration, jit, price) = clam_safe_create_bounds(</span>
  536 | *   | <span class='executed'>                priorityFee,</span>
  537 | *   | <span class='executed'>                fee,</span>
  538 | *   | <span class='executed'>                maxTick,</span>
  539 | *   | <span class='executed'>                volatility,</span>
  540 | *   | <span class='executed'>                duration,</span>
  541 | *   | <span class='executed'>                jit,</span>
  542 | *   | <span class='executed'>                price</span>
  543 |     | <span class='neutral'>            );</span>
  544 |     | <span class='neutral'>        }</span>
  545 | *   | <span class='executed'>        bytes memory createPoolData = ProcessingLib.encodeCreatePool(</span>
  546 | *   | <span class='executed'>            pairId,</span>
  547 | *   | <span class='executed'>            address(this), //controller</span>
  548 |     | <span class='neutral'>            priorityFee, // no priority fee</span>
  549 |     | <span class='neutral'>            fee,</span>
  550 |     | <span class='neutral'>            volatility,</span>
  551 |     | <span class='neutral'>            duration,</span>
  552 |     | <span class='neutral'>            jit, // no jit</span>
  553 |     | <span class='neutral'>            maxTick,</span>
  554 |     | <span class='neutral'>            price</span>
  555 |     | <span class='neutral'>        );</span>
  556 | *   | <span class='executed'>        {</span>
  557 | *   | <span class='executed'>            (HyperPool memory pool, uint64 poolId) = execute_create_pool(pairId, createPoolData, true);</span>
  558 | *   | <span class='executed'>            assert(pool.isMutable());</span>
  559 | *   | <span class='executed'>            HyperCurve memory curve = pool.params;</span>
  560 | *   | <span class='executed'>            assert(pool.lastTimestamp == block.timestamp);</span>
  561 | *   | <span class='executed'>            assert(curve.createdAt == block.timestamp);</span>
  562 | *   | <span class='executed'>            assert(pool.controller == address(this));</span>
  563 | *   | <span class='executed'>            assert(curve.priorityFee == priorityFee);</span>
  564 | *   | <span class='executed'>            assert(curve.fee == fee);</span>
  565 | *   | <span class='executed'>            assert(curve.volatility == volatility);</span>
  566 | *   | <span class='executed'>            assert(curve.duration == duration);</span>
  567 | *   | <span class='executed'>            assert(curve.jit == jit);</span>
  568 | *   | <span class='executed'>            assert(curve.maxTick == maxTick);</span>
  569 |     | <span class='neutral'>        }</span>
  570 |     | <span class='neutral'>    }</span>
  571 |     | <span class='neutral'></span>
  572 | *   | <span class='executed'>    function execute_create_pool(</span>
  573 |     | <span class='neutral'>        uint24 pairId,</span>
  574 |     | <span class='neutral'>        bytes memory createPoolData,</span>
  575 |     | <span class='neutral'>        bool hasController</span>
  576 | *   | <span class='executed'>    ) private returns (HyperPool memory pool, uint64 poolId) {</span>
  577 | *   | <span class='executed'>        uint256 preCreationPoolNonce = _hyper.getPoolNonce();</span>
  578 | *   | <span class='executed'>        (bool success, ) = address(_hyper).call(createPoolData);</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>        // pool nonce should increase by 1 each time a pool is created</span>
  581 | *   | <span class='executed'>        uint256 poolNonce = _hyper.getPoolNonce();</span>
  582 | *   | <span class='executed'>        assert(poolNonce == preCreationPoolNonce + 1);</span>
  583 |     | <span class='neutral'></span>
  584 |     | <span class='neutral'>        // pool should be created and exist</span>
  585 | *   | <span class='executed'>        poolId = ProcessingLib.encodePoolId(pairId, hasController, uint32(poolNonce));</span>
  586 | *   | <span class='executed'>        pool = getPool(address(_hyper), poolId);</span>
  587 | *   | <span class='executed'>        if (!pool.exists()) {</span>
  588 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Pool should return true on exists after being created.&quot;);</span>
  589 |     | <span class='neutral'>        }</span>
  590 |     | <span class='neutral'></span>
  591 |     | <span class='neutral'>        // save pools in Echidna</span>
  592 |     | <span class='neutral'>        save_pool_id(poolId);</span>
  593 |     | <span class='neutral'>    }</span>
  594 |     | <span class='neutral'></span>
  595 |     | <span class='neutral'>    // ******************** Change Pool Parameters ********************</span>
  596 | r   | <span class='reverted'>    function change_parameters(</span>
  597 |     | <span class='neutral'>        uint256 id,</span>
  598 |     | <span class='neutral'>        uint16 priorityFee,</span>
  599 |     | <span class='neutral'>        uint16 fee,</span>
  600 |     | <span class='neutral'>        int24 maxTick,</span>
  601 |     | <span class='neutral'>        uint16 volatility,</span>
  602 |     | <span class='neutral'>        uint16 duration,</span>
  603 |     | <span class='neutral'>        uint16 jit,</span>
  604 |     | <span class='neutral'>        uint128 price</span>
  605 |     | <span class='neutral'>    ) public {</span>
  606 | r   | <span class='reverted'>        (HyperPool memory preChangeState, uint64 poolId, , ) = retrieve_random_pool_and_tokens(id);</span>
  607 | r   | <span class='reverted'>        emit LogUint256(&quot;created pools&quot;, poolIds.length);</span>
  608 | r   | <span class='reverted'>        emit LogUint256(&quot;pool ID&quot;, uint256(poolId));</span>
  609 | r   | <span class='reverted'>        require(preChangeState.isMutable());</span>
  610 |     | <span class='unexecuted'>        require(preChangeState.controller == address(this));</span>
  611 |     | <span class='neutral'>        {</span>
  612 |     | <span class='neutral'>            // scaling remaining pool creation values</span>
  613 |     | <span class='unexecuted'>            fee = uint16(between(fee, MIN_FEE, MAX_FEE));</span>
  614 |     | <span class='unexecuted'>            priorityFee = uint16(between(priorityFee, 1, fee));</span>
  615 |     | <span class='unexecuted'>            volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));</span>
  616 |     | <span class='unexecuted'>            duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));</span>
  617 |     | <span class='unexecuted'>            maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]</span>
  618 |     | <span class='unexecuted'>            jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));</span>
  619 |     | <span class='unexecuted'>            price = uint128(between(price, 1, type(uint128).max)); // price is between 1-uint256.max</span>
  620 |     | <span class='neutral'>        }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='unexecuted'>        _hyper.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);</span>
  623 |     | <span class='neutral'>        {</span>
  624 |     | <span class='unexecuted'>            (HyperPool memory postChangeState, , , ) = retrieve_random_pool_and_tokens(id);</span>
  625 |     | <span class='unexecuted'>            HyperCurve memory preChangeCurve = preChangeState.params;</span>
  626 |     | <span class='unexecuted'>            HyperCurve memory postChangeCurve = postChangeState.params;</span>
  627 |     | <span class='unexecuted'>            assert(postChangeState.lastTimestamp == preChangeState.lastTimestamp);</span>
  628 |     | <span class='unexecuted'>            assert(postChangeState.controller == address(this));</span>
  629 |     | <span class='unexecuted'>            assert(postChangeCurve.createdAt == preChangeCurve.createdAt);</span>
  630 |     | <span class='neutral'>            assert(postChangeCurve.priorityFee == priorityFee);</span>
  631 |     | <span class='neutral'>            assert(postChangeCurve.fee == fee);</span>
  632 |     | <span class='neutral'>            assert(postChangeCurve.volatility == volatility);</span>
  633 |     | <span class='neutral'>            assert(postChangeCurve.duration == duration);</span>
  634 |     | <span class='neutral'>            assert(postChangeCurve.jit == jit);</span>
  635 |     | <span class='neutral'>            assert(postChangeCurve.maxTick == maxTick);</span>
  636 |     | <span class='neutral'>        }</span>
  637 |     | <span class='neutral'>    }</span>
  638 |     | <span class='neutral'></span>
  639 |     | <span class='neutral'>    // Invariant: Attempting to change parameters of a nonmutable pool should fail</span>
  640 | r   | <span class='reverted'>    function change_parameters_to_non_mutable_pool_should_fail(</span>
  641 |     | <span class='neutral'>        uint256 id,</span>
  642 |     | <span class='neutral'>        uint16 priorityFee,</span>
  643 |     | <span class='neutral'>        uint16 fee,</span>
  644 |     | <span class='neutral'>        int24 maxTick,</span>
  645 |     | <span class='neutral'>        uint16 volatility,</span>
  646 |     | <span class='neutral'>        uint16 duration,</span>
  647 |     | <span class='neutral'>        uint16 jit,</span>
  648 |     | <span class='neutral'>        uint128 price</span>
  649 |     | <span class='unexecuted'>    ) public {</span>
  650 | r   | <span class='reverted'>        (HyperPool memory preChangeState, uint64 poolId, , ) = retrieve_random_pool_and_tokens(id);</span>
  651 | r   | <span class='reverted'>        emit LogUint256(&quot;created pools&quot;, poolIds.length);</span>
  652 | r   | <span class='reverted'>        emit LogUint256(&quot;pool ID&quot;, uint256(poolId));</span>
  653 | r   | <span class='reverted'>        require(!preChangeState.isMutable());</span>
  654 | r   | <span class='reverted'>        require(preChangeState.controller == address(this));</span>
  655 |     | <span class='neutral'>        {</span>
  656 |     | <span class='neutral'>            // scaling remaining pool creation values</span>
  657 |     | <span class='unexecuted'>            fee = uint16(between(fee, MIN_FEE, MAX_FEE));</span>
  658 |     | <span class='unexecuted'>            priorityFee = uint16(between(priorityFee, 1, fee));</span>
  659 |     | <span class='unexecuted'>            volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));</span>
  660 |     | <span class='unexecuted'>            duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));</span>
  661 |     | <span class='unexecuted'>            maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]</span>
  662 |     | <span class='unexecuted'>            jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));</span>
  663 |     | <span class='unexecuted'>            price = uint128(between(price, 1, type(uint128).max)); // price is between 1-uint256.max</span>
  664 |     | <span class='neutral'>        }</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='unexecuted'>        try _hyper.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick) {</span>
  667 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Changing pool parameters of a nonmutable pool should not be possible&quot;);</span>
  668 |     | <span class='neutral'>        } catch {}</span>
  669 |     | <span class='neutral'>    }</span>
  670 |     | <span class='neutral'></span>
  671 |     | <span class='neutral'>    // Invariant: Attempting to change parameters by a non-controller should fail</span>
  672 |     | <span class='neutral'>    // ******************** Funding ********************</span>
  673 |     | <span class='neutral'></span>
  674 | *r  | <span class='executed'>    function fund_with_correct_preconditions_should_succeed(uint256 assetAmount, uint256 quoteAmount) public {</span>
  675 |     | <span class='neutral'>        // asset and quote amount &gt; 1</span>
  676 | *r  | <span class='executed'>        assetAmount = between(assetAmount, 1, type(uint64).max);</span>
  677 | *r  | <span class='executed'>        quoteAmount = between(quoteAmount, 1, type(uint64).max);</span>
  678 |     | <span class='neutral'></span>
  679 | *r  | <span class='executed'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);</span>
  680 |     | <span class='neutral'></span>
  681 | *r  | <span class='executed'>        emit LogUint256(&quot;assetAmount&quot;, assetAmount);</span>
  682 | *r  | <span class='executed'>        emit LogUint256(&quot;quoteAmount&quot;, quoteAmount);</span>
  683 | *r  | <span class='executed'>        mint_and_approve(_asset, assetAmount);</span>
  684 | *r  | <span class='executed'>        mint_and_approve(_quote, quoteAmount);</span>
  685 |     | <span class='neutral'></span>
  686 | *   | <span class='executed'>        if (_asset.balanceOf(address(this)) &lt; assetAmount) {</span>
  687 |     | <span class='unexecuted'>            emit LogUint256(&quot;asset balance&quot;, _asset.balanceOf(address(this)));</span>
  688 |     | <span class='neutral'>        }</span>
  689 | *   | <span class='executed'>        if (_quote.balanceOf(address(this)) &lt; quoteAmount) {</span>
  690 |     | <span class='unexecuted'>            emit LogUint256(&quot;quote balance&quot;, _quote.balanceOf(address(this)));</span>
  691 |     | <span class='neutral'>        }</span>
  692 |     | <span class='neutral'></span>
  693 | *   | <span class='executed'>        fund_token(address(_asset), assetAmount);</span>
  694 | *   | <span class='executed'>        fund_token(address(_quote), quoteAmount);</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 | *r  | <span class='executed'>    function fund_with_insufficient_funds_should_fail(uint256 assetAmount, uint256 quoteAmount) public {</span>
  698 | *r  | <span class='executed'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);</span>
  699 |     | <span class='neutral'></span>
  700 | *   | <span class='executed'>        assetAmount = between(assetAmount, 1, type(uint256).max);</span>
  701 | *   | <span class='executed'>        quoteAmount = between(quoteAmount, 1, type(uint256).max);</span>
  702 |     | <span class='neutral'></span>
  703 | *   | <span class='executed'>        try _hyper.fund(address(_asset), assetAmount) {</span>
  704 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Funding with insufficient asset should fail&quot;);</span>
  705 |     | <span class='neutral'>        } catch {}</span>
  706 |     | <span class='neutral'></span>
  707 | *   | <span class='executed'>        try _hyper.fund(address(_quote), quoteAmount) {</span>
  708 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;Funding with insufficient quote should fail&quot;);</span>
  709 |     | <span class='neutral'>        } catch {}</span>
  710 |     | <span class='neutral'>    }</span>
  711 |     | <span class='neutral'></span>
  712 | *r  | <span class='executed'>    function fund_with_insufficient_allowance_should_fail(uint256 id, uint256 fundAmount) public {</span>
  713 | *r  | <span class='executed'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(id, fundAmount);</span>
  714 |     | <span class='neutral'></span>
  715 | *r  | <span class='executed'>        uint256 smallAssetAllowance = between(fundAmount, 1, fundAmount - 1);</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>        // mint the asset to address(this) and approve some amount &lt; fund</span>
  718 | *r  | <span class='executed'>        _asset.mint(address(this), fundAmount);</span>
  719 | *r  | <span class='executed'>        _asset.approve(address(_hyper), smallAssetAllowance);</span>
  720 | *r  | <span class='executed'>        try _hyper.fund(address(_asset), fundAmount) {</span>
  721 |     | <span class='unexecuted'>            emit LogUint256(&quot;small asset allowance&quot;, smallAssetAllowance);</span>
  722 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: insufficient allowance on asset should fail.&quot;);</span>
  723 |     | <span class='neutral'>        } catch {}</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>        // mint the quote token to address(this), approve some amount &lt; fund</span>
  726 | *r  | <span class='executed'>        _quote.mint(address(this), fundAmount);</span>
  727 | *   | <span class='executed'>        _quote.approve(address(_hyper), smallAssetAllowance);</span>
  728 | *   | <span class='executed'>        try _hyper.fund(address(_quote), fundAmount) {</span>
  729 |     | <span class='unexecuted'>            emit LogUint256(&quot;small quote allowance&quot;, smallAssetAllowance);</span>
  730 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: insufficient allowance on quote should fail.&quot;);</span>
  731 |     | <span class='neutral'>        } catch {}</span>
  732 |     | <span class='neutral'>    }</span>
  733 |     | <span class='neutral'></span>
  734 | *r  | <span class='executed'>    function fund_with_zero(uint256 id1, uint256 id2) public {</span>
  735 | *r  | <span class='executed'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(id1, id2);</span>
  736 |     | <span class='neutral'></span>
  737 | *   | <span class='executed'>        mint_and_approve(_asset, 0);</span>
  738 | *   | <span class='executed'>        mint_and_approve(_quote, 0);</span>
  739 | *   | <span class='executed'>        _hyper.fund(address(_asset), 0);</span>
  740 | *   | <span class='executed'>        _hyper.fund(address(_quote), 0);</span>
  741 |     | <span class='neutral'>    }</span>
  742 |     | <span class='neutral'></span>
  743 | *   | <span class='executed'>    function fund_token(address token, uint256 amount) private returns (bool) {</span>
  744 |     | <span class='neutral'>        // TODO Refactor: reuse the HelperHyperView.getState() keeps this cleaner</span>
  745 | *   | <span class='executed'>        uint256 senderBalancePreFund = EchidnaERC20(token).balanceOf(address(this));</span>
  746 | *   | <span class='executed'>        uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(token));</span>
  747 | *   | <span class='executed'>        uint256 reservePreFund = getReserve(address(_hyper), address(token));</span>
  748 | *   | <span class='executed'>        uint256 hyperBalancePreFund = EchidnaERC20(token).balanceOf(address(_hyper));</span>
  749 |     | <span class='neutral'></span>
  750 | *   | <span class='executed'>        try _hyper.fund(address(token), amount) {} catch (bytes memory error) {</span>
  751 |     | <span class='unexecuted'>            emit LogBytes(&quot;error&quot;, error);</span>
  752 |     | <span class='unexecuted'>            assert(false);</span>
  753 |     | <span class='neutral'>        }</span>
  754 |     | <span class='neutral'></span>
  755 |     | <span class='neutral'>        // sender&#39;s token balance should decrease</span>
  756 |     | <span class='neutral'>        // usdc sender pre token balance = 100 ; usdc sender post token = 100 - 1</span>
  757 | *   | <span class='executed'>        uint256 senderBalancePostFund = EchidnaERC20(token).balanceOf(address(this));</span>
  758 | *   | <span class='executed'>        if (senderBalancePostFund != senderBalancePreFund - amount) {</span>
  759 |     | <span class='unexecuted'>            emit LogUint256(&quot;postTransfer sender balance&quot;, senderBalancePostFund);</span>
  760 |     | <span class='unexecuted'>            emit LogUint256(&quot;preTransfer:&quot;, senderBalancePreFund);</span>
  761 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Sender balance of token did not decrease by amount after funding&quot;);</span>
  762 |     | <span class='neutral'>        }</span>
  763 |     | <span class='neutral'>        // hyper balance of the sender should increase</span>
  764 |     | <span class='neutral'>        // pre hyper balance = a; post hyperbalance + 100</span>
  765 | *   | <span class='executed'>        uint256 virtualBalancePostFund = getBalance(address(_hyper), address(this), address(token));</span>
  766 | *   | <span class='executed'>        if (virtualBalancePostFund != virtualBalancePreFund + amount) {</span>
  767 |     | <span class='unexecuted'>            emit LogUint256(&quot;tracked balance after funding&quot;, virtualBalancePostFund);</span>
  768 |     | <span class='unexecuted'>            emit LogUint256(&quot;tracked balance before funding:&quot;, virtualBalancePreFund);</span>
  769 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Tracked balance of sender did not increase after funding&quot;);</span>
  770 |     | <span class='neutral'>        }</span>
  771 |     | <span class='neutral'>        // hyper reserves for token should increase</span>
  772 |     | <span class='neutral'>        // reserve balance = b; post reserves + 100</span>
  773 | *   | <span class='executed'>        uint256 reservePostFund = getReserve(address(_hyper), address(token));</span>
  774 | *   | <span class='executed'>        if (reservePostFund != reservePreFund + amount) {</span>
  775 |     | <span class='unexecuted'>            emit LogUint256(&quot;reserve after funding&quot;, reservePostFund);</span>
  776 |     | <span class='unexecuted'>            emit LogUint256(&quot;reserve balance before funding:&quot;, reservePreFund);</span>
  777 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Reserve of hyper did not increase after funding&quot;);</span>
  778 |     | <span class='neutral'>        }</span>
  779 |     | <span class='neutral'>        // hyper&#39;s token balance should increase</span>
  780 |     | <span class='neutral'>        // pre balance of usdc = y; post balance = y + 100</span>
  781 | *   | <span class='executed'>        uint256 hyperBalancePostFund = EchidnaERC20(token).balanceOf(address(_hyper));</span>
  782 | *   | <span class='executed'>        if (hyperBalancePostFund != hyperBalancePreFund + amount) {</span>
  783 |     | <span class='unexecuted'>            emit LogUint256(&quot;hyper token balance after funding&quot;, hyperBalancePostFund);</span>
  784 |     | <span class='unexecuted'>            emit LogUint256(&quot;hyper balance before funding:&quot;, hyperBalancePreFund);</span>
  785 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: Hyper token balance did not increase after funding&quot;);</span>
  786 |     | <span class='neutral'>        }</span>
  787 | *   | <span class='executed'>        return true;</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 | *r  | <span class='executed'>    function mint_and_approve(EchidnaERC20 token, uint256 amount) private {</span>
  791 | *r  | <span class='executed'>        token.mint(address(this), amount);</span>
  792 | *r  | <span class='executed'>        token.approve(address(_hyper), type(uint256).max);</span>
  793 |     | <span class='neutral'>    }</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>    // ******************** Draw ********************</span>
  796 | r   | <span class='reverted'>    function draw_should_succeed(</span>
  797 |     | <span class='neutral'>        uint256 assetAmount,</span>
  798 |     | <span class='neutral'>        uint256 quoteAmount,</span>
  799 |     | <span class='neutral'>        address recipient</span>
  800 |     | <span class='neutral'>    ) public {</span>
  801 | r   | <span class='reverted'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);</span>
  802 |     | <span class='neutral'></span>
  803 | r   | <span class='reverted'>        assetAmount = between(assetAmount, 1, type(uint64).max);</span>
  804 | r   | <span class='reverted'>        quoteAmount = between(quoteAmount, 1, type(uint64).max);</span>
  805 | r   | <span class='reverted'>        emit LogUint256(&quot;asset amount: &quot;, assetAmount);</span>
  806 | r   | <span class='reverted'>        emit LogUint256(&quot;quote amount:&quot;, quoteAmount);</span>
  807 |     | <span class='neutral'></span>
  808 | r   | <span class='reverted'>        require(recipient != address(_hyper));</span>
  809 | r   | <span class='reverted'>        require(recipient != address(0));</span>
  810 |     | <span class='neutral'></span>
  811 | r   | <span class='reverted'>        draw_token(address(_asset), assetAmount, recipient);</span>
  812 | r   | <span class='reverted'>        draw_token(address(_quote), quoteAmount, recipient);</span>
  813 |     | <span class='neutral'>    }</span>
  814 |     | <span class='neutral'></span>
  815 | r   | <span class='reverted'>    function draw_token(</span>
  816 |     | <span class='neutral'>        address token,</span>
  817 |     | <span class='neutral'>        uint256 amount,</span>
  818 |     | <span class='neutral'>        address recipient</span>
  819 |     | <span class='unexecuted'>    ) private {</span>
  820 |     | <span class='neutral'>        // make sure a user has funded already</span>
  821 | r   | <span class='reverted'>        uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(token));</span>
  822 | r   | <span class='reverted'>        require(virtualBalancePreFund &gt; 0);</span>
  823 | r   | <span class='reverted'>        amount = between(amount, 1, virtualBalancePreFund);</span>
  824 |     | <span class='neutral'></span>
  825 | r   | <span class='reverted'>        uint256 recipientBalancePreFund = EchidnaERC20(token).balanceOf(address(recipient));</span>
  826 | r   | <span class='reverted'>        uint256 reservePreFund = getReserve(address(_hyper), address(token));</span>
  827 | r   | <span class='reverted'>        uint256 hyperBalancePreFund = EchidnaERC20(token).balanceOf(address(_hyper));</span>
  828 |     | <span class='neutral'></span>
  829 | r   | <span class='reverted'>        _hyper.draw(token, amount, recipient);</span>
  830 |     | <span class='neutral'></span>
  831 |     | <span class='neutral'>        //-- Postconditions</span>
  832 |     | <span class='neutral'>        // caller balance should decrease</span>
  833 |     | <span class='neutral'>        // pre caller balance = a; post caller balance = a - 100</span>
  834 | r   | <span class='reverted'>        uint256 virtualBalancePostFund = getBalance(address(_hyper), address(this), address(token));</span>
  835 | r   | <span class='reverted'>        if (virtualBalancePostFund != virtualBalancePreFund - amount) {</span>
  836 |     | <span class='unexecuted'>            emit LogUint256(&quot;virtual balance post draw&quot;, virtualBalancePostFund);</span>
  837 |     | <span class='unexecuted'>            emit LogUint256(&quot;virtual balance pre draw&quot;, virtualBalancePreFund);</span>
  838 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: virtual balance should decrease after drawing tokens&quot;);</span>
  839 |     | <span class='neutral'>        }</span>
  840 |     | <span class='neutral'>        // reserves should decrease</span>
  841 | r   | <span class='reverted'>        uint256 reservePostFund = getReserve(address(_hyper), address(token));</span>
  842 | r   | <span class='reverted'>        if (reservePostFund != reservePreFund - amount) {</span>
  843 |     | <span class='unexecuted'>            emit LogUint256(&quot;reserve post draw&quot;, reservePostFund);</span>
  844 |     | <span class='unexecuted'>            emit LogUint256(&quot;reserve pre draw&quot;, reservePreFund);</span>
  845 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: reserve balance should decrease after drawing tokens&quot;);</span>
  846 |     | <span class='neutral'>        }</span>
  847 |     | <span class='neutral'>        // to address should increase</span>
  848 |     | <span class='neutral'>        // pre-token balance = a; post-token = a + 100</span>
  849 | r   | <span class='reverted'>        uint256 recipientBalancePostFund = EchidnaERC20(token).balanceOf(address(recipient));</span>
  850 | r   | <span class='reverted'>        if (recipientBalancePostFund != recipientBalancePreFund + amount) {</span>
  851 |     | <span class='unexecuted'>            emit LogUint256(&quot;recipient balance post draw&quot;, recipientBalancePostFund);</span>
  852 |     | <span class='unexecuted'>            emit LogUint256(&quot;recipient balance pre draw&quot;, recipientBalancePreFund);</span>
  853 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: recipient balance should increase after drawing tokens&quot;);</span>
  854 |     | <span class='neutral'>        }</span>
  855 |     | <span class='neutral'>        // hyper token&#39;s balance should decrease</span>
  856 | r   | <span class='reverted'>        uint256 tokenPostFund = EchidnaERC20(token).balanceOf(address(_hyper));</span>
  857 | r   | <span class='reverted'>        if (tokenPostFund != hyperBalancePreFund - amount) {</span>
  858 |     | <span class='unexecuted'>            emit LogUint256(&quot;token post draw&quot;, tokenPostFund);</span>
  859 |     | <span class='unexecuted'>            emit LogUint256(&quot;token pre draw&quot;, hyperBalancePreFund);</span>
  860 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: hyper token balance should increase after drawing tokens&quot;);</span>
  861 |     | <span class='neutral'>        }</span>
  862 |     | <span class='neutral'>    }</span>
  863 |     | <span class='neutral'></span>
  864 | *r  | <span class='executed'>    function draw_to_zero_should_fail(uint256 assetAmount, uint256 quoteAmount) public {</span>
  865 | r   | <span class='reverted'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);</span>
  866 |     | <span class='neutral'></span>
  867 |     | <span class='neutral'>        // make sure a user has funded already</span>
  868 | r   | <span class='reverted'>        uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(_asset));</span>
  869 | r   | <span class='reverted'>        emit LogUint256(&quot;virtual balance pre fund&quot;, virtualBalancePreFund);</span>
  870 |     | <span class='neutral'>        require(virtualBalancePreFund &gt;= 0);</span>
  871 | r   | <span class='reverted'>        assetAmount = between(assetAmount, 1, virtualBalancePreFund);</span>
  872 |     | <span class='neutral'></span>
  873 | *   | <span class='executed'>        try _hyper.draw(address(_asset), assetAmount, address(0)) {</span>
  874 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: draw should fail attempting to transfer to zero&quot;);</span>
  875 |     | <span class='neutral'>        } catch {}</span>
  876 |     | <span class='neutral'>    }</span>
  877 |     | <span class='neutral'></span>
  878 | *r  | <span class='executed'>    function fund_then_draw(uint256 whichToken, uint256 amount) public {</span>
  879 | *r  | <span class='executed'>        (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(amount, whichToken);</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>        // this can be extended to use the token list in `hyperTokens`</span>
  882 | *r  | <span class='executed'>        address token;</span>
  883 | *r  | <span class='executed'>        if (whichToken % 2 == 0) token = address(_asset);</span>
  884 | *r  | <span class='executed'>        else token = address(_quote);</span>
  885 |     | <span class='neutral'></span>
  886 | *r  | <span class='executed'>        mint_and_approve(_asset, amount);</span>
  887 | *r  | <span class='executed'>        mint_and_approve(_quote, amount);</span>
  888 |     | <span class='neutral'></span>
  889 | *r  | <span class='executed'>        uint256 hyperBalancePreFund = EchidnaERC20(token).balanceOf(address(_hyper));</span>
  890 | *r  | <span class='executed'>        require(hyperBalancePreFund == 0);</span>
  891 |     | <span class='neutral'></span>
  892 | *r  | <span class='executed'>        uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(token));</span>
  893 | *r  | <span class='executed'>        uint256 recipientBalancePreFund = EchidnaERC20(token).balanceOf(address(this));</span>
  894 | *r  | <span class='executed'>        uint256 reservePreFund = getReserve(address(_hyper), address(token));</span>
  895 |     | <span class='neutral'></span>
  896 |     | <span class='neutral'>        // Call fund and draw</span>
  897 | *r  | <span class='executed'>        _hyper.fund(token, amount);</span>
  898 | *   | <span class='executed'>        _hyper.draw(token, amount, address(this));</span>
  899 |     | <span class='neutral'></span>
  900 |     | <span class='neutral'>        //-- Postconditions</span>
  901 |     | <span class='neutral'>        // caller balance should be equal</span>
  902 |     | <span class='neutral'></span>
  903 |     | <span class='neutral'>        //TODO Refactor: use HelperHyperView.getState() here</span>
  904 | *   | <span class='executed'>        uint256 virtualBalancePostFund = getBalance(address(_hyper), address(this), address(token));</span>
  905 | *   | <span class='executed'>        if (virtualBalancePostFund != virtualBalancePreFund) {</span>
  906 |     | <span class='unexecuted'>            emit LogUint256(&quot;virtual balance post fund-draw&quot;, virtualBalancePostFund);</span>
  907 |     | <span class='unexecuted'>            emit LogUint256(&quot;virtual balance pre fund-draw&quot;, virtualBalancePreFund);</span>
  908 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: virtual balance should be equal after fund-draw&quot;);</span>
  909 |     | <span class='neutral'>        }</span>
  910 |     | <span class='neutral'>        // reserves should be equal</span>
  911 | *   | <span class='executed'>        uint256 reservePostFund = getReserve(address(_hyper), address(token));</span>
  912 | *   | <span class='executed'>        if (reservePostFund != reservePreFund) {</span>
  913 |     | <span class='unexecuted'>            emit LogUint256(&quot;reserve post fund-draw&quot;, reservePostFund);</span>
  914 |     | <span class='unexecuted'>            emit LogUint256(&quot;reserve pre fund-draw&quot;, reservePreFund);</span>
  915 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: reserve balance should be equal after fund-draw&quot;);</span>
  916 |     | <span class='neutral'>        }</span>
  917 |     | <span class='neutral'>        // recipient = sender balance should be equal</span>
  918 | *   | <span class='executed'>        uint256 recipientBalancePostFund = EchidnaERC20(token).balanceOf(address(this));</span>
  919 | *   | <span class='executed'>        if (recipientBalancePostFund != recipientBalancePreFund) {</span>
  920 |     | <span class='unexecuted'>            emit LogUint256(&quot;recipient balance post fund-draw&quot;, recipientBalancePostFund);</span>
  921 |     | <span class='unexecuted'>            emit LogUint256(&quot;recipient balance pre fund-draw&quot;, recipientBalancePreFund);</span>
  922 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: recipient balance should be equal after fund-draw&quot;);</span>
  923 |     | <span class='neutral'>        }</span>
  924 |     | <span class='neutral'>        // hyper token&#39;s balance should be equal</span>
  925 | *   | <span class='executed'>        uint256 tokenPostFund = EchidnaERC20(token).balanceOf(address(_hyper));</span>
  926 | *   | <span class='executed'>        if (tokenPostFund != hyperBalancePreFund) {</span>
  927 |     | <span class='unexecuted'>            emit LogUint256(&quot;token post fund-draw&quot;, tokenPostFund);</span>
  928 |     | <span class='unexecuted'>            emit LogUint256(&quot;token pre fund-draw&quot;, hyperBalancePreFund);</span>
  929 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: hyper token balance should be equal after fund-draw&quot;);</span>
  930 |     | <span class='neutral'>        }</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    // ******************** Depositing ********************</span>
  934 |     | <span class='neutral'></span>
  935 | *r  | <span class='executed'>    function deposit_with_correct_postconditions_should_succeed() public payable {</span>
  936 | *r  | <span class='executed'>        require(msg.value &gt; 0);</span>
  937 | *   | <span class='executed'>        emit LogUint256(&quot;msg.value&quot;, msg.value);</span>
  938 |     | <span class='neutral'></span>
  939 | *   | <span class='executed'>        uint256 thisEthBalancePre = address(this).balance;</span>
  940 | *   | <span class='executed'>        uint256 reserveBalancePre = getReserve(address(_hyper), address(_weth));</span>
  941 | *   | <span class='executed'>        uint256 wethBalancePre = _weth.balanceOf(address(_hyper));</span>
  942 |     | <span class='neutral'></span>
  943 | *   | <span class='executed'>        try _hyper.deposit{value: msg.value}() {</span>
  944 | *   | <span class='executed'>            uint256 thisEthBalancePost = address(this).balance;</span>
  945 | *   | <span class='executed'>            uint256 reserveBalancePost = getReserve(address(_hyper), address(_weth));</span>
  946 | *   | <span class='executed'>            uint256 wethBalancePost = _weth.balanceOf(address(_hyper));</span>
  947 |     | <span class='neutral'>            // Eth balance of this contract should decrease by the deposited amount</span>
  948 | *   | <span class='executed'>            if (thisEthBalancePost != thisEthBalancePre-msg.value) {</span>
  949 |     | <span class='unexecuted'>                emit LogUint256(&quot;eth balance post transfer (sender)&quot;, thisEthBalancePost);</span>
  950 |     | <span class='unexecuted'>                emit LogUint256(&quot;eth balance pre transfer (sender)&quot;, thisEthBalancePre);</span>
  951 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;sender&#39;s eth balance should not change.&quot;);</span>
  952 |     | <span class='neutral'>            }</span>
  953 |     | <span class='neutral'>            // Hyper reserve of WETH should increase by msg.value</span>
  954 | *   | <span class='executed'>            if (reserveBalancePost != reserveBalancePre + msg.value) {</span>
  955 |     | <span class='unexecuted'>                emit LogUint256(&quot;weth reserve post transfer (hyper)&quot;, reserveBalancePost);</span>
  956 |     | <span class='unexecuted'>                emit LogUint256(&quot;weth reserve pre transfer (hyper)&quot;, reserveBalancePre);</span>
  957 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;hyper&#39;s weth reserve should increase by added amount.&quot;);</span>
  958 |     | <span class='neutral'>            }</span>
  959 |     | <span class='neutral'>            // Hyper balance of WETH should increase by msg.value</span>
  960 | *   | <span class='executed'>            if (wethBalancePost != wethBalancePre + msg.value) {</span>
  961 |     | <span class='unexecuted'>                emit LogUint256(&quot;weth balance post transfer (hyper)&quot;, wethBalancePost);</span>
  962 |     | <span class='unexecuted'>                emit LogUint256(&quot;weth balance pre transfer (hyper)&quot;, wethBalancePre);</span>
  963 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;hypers&#39;s weth balance should increase by added amount.&quot;);</span>
  964 |     | <span class='neutral'>            }</span>
  965 |     | <span class='unexecuted'>        } catch (bytes memory err) {</span>
  966 |     | <span class='unexecuted'>            emit LogBytes(&quot;error&quot;, err);</span>
  967 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: deposit should not have failed.&quot;);</span>
  968 |     | <span class='neutral'>        }</span>
  969 |     | <span class='neutral'>    }</span>
  970 |     | <span class='neutral'></span>
  971 |     | <span class='neutral'>    using SafeCastLib for uint256;</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    // Future invariant: Funding with WETH and then depositing with ETH should have the same impact on the pool</span>
  974 |     | <span class='neutral'>    // ******************** Allocate ********************</span>
  975 | r   | <span class='reverted'>    function allocate_should_succeed_with_correct_preconditions(uint256 id, uint256 deltaLiquidity) public {</span>
  976 | r   | <span class='reverted'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote) = retrieve_random_pool_and_tokens(</span>
  977 | r   | <span class='reverted'>            id</span>
  978 |     | <span class='neutral'>        );</span>
  979 | r   | <span class='reverted'>        emit LogUint256(&quot;pool id:&quot;, uint256(poolId));</span>
  980 |     | <span class='neutral'></span>
  981 | r   | <span class='reverted'>        require(pool.lastPrice != 0);</span>
  982 | r   | <span class='reverted'>        require(pool.lastTimestamp != 0);</span>
  983 |     | <span class='neutral'></span>
  984 |     | <span class='neutral'>        // ensures deltaLiquidity is never zero</span>
  985 | r   | <span class='reverted'>        deltaLiquidity = between(deltaLiquidity, 1, type(uint256).max);</span>
  986 | r   | <span class='reverted'>        if (deltaLiquidity == type(uint256).max) {</span>
  987 |     | <span class='unexecuted'>            deltaLiquidity = 1;</span>
  988 |     | <span class='neutral'>        } else {</span>
  989 | r   | <span class='reverted'>            deltaLiquidity = uint128(deltaLiquidity);</span>
  990 |     | <span class='neutral'>        }</span>
  991 |     | <span class='neutral'></span>
  992 | r   | <span class='reverted'>        int128 deltaLiquidityInt = convertToInt128(uint128(deltaLiquidity));</span>
  993 | r   | <span class='reverted'>        (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidityInt);</span>
  994 |     | <span class='neutral'></span>
  995 | r   | <span class='reverted'>        emit LogUint256(&quot;delta asset:&quot;, deltaAsset);</span>
  996 | r   | <span class='reverted'>        emit LogUint256(&quot;delta quote:&quot;, deltaQuote);</span>
  997 | r   | <span class='reverted'>        emit LogUint256(&quot;deltaLiquidity&quot;, deltaLiquidity);</span>
  998 |     | <span class='neutral'></span>
  999 | r   | <span class='reverted'>        execute_allocate_call(poolId, _asset,_quote,deltaAsset,deltaQuote,deltaLiquidity);</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 | r   | <span class='reverted'>    function execute_allocate_call(uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote,uint256 deltaAsset, uint256 deltaQuote, uint256 deltaLiquidity) internal {</span>
 1002 |     | <span class='neutral'>        // Caller must have a balance and have approved hyper</span>
 1003 | r   | <span class='reverted'>        mint_and_approve(_asset, deltaAsset);</span>
 1004 | r   | <span class='reverted'>        mint_and_approve(_quote, deltaQuote);</span>
 1005 |     | <span class='neutral'></span>
 1006 | r   | <span class='reverted'>        address[] memory owners = new address[](1);        </span>
 1007 |     | <span class='neutral'></span>
 1008 |     | <span class='neutral'>        // Save pre allocation state</span>
 1009 | r   | <span class='reverted'>        HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);</span>
 1010 |     | <span class='neutral'></span>
 1011 | r   | <span class='reverted'>        (uint256 allocateAsset, uint256 allocateQuote) = _hyper.allocate(poolId, deltaLiquidity);</span>
 1012 |     | <span class='unexecuted'>        emit LogUint256(&quot;allocate asset return&quot;, allocateAsset);</span>
 1013 |     | <span class='unexecuted'>        emit LogUint256(&quot;allocate quote return&quot;, allocateQuote);</span>
 1014 |     | <span class='neutral'></span>
 1015 |     | <span class='unexecuted'>        HyperState memory postState = getState(address(_hyper), poolId, address(this), owners);</span>
 1016 |     | <span class='neutral'>        {</span>
 1017 |     | <span class='neutral'>            // Reserves in both tokens should increase</span>
 1018 |     | <span class='unexecuted'>            if (preState.reserveAsset + deltaAsset != postState.reserveAsset) {</span>
 1019 |     | <span class='unexecuted'>                emit LogUint256(&quot;pre allocate reserve asset&quot;, preState.reserveAsset);</span>
 1020 |     | <span class='unexecuted'>                emit LogUint256(&quot;post allocate reserve asset&quot;, postState.reserveAsset);</span>
 1021 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG: Reserve asset did not increase by deltaAsset&quot;);</span>
 1022 |     | <span class='neutral'>            }</span>
 1023 |     | <span class='unexecuted'>            if (preState.reserveQuote + deltaQuote != postState.reserveQuote) {</span>
 1024 |     | <span class='unexecuted'>                emit LogUint256(&quot;pre allocate reserve quote&quot;, preState.reserveQuote);</span>
 1025 |     | <span class='unexecuted'>                emit LogUint256(&quot;post allocate reserve quote&quot;, postState.reserveQuote);</span>
 1026 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG: Reserve quote did not increase by deltaQuote&quot;);</span>
 1027 |     | <span class='neutral'>            }</span>
 1028 |     | <span class='neutral'>            // Total pool liquidity should increase by deltaLiquidity</span>
 1029 |     | <span class='unexecuted'>            if (preState.totalPoolLiquidity + deltaLiquidity != postState.totalPoolLiquidity) {</span>
 1030 |     | <span class='unexecuted'>                emit LogUint256(&quot;pre allocate total pool liqudity&quot;, preState.totalPoolLiquidity);</span>
 1031 |     | <span class='unexecuted'>                emit LogUint256(&quot;post allocate total pool liquidity&quot;, postState.totalPoolLiquidity);</span>
 1032 |     | <span class='unexecuted'>                emit AssertionFailed(&quot;BUG: Total liquidity did not increase by deltaLiquidity&quot;);</span>
 1033 |     | <span class='neutral'>            }</span>
 1034 |     | <span class='neutral'>            // Physical asset balance of both tokens should increase</span>
 1035 |     | <span class='unexecuted'>            assert(preState.physicalBalanceAsset + deltaAsset == postState.physicalBalanceAsset);</span>
 1036 |     | <span class='unexecuted'>            assert(preState.physicalBalanceQuote + deltaQuote == postState.physicalBalanceQuote);</span>
 1037 |     | <span class='unexecuted'>            assert(preState.callerPositionLiquidity + deltaLiquidity == postState.callerPositionLiquidity);</span>
 1038 |     | <span class='neutral'>        }</span>
 1039 |     | <span class='neutral'>        {</span>
 1040 |     | <span class='unexecuted'>            if (preState.feeGrowthAssetPool != postState.feeGrowthAssetPool) {</span>
 1041 |     | <span class='unexecuted'>                assert(postState.feeGrowthAssetPosition != 0);</span>
 1042 |     | <span class='neutral'>            }</span>
 1043 |     | <span class='unexecuted'>            if (preState.feeGrowthQuotePool != postState.feeGrowthQuotePool) {</span>
 1044 |     | <span class='unexecuted'>                assert(postState.feeGrowthQuotePosition != 0);</span>
 1045 |     | <span class='neutral'>            }</span>
 1046 |     | <span class='neutral'>        }        </span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 | r   | <span class='reverted'>    function allocate_with_non_existent_pool_should_fail(</span>
 1050 |     | <span class='neutral'>        uint256 id,</span>
 1051 |     | <span class='neutral'>        uint256 deltaLiquidity</span>
 1052 |     | <span class='neutral'>    ) public {</span>
 1053 | r   | <span class='reverted'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote) = retrieve_random_pool_and_tokens(</span>
 1054 | r   | <span class='reverted'>            id</span>
 1055 |     | <span class='neutral'>        );</span>
 1056 |     | <span class='neutral'></span>
 1057 | r   | <span class='reverted'>        address[] memory owners = new address[](1);</span>
 1058 | r   | <span class='reverted'>        require(!is_created_pool(poolId)); // require pool does not exist</span>
 1059 |     | <span class='unexecuted'>        emit LogUint256(&quot;pool id:&quot;, uint256(poolId));</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='unexecuted'>        deltaLiquidity = between(deltaLiquidity, 1, type(uint256).max);</span>
 1062 |     | <span class='unexecuted'>        if (deltaLiquidity == type(uint256).max) {</span>
 1063 |     | <span class='unexecuted'>            deltaLiquidity = 1;</span>
 1064 |     | <span class='neutral'>        } else {</span>
 1065 |     | <span class='unexecuted'>            deltaLiquidity = uint128(deltaLiquidity);</span>
 1066 |     | <span class='neutral'>        }</span>
 1067 |     | <span class='neutral'></span>
 1068 |     | <span class='unexecuted'>        int128 deltaLiquidityInt = convertToInt128(uint128(deltaLiquidity));</span>
 1069 |     | <span class='unexecuted'>        (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidityInt);</span>
 1070 |     | <span class='neutral'></span>
 1071 |     | <span class='unexecuted'>        emit LogUint256(&quot;delta asset:&quot;, deltaAsset);</span>
 1072 |     | <span class='unexecuted'>        emit LogUint256(&quot;delta quote:&quot;, deltaQuote);</span>
 1073 |     | <span class='unexecuted'>        emit LogUint256(&quot;deltaLiquidity&quot;, deltaLiquidity);</span>
 1074 |     | <span class='neutral'></span>
 1075 |     | <span class='neutral'>        // Caller must have a balance and have approved hyper</span>
 1076 |     | <span class='unexecuted'>        mint_and_approve(_asset, deltaAsset);</span>
 1077 |     | <span class='unexecuted'>        mint_and_approve(_quote, deltaQuote);</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>        // Save pre allocation state</span>
 1080 |     | <span class='unexecuted'>        HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='unexecuted'>        try _hyper.allocate(poolId, deltaLiquidity) returns (uint256 allocateAset, uint256 allocateQuote) {</span>
 1083 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: allocate with non existent pool should fail&quot;);</span>
 1084 |     | <span class='neutral'>        } catch {}</span>
 1085 |     | <span class='neutral'>    }</span>
 1086 |     | <span class='neutral'></span>
 1087 | *r  | <span class='executed'>    function allocate_with_zero_delta_liquidity_should_fail(uint256 id) public {</span>
 1088 | *r  | <span class='executed'>        address[] memory owners = new address[](1);</span>
 1089 | *r  | <span class='executed'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote) = retrieve_random_pool_and_tokens(</span>
 1090 | *r  | <span class='executed'>            id</span>
 1091 |     | <span class='neutral'>        );</span>
 1092 | *   | <span class='executed'>        emit LogUint256(&quot;pool id:&quot;, uint256(poolId));</span>
 1093 |     | <span class='neutral'></span>
 1094 | *   | <span class='executed'>        require(pool.lastPrice != 0);</span>
 1095 | *   | <span class='executed'>        require(pool.lastTimestamp != 0);</span>
 1096 |     | <span class='neutral'></span>
 1097 | *   | <span class='executed'>        uint128 deltaLiquidity = 0;</span>
 1098 |     | <span class='neutral'></span>
 1099 | *   | <span class='executed'>        int128 deltaLiquidityInt = convertToInt128(uint128(deltaLiquidity));</span>
 1100 | *   | <span class='executed'>        (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidityInt);</span>
 1101 |     | <span class='neutral'></span>
 1102 | *   | <span class='executed'>        emit LogUint256(&quot;delta asset:&quot;, deltaAsset);</span>
 1103 | *   | <span class='executed'>        emit LogUint256(&quot;delta quote:&quot;, deltaQuote);</span>
 1104 | *   | <span class='executed'>        emit LogUint256(&quot;deltaLiquidity&quot;, deltaLiquidity);</span>
 1105 |     | <span class='neutral'></span>
 1106 |     | <span class='neutral'>        // Caller must have a balance and have approved hyper</span>
 1107 | *   | <span class='executed'>        mint_and_approve(_asset, deltaAsset);</span>
 1108 | *   | <span class='executed'>        mint_and_approve(_quote, deltaQuote);</span>
 1109 |     | <span class='neutral'></span>
 1110 | *   | <span class='executed'>        try _hyper.allocate(poolId, deltaLiquidity) returns (uint256 allocateAset, uint256 allocateQuote) {</span>
 1111 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: allocate with deltaLiquidity=0 should fail&quot;);</span>
 1112 |     | <span class='neutral'>        } catch {}</span>
 1113 |     | <span class='neutral'>    }</span>
 1114 |     | <span class='neutral'></span>
 1115 |     | <span class='neutral'>    // A user should not be able to allocate more than they own</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    // ******************** Unallocate ********************</span>
 1118 | r   | <span class='reverted'>    function unallocate_with_correct_preconditions_should_work(uint256 id, uint256 amount) public {</span>
 1119 | r   | <span class='reverted'>        address[] memory owners = new address[](1);</span>
 1120 | r   | <span class='reverted'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote) = retrieve_random_pool_and_tokens(</span>
 1121 | r   | <span class='reverted'>            id</span>
 1122 |     | <span class='neutral'>        );</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>        // Save pre unallocation state</span>
 1125 | r   | <span class='reverted'>        HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);</span>
 1126 | r   | <span class='reverted'>        uint256 preUnallocateAssetBalance = _asset.balanceOf(address(this));</span>
 1127 | r   | <span class='reverted'>        uint256 preUnallocateQuoteBalance = _quote.balanceOf(address(this));</span>
 1128 | r   | <span class='reverted'>        require(preState.callerPositionLiquidity &gt; 0);</span>
 1129 |     | <span class='unexecuted'>        require(pool.lastTimestamp - block.timestamp &lt; JUST_IN_TIME_LIQUIDITY_POLICY);</span>
 1130 |     | <span class='neutral'></span>
 1131 |     | <span class='unexecuted'>        (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getAmounts(poolId);</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='unexecuted'>        _hyper.unallocate(poolId, amount);</span>
 1134 |     | <span class='neutral'></span>
 1135 |     | <span class='neutral'>        // Save post unallocation state</span>
 1136 |     | <span class='unexecuted'>        HyperState memory postState = getState(address(_hyper), poolId, address(this), owners);</span>
 1137 |     | <span class='unexecuted'>        {</span>
 1138 |     | <span class='unexecuted'>            uint256 postUnallocateAssetBalance = _asset.balanceOf(address(this));</span>
 1139 |     | <span class='unexecuted'>            uint256 postUnallocateQuoteBalance = _quote.balanceOf(address(this));</span>
 1140 |     | <span class='unexecuted'>            assert(preUnallocateAssetBalance + deltaAsset == postUnallocateAssetBalance);</span>
 1141 |     | <span class='unexecuted'>            assert(preUnallocateQuoteBalance + deltaQuote == postUnallocateQuoteBalance);</span>
 1142 |     | <span class='neutral'>        }</span>
 1143 |     | <span class='neutral'></span>
 1144 |     | <span class='unexecuted'>        assert(preState.totalPoolLiquidity - amount == postState.totalPoolLiquidity);</span>
 1145 |     | <span class='unexecuted'>        assert(preState.callerPositionLiquidity - amount == postState.callerPositionLiquidity);</span>
 1146 |     | <span class='unexecuted'>        assert(preState.reserveAsset == postState.reserveAsset);</span>
 1147 |     | <span class='unexecuted'>        assert(preState.reserveQuote == postState.reserveQuote);</span>
 1148 |     | <span class='unexecuted'>        assert(preState.physicalBalanceAsset == postState.physicalBalanceAsset);</span>
 1149 |     | <span class='unexecuted'>        assert(preState.physicalBalanceQuote == postState.physicalBalanceQuote);</span>
 1150 |     | <span class='neutral'>    }</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>    // A user without a position should not be able to unallocate funds</span>
 1153 | r   | <span class='reverted'>    function unallocate_without_position_should_fail(uint256 id, uint256 amount) public {</span>
 1154 | r   | <span class='reverted'>        address[] memory owners = new address[](1);</span>
 1155 | r   | <span class='reverted'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote) = retrieve_random_pool_and_tokens(</span>
 1156 | r   | <span class='reverted'>            id</span>
 1157 |     | <span class='neutral'>        );</span>
 1158 |     | <span class='neutral'></span>
 1159 |     | <span class='neutral'>        // Save pre unallocation state</span>
 1160 | r   | <span class='reverted'>        HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);</span>
 1161 | r   | <span class='reverted'>        uint256 preUnallocateAssetBalance = _asset.balanceOf(address(this));</span>
 1162 | r   | <span class='reverted'>        uint256 preUnallocateQuoteBalance = _quote.balanceOf(address(this));</span>
 1163 | r   | <span class='reverted'>        require(pool.lastTimestamp - block.timestamp &lt; JUST_IN_TIME_LIQUIDITY_POLICY);</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='unexecuted'>        try _hyper.unallocate(poolId, amount){</span>
 1166 |     | <span class='unexecuted'>            emit AssertionFailed(&quot;BUG: User was able to unallocate without prior allocation&quot;);</span>
 1167 |     | <span class='neutral'>        }catch {</span>
 1168 |     | <span class='neutral'>        }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    }    </span>
 1171 |     | <span class='neutral'>    // A user attempting to unallocate a nonexistent pool should fail</span>
 1172 |     | <span class='neutral'>    // A user attempting to unallocate an expired pool should be successful</span>
 1173 |     | <span class='neutral'>    // Caller position last timestamp &lt;= block.timestamp, with JIT policy</span>
 1174 |     | <span class='neutral'>    // A user should not be able to unallocate more than they own</span>
 1175 |     | <span class='neutral'>    // A user calling allocate then unallocate should succeed </span>
 1176 | r   | <span class='reverted'>    function allocate_then_unallocate_should_succeed(uint256 id, uint256 amount) public {</span>
 1177 | r   | <span class='reverted'>        address[] memory owners = new address[](1);</span>
 1178 | r   | <span class='reverted'>        (HyperPool memory pool, uint64 poolId, EchidnaERC20 _asset, EchidnaERC20 _quote) = retrieve_random_pool_and_tokens(</span>
 1179 | r   | <span class='reverted'>            id</span>
 1180 |     | <span class='neutral'>        );</span>
 1181 | r   | <span class='reverted'>        emit LogUint256(&quot;pool id:&quot;, uint256(poolId));</span>
 1182 |     | <span class='neutral'></span>
 1183 | r   | <span class='reverted'>        require(pool.lastPrice != 0);</span>
 1184 | r   | <span class='reverted'>        require(pool.lastTimestamp != 0);</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='neutral'>        // ensures deltaLiquidity is never zero</span>
 1187 | r   | <span class='reverted'>        amount = between(amount, 1, type(uint256).max);</span>
 1188 | r   | <span class='reverted'>        if (amount == type(uint256).max) {</span>
 1189 |     | <span class='unexecuted'>            amount = 1;</span>
 1190 |     | <span class='neutral'>        } else {</span>
 1191 | r   | <span class='reverted'>            amount = uint128(amount);</span>
 1192 |     | <span class='neutral'>        }</span>
 1193 |     | <span class='neutral'></span>
 1194 | r   | <span class='reverted'>        int128 amountInt = convertToInt128(uint128(amount));</span>
 1195 | r   | <span class='reverted'>        (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, amountInt);</span>
 1196 |     | <span class='neutral'></span>
 1197 | r   | <span class='reverted'>        emit LogUint256(&quot;delta asset:&quot;, deltaAsset);</span>
 1198 | r   | <span class='reverted'>        emit LogUint256(&quot;delta quote:&quot;, deltaQuote);</span>
 1199 | r   | <span class='reverted'>        emit LogUint256(&quot;amount&quot;, amount);</span>
 1200 |     | <span class='neutral'></span>
 1201 | r   | <span class='reverted'>        execute_allocate_call(poolId,_asset,_quote,deltaAsset,deltaQuote,amount);</span>
 1202 |     | <span class='unexecuted'>        _hyper.unallocate(poolId, amount);</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 | *r  | <span class='executed'>    function retrieve_random_pool_and_tokens(uint256 id)</span>
 1206 |     | <span class='neutral'>        private</span>
 1207 |     | <span class='neutral'>        view</span>
 1208 |     | <span class='neutral'>        returns (</span>
 1209 | *r  | <span class='executed'>            HyperPool memory pool,</span>
 1210 | *r  | <span class='executed'>            uint64 poolId,</span>
 1211 | *r  | <span class='executed'>            EchidnaERC20 quote,</span>
 1212 | *r  | <span class='executed'>            EchidnaERC20 asset</span>
 1213 |     | <span class='neutral'>        )</span>
 1214 |     | <span class='neutral'>    {</span>
 1215 | *r  | <span class='executed'>        require(poolIds.length &gt; 0);</span>
 1216 | *r  | <span class='executed'>        uint256 random = between(id, 0, poolIds.length-1);</span>
 1217 |     | <span class='neutral'></span>
 1218 | *r  | <span class='executed'>        pool = getPool(address(_hyper), poolIds[random]);</span>
 1219 | *r  | <span class='executed'>        poolId = poolIds[random];</span>
 1220 | *r  | <span class='executed'>        HyperPair memory pair = pool.pair;</span>
 1221 | *r  | <span class='executed'>        quote = EchidnaERC20(pair.tokenQuote);</span>
 1222 | *r  | <span class='executed'>        asset = EchidnaERC20(pair.tokenAsset);</span>
 1223 |     | <span class='neutral'>    }    </span>
 1224 |     | <span class='neutral'>}</span>
 1225 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/echidna/EchidnaStateHandling.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;../test/EchidnaERC20.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;./Helper.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract EchidnaStateHandling is Helper{</span>
  7 |     | <span class='neutral'>    // Hyper Tokens</span>
  8 | *r  | <span class='executed'>    EchidnaERC20[] public hyperTokens;</span>
  9 |     | <span class='neutral'></span>
 10 | *   | <span class='executed'>    function add_created_hyper_token(EchidnaERC20 token) internal {</span>
 11 | *   | <span class='executed'>        hyperTokens.push(token);</span>
 12 |     | <span class='neutral'>    }</span>
 13 | *r  | <span class='executed'>    function get_hyper_tokens(uint256 id1, uint256 id2) internal view returns (EchidnaERC20 asset, EchidnaERC20 quote) {</span>
 14 |     | <span class='neutral'>        // This assumes that hyperTokens.length is always &gt;2</span>
 15 | *r  | <span class='executed'>        id1 = between(id1, 0, hyperTokens.length - 1);</span>
 16 | *r  | <span class='executed'>        id2 = between(id2, 0, hyperTokens.length - 1);</span>
 17 | *r  | <span class='executed'>        require(id1 != id2);</span>
 18 | *r  | <span class='executed'>        return (hyperTokens[id1], hyperTokens[id2]);</span>
 19 |     | <span class='neutral'>    }    </span>
 20 | *   | <span class='executed'>    function get_token_at_index(uint256 index) internal view returns (EchidnaERC20 token){</span>
 21 | *   | <span class='executed'>        return hyperTokens[index];</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>    // Pairs </span>
 24 |     | <span class='neutral'>    uint24[] pairIds;</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>    function save_pair_id(uint24 pairId) internal {</span>
 27 | *   | <span class='executed'>        pairIds.push(pairId);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 | *r  | <span class='executed'>    function retrieve_created_pair(uint256 id) internal view returns (uint24 pairId) {</span>
 31 | *r  | <span class='executed'>        require(pairIds.length &gt; 0);</span>
 32 | *r  | <span class='executed'>        id = between(id, 0, pairIds.length);</span>
 33 | *r  | <span class='executed'>        return pairIds[id];</span>
 34 |     | <span class='neutral'>    }    </span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    // Pools </span>
 37 |     | <span class='neutral'>    uint64[] poolIds;</span>
 38 |     | <span class='neutral'>    function save_pool_id(uint64 id) internal {</span>
 39 | *   | <span class='executed'>        poolIds.push(id);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 | r   | <span class='reverted'>    function is_created_pool(uint64 id) internal view returns (bool) {</span>
 43 | r   | <span class='reverted'>        for (uint8 i = 0; i &lt; poolIds.length; i++) {</span>
 44 | r   | <span class='reverted'>            if (poolIds[i] == id) return true;</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='unexecuted'>        return false;</span>
 47 |     | <span class='neutral'>    }    </span>
 48 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/code/hyper/contracts/echidna/Helper.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='unexecuted'></span>
  3 |     | <span class='neutral'>contract Helper {</span>
  4 |     | <span class='neutral'>    event AssertionFailed(string msg);</span>
  5 |     | <span class='neutral'>    event LogUint256(string msg, uint256 value);</span>
  6 |     | <span class='neutral'>    event LogBytes(string msg, bytes value);</span>
  7 |     | <span class='neutral'>    event LogAddress(string msg, address tkn);</span>
  8 |     | <span class='neutral'>    event LogBool(string msg, bool value);</span>
  9 |     | <span class='neutral'>    event LogInt24(string msg, int24 value);</span>
 10 |     | <span class='neutral'>    event LogInt128(string msg, int128 value);</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    int24 constant MAX_TICK = 887272;</span>
 13 |     | <span class='neutral'>    int24 constant MIN_TICK = -414486;</span>
 14 |     | <span class='neutral'>    uint256 constant BUFFER = 300 seconds;</span>
 15 | *r  | <span class='executed'>    uint256 constant MIN_FEE = 1; // 0.01%</span>
 16 | *r  | <span class='executed'>    uint256 constant MAX_FEE = 1000; // 10%</span>
 17 | *   | <span class='executed'>    uint256 constant MIN_VOLATILITY = 100; // 1%</span>
 18 | *   | <span class='executed'>    uint256 constant MAX_VOLATILITY = 25_000; // 250%</span>
 19 | *   | <span class='executed'>    uint256 constant MIN_DURATION = 1; // days, but without units</span>
 20 | *   | <span class='executed'>    uint256 constant MAX_DURATION = 500; // days, but without units</span>
 21 | *   | <span class='executed'>    uint256 constant JUST_IN_TIME_MAX = 600 seconds;</span>
 22 | *r  | <span class='executed'>    uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;</span>
 23 |     | <span class='neutral'></span>
 24 | *r  | <span class='executed'>    function clam_safe_create_bounds(</span>
 25 |     | <span class='neutral'>        uint16 priorityFee,</span>
 26 |     | <span class='neutral'>        uint16 fee,</span>
 27 |     | <span class='neutral'>        int24 maxTick,</span>
 28 |     | <span class='neutral'>        uint16 volatility,</span>
 29 |     | <span class='neutral'>        uint16 duration,</span>
 30 |     | <span class='neutral'>        uint16 jit,</span>
 31 |     | <span class='neutral'>        uint128 price</span>
 32 | *r  | <span class='executed'>    ) internal returns (uint16, uint16, int24, uint16, uint16, uint16, uint128) {</span>
 33 |     | <span class='neutral'>        // scaling remaining pool creation values</span>
 34 | *r  | <span class='executed'>        fee = uint16(between(fee, MIN_FEE, MAX_FEE));</span>
 35 | *r  | <span class='executed'>        priorityFee = uint16(between(priorityFee, 1, fee));</span>
 36 | *   | <span class='executed'>        emit LogUint256(&quot;priority fee&quot;, uint256(priorityFee));</span>
 37 | *   | <span class='executed'>        volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));</span>
 38 | *   | <span class='executed'>        duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));</span>
 39 | *   | <span class='executed'>        maxTick = (-MIN_TICK) + (maxTick % (MAX_TICK - (-MIN_TICK))); // [-MIN_TICK,MAX_TICK]</span>
 40 | *   | <span class='executed'>        if (maxTick == 0) {</span>
 41 |     | <span class='unexecuted'>            maxTick += 1;</span>
 42 |     | <span class='neutral'>        }</span>
 43 | *   | <span class='executed'>        emit LogInt24(&quot;maxTick&quot;, maxTick);</span>
 44 | *   | <span class='executed'>        jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));</span>
 45 | *   | <span class='executed'>        price = uint128(between(price, 1, type(uint128).max)); // price is between 1-uint256.max</span>
 46 | *   | <span class='executed'>        return (priorityFee, fee, maxTick, volatility, duration, jit, price);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'>    // ******************** Helper ********************</span>
 49 |     | <span class='neutral'></span>
 50 | *r  | <span class='executed'>    function between(uint256 random, uint256 low, uint256 high) public pure returns (uint256) {</span>
 51 | *r  | <span class='executed'>        return low + (random % (high - low));</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 | *r  | <span class='executed'>    function convertToInt128(uint128 a) internal pure returns (int128 b) {</span>
 55 |     | <span class='neutral'>        assembly {</span>
 56 | *r  | <span class='executed'>            if gt(a, 0x7fffffffffffffffffffffffffffffff) { revert(0, 0) }</span>
 57 |     | <span class='neutral'></span>
 58 | *r  | <span class='executed'>            b := a</span>
 59 |     | <span class='neutral'>        }</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20 {</span>
  5 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function transferFrom(</span>
 16 |     | <span class='neutral'>        address sender,</span>
 17 |     | <span class='neutral'>        address recipient,</span>
 18 |     | <span class='neutral'>        uint256 amount</span>
 19 |     | <span class='neutral'>    ) external returns (bool);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/interfaces/IHyper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {HyperCurve, HyperPair} from &quot;../HyperLib.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface IHyperEvents {</span>
   7 |     | <span class='neutral'>    event Deposit(address indexed account, uint amount);</span>
   8 |     | <span class='neutral'>    event DecreaseUserBalance(address indexed account, address indexed token, uint256 amount);</span>
   9 |     | <span class='neutral'>    event DecreaseReserveBalance(address indexed token, uint256 amount);</span>
  10 |     | <span class='neutral'>    event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);</span>
  11 |     | <span class='neutral'>    event IncreaseReserveBalance(address indexed token, uint256 amount);</span>
  12 |     | <span class='neutral'>    event Swap(</span>
  13 |     | <span class='neutral'>        uint64 indexed poolId,</span>
  14 |     | <span class='neutral'>        uint256 price,</span>
  15 |     | <span class='neutral'>        address indexed tokenIn,</span>
  16 |     | <span class='neutral'>        uint256 input,</span>
  17 |     | <span class='neutral'>        address indexed tokenOut,</span>
  18 |     | <span class='neutral'>        uint256 output</span>
  19 |     | <span class='neutral'>    );</span>
  20 |     | <span class='neutral'>    event Stake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);</span>
  21 |     | <span class='neutral'>    event Unstake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);</span>
  22 |     | <span class='neutral'>    event Allocate(</span>
  23 |     | <span class='neutral'>        uint64 indexed poolId,</span>
  24 |     | <span class='neutral'>        address indexed asset,</span>
  25 |     | <span class='neutral'>        address indexed quote,</span>
  26 |     | <span class='neutral'>        uint256 deltaAsset,</span>
  27 |     | <span class='neutral'>        uint256 deltaQuote,</span>
  28 |     | <span class='neutral'>        uint256 deltaLiquidity</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'>    event Unallocate(</span>
  31 |     | <span class='neutral'>        uint64 indexed poolId,</span>
  32 |     | <span class='neutral'>        address indexed asset,</span>
  33 |     | <span class='neutral'>        address indexed quote,</span>
  34 |     | <span class='neutral'>        uint256 deltaAsset,</span>
  35 |     | <span class='neutral'>        uint256 deltaQuote,</span>
  36 |     | <span class='neutral'>        uint256 deltaLiquidity</span>
  37 |     | <span class='neutral'>    );</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    event ChangeParameters(</span>
  40 |     | <span class='neutral'>        uint64 indexed poolId,</span>
  41 |     | <span class='neutral'>        uint16 priorityFee,</span>
  42 |     | <span class='neutral'>        uint16 indexed fee,</span>
  43 |     | <span class='neutral'>        uint16 volatility,</span>
  44 |     | <span class='neutral'>        uint16 duration,</span>
  45 |     | <span class='neutral'>        uint16 jit,</span>
  46 |     | <span class='neutral'>        int24 indexed maxTick</span>
  47 |     | <span class='neutral'>    );</span>
  48 |     | <span class='neutral'>    event Collect(</span>
  49 |     | <span class='neutral'>        uint64 poolId,</span>
  50 |     | <span class='neutral'>        address account,</span>
  51 |     | <span class='neutral'>        uint feeAsset,</span>
  52 |     | <span class='neutral'>        address indexed asset,</span>
  53 |     | <span class='neutral'>        uint feeQuote,</span>
  54 |     | <span class='neutral'>        address indexed quote,</span>
  55 |     | <span class='neutral'>        uint feeReward,</span>
  56 |     | <span class='neutral'>        address indexed reward</span>
  57 |     | <span class='neutral'>    );</span>
  58 |     | <span class='neutral'>    event CreatePair(</span>
  59 |     | <span class='neutral'>        uint24 indexed pairId,</span>
  60 |     | <span class='neutral'>        address indexed asset,</span>
  61 |     | <span class='neutral'>        address indexed quote,</span>
  62 |     | <span class='neutral'>        uint8 decimalsAsset,</span>
  63 |     | <span class='neutral'>        uint8 decimalsQuote</span>
  64 |     | <span class='neutral'>    );</span>
  65 |     | <span class='neutral'>    event CreatePool(</span>
  66 |     | <span class='neutral'>        uint64 indexed poolId,</span>
  67 |     | <span class='neutral'>        bool isMutable,</span>
  68 |     | <span class='neutral'>        address indexed asset,</span>
  69 |     | <span class='neutral'>        address indexed quote,</span>
  70 |     | <span class='neutral'>        uint256 price</span>
  71 |     | <span class='neutral'>    );</span>
  72 |     | <span class='neutral'>}</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>interface IHyperGetters {</span>
  75 |     | <span class='neutral'>    function getNetBalance(address token) external view returns (int);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function getReserve(address token) external view returns (uint);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function getBalance(address owner, address token) external view returns (uint);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function pairs(</span>
  82 |     | <span class='neutral'>        uint24 pairId</span>
  83 |     | <span class='neutral'>    ) external view returns (address tokenAsset, uint8 decimalsAsset, address tokenQuote, uint8 decimalsQuote);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function pools(</span>
  86 |     | <span class='neutral'>        uint64 poolId</span>
  87 |     | <span class='neutral'>    )</span>
  88 |     | <span class='neutral'>        external</span>
  89 |     | <span class='neutral'>        view</span>
  90 |     | <span class='neutral'>        returns (</span>
  91 |     | <span class='neutral'>            int24 lastTick,</span>
  92 |     | <span class='neutral'>            uint32 lastTimestamp,</span>
  93 |     | <span class='neutral'>            address controller,</span>
  94 |     | <span class='neutral'>            uint256 feeGrowthGlobalReward,</span>
  95 |     | <span class='neutral'>            uint256 feeGrowthGlobalAsset,</span>
  96 |     | <span class='neutral'>            uint256 feeGrowthGlobalQuote,</span>
  97 |     | <span class='neutral'>            uint128 lastPrice,</span>
  98 |     | <span class='neutral'>            uint128 liquidity,</span>
  99 |     | <span class='neutral'>            uint128 stakedLiquidity,</span>
 100 |     | <span class='neutral'>            int128 stakedLiquidityDelta,</span>
 101 |     | <span class='neutral'>            HyperCurve memory,</span>
 102 |     | <span class='neutral'>            HyperPair memory</span>
 103 |     | <span class='neutral'>        );</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function positions(</span>
 106 |     | <span class='neutral'>        address owner,</span>
 107 |     | <span class='neutral'>        uint64 poolId</span>
 108 |     | <span class='neutral'>    )</span>
 109 |     | <span class='neutral'>        external</span>
 110 |     | <span class='neutral'>        view</span>
 111 |     | <span class='neutral'>        returns (</span>
 112 |     | <span class='neutral'>            uint128 freeLiquidity,</span>
 113 |     | <span class='neutral'>            uint128 stakedLiquidity,</span>
 114 |     | <span class='neutral'>            uint256 lastTimestamp,</span>
 115 |     | <span class='neutral'>            uint256 stakeTimestamp,</span>
 116 |     | <span class='neutral'>            uint256 unstakeTimestamp,</span>
 117 |     | <span class='neutral'>            uint256 feeGrowthRewardLast,</span>
 118 |     | <span class='neutral'>            uint256 feeGrowthAssetLast,</span>
 119 |     | <span class='neutral'>            uint256 feeGrowthQuoteLast,</span>
 120 |     | <span class='neutral'>            uint128 tokensOwedAsset,</span>
 121 |     | <span class='neutral'>            uint128 tokensOwedQuote,</span>
 122 |     | <span class='neutral'>            uint128 tokensOwedReward</span>
 123 |     | <span class='neutral'>        );</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function getPairNonce() external view returns (uint256);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function getAmounts(uint64 poolId) external view returns (uint256 deltaAsset, uint256 deltaQuote);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) external view returns (uint);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function getVirtualReserves(uint64 poolId) external view returns (uint128 deltaAsset, uint128 deltaQuote);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    function getMaxLiquidity(</span>
 134 |     | <span class='neutral'>        uint64 poolId,</span>
 135 |     | <span class='neutral'>        uint deltaAsset,</span>
 136 |     | <span class='neutral'>        uint deltaQuote</span>
 137 |     | <span class='neutral'>    ) external view returns (uint128 deltaLiquidity);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function getLiquidityDeltas(</span>
 140 |     | <span class='neutral'>        uint64 poolId,</span>
 141 |     | <span class='neutral'>        int128 deltaLiquidity</span>
 142 |     | <span class='neutral'>    ) external view returns (uint128 deltaAsset, uint128 deltaQuote);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    function getLatestPrice(uint64 poolId) external view returns (uint price);</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>interface IHyperActions {</span>
 148 |     | <span class='neutral'>    function allocate(uint64 poolId, uint deltaLiquidity) external returns (uint deltaAsset, uint deltaQuote);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function unallocate(uint64 poolId, uint amount) external returns (uint deltaAsset, uint deltaQuote);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function stake(uint64 poolId, uint128 deltaLiquidity) external;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function unstake(uint64 poolId, uint128 deltaLiquidity) external;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function swap(</span>
 157 |     | <span class='neutral'>        uint64 poolId,</span>
 158 |     | <span class='neutral'>        bool sellAsset,</span>
 159 |     | <span class='neutral'>        uint amount,</span>
 160 |     | <span class='neutral'>        uint limit</span>
 161 |     | <span class='neutral'>    ) external returns (uint output, uint remainder);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function fund(address token, uint256 amount) external;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function draw(address token, uint256 amount, address to) external;</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function deposit() external payable;</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    function changeParameters(</span>
 170 |     | <span class='neutral'>        uint64 poolId,</span>
 171 |     | <span class='neutral'>        uint16 priorityFee,</span>
 172 |     | <span class='neutral'>        uint16 fee,</span>
 173 |     | <span class='neutral'>        uint16 volatility,</span>
 174 |     | <span class='neutral'>        uint16 duration,</span>
 175 |     | <span class='neutral'>        uint16 jit,</span>
 176 |     | <span class='neutral'>        int24 maxTick</span>
 177 |     | <span class='neutral'>    ) external;</span>
 178 |     | <span class='neutral'>}</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>interface IHyper is IHyperActions, IHyperEvents, IHyperGetters {}</span>
 181 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/interfaces/IWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IWETH {</span>
  5 |     | <span class='neutral'>    function deposit() external payable;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function withdraw(uint256 wad) external;</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/libraries/Price.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;solstat/Invariant.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>using Price for Price.RMM global;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev     Library for RMM to compute reserves, prices, and changes in reserves over time.</span>
  10 |     | <span class='neutral'> * @notice  Units Glossary:</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> *          wad - `1 ether` == 1e18</span>
  13 |     | <span class='neutral'> *          seconds - `1 seconds` == 1</span>
  14 |     | <span class='neutral'> *          percentage - 10_000 == 100%</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='unexecuted'> */</span>
  17 |     | <span class='neutral'>library Price {</span>
  18 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  19 |     | <span class='neutral'>    using FixedPointMathLib for int256;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    struct RMM {</span>
  22 |     | <span class='neutral'>        uint256 strike; // wad</span>
  23 |     | <span class='neutral'>        uint256 sigma; // 10_000 = 100%;</span>
  24 |     | <span class='neutral'>        uint256 tau; // seconds</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    error OverflowWad(int256 wad);</span>
  28 |     | <span class='neutral'></span>
  29 | *r  | <span class='executed'>    int256 internal constant TICK_BASE = 1_0001e14;</span>
  30 |     | <span class='unexecuted'>    uint256 internal constant DOUBLE_WAD = 2 ether;</span>
  31 |     | <span class='unexecuted'>    uint256 internal constant PERCENTAGE = 10_000;</span>
  32 | *r  | <span class='executed'>    uint256 internal constant SQRT_WAD = 1e9;</span>
  33 |     | <span class='unexecuted'>    uint256 internal constant WAD = 1 ether;</span>
  34 |     | <span class='neutral'>    uint256 internal constant YEAR = 31556953 seconds;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // ===== Class Methods ===== //</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    function invariantOf(RMM memory args, uint R_y, uint R_x) internal pure returns (int256) {</span>
  39 |     | <span class='unexecuted'>        return Invariant.invariant(R_y, R_x, args.strike, convertPercentageToWad(args.sigma), args.tau);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 | *r  | <span class='executed'>    function getXWithPrice(RMM memory args, uint256 prc) internal pure returns (uint256 R_x) {</span>
  43 | *r  | <span class='executed'>        R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    function getPriceWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 prc) {</span>
  47 |     | <span class='unexecuted'>        prc = getPriceWithX(R_x, args.strike, args.sigma, args.tau);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 | *r  | <span class='executed'>    function getYWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 R_y) {</span>
  51 | *r  | <span class='executed'>        R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function getXWithY(RMM memory args, uint256 R_y) internal pure returns (uint256 R_x) {</span>
  55 |     | <span class='unexecuted'>        R_x = getXWithY(R_y, args.strike, args.sigma, args.tau, 0);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function computePriceWithChangeInTau(RMM memory args, uint256 prc, uint256 eps) internal pure returns (uint256) {</span>
  59 |     | <span class='unexecuted'>        return computePriceWithChangeInTau(args.strike, args.sigma, prc, args.tau, eps);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 | r   | <span class='reverted'>    function computeReserves(RMM memory args, uint prc) internal pure returns (uint R_y, uint R_x) {</span>
  63 | r   | <span class='reverted'>        R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);</span>
  64 | r   | <span class='reverted'>        R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // ===== Raw Functions ===== //</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Computes change in price given a change in time in seconds.</span>
  71 |     | <span class='neutral'>     * @param stk WAD</span>
  72 |     | <span class='neutral'>     * @param vol percentage</span>
  73 |     | <span class='neutral'>     * @param prc WAD</span>
  74 |     | <span class='neutral'>     * @param tau seconds</span>
  75 |     | <span class='neutral'>     * @param epsilon seconds</span>
  76 |     | <span class='neutral'>     * @custom:math P(τ - ε) = ( P(τ)^(√(1 - ε/τ)) / K^2 )e^((1/2)(t^2)(√(τ)√(τ- ε) - (τ - ε)))</span>
  77 |     | <span class='neutral'>     */</span>
  78 | *r  | <span class='executed'>    function computePriceWithChangeInTau(</span>
  79 |     | <span class='neutral'>        uint256 stk,</span>
  80 |     | <span class='neutral'>        uint256 vol,</span>
  81 |     | <span class='neutral'>        uint256 prc,</span>
  82 |     | <span class='neutral'>        uint256 tau,</span>
  83 |     | <span class='neutral'>        uint256 epsilon</span>
  84 | *r  | <span class='executed'>    ) internal pure returns (uint256) {</span>
  85 | *r  | <span class='executed'>        if (epsilon == 0) return prc;</span>
  86 | *r  | <span class='executed'>        if (epsilon &gt; tau) return stk;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        RMM memory params = RMM(stk, vol, tau);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        uint256 tauYears;</span>
  91 |     | <span class='neutral'>        assembly {</span>
  92 |     | <span class='unexecuted'>            tauYears := sdiv(mul(tau, WAD), YEAR) // tau * WAD / year = time in years scaled to WAD</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        uint256 epsilonYears;</span>
  96 |     | <span class='neutral'>        assembly {</span>
  97 |     | <span class='unexecuted'>            epsilonYears := sdiv(mul(epsilon, WAD), YEAR) // epsilon * WAD / year = epsilon in years scaled to WAD</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        uint256 term_0 = WAD - (epsilonYears.divWadUp(tauYears)); // WAD - ((epsilon * WAD) / tau rounded down), units are WAD - WAD, time units cancel out</span>
 101 |     | <span class='unexecuted'>        uint256 term_1 = term_0.sqrt(); // this sqrts WAD, so we end up with SQRT_WAD units</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        uint256 term_2 = prc.divWadUp(params.strike); // p(t) / K, both units are already WAD</span>
 104 |     | <span class='unexecuted'>        uint256 term_3 = uint256(int256(term_2).powWad(int256(term_1 * SQRT_WAD)));</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        uint256 term_7;</span>
 107 |     | <span class='unexecuted'>        {</span>
 108 |     | <span class='unexecuted'>            uint256 currentTau = tauYears - epsilonYears; // WAD - WAD = WAD</span>
 109 |     | <span class='unexecuted'>            uint256 tausSqrt = tauYears.sqrt() * (currentTau).sqrt(); // sqrt(1e18) = 1e9, so 1e9 * 1e9 = 1e18</span>
 110 |     | <span class='unexecuted'>            uint256 term_4 = tausSqrt - currentTau; // WAD - WAD = WAD</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>            uint256 sigmaWad = convertPercentageToWad(uint256(params.sigma));</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>            uint256 term_5 = (sigmaWad * sigmaWad) / DOUBLE_WAD; // 1e4 * 1e4 * 1e17 / 1e4 = 1e17, which is half WAD</span>
 115 | *r  | <span class='executed'>            uint256 term_6 = uint256((int256(term_5.mulWadDown(term_4))).expWad()); // exp(WAD * WAD / WAD)</span>
 116 |     | <span class='unexecuted'>            term_7 = uint256(params.strike).mulWadDown(term_6); // WAD * WAD / WAD</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        uint256 price = term_3.mulWadDown(term_7); // WAD * WAD / WAD = WAD</span>
 120 |     | <span class='neutral'>        return price;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @dev R_y = tradingFunction(R_x, ...)</span>
 125 |     | <span class='neutral'>     * @param R_x WAD</span>
 126 |     | <span class='neutral'>     * @param stk WAD</span>
 127 |     | <span class='neutral'>     * @param vol percentage</span>
 128 |     | <span class='neutral'>     * @param tau seconds</span>
 129 |     | <span class='neutral'>     * @param inv WAD</span>
 130 |     | <span class='neutral'>     * @return R_y WAD</span>
 131 |     | <span class='neutral'>     */</span>
 132 | *r  | <span class='executed'>    function getYWithX(</span>
 133 |     | <span class='neutral'>        uint256 R_x,</span>
 134 |     | <span class='neutral'>        uint256 stk,</span>
 135 |     | <span class='neutral'>        uint256 vol,</span>
 136 |     | <span class='neutral'>        uint256 tau,</span>
 137 |     | <span class='neutral'>        int256 inv</span>
 138 | *r  | <span class='executed'>    ) internal pure returns (uint256 R_y) {</span>
 139 | *r  | <span class='executed'>        R_y = Invariant.getY(R_x, stk, convertPercentageToWad(vol), tau, inv);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev R_x = tradingFunction(R_y, ...)</span>
 144 |     | <span class='neutral'>     * @param R_y WAD</span>
 145 |     | <span class='neutral'>     * @param stk WAD</span>
 146 |     | <span class='neutral'>     * @param vol percentage</span>
 147 |     | <span class='neutral'>     * @param tau seconds</span>
 148 |     | <span class='neutral'>     * @param inv WAD</span>
 149 |     | <span class='neutral'>     * @return R_x WAD</span>
 150 |     | <span class='neutral'>     */</span>
 151 |     | <span class='unexecuted'>    function getXWithY(</span>
 152 |     | <span class='neutral'>        uint256 R_y,</span>
 153 |     | <span class='neutral'>        uint256 stk,</span>
 154 |     | <span class='neutral'>        uint256 vol,</span>
 155 |     | <span class='neutral'>        uint256 tau,</span>
 156 |     | <span class='neutral'>        int256 inv</span>
 157 |     | <span class='unexecuted'>    ) internal pure returns (uint256 R_x) {</span>
 158 |     | <span class='unexecuted'>        R_x = Invariant.getX(R_y, stk, convertPercentageToWad(vol), tau, inv);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Used in `getAmounts` to compute the virtual amount of assets at the pool&#39;s price.</span>
 163 |     | <span class='neutral'>     * @param prc WAD</span>
 164 |     | <span class='neutral'>     * @param stk WAD</span>
 165 |     | <span class='neutral'>     * @param vol percentage</span>
 166 |     | <span class='neutral'>     * @param tau seconds</span>
 167 |     | <span class='neutral'>     * @return R_x WAD</span>
 168 |     | <span class='neutral'>     * @custom:math R_x = 1 - Φ(( ln(S/K) + (σ²/2)τ ) / σ√τ)</span>
 169 |     | <span class='neutral'>     */</span>
 170 | *r  | <span class='executed'>    function getXWithPrice(uint256 prc, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 R_x) {</span>
 171 | *r  | <span class='executed'>        if (prc != 0) {</span>
 172 | *r  | <span class='executed'>            int256 ln = FixedPointMathLib.lnWad(int256(FixedPointMathLib.divWadDown(prc, stk)));</span>
 173 | *r  | <span class='executed'>            uint256 tauYears = convertSecondsToWadYears(tau);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>            uint256 sigmaWad = convertPercentageToWad(vol);</span>
 176 | *r  | <span class='executed'>            uint256 doubleSigma = (sigmaWad * sigmaWad) / uint256(Gaussian.TWO);</span>
 177 | *r  | <span class='executed'>            uint256 halfSigmaTau = doubleSigma * tauYears;</span>
 178 | *r  | <span class='executed'>            uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(sigmaWad);</span>
 179 |     | <span class='neutral'></span>
 180 | *r  | <span class='executed'>            int256 lnOverVol = (ln * Gaussian.ONE + int256(halfSigmaTau)) / int256(sqrtTauSigma);</span>
 181 | *r  | <span class='executed'>            int256 cdf = Gaussian.cdf(lnOverVol);</span>
 182 | *r  | <span class='executed'>            if (cdf &gt; Gaussian.ONE) revert OverflowWad(cdf);</span>
 183 | *r  | <span class='executed'>            R_x = uint256(Gaussian.ONE - cdf);</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev price(R_x) = Ke^(Φ^-1(1 - R_x)σ√τ - 1/2σ^2τ)</span>
 189 |     | <span class='neutral'>     * @param R_x WAD</span>
 190 |     | <span class='neutral'>     * @param stk WAD</span>
 191 |     | <span class='neutral'>     * @param vol percentage</span>
 192 |     | <span class='neutral'>     * @param tau seconds</span>
 193 |     | <span class='neutral'>     * @return prc WAD</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='unexecuted'>    function getPriceWithX(uint256 R_x, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 prc) {</span>
 196 |     | <span class='unexecuted'>        uint256 tauYears = convertSecondsToWadYears(tau);</span>
 197 |     | <span class='unexecuted'>        uint256 volWad = convertPercentageToWad(vol);</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        if (uint256(Gaussian.ONE) &lt; R_x) revert OverflowWad(int256(R_x));</span>
 200 |     | <span class='unexecuted'>        int256 input = Gaussian.ONE - int256(R_x);</span>
 201 |     | <span class='unexecuted'>        int256 ppf = Gaussian.ppf(input);</span>
 202 |     | <span class='unexecuted'>        uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(volWad);</span>
 203 |     | <span class='unexecuted'>        int256 first = (ppf * int256(sqrtTauSigma)) / Gaussian.ONE; // Φ^-1(1 - R_x)σ√τ</span>
 204 |     | <span class='unexecuted'>        uint256 doubleSigma = (volWad * volWad) / uint256(Gaussian.TWO);</span>
 205 |     | <span class='unexecuted'>        int256 halfSigmaTau = int256(doubleSigma * tauYears) / Gaussian.ONE; // 1/2σ^2τ</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>        int256 exponent = first - halfSigmaTau;</span>
 208 |     | <span class='unexecuted'>        int256 exp = exponent.expWad();</span>
 209 |     | <span class='unexecuted'>        prc = uint256(exp).mulWadDown(stk);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    // ===== Tick Math ===== //</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @dev Computes a price value from a tick key.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * @custom:math price = e^(ln(1.0001) * tick)</span>
 218 |     | <span class='neutral'>     *</span>
 219 |     | <span class='neutral'>     * @param tick Key of a slot in a price/liquidity grid.</span>
 220 |     | <span class='neutral'>     * @return price WAD Value on a key (tick) value pair of a price grid.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *r  | <span class='executed'>    function computePriceWithTick(int24 tick) internal pure returns (uint256 price) {</span>
 223 | *r  | <span class='executed'>        int256 tickWad = int256(tick) * int256(FixedPointMathLib.WAD);</span>
 224 | *r  | <span class='executed'>        price = uint256(FixedPointMathLib.powWad(TICK_BASE, tickWad));</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    /**</span>
 228 |     | <span class='neutral'>     * @dev Computes a tick value from the price.</span>
 229 |     | <span class='neutral'>     *</span>
 230 |     | <span class='neutral'>     * @custom:math tick = ln(price) / ln(1.0001)</span>
 231 |     | <span class='neutral'>     *</span>
 232 |     | <span class='neutral'>     * @param price WAD Value on a key (tick) value pair of a price grid.</span>
 233 |     | <span class='neutral'>     * @return tick Key of a slot in a price/liquidity grid.</span>
 234 |     | <span class='neutral'>     */</span>
 235 | *r  | <span class='executed'>    function computeTickWithPrice(uint256 price) internal pure returns (int24 tick) {</span>
 236 | *r  | <span class='executed'>        uint256 numerator = uint256(int256(price).lnWad());</span>
 237 | *r  | <span class='executed'>        uint256 denominator = uint256(TICK_BASE.lnWad());</span>
 238 | *r  | <span class='executed'>        tick = int24(int256((numerator)) / int256(denominator) + 1);</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    // ===== Utils ===== //</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function convertSecondsToWadYears(uint256 sec) internal pure returns (uint256 yrsWad) {</span>
 244 |     | <span class='neutral'>        assembly {</span>
 245 | *r  | <span class='executed'>            yrsWad := div(mul(sec, WAD), YEAR)</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>    function convertPercentageToWad(uint256 pct) internal pure returns (uint256 pctWad) {</span>
 250 |     | <span class='neutral'>        assembly {</span>
 251 | *r  | <span class='executed'>            pctWad := div(mul(pct, WAD), PERCENTAGE)</span>
 252 |     | <span class='neutral'>        }</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'>}</span>
 255 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/test/EchidnaERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../interfaces/IERC20.sol&quot;;</span>
   5 | *r  | <span class='executed'></span>
   6 |     | <span class='neutral'>contract EchidnaERC20 is IERC20 {</span>
   7 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  12 |     | <span class='neutral'></span>
  13 | *r  | <span class='executed'>    string public name;</span>
  14 | *   | <span class='executed'>    string public symbol;</span>
  15 | *r  | <span class='executed'>    uint8 public override decimals;</span>
  16 | *   | <span class='executed'>    address public hyper;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    constructor(</span>
  19 |     | <span class='neutral'>        string memory name_,</span>
  20 |     | <span class='neutral'>        string memory symbol_,</span>
  21 |     | <span class='neutral'>        uint8 decimals_,</span>
  22 |     | <span class='neutral'>        address _hyper</span>
  23 |     | <span class='neutral'>    ) {</span>
  24 |     | <span class='unexecuted'>        name = name_;</span>
  25 |     | <span class='unexecuted'>        symbol = symbol_;</span>
  26 |     | <span class='unexecuted'>        decimals = decimals_;</span>
  27 |     | <span class='unexecuted'>        hyper = _hyper;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @notice Used for testing pairs with decimals that are not 18</span>
  31 | *   | <span class='executed'>    function setDecimals(uint8 decimals_) public {</span>
  32 | *   | <span class='executed'>        decimals = decimals_;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 | *r  | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  36 | *   | <span class='executed'>        return _totalSupply;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *r  | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
  40 | *r  | <span class='executed'>        return _balances[account];</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 | *r  | <span class='executed'>    function mint(address to, uint256 wad) public {</span>
  44 | *r  | <span class='executed'>        if (to == address(hyper)) return;</span>
  45 | *r  | <span class='executed'>        _mint(to, wad);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 | *r  | <span class='executed'>    function burn(address to, uint256 wad) public {</span>
  49 | *r  | <span class='executed'>        _burn(to, wad);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 | *r  | <span class='executed'>    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {</span>
  53 | *r  | <span class='executed'>        _transfer(msg.sender, recipient, amount);</span>
  54 |     | <span class='neutral'>        return true;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
  58 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 | *r  | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
  62 | *r  | <span class='executed'>        _approve(msg.sender, spender, amount);</span>
  63 | *r  | <span class='executed'>        return true;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 | *r  | <span class='executed'>    function transferFrom(</span>
  67 |     | <span class='neutral'>        address sender,</span>
  68 |     | <span class='neutral'>        address recipient,</span>
  69 |     | <span class='neutral'>        uint256 amount</span>
  70 | *r  | <span class='executed'>    ) public virtual override returns (bool) {</span>
  71 | *r  | <span class='executed'>        _transfer(sender, recipient, amount);</span>
  72 |     | <span class='neutral'></span>
  73 | *r  | <span class='executed'>        uint256 currentAllowance = _allowances[sender][msg.sender];</span>
  74 | *r  | <span class='executed'>        require(currentAllowance &gt;= amount, &quot;ERC20: transfer amount exceeds allowance&quot;);</span>
  75 |     | <span class='neutral'>        unchecked {</span>
  76 | *r  | <span class='executed'>            _approve(sender, msg.sender, currentAllowance - amount);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'></span>
  79 | *r  | <span class='executed'>        return true;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 | *r  | <span class='executed'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
  83 | *r  | <span class='executed'>        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);</span>
  84 |     | <span class='neutral'>        return true;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *r  | <span class='executed'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
  88 | *r  | <span class='executed'>        uint256 currentAllowance = _allowances[msg.sender][spender];</span>
  89 | *r  | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
  90 |     | <span class='neutral'>        unchecked {</span>
  91 | *r  | <span class='executed'>            _approve(msg.sender, spender, currentAllowance - subtractedValue);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        return true;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 | *r  | <span class='executed'>    function _transfer(</span>
  98 |     | <span class='neutral'>        address sender,</span>
  99 |     | <span class='neutral'>        address recipient,</span>
 100 |     | <span class='neutral'>        uint256 amount</span>
 101 | *r  | <span class='executed'>    ) internal virtual {</span>
 102 | *r  | <span class='executed'>        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 103 | *r  | <span class='executed'>        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        _beforeTokenTransfer(sender, recipient, amount);</span>
 106 |     | <span class='neutral'></span>
 107 | *r  | <span class='executed'>        uint256 senderBalance = _balances[sender];</span>
 108 | *r  | <span class='executed'>        require(senderBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 109 |     | <span class='neutral'>        unchecked {</span>
 110 | *r  | <span class='executed'>            _balances[sender] = senderBalance - amount;</span>
 111 |     | <span class='neutral'>        }</span>
 112 | *r  | <span class='executed'>        _balances[recipient] += amount;</span>
 113 |     | <span class='neutral'></span>
 114 | *r  | <span class='executed'>        emit Transfer(sender, recipient, amount);</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 | *r  | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 118 | *r  | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 121 |     | <span class='neutral'></span>
 122 | *r  | <span class='executed'>        _totalSupply += amount;</span>
 123 | *r  | <span class='executed'>        _balances[account] += amount;</span>
 124 | *r  | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *r  | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 128 | *r  | <span class='executed'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 131 |     | <span class='neutral'></span>
 132 | *r  | <span class='executed'>        uint256 accountBalance = _balances[account];</span>
 133 | *r  | <span class='executed'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 134 |     | <span class='neutral'>        unchecked {</span>
 135 | *   | <span class='executed'>            _balances[account] = accountBalance - amount;</span>
 136 |     | <span class='neutral'>        }</span>
 137 | *   | <span class='executed'>        _totalSupply -= amount;</span>
 138 |     | <span class='neutral'></span>
 139 | *   | <span class='executed'>        emit Transfer(account, address(0), amount);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 | *r  | <span class='executed'>    function _approve(</span>
 143 |     | <span class='neutral'>        address owner,</span>
 144 |     | <span class='neutral'>        address spender,</span>
 145 |     | <span class='neutral'>        uint256 amount</span>
 146 |     | <span class='neutral'>    ) internal virtual {</span>
 147 | *r  | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 148 | *r  | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 149 |     | <span class='neutral'></span>
 150 | *r  | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 151 | *r  | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function _beforeTokenTransfer(</span>
 155 |     | <span class='neutral'>        address from,</span>
 156 |     | <span class='neutral'>        address to,</span>
 157 |     | <span class='neutral'>        uint256 amount</span>
 158 |     | <span class='neutral'>    ) internal virtual {}</span>
 159 |     | <span class='neutral'>}</span>
 160 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/test/HyperForwarderHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20 {</span>
  5 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external;</span>
  6 |     | <span class='neutral'>}</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract HyperForwarderHelper {</span>
  9 |     | <span class='unexecuted'>    Caller public caller;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event Success();</span>
 12 |     | <span class='neutral'>    event Fail(bytes reason);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor() {</span>
 15 |     | <span class='unexecuted'>        caller = new Caller();</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function approve(address token, address target) external {</span>
 19 |     | <span class='unexecuted'>        caller.approve(token, target, type(uint256).max);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // Assumes Hyper calls this, for testing only.</span>
 23 |     | <span class='unexecuted'>    function pass(address target, bytes calldata data) external payable returns (bool) {</span>
 24 |     | <span class='unexecuted'>        try caller.forward{value: msg.value}(target, data) {</span>
 25 |     | <span class='unexecuted'>            emit Success();</span>
 26 |     | <span class='unexecuted'>            return true;</span>
 27 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 28 |     | <span class='unexecuted'>            emit Fail(reason);</span>
 29 |     | <span class='neutral'>            assembly {</span>
 30 |     | <span class='unexecuted'>                revert(add(32, reason), mload(reason))</span>
 31 |     | <span class='neutral'>            }</span>
 32 |     | <span class='neutral'>        }</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function getPoolId(uint24 pairId, bool isMutable, uint32 poolNonce) public pure returns (uint64) {</span>
 36 |     | <span class='unexecuted'>        return uint64(bytes8(abi.encodePacked(pairId, isMutable ? 1 : 0, poolNonce)));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>/// @dev msg.sender in Hyper calls.</span>
 41 |     | <span class='neutral'>contract Caller {</span>
 42 |     | <span class='unexecuted'>    function approve(address token, address to, uint256 amount) external {</span>
 43 |     | <span class='unexecuted'>        IERC20(token).approve(to, amount);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function forward(address target, bytes calldata data) external payable returns (bool) {</span>
 47 |     | <span class='unexecuted'>        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);</span>
 48 |     | <span class='unexecuted'>        if (!success) {</span>
 49 |     | <span class='neutral'>            assembly {</span>
 50 |     | <span class='unexecuted'>                revert(add(32, returnData), mload(returnData))</span>
 51 |     | <span class='neutral'>            }</span>
 52 |     | <span class='neutral'>        }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>        return success;</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/test/TestERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='unexecuted'></span>
   6 |     | <span class='neutral'>contract TestERC20 is IERC20 {</span>
   7 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    string public name;</span>
  14 |     | <span class='unexecuted'>    string public symbol;</span>
  15 |     | <span class='unexecuted'>    uint8 public override decimals;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    constructor(</span>
  18 |     | <span class='neutral'>        string memory name_,</span>
  19 |     | <span class='neutral'>        string memory symbol_,</span>
  20 |     | <span class='neutral'>        uint8 decimals_</span>
  21 |     | <span class='neutral'>    ) {</span>
  22 |     | <span class='unexecuted'>        name = name_;</span>
  23 |     | <span class='unexecuted'>        symbol = symbol_;</span>
  24 |     | <span class='unexecuted'>        decimals = decimals_;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Used for testing pairs with decimals that are not 18</span>
  28 |     | <span class='unexecuted'>    function setDecimals(uint8 decimals_) public {</span>
  29 |     | <span class='unexecuted'>        decimals = decimals_;</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
  33 |     | <span class='unexecuted'>        return _totalSupply;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
  37 |     | <span class='unexecuted'>        return _balances[account];</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function mint(address to, uint256 wad) public {</span>
  41 |     | <span class='unexecuted'>        _mint(to, wad);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function burn(address to, uint256 wad) public {</span>
  45 |     | <span class='unexecuted'>        _burn(to, wad);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {</span>
  49 |     | <span class='unexecuted'>        _transfer(msg.sender, recipient, amount);</span>
  50 |     | <span class='neutral'>        return true;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
  54 |     | <span class='unexecuted'>        return _allowances[owner][spender];</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
  58 |     | <span class='unexecuted'>        _approve(msg.sender, spender, amount);</span>
  59 |     | <span class='unexecuted'>        return true;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function transferFrom(</span>
  63 |     | <span class='neutral'>        address sender,</span>
  64 |     | <span class='neutral'>        address recipient,</span>
  65 |     | <span class='neutral'>        uint256 amount</span>
  66 |     | <span class='unexecuted'>    ) public virtual override returns (bool) {</span>
  67 |     | <span class='unexecuted'>        _transfer(sender, recipient, amount);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        uint256 currentAllowance = _allowances[sender][msg.sender];</span>
  70 |     | <span class='unexecuted'>        require(currentAllowance &gt;= amount, &quot;ERC20: transfer amount exceeds allowance&quot;);</span>
  71 |     | <span class='neutral'>        unchecked {</span>
  72 |     | <span class='unexecuted'>            _approve(sender, msg.sender, currentAllowance - amount);</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        return true;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
  79 |     | <span class='unexecuted'>        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);</span>
  80 |     | <span class='neutral'>        return true;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
  84 |     | <span class='unexecuted'>        uint256 currentAllowance = _allowances[msg.sender][spender];</span>
  85 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
  86 |     | <span class='neutral'>        unchecked {</span>
  87 |     | <span class='unexecuted'>            _approve(msg.sender, spender, currentAllowance - subtractedValue);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        return true;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function _transfer(</span>
  94 |     | <span class='neutral'>        address sender,</span>
  95 |     | <span class='neutral'>        address recipient,</span>
  96 |     | <span class='neutral'>        uint256 amount</span>
  97 |     | <span class='unexecuted'>    ) internal virtual {</span>
  98 |     | <span class='unexecuted'>        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
  99 |     | <span class='unexecuted'>        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        _beforeTokenTransfer(sender, recipient, amount);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        uint256 senderBalance = _balances[sender];</span>
 104 |     | <span class='unexecuted'>        require(senderBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 105 |     | <span class='neutral'>        unchecked {</span>
 106 |     | <span class='unexecuted'>            _balances[sender] = senderBalance - amount;</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='unexecuted'>        _balances[recipient] += amount;</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        emit Transfer(sender, recipient, amount);</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>    function _mint(address account, uint256 amount) internal virtual {</span>
 114 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        _totalSupply += amount;</span>
 119 |     | <span class='unexecuted'>        _balances[account] += amount;</span>
 120 |     | <span class='unexecuted'>        emit Transfer(address(0), account, amount);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 124 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 129 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 130 |     | <span class='neutral'>        unchecked {</span>
 131 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='unexecuted'>        _totalSupply -= amount;</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function _approve(</span>
 139 |     | <span class='neutral'>        address owner,</span>
 140 |     | <span class='neutral'>        address spender,</span>
 141 |     | <span class='neutral'>        uint256 amount</span>
 142 |     | <span class='neutral'>    ) internal virtual {</span>
 143 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 144 |     | <span class='unexecuted'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        _allowances[owner][spender] = amount;</span>
 147 |     | <span class='unexecuted'>        emit Approval(owner, spender, amount);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function _beforeTokenTransfer(</span>
 151 |     | <span class='neutral'>        address from,</span>
 152 |     | <span class='neutral'>        address to,</span>
 153 |     | <span class='neutral'>        uint256 amount</span>
 154 |     | <span class='neutral'>    ) internal virtual {}</span>
 155 |     | <span class='neutral'>}</span>
 156 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/contracts/test/TestHyperTime.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../Hyper.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestHyperTime is Hyper {</span>
  7 |     | <span class='unexecuted'>    uint256 public timestamp;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function set(uint256 x) public {</span>
 10 |     | <span class='unexecuted'>        timestamp = x;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    constructor(address weth) Hyper(weth) {}</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function _blockTimestamp() internal view override returns (uint128) {</span>
 16 |     | <span class='unexecuted'>        return uint128(timestamp);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.</span>
  9 |     | <span class='unexecuted'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
 10 |     | <span class='neutral'>    // console.sol and console2.sol work by executing a staticcall to this address.</span>
 11 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 12 |     | <span class='neutral'>    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.</span>
 13 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))));</span>
 14 |     | <span class='neutral'>    // Address of the test contract, deployed by the DEFAULT_SENDER.</span>
 15 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 18 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 21 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 27 |     | <span class='neutral'>    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 28 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 31 |     | <span class='neutral'>}</span>
 32 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
   5 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions is DSTest {</span>
   8 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
   9 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  10 |     | <span class='neutral'>    event log_array(address[] val);</span>
  11 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  12 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  13 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function fail(string memory err) internal virtual {</span>
  16 |     | <span class='neutral'>        emit log_named_string(&quot;Error&quot;, err);</span>
  17 |     | <span class='neutral'>        fail();</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function assertFalse(bool data) internal virtual {</span>
  21 |     | <span class='neutral'>        assertTrue(!data);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal virtual {</span>
  25 |     | <span class='neutral'>        assertTrue(!data, err);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function assertEq(bool a, bool b) internal virtual {</span>
  29 |     | <span class='neutral'>        if (a != b) {</span>
  30 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bool]&quot;);</span>
  31 |     | <span class='neutral'>            emit log_named_string(&quot;  Expected&quot;, b ? &quot;true&quot; : &quot;false&quot;);</span>
  32 |     | <span class='neutral'>            emit log_named_string(&quot;    Actual&quot;, a ? &quot;true&quot; : &quot;false&quot;);</span>
  33 |     | <span class='neutral'>            fail();</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function assertEq(bool a, bool b, string memory err) internal virtual {</span>
  38 |     | <span class='neutral'>        if (a != b) {</span>
  39 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  40 |     | <span class='neutral'>            assertEq(a, b);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function assertEq(bytes memory a, bytes memory b) internal virtual {</span>
  45 |     | <span class='unexecuted'>        assertEq0(a, b);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {</span>
  49 |     | <span class='neutral'>        assertEq0(a, b, err);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {</span>
  53 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  54 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [uint[]]&quot;);</span>
  55 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  56 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  57 |     | <span class='neutral'>            fail();</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b) internal virtual {</span>
  62 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  63 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int[]]&quot;);</span>
  64 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  65 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  66 |     | <span class='neutral'>            fail();</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b) internal virtual {</span>
  71 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  72 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address[]]&quot;);</span>
  73 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  74 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  75 |     | <span class='neutral'>            fail();</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {</span>
  80 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  81 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  82 |     | <span class='neutral'>            assertEq(a, b);</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {</span>
  87 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  88 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  89 |     | <span class='neutral'>            assertEq(a, b);</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {</span>
  94 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  95 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  96 |     | <span class='neutral'>            assertEq(a, b);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Legacy helper</span>
 101 |     | <span class='neutral'>    function assertEqUint(uint256 a, uint256 b) internal virtual {</span>
 102 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {</span>
 106 |     | <span class='unexecuted'>        uint256 delta = stdMath.delta(a, b);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        if (delta &gt; maxDelta) {</span>
 109 |     | <span class='unexecuted'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 110 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='unexecuted'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='unexecuted'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 113 |     | <span class='unexecuted'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 114 |     | <span class='unexecuted'>            fail();</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 119 |     | <span class='unexecuted'>        uint256 delta = stdMath.delta(a, b);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        if (delta &gt; maxDelta) {</span>
 122 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 123 |     | <span class='unexecuted'>            assertApproxEqAbs(a, b, maxDelta);</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {</span>
 128 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 131 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 132 |     | <span class='neutral'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 133 |     | <span class='neutral'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 134 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 135 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 136 |     | <span class='neutral'>            fail();</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 141 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 144 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 145 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function assertApproxEqRel(</span>
 150 |     | <span class='neutral'>        uint256 a,</span>
 151 |     | <span class='neutral'>        uint256 b,</span>
 152 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 153 |     | <span class='neutral'>    ) internal virtual {</span>
 154 |     | <span class='unexecuted'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        if (percentDelta &gt; maxPercentDelta) {</span>
 159 |     | <span class='unexecuted'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 160 |     | <span class='unexecuted'>            emit log_named_uint(&quot;    Expected&quot;, b);</span>
 161 |     | <span class='unexecuted'>            emit log_named_uint(&quot;      Actual&quot;, a);</span>
 162 |     | <span class='unexecuted'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 163 |     | <span class='unexecuted'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 164 |     | <span class='unexecuted'>            fail();</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function assertApproxEqRel(</span>
 169 |     | <span class='neutral'>        uint256 a,</span>
 170 |     | <span class='neutral'>        uint256 b,</span>
 171 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 172 |     | <span class='neutral'>        string memory err</span>
 173 |     | <span class='neutral'>    ) internal virtual {</span>
 174 |     | <span class='unexecuted'>        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        if (percentDelta &gt; maxPercentDelta) {</span>
 179 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 180 |     | <span class='unexecuted'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {</span>
 185 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 190 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 191 |     | <span class='neutral'>            emit log_named_int(&quot;    Expected&quot;, b);</span>
 192 |     | <span class='neutral'>            emit log_named_int(&quot;      Actual&quot;, a);</span>
 193 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 194 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 195 |     | <span class='neutral'>            fail();</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {</span>
 200 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 205 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 206 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
  10 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
  11 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  12 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  13 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  14 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initialize` function.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  17 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, Chain memory chain)`</span>
  18 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  21 |     | <span class='neutral'> * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  22 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  27 |     | <span class='neutral'> * we want to retrieve `mainnet`&#39;s RPC URL:</span>
  28 |     | <span class='neutral'> *   - If you haven&#39;t set any mainnet chain info with `setChain` and you haven&#39;t specified that</span>
  29 |     | <span class='neutral'> *     chain in `foundry.toml`, the default data and RPC URL will be returned.</span>
  30 |     | <span class='neutral'> *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if</span>
  31 |     | <span class='neutral'> *     a URL is given or if an environment variable is given and that environment variable exists).</span>
  32 |     | <span class='neutral'> *     Otherwise, the default data is returned.</span>
  33 |     | <span class='neutral'> *   - If you specified data with `setChain` it will return that.</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; defaults.</span>
  36 |     | <span class='neutral'> */</span>
  37 |     | <span class='neutral'>abstract contract StdChains {</span>
  38 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    bool private initialized;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct Chain {</span>
  43 |     | <span class='neutral'>        // The chain name.</span>
  44 |     | <span class='neutral'>        string name;</span>
  45 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  46 |     | <span class='neutral'>        uint256 chainId;</span>
  47 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  48 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  49 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  50 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  51 |     | <span class='neutral'>        string rpcUrl;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  55 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  56 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  57 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  58 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  59 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  62 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  63 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        initialize();</span>
  66 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  67 |     | <span class='neutral'>        require(</span>
  68 |     | <span class='neutral'>            chain.chainId != 0,</span>
  69 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  70 |     | <span class='neutral'>        );</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  76 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  77 |     | <span class='neutral'>        initialize();</span>
  78 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        require(</span>
  83 |     | <span class='neutral'>            chain.chainId != 0,</span>
  84 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
  91 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
  92 |     | <span class='neutral'>        require(</span>
  93 |     | <span class='neutral'>            bytes(chainAlias).length != 0, &quot;StdChains setChain(string,Chain): Chain alias cannot be the empty string.&quot;</span>
  94 |     | <span class='neutral'>        );</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,Chain): Chain ID cannot be 0.&quot;);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        initialize();</span>
  99 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        require(</span>
 102 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 103 |     | <span class='neutral'>            string(</span>
 104 |     | <span class='neutral'>                abi.encodePacked(</span>
 105 |     | <span class='neutral'>                    &quot;StdChains setChain(string,Chain): Chain ID &quot;,</span>
 106 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 107 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 108 |     | <span class='neutral'>                    foundAlias,</span>
 109 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 110 |     | <span class='neutral'>                )</span>
 111 |     | <span class='neutral'>            )</span>
 112 |     | <span class='neutral'>        );</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 115 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        chains[chainAlias] = chain;</span>
 118 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 122 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; default</span>
 123 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)</span>
 124 |     | <span class='neutral'>        private</span>
 125 |     | <span class='neutral'>        view</span>
 126 |     | <span class='neutral'>        returns (Chain memory)</span>
 127 |     | <span class='neutral'>    {</span>
 128 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 129 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 130 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 131 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 132 |     | <span class='neutral'>                chain.rpcUrl = defaultRpcUrls[chainAlias];</span>
 133 |     | <span class='neutral'>                // distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 134 |     | <span class='neutral'>                bytes memory notFoundError =</span>
 135 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 136 |     | <span class='neutral'>                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {</span>
 137 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 138 |     | <span class='neutral'>                    assembly {</span>
 139 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 140 |     | <span class='neutral'>                    }</span>
 141 |     | <span class='neutral'>                }</span>
 142 |     | <span class='neutral'>            }</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        return chain;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function initialize() private {</span>
 148 |     | <span class='neutral'>        if (initialized) return;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        initialized = true;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`</span>
 153 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, Chain(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 154 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 155 |     | <span class='neutral'>            &quot;mainnet&quot;, Chain(&quot;Mainnet&quot;, 1, &quot;https://mainnet.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;)</span>
 156 |     | <span class='neutral'>        );</span>
 157 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 158 |     | <span class='neutral'>            &quot;goerli&quot;, Chain(&quot;Goerli&quot;, 5, &quot;https://goerli.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;)</span>
 159 |     | <span class='neutral'>        );</span>
 160 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 161 |     | <span class='neutral'>            &quot;sepolia&quot;, Chain(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;)</span>
 162 |     | <span class='neutral'>        );</span>
 163 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, Chain(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 164 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism_goerli&quot;, Chain(&quot;Optimism Goerli&quot;, 420, &quot;https://goerli.optimism.io&quot;));</span>
 165 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, Chain(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 166 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 167 |     | <span class='neutral'>            &quot;arbitrum_one_goerli&quot;, Chain(&quot;Arbitrum One Goerli&quot;, 421613, &quot;https://goerli-rollup.arbitrum.io/rpc&quot;)</span>
 168 |     | <span class='neutral'>        );</span>
 169 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, Chain(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 170 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, Chain(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 171 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon_mumbai&quot;, Chain(&quot;Polygon Mumbai&quot;, 80001, &quot;https://rpc-mumbai.maticvigil.com&quot;));</span>
 172 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, Chain(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 173 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 174 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, Chain(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 175 |     | <span class='neutral'>        );</span>
 176 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;bnb_smart_chain&quot;, Chain(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;));</span>
 177 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;bnb_smart_chain_testnet&quot;, Chain(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://data-seed-prebsc-1-s1.binance.org:8545&quot;));// forgefmt: disable-line</span>
 178 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, Chain(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 182 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, Chain memory chain) private {</span>
 183 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 184 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 185 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 186 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 187 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'>}</span>
 190 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  10 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  15 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  16 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    struct RawTx1559 {</span>
  19 |     | <span class='neutral'>        string[] arguments;</span>
  20 |     | <span class='neutral'>        address contractAddress;</span>
  21 |     | <span class='neutral'>        string contractName;</span>
  22 |     | <span class='neutral'>        // json value name = function</span>
  23 |     | <span class='neutral'>        string functionSig;</span>
  24 |     | <span class='neutral'>        bytes32 hash;</span>
  25 |     | <span class='neutral'>        // json value name = tx</span>
  26 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  27 |     | <span class='neutral'>        // json value name = type</span>
  28 |     | <span class='neutral'>        string opcode;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  32 |     | <span class='neutral'>        AccessList[] accessList;</span>
  33 |     | <span class='neutral'>        bytes data;</span>
  34 |     | <span class='neutral'>        address from;</span>
  35 |     | <span class='neutral'>        bytes gas;</span>
  36 |     | <span class='neutral'>        bytes nonce;</span>
  37 |     | <span class='neutral'>        address to;</span>
  38 |     | <span class='neutral'>        bytes txType;</span>
  39 |     | <span class='neutral'>        bytes value;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct Tx1559 {</span>
  43 |     | <span class='neutral'>        string[] arguments;</span>
  44 |     | <span class='neutral'>        address contractAddress;</span>
  45 |     | <span class='neutral'>        string contractName;</span>
  46 |     | <span class='neutral'>        string functionSig;</span>
  47 |     | <span class='neutral'>        bytes32 hash;</span>
  48 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  49 |     | <span class='neutral'>        string opcode;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  53 |     | <span class='neutral'>        AccessList[] accessList;</span>
  54 |     | <span class='neutral'>        bytes data;</span>
  55 |     | <span class='neutral'>        address from;</span>
  56 |     | <span class='neutral'>        uint256 gas;</span>
  57 |     | <span class='neutral'>        uint256 nonce;</span>
  58 |     | <span class='neutral'>        address to;</span>
  59 |     | <span class='neutral'>        uint256 txType;</span>
  60 |     | <span class='neutral'>        uint256 value;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  64 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  65 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    struct TxLegacy {</span>
  68 |     | <span class='neutral'>        string[] arguments;</span>
  69 |     | <span class='neutral'>        address contractAddress;</span>
  70 |     | <span class='neutral'>        string contractName;</span>
  71 |     | <span class='neutral'>        string functionSig;</span>
  72 |     | <span class='neutral'>        string hash;</span>
  73 |     | <span class='neutral'>        string opcode;</span>
  74 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  78 |     | <span class='neutral'>        AccessList[] accessList;</span>
  79 |     | <span class='neutral'>        uint256 chainId;</span>
  80 |     | <span class='neutral'>        bytes data;</span>
  81 |     | <span class='neutral'>        address from;</span>
  82 |     | <span class='neutral'>        uint256 gas;</span>
  83 |     | <span class='neutral'>        uint256 gasPrice;</span>
  84 |     | <span class='neutral'>        bytes32 hash;</span>
  85 |     | <span class='neutral'>        uint256 nonce;</span>
  86 |     | <span class='neutral'>        bytes1 opcode;</span>
  87 |     | <span class='neutral'>        bytes32 r;</span>
  88 |     | <span class='neutral'>        bytes32 s;</span>
  89 |     | <span class='neutral'>        uint256 txType;</span>
  90 |     | <span class='neutral'>        address to;</span>
  91 |     | <span class='neutral'>        uint8 v;</span>
  92 |     | <span class='neutral'>        uint256 value;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    struct AccessList {</span>
  96 |     | <span class='neutral'>        address accessAddress;</span>
  97 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 101 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 102 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    struct RawReceipt {</span>
 105 |     | <span class='neutral'>        bytes32 blockHash;</span>
 106 |     | <span class='neutral'>        bytes blockNumber;</span>
 107 |     | <span class='neutral'>        address contractAddress;</span>
 108 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 109 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 110 |     | <span class='neutral'>        address from;</span>
 111 |     | <span class='neutral'>        bytes gasUsed;</span>
 112 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 113 |     | <span class='neutral'>        bytes logsBloom;</span>
 114 |     | <span class='neutral'>        bytes status;</span>
 115 |     | <span class='neutral'>        address to;</span>
 116 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 117 |     | <span class='neutral'>        bytes transactionIndex;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    struct Receipt {</span>
 121 |     | <span class='neutral'>        bytes32 blockHash;</span>
 122 |     | <span class='neutral'>        uint256 blockNumber;</span>
 123 |     | <span class='neutral'>        address contractAddress;</span>
 124 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 125 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 126 |     | <span class='neutral'>        address from;</span>
 127 |     | <span class='neutral'>        uint256 gasUsed;</span>
 128 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 129 |     | <span class='neutral'>        bytes logsBloom;</span>
 130 |     | <span class='neutral'>        uint256 status;</span>
 131 |     | <span class='neutral'>        address to;</span>
 132 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 133 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 137 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 140 |     | <span class='neutral'>        string[] libraries;</span>
 141 |     | <span class='neutral'>        string path;</span>
 142 |     | <span class='neutral'>        string[] pending;</span>
 143 |     | <span class='neutral'>        Receipt[] receipts;</span>
 144 |     | <span class='neutral'>        uint256 timestamp;</span>
 145 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 146 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 150 |     | <span class='neutral'>        string[] libraries;</span>
 151 |     | <span class='neutral'>        string path;</span>
 152 |     | <span class='neutral'>        string[] pending;</span>
 153 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 154 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 155 |     | <span class='neutral'>        uint256 timestamp;</span>
 156 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 160 |     | <span class='neutral'>        // json value = address</span>
 161 |     | <span class='neutral'>        address logAddress;</span>
 162 |     | <span class='neutral'>        bytes32 blockHash;</span>
 163 |     | <span class='neutral'>        bytes blockNumber;</span>
 164 |     | <span class='neutral'>        bytes data;</span>
 165 |     | <span class='neutral'>        bytes logIndex;</span>
 166 |     | <span class='neutral'>        bool removed;</span>
 167 |     | <span class='neutral'>        bytes32[] topics;</span>
 168 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 169 |     | <span class='neutral'>        bytes transactionIndex;</span>
 170 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    struct ReceiptLog {</span>
 174 |     | <span class='neutral'>        // json value = address</span>
 175 |     | <span class='neutral'>        address logAddress;</span>
 176 |     | <span class='neutral'>        bytes32 blockHash;</span>
 177 |     | <span class='neutral'>        uint256 blockNumber;</span>
 178 |     | <span class='neutral'>        bytes data;</span>
 179 |     | <span class='neutral'>        uint256 logIndex;</span>
 180 |     | <span class='neutral'>        bytes32[] topics;</span>
 181 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 182 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 183 |     | <span class='neutral'>        bool removed;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    struct TxReturn {</span>
 187 |     | <span class='neutral'>        string internalType;</span>
 188 |     | <span class='neutral'>        string value;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr) internal virtual {</span>
 192 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 193 |     | <span class='neutral'>        uint256 chainId;</span>
 194 |     | <span class='neutral'>        assembly {</span>
 195 |     | <span class='neutral'>            chainId := chainid()</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>        assumeNoPrecompiles(addr, chainId);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {</span>
 201 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 202 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        // These should be present on all EVM-compatible chains.</span>
 205 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0x9));</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 208 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 209 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 210 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 211 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 212 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 213 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 214 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 215 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 216 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 217 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 218 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 224 |     | <span class='neutral'>        internal</span>
 225 |     | <span class='neutral'>        view</span>
 226 |     | <span class='neutral'>        virtual</span>
 227 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 228 |     | <span class='neutral'>    {</span>
 229 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 230 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 231 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 232 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 233 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 234 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 235 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 236 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 237 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 238 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 239 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 240 |     | <span class='neutral'>        return artifact;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 244 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 245 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 246 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        return txs;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 252 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 253 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 254 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 255 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 256 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 257 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 258 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 259 |     | <span class='neutral'>        return transaction;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        pure</span>
 265 |     | <span class='neutral'>        virtual</span>
 266 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 267 |     | <span class='neutral'>    {</span>
 268 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 269 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 270 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 271 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 272 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 273 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 274 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 275 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 276 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 277 |     | <span class='neutral'>        return txDetail;</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 281 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 282 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 283 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 284 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 288 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 289 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 290 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 291 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 292 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 296 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 297 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 298 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 299 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 300 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 304 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 305 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 306 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 307 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 308 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 312 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 313 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 314 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'>        return receipts;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 320 |     | <span class='neutral'>        Receipt memory receipt;</span>
 321 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 322 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 323 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 324 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 325 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 326 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 327 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 328 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 329 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 330 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 331 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 332 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 333 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 334 |     | <span class='neutral'>        return receipt;</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 338 |     | <span class='neutral'>        internal</span>
 339 |     | <span class='neutral'>        pure</span>
 340 |     | <span class='neutral'>        virtual</span>
 341 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 342 |     | <span class='neutral'>    {</span>
 343 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 344 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 345 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 346 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 347 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 348 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 349 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 350 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 351 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 352 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 353 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>        return logs;</span>
 356 |     | <span class='neutral'>    }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 359 |     | <span class='neutral'>    // the artifacts directory</span>
 360 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 361 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 362 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 363 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 364 |     | <span class='neutral'>        assembly {</span>
 365 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 366 |     | <span class='neutral'>        }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 372 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 374 |     | <span class='neutral'>        assembly {</span>
 375 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 382 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 383 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 384 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 385 |     | <span class='neutral'>        assembly {</span>
 386 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 393 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 394 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 395 |     | <span class='neutral'>        assembly {</span>
 396 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 400 |     | <span class='neutral'>    }</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 403 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 404 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 405 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 406 |     | <span class='neutral'>        vm.label(addr, name);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    // creates a labeled address</span>
 410 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 411 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 415 |     | <span class='neutral'>        internal</span>
 416 |     | <span class='neutral'>        virtual</span>
 417 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 418 |     | <span class='neutral'>    {</span>
 419 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 420 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 424 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 425 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function isFork() internal view virtual returns (bool status) {</span>
 429 |     | <span class='neutral'>        try vm.activeFork() {</span>
 430 |     | <span class='neutral'>            status = true;</span>
 431 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 432 |     | <span class='neutral'>    }</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 435 |     | <span class='neutral'>        if (!isFork()) {</span>
 436 |     | <span class='neutral'>            _;</span>
 437 |     | <span class='neutral'>        }</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 441 |     | <span class='neutral'>        if (isFork()) {</span>
 442 |     | <span class='neutral'>            _;</span>
 443 |     | <span class='neutral'>        }</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 447 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 448 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 449 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 450 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 451 |     | <span class='neutral'>        //</span>
 452 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 453 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 454 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 455 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 456 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>        _;</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 461 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 462 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 463 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 464 |     | <span class='neutral'>        }</span>
 465 |     | <span class='neutral'>    }</span>
 466 |     | <span class='neutral'>}</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 469 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 470 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 473 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 476 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 477 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 481 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
 482 |     | <span class='neutral'>    }</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 485 |     | <span class='neutral'>    function hoax(address who) internal virtual {</span>
 486 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 487 |     | <span class='neutral'>        vm.prank(who);</span>
 488 |     | <span class='neutral'>    }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>    function hoax(address who, uint256 give) internal virtual {</span>
 491 |     | <span class='neutral'>        vm.deal(who, give);</span>
 492 |     | <span class='neutral'>        vm.prank(who);</span>
 493 |     | <span class='neutral'>    }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>    function hoax(address who, address origin) internal virtual {</span>
 496 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 497 |     | <span class='neutral'>        vm.prank(who, origin);</span>
 498 |     | <span class='neutral'>    }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>    function hoax(address who, address origin, uint256 give) internal virtual {</span>
 501 |     | <span class='neutral'>        vm.deal(who, give);</span>
 502 |     | <span class='neutral'>        vm.prank(who, origin);</span>
 503 |     | <span class='neutral'>    }</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 506 |     | <span class='neutral'>    function startHoax(address who) internal virtual {</span>
 507 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 508 |     | <span class='neutral'>        vm.startPrank(who);</span>
 509 |     | <span class='neutral'>    }</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>    function startHoax(address who, uint256 give) internal virtual {</span>
 512 |     | <span class='neutral'>        vm.deal(who, give);</span>
 513 |     | <span class='neutral'>        vm.startPrank(who);</span>
 514 |     | <span class='neutral'>    }</span>
 515 |     | <span class='neutral'></span>
 516 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 517 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 518 |     | <span class='neutral'>    function startHoax(address who, address origin) internal virtual {</span>
 519 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 520 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
 521 |     | <span class='neutral'>    }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>    function startHoax(address who, address origin, uint256 give) internal virtual {</span>
 524 |     | <span class='neutral'>        vm.deal(who, give);</span>
 525 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
 526 |     | <span class='neutral'>    }</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>    function changePrank(address who) internal virtual {</span>
 529 |     | <span class='neutral'>        vm.stopPrank();</span>
 530 |     | <span class='neutral'>        vm.startPrank(who);</span>
 531 |     | <span class='neutral'>    }</span>
 532 |     | <span class='neutral'></span>
 533 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 534 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 535 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 536 |     | <span class='neutral'>        vm.deal(to, give);</span>
 537 |     | <span class='neutral'>    }</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 540 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 541 |     | <span class='unexecuted'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 542 |     | <span class='unexecuted'>        deal(token, to, give, false);</span>
 543 |     | <span class='neutral'>    }</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='unexecuted'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 546 |     | <span class='neutral'>        // get current balance</span>
 547 |     | <span class='unexecuted'>        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));</span>
 548 |     | <span class='unexecuted'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>        // update balance</span>
 551 |     | <span class='unexecuted'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>        // update total supply</span>
 554 |     | <span class='unexecuted'>        if (adjust) {</span>
 555 |     | <span class='unexecuted'>            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));</span>
 556 |     | <span class='unexecuted'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 557 |     | <span class='unexecuted'>            if (give &lt; prevBal) {</span>
 558 |     | <span class='unexecuted'>                totSup -= (prevBal - give);</span>
 559 |     | <span class='neutral'>            } else {</span>
 560 |     | <span class='unexecuted'>                totSup += (give - prevBal);</span>
 561 |     | <span class='neutral'>            }</span>
 562 |     | <span class='unexecuted'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 563 |     | <span class='neutral'>        }</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'>}</span>
 566 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;some_peth&quot;);</span>
  13 |     | <span class='neutral'>// json.parseUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;deploymentArtifact&quot;;</span>
  19 |     | <span class='neutral'>// Contract contract = new Contract();</span>
  20 |     | <span class='neutral'>// json.serialize(&quot;contractAddress&quot;, address(contract));</span>
  21 |     | <span class='neutral'>// json = json.serialize(&quot;deploymentTimes&quot;, uint(1));</span>
  22 |     | <span class='neutral'>// // store the stringified JSON to the &#39;json&#39; variable we have been using as a key</span>
  23 |     | <span class='neutral'>// // as we won&#39;t need it any longer</span>
  24 |     | <span class='neutral'>// string memory json2 = &quot;finalArtifact&quot;;</span>
  25 |     | <span class='neutral'>// string memory final = json2.serialize(&quot;depArtifact&quot;, json);</span>
  26 |     | <span class='neutral'>// final.write(&quot;&lt;some_path&gt;&quot;);</span>
  27 |     | <span class='neutral'>// ```</span>
  28 |     | <span class='unexecuted'></span>
  29 |     | <span class='neutral'>library stdJson {</span>
  30 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (uint256));</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (uint256[]));</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (int256));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (int256[]));</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes32));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes32[]));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (string));</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (string[]));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (address));</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (address[]));</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bool));</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bool[]));</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes));</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes[]));</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='unexecuted'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='unexecuted'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct StdStorage {</span>
   7 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; uint256))) slots;</span>
   8 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; bool))) finds;</span>
   9 |     | <span class='neutral'>    bytes32[] _keys;</span>
  10 |     | <span class='neutral'>    bytes4 _sig;</span>
  11 |     | <span class='neutral'>    uint256 _depth;</span>
  12 |     | <span class='neutral'>    address _target;</span>
  13 |     | <span class='neutral'>    bytes32 _set;</span>
  14 |     | <span class='neutral'>}</span>
  15 |     | <span class='unexecuted'></span>
  16 |     | <span class='neutral'>library stdStorageSafe {</span>
  17 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  18 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  23 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
  27 |     | <span class='neutral'>    // slot complexity:</span>
  28 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
  29 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
  30 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
  31 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
  32 |     | <span class='unexecuted'>    function find(StdStorage storage self) internal returns (uint256) {</span>
  33 |     | <span class='unexecuted'>        address who = self._target;</span>
  34 |     | <span class='unexecuted'>        bytes4 fsig = self._sig;</span>
  35 |     | <span class='unexecuted'>        uint256 field_depth = self._depth;</span>
  36 |     | <span class='unexecuted'>        bytes32[] memory ins = self._keys;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // calldata to test against</span>
  39 |     | <span class='unexecuted'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
  40 |     | <span class='unexecuted'>            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='unexecuted'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
  43 |     | <span class='unexecuted'>        vm.record();</span>
  44 |     | <span class='unexecuted'>        bytes32 fdat;</span>
  45 |     | <span class='neutral'>        {</span>
  46 |     | <span class='unexecuted'>            (, bytes memory rdat) = who.staticcall(cald);</span>
  47 |     | <span class='unexecuted'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
  51 |     | <span class='unexecuted'>        if (reads.length == 1) {</span>
  52 |     | <span class='unexecuted'>            bytes32 curr = vm.load(who, reads[0]);</span>
  53 |     | <span class='unexecuted'>            if (curr == bytes32(0)) {</span>
  54 |     | <span class='unexecuted'>                emit WARNING_UninitedSlot(who, uint256(reads[0]));</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='unexecuted'>            if (fdat != curr) {</span>
  57 |     | <span class='unexecuted'>                require(</span>
  58 |     | <span class='neutral'>                    false,</span>
  59 |     | <span class='neutral'>                    &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
  60 |     | <span class='neutral'>                );</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='unexecuted'>            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));</span>
  63 |     | <span class='unexecuted'>            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);</span>
  64 |     | <span class='unexecuted'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  65 |     | <span class='unexecuted'>        } else if (reads.length &gt; 1) {</span>
  66 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
  67 |     | <span class='unexecuted'>                bytes32 prev = vm.load(who, reads[i]);</span>
  68 |     | <span class='unexecuted'>                if (prev == bytes32(0)) {</span>
  69 |     | <span class='unexecuted'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
  70 |     | <span class='neutral'>                }</span>
  71 |     | <span class='neutral'>                // store</span>
  72 |     | <span class='unexecuted'>                vm.store(who, reads[i], bytes32(hex&quot;1337&quot;));</span>
  73 |     | <span class='unexecuted'>                bool success;</span>
  74 |     | <span class='unexecuted'>                bytes memory rdat;</span>
  75 |     | <span class='neutral'>                {</span>
  76 |     | <span class='unexecuted'>                    (success, rdat) = who.staticcall(cald);</span>
  77 |     | <span class='unexecuted'>                    fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  78 |     | <span class='neutral'>                }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>                if (success &amp;&amp; fdat == bytes32(hex&quot;1337&quot;)) {</span>
  81 |     | <span class='neutral'>                    // we found which of the slots is the actual one</span>
  82 |     | <span class='unexecuted'>                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));</span>
  83 |     | <span class='unexecuted'>                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);</span>
  84 |     | <span class='unexecuted'>                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  85 |     | <span class='unexecuted'>                    vm.store(who, reads[i], prev);</span>
  86 |     | <span class='unexecuted'>                    break;</span>
  87 |     | <span class='neutral'>                }</span>
  88 |     | <span class='unexecuted'>                vm.store(who, reads[i], prev);</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'>        } else {</span>
  91 |     | <span class='unexecuted'>            require(false, &quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        require(</span>
  95 |     | <span class='unexecuted'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],</span>
  96 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        delete self._target;</span>
 100 |     | <span class='unexecuted'>        delete self._sig;</span>
 101 |     | <span class='unexecuted'>        delete self._keys;</span>
 102 |     | <span class='unexecuted'>        delete self._depth;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 108 |     | <span class='unexecuted'>        self._target = _target;</span>
 109 |     | <span class='neutral'>        return self;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 113 |     | <span class='unexecuted'>        self._sig = _sig;</span>
 114 |     | <span class='neutral'>        return self;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 118 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 119 |     | <span class='neutral'>        return self;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 123 |     | <span class='unexecuted'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 124 |     | <span class='neutral'>        return self;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 128 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 129 |     | <span class='neutral'>        return self;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 133 |     | <span class='neutral'>        self._keys.push(key);</span>
 134 |     | <span class='neutral'>        return self;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 138 |     | <span class='neutral'>        self._depth = _depth;</span>
 139 |     | <span class='neutral'>        return self;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 143 |     | <span class='neutral'>        address t = self._target;</span>
 144 |     | <span class='neutral'>        uint256 s = find(self);</span>
 145 |     | <span class='neutral'>        return abi.encode(vm.load(t, bytes32(s)));</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 149 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 153 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 154 |     | <span class='neutral'>        if (v == 0) return false;</span>
 155 |     | <span class='neutral'>        if (v == 1) return true;</span>
 156 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 160 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 164 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 168 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 172 |     | <span class='unexecuted'>        bytes32 out;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 175 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 176 |     | <span class='unexecuted'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        return out;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 182 |     | <span class='unexecuted'>        bytes memory result = new bytes(b.length * 32);</span>
 183 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 184 |     | <span class='unexecuted'>            bytes32 k = b[i];</span>
 185 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 186 |     | <span class='unexecuted'>            assembly {</span>
 187 |     | <span class='unexecuted'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 188 |     | <span class='neutral'>            }</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        return result;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='unexecuted'></span>
 195 |     | <span class='neutral'>library stdStorage {</span>
 196 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 199 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 203 |     | <span class='unexecuted'>        return stdStorageSafe.find(self);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 207 |     | <span class='unexecuted'>        return stdStorageSafe.target(self, _target);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 211 |     | <span class='unexecuted'>        return stdStorageSafe.sig(self, _sig);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 215 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 219 |     | <span class='unexecuted'>        return stdStorageSafe.with_key(self, who);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 223 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 227 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 231 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 235 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 239 |     | <span class='unexecuted'>        checked_write(self, bytes32(amt));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 243 |     | <span class='neutral'>        bytes32 t;</span>
 244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 245 |     | <span class='neutral'>        assembly {</span>
 246 |     | <span class='neutral'>            t := write</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        checked_write(self, t);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 252 |     | <span class='unexecuted'>        address who = self._target;</span>
 253 |     | <span class='unexecuted'>        bytes4 fsig = self._sig;</span>
 254 |     | <span class='unexecuted'>        uint256 field_depth = self._depth;</span>
 255 |     | <span class='unexecuted'>        bytes32[] memory ins = self._keys;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
 258 |     | <span class='unexecuted'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
 259 |     | <span class='unexecuted'>            find(self);</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='unexecuted'>        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>        bytes32 fdat;</span>
 264 |     | <span class='neutral'>        {</span>
 265 |     | <span class='unexecuted'>            (, bytes memory rdat) = who.staticcall(cald);</span>
 266 |     | <span class='unexecuted'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='unexecuted'>        bytes32 curr = vm.load(who, slot);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        if (fdat != curr) {</span>
 271 |     | <span class='unexecuted'>            require(</span>
 272 |     | <span class='neutral'>                false,</span>
 273 |     | <span class='neutral'>                &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
 274 |     | <span class='neutral'>            );</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='unexecuted'>        vm.store(who, slot, set);</span>
 277 |     | <span class='unexecuted'>        delete self._target;</span>
 278 |     | <span class='unexecuted'>        delete self._sig;</span>
 279 |     | <span class='unexecuted'>        delete self._keys;</span>
 280 |     | <span class='unexecuted'>        delete self._depth;</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 284 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 288 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 292 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 296 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 300 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 304 |     | <span class='unexecuted'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 305 |     | <span class='unexecuted'>        bytes32 out;</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 308 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 309 |     | <span class='unexecuted'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='unexecuted'>        return out;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 315 |     | <span class='unexecuted'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 316 |     | <span class='unexecuted'>        bytes memory result = new bytes(b.length * 32);</span>
 317 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 318 |     | <span class='unexecuted'>            bytes32 k = b[i];</span>
 319 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 320 |     | <span class='unexecuted'>            assembly {</span>
 321 |     | <span class='unexecuted'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 322 |     | <span class='neutral'>            }</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='unexecuted'>        return result;</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'>}</span>
 328 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// TODO Remove import.</span>
   5 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdUtils {</span>
   8 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   9 |     | <span class='unexecuted'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  12 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  13 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  14 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  17 |     | <span class='unexecuted'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  18 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  19 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  20 |     | <span class='unexecuted'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>        uint256 size = max - min + 1;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  25 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  26 |     | <span class='unexecuted'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  27 |     | <span class='unexecuted'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  30 |     | <span class='unexecuted'>        if (x &gt; max) {</span>
  31 |     | <span class='unexecuted'>            uint256 diff = x - max;</span>
  32 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  33 |     | <span class='unexecuted'>            if (rem == 0) return max;</span>
  34 |     | <span class='unexecuted'>            result = min + rem - 1;</span>
  35 |     | <span class='unexecuted'>        } else if (x &lt; min) {</span>
  36 |     | <span class='unexecuted'>            uint256 diff = min - x;</span>
  37 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  38 |     | <span class='unexecuted'>            if (rem == 0) return min;</span>
  39 |     | <span class='unexecuted'>            result = max - rem + 1;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {</span>
  44 |     | <span class='unexecuted'>        result = _bound(x, min, max);</span>
  45 |     | <span class='unexecuted'>        console2_log(&quot;Bound Result&quot;, result);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {</span>
  49 |     | <span class='unexecuted'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  52 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  53 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  54 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  55 |     | <span class='neutral'>        //</span>
  56 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  57 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  58 |     | <span class='unexecuted'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  59 |     | <span class='unexecuted'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  60 |     | <span class='unexecuted'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        uint256 y = _bound(_x, _min, _max);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  65 |     | <span class='unexecuted'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  66 |     | <span class='unexecuted'>        console2_log(&quot;Bound result&quot;, vm.toString(result));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
  70 |     | <span class='neutral'>    /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
  71 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
  72 |     | <span class='neutral'>        // forgefmt: disable-start</span>
  73 |     | <span class='neutral'>        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.</span>
  74 |     | <span class='neutral'>        // A one byte integer uses its own value as its length prefix, there is no additional &quot;0x80 + length&quot; prefix that comes before it.</span>
  75 |     | <span class='neutral'>        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));</span>
  76 |     | <span class='neutral'>        if (nonce &lt;= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.</span>
  79 |     | <span class='neutral'>        if (nonce &lt;= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));</span>
  80 |     | <span class='neutral'>        if (nonce &lt;= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));</span>
  81 |     | <span class='neutral'>        if (nonce &lt;= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));</span>
  82 |     | <span class='neutral'>        // forgefmt: disable-end</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp</span>
  85 |     | <span class='neutral'>        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)</span>
  86 |     | <span class='neutral'>        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
  87 |     | <span class='neutral'>        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)</span>
  88 |     | <span class='neutral'>        // We assume nobody can have a nonce large enough to require more than 32 bytes.</span>
  89 |     | <span class='neutral'>        return addressFromLast20Bytes(</span>
  90 |     | <span class='neutral'>            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))</span>
  91 |     | <span class='neutral'>        );</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
  95 |     | <span class='neutral'>        internal</span>
  96 |     | <span class='neutral'>        pure</span>
  97 |     | <span class='neutral'>        virtual</span>
  98 |     | <span class='neutral'>        returns (address)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
 104 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 105 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 109 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function console2_log(string memory p0, uint256 p1) private view {</span>
 115 |     | <span class='unexecuted'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 116 |     | <span class='neutral'>        status;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function console2_log(string memory p0, string memory p1) private view {</span>
 120 |     | <span class='unexecuted'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 121 |     | <span class='neutral'>        status;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'>}</span>
 124 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// 💬 ABOUT</span>
  5 |     | <span class='neutral'>// Standard Library&#39;s default Test</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// 🧩 MODULES</span>
  8 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
  9 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 11 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 12 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 13 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 14 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 15 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 16 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 17 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 18 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>// 📦 BOILERPLATE</span>
 21 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 22 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>// ⭐️ TEST</span>
 25 |     | <span class='neutral'>abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdUtils, TestBase {</span>
 26 |     | <span class='neutral'>// Note: IS_TEST() must return true.</span>
 27 |     | <span class='neutral'>// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/Vm.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Cheatcodes are marked as view/pure/none using the following rules:</span>
   7 |     | <span class='neutral'>// 0. A call&#39;s observable behaviour includes its return value, logs, reverts and state writes,</span>
   8 |     | <span class='neutral'>// 1. If you can influence a later call&#39;s observable behaviour, you&#39;re neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),</span>
   9 |     | <span class='neutral'>// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you&#39;re `view`,</span>
  10 |     | <span class='neutral'>// 3. Otherwise you&#39;re `pure`.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>interface VmSafe {</span>
  13 |     | <span class='neutral'>    struct Log {</span>
  14 |     | <span class='neutral'>        bytes32[] topics;</span>
  15 |     | <span class='neutral'>        bytes data;</span>
  16 |     | <span class='neutral'>        address emitter;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct Rpc {</span>
  20 |     | <span class='neutral'>        string key;</span>
  21 |     | <span class='neutral'>        string url;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct FsMetadata {</span>
  25 |     | <span class='neutral'>        bool isDir;</span>
  26 |     | <span class='neutral'>        bool isSymlink;</span>
  27 |     | <span class='neutral'>        uint256 length;</span>
  28 |     | <span class='neutral'>        bool readOnly;</span>
  29 |     | <span class='neutral'>        uint256 modified;</span>
  30 |     | <span class='neutral'>        uint256 accessed;</span>
  31 |     | <span class='neutral'>        uint256 created;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
  35 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  36 |     | <span class='neutral'>    // Signs data</span>
  37 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  38 |     | <span class='neutral'>    // Gets the address for a given private key</span>
  39 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address keyAddr);</span>
  40 |     | <span class='neutral'>    // Gets the nonce of an account</span>
  41 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  42 |     | <span class='neutral'>    // Performs a foreign function call via the terminal</span>
  43 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  44 |     | <span class='neutral'>    // Sets environment variables</span>
  45 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  46 |     | <span class='neutral'>    // Reads environment variables, (name) =&gt; (value)</span>
  47 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  48 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  49 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  50 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  51 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  52 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  53 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  54 |     | <span class='neutral'>    // Reads environment variables as arrays</span>
  55 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  56 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  57 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  58 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  59 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  60 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  61 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  62 |     | <span class='neutral'>    // Read environment variables with default value</span>
  63 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external returns (bool value);</span>
  64 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);</span>
  65 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);</span>
  66 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external returns (address value);</span>
  67 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);</span>
  68 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);</span>
  69 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);</span>
  70 |     | <span class='neutral'>    // Read environment variables as arrays with default value</span>
  71 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  72 |     | <span class='neutral'>        external</span>
  73 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  74 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  75 |     | <span class='neutral'>        external</span>
  76 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  77 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  78 |     | <span class='neutral'>        external</span>
  79 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  80 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  81 |     | <span class='neutral'>        external</span>
  82 |     | <span class='neutral'>        returns (address[] memory value);</span>
  83 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  84 |     | <span class='neutral'>        external</span>
  85 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  86 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  87 |     | <span class='neutral'>        external</span>
  88 |     | <span class='neutral'>        returns (string[] memory value);</span>
  89 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  90 |     | <span class='neutral'>        external</span>
  91 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  92 |     | <span class='neutral'>    // Records all storage reads and writes</span>
  93 |     | <span class='neutral'>    function record() external;</span>
  94 |     | <span class='neutral'>    // Gets all accessed reads and write slot from a recording session, for a given address</span>
  95 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  96 |     | <span class='neutral'>    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  97 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  98 |     | <span class='neutral'>    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  99 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
 100 |     | <span class='neutral'>    // Labels an address in call traces</span>
 101 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 102 |     | <span class='neutral'>    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain</span>
 103 |     | <span class='neutral'>    function broadcast() external;</span>
 104 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain</span>
 105 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
 106 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain</span>
 107 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
 108 |     | <span class='neutral'>    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain</span>
 109 |     | <span class='neutral'>    function startBroadcast() external;</span>
 110 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain</span>
 111 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
 112 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain</span>
 113 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
 114 |     | <span class='neutral'>    // Stops collecting onchain transactions</span>
 115 |     | <span class='neutral'>    function stopBroadcast() external;</span>
 116 |     | <span class='neutral'>    // Reads the entire content of file to string</span>
 117 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
 118 |     | <span class='neutral'>    // Reads the entire content of file as binary. Path is relative to the project root.</span>
 119 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
 120 |     | <span class='neutral'>    // Get the path of the current project root</span>
 121 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
 122 |     | <span class='neutral'>    // Get the metadata for a file/directory</span>
 123 |     | <span class='neutral'>    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);</span>
 124 |     | <span class='neutral'>    // Reads next line of file to string</span>
 125 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
 126 |     | <span class='neutral'>    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
 127 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
 128 |     | <span class='neutral'>    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
 129 |     | <span class='neutral'>    // Path is relative to the project root.</span>
 130 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
 131 |     | <span class='neutral'>    // Writes line to file, creating a file if it does not exist.</span>
 132 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
 133 |     | <span class='neutral'>    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
 134 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
 135 |     | <span class='neutral'>    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
 136 |     | <span class='neutral'>    // - Path points to a directory.</span>
 137 |     | <span class='neutral'>    // - The file doesn&#39;t exist.</span>
 138 |     | <span class='neutral'>    // - The user lacks permissions to remove the file.</span>
 139 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
 140 |     | <span class='neutral'>    // Convert values to a string</span>
 141 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
 142 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
 143 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
 144 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
 145 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
 146 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
 147 |     | <span class='neutral'>    // Convert values from a string</span>
 148 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
 149 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
 150 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
 151 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
 152 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
 153 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
 154 |     | <span class='neutral'>    // Record all the transaction logs</span>
 155 |     | <span class='neutral'>    function recordLogs() external;</span>
 156 |     | <span class='neutral'>    // Gets all the recorded logs</span>
 157 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
 158 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44&#39;/60&#39;/0&#39;/0/{index}</span>
 159 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
 160 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}</span>
 161 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
 162 |     | <span class='neutral'>        external</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 165 |     | <span class='neutral'>    // Adds a private key to the local forge wallet and returns the address</span>
 166 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address keyAddr);</span>
 167 |     | <span class='neutral'>    //</span>
 168 |     | <span class='neutral'>    // parseJson</span>
 169 |     | <span class='neutral'>    //</span>
 170 |     | <span class='neutral'>    // ----</span>
 171 |     | <span class='neutral'>    // In case the returned value is a JSON object, it&#39;s encoded as a ABI-encoded tuple. As JSON objects</span>
 172 |     | <span class='neutral'>    // don&#39;t have the notion of ordered, but tuples do, they JSON object is encoded with it&#39;s fields ordered in</span>
 173 |     | <span class='neutral'>    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that</span>
 174 |     | <span class='neutral'>    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded</span>
 175 |     | <span class='neutral'>    // as tuples, with the attributes in the order in which they are defined.</span>
 176 |     | <span class='neutral'>    // For example: json = { &#39;a&#39;: 1, &#39;b&#39;: 0xa4tb......3xs}</span>
 177 |     | <span class='neutral'>    // a: uint256</span>
 178 |     | <span class='neutral'>    // b: address</span>
 179 |     | <span class='neutral'>    // To decode that json, we need to define a struct or a tuple as follows:</span>
 180 |     | <span class='neutral'>    // struct json = { uint256 a; address b; }</span>
 181 |     | <span class='neutral'>    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to</span>
 182 |     | <span class='neutral'>    // decode the tuple in that order, and thus fail.</span>
 183 |     | <span class='neutral'>    // ----</span>
 184 |     | <span class='neutral'>    // Given a string of JSON, return it as ABI-encoded</span>
 185 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 186 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file</span>
 189 |     | <span class='neutral'>    // It returns the stringified version of the specific JSON file up to that moment.</span>
 190 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
 191 |     | <span class='neutral'>        external</span>
 192 |     | <span class='neutral'>        returns (string memory json);</span>
 193 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 194 |     | <span class='neutral'>        external</span>
 195 |     | <span class='neutral'>        returns (string memory json);</span>
 196 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
 197 |     | <span class='neutral'>        external</span>
 198 |     | <span class='neutral'>        returns (string memory json);</span>
 199 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
 200 |     | <span class='neutral'>        external</span>
 201 |     | <span class='neutral'>        returns (string memory json);</span>
 202 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
 203 |     | <span class='neutral'>        external</span>
 204 |     | <span class='neutral'>        returns (string memory json);</span>
 205 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
 206 |     | <span class='neutral'>        external</span>
 207 |     | <span class='neutral'>        returns (string memory json);</span>
 208 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
 209 |     | <span class='neutral'>        external</span>
 210 |     | <span class='neutral'>        returns (string memory json);</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
 213 |     | <span class='neutral'>        external</span>
 214 |     | <span class='neutral'>        returns (string memory json);</span>
 215 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
 216 |     | <span class='neutral'>        external</span>
 217 |     | <span class='neutral'>        returns (string memory json);</span>
 218 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
 219 |     | <span class='neutral'>        external</span>
 220 |     | <span class='neutral'>        returns (string memory json);</span>
 221 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
 222 |     | <span class='neutral'>        external</span>
 223 |     | <span class='neutral'>        returns (string memory json);</span>
 224 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
 225 |     | <span class='neutral'>        external</span>
 226 |     | <span class='neutral'>        returns (string memory json);</span>
 227 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
 228 |     | <span class='neutral'>        external</span>
 229 |     | <span class='neutral'>        returns (string memory json);</span>
 230 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
 231 |     | <span class='neutral'>        external</span>
 232 |     | <span class='neutral'>        returns (string memory json);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    //</span>
 235 |     | <span class='neutral'>    // writeJson</span>
 236 |     | <span class='neutral'>    //</span>
 237 |     | <span class='neutral'>    // ----</span>
 238 |     | <span class='neutral'>    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
 239 |     | <span class='neutral'>    // Let&#39;s assume we want to write the following JSON to a file:</span>
 240 |     | <span class='neutral'>    //</span>
 241 |     | <span class='neutral'>    // { &quot;boolean&quot;: true, &quot;number&quot;: 342, &quot;object&quot;: { &quot;title&quot;: &quot;finally json serialization&quot; } }</span>
 242 |     | <span class='neutral'>    //</span>
 243 |     | <span class='neutral'>    // ```</span>
 244 |     | <span class='neutral'>    //  string memory json1 = &quot;some key&quot;;</span>
 245 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;boolean&quot;, true);</span>
 246 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;number&quot;, uint256(342));</span>
 247 |     | <span class='neutral'>    //  json2 = &quot;some other key&quot;;</span>
 248 |     | <span class='neutral'>    //  string memory output = vm.serializeString(json2, &quot;title&quot;, &quot;finally json serialization&quot;);</span>
 249 |     | <span class='neutral'>    //  string memory finalJson = vm.serialize(json1, &quot;object&quot;, output);</span>
 250 |     | <span class='neutral'>    //  vm.writeJson(finalJson, &quot;./output/example.json&quot;);</span>
 251 |     | <span class='neutral'>    // ```</span>
 252 |     | <span class='neutral'>    // The critical insight is that every invocation of serialization will return the stringified version of the JSON</span>
 253 |     | <span class='neutral'>    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version</span>
 254 |     | <span class='neutral'>    // to serialize them as values to another JSON object.</span>
 255 |     | <span class='neutral'>    //</span>
 256 |     | <span class='neutral'>    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)</span>
 257 |     | <span class='neutral'>    // will find the object in-memory that is keyed by &quot;some key&quot;.</span>
 258 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
 259 |     | <span class='neutral'>    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key&gt;</span>
 260 |     | <span class='neutral'>    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing</span>
 261 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
 262 |     | <span class='neutral'>    // Returns the RPC url for the given alias</span>
 263 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 264 |     | <span class='neutral'>    // Returns all rpc urls and their aliases `[alias, url][]`</span>
 265 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 266 |     | <span class='neutral'>    // Returns all rpc urls and their aliases as structs.</span>
 267 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 268 |     | <span class='neutral'>    // If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 269 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 270 |     | <span class='neutral'>    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
 271 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
 272 |     | <span class='neutral'>    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
 273 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
 274 |     | <span class='neutral'>}</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 277 |     | <span class='neutral'>    // Sets block.timestamp</span>
 278 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 279 |     | <span class='neutral'>    // Sets block.height</span>
 280 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 281 |     | <span class='neutral'>    // Sets block.basefee</span>
 282 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 283 |     | <span class='neutral'>    // Sets block.difficulty</span>
 284 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 285 |     | <span class='neutral'>    // Sets block.chainid</span>
 286 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 287 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot.</span>
 288 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 289 |     | <span class='neutral'>    // Sets the nonce of an account; must be higher than the current nonce of the account</span>
 290 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 291 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address</span>
 292 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 293 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called</span>
 294 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 295 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address, and the tx.origin to be the second input</span>
 296 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 297 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span>
 298 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 299 |     | <span class='neutral'>    // Resets subsequent calls&#39; msg.sender to be `address(this)`</span>
 300 |     | <span class='neutral'>    function stopPrank() external;</span>
 301 |     | <span class='neutral'>    // Sets an address&#39; balance</span>
 302 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 303 |     | <span class='neutral'>    // Sets an address&#39; code</span>
 304 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 305 |     | <span class='neutral'>    // Expects an error on next call</span>
 306 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 307 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 308 |     | <span class='neutral'>    function expectRevert() external;</span>
 309 |     | <span class='neutral'>    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).</span>
 310 |     | <span class='neutral'>    // Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 311 |     | <span class='neutral'>    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)</span>
 312 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 313 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 314 |     | <span class='neutral'>        external;</span>
 315 |     | <span class='neutral'>    // Mocks a call to an address, returning specified data.</span>
 316 |     | <span class='neutral'>    // Calldata can either be strict or a partial match, e.g. if you only</span>
 317 |     | <span class='neutral'>    // pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 318 |     | <span class='neutral'>    // function will be mocked.</span>
 319 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 320 |     | <span class='neutral'>    // Mocks a call to an address with a specific msg.value, returning specified data.</span>
 321 |     | <span class='neutral'>    // Calldata match takes precedence over msg.value in case of ambiguity.</span>
 322 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 323 |     | <span class='neutral'>    // Clears all mocked calls</span>
 324 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 325 |     | <span class='neutral'>    // Expects a call to an address with the specified calldata.</span>
 326 |     | <span class='neutral'>    // Calldata can either be a strict or a partial match</span>
 327 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 328 |     | <span class='neutral'>    // Expects a call to an address with the specified msg.value and calldata</span>
 329 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 330 |     | <span class='neutral'>    // Sets block.coinbase</span>
 331 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 332 |     | <span class='neutral'>    // Snapshot the current state of the evm.</span>
 333 |     | <span class='neutral'>    // Returns the id of the snapshot that was created.</span>
 334 |     | <span class='neutral'>    // To revert a snapshot use `revertTo`</span>
 335 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 336 |     | <span class='neutral'>    // Revert the state of the EVM to a previous snapshot</span>
 337 |     | <span class='neutral'>    // Takes the snapshot id to revert to.</span>
 338 |     | <span class='neutral'>    // This deletes the snapshot and all snapshots taken after the given snapshot id.</span>
 339 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 340 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and block and returns the identifier of the fork</span>
 341 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 342 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork</span>
 343 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 344 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,</span>
 345 |     | <span class='neutral'>    // and returns the identifier of the fork</span>
 346 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 347 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork</span>
 348 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 349 |     | <span class='neutral'>    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before</span>
 350 |     | <span class='neutral'>    // the transaction, returns the identifier of the fork</span>
 351 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 352 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 353 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 354 |     | <span class='neutral'>    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 355 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 356 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 357 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 358 |     | <span class='neutral'>    // Updates the currently active fork to given block number</span>
 359 |     | <span class='neutral'>    // This is similar to `roll` but for the currently active fork</span>
 360 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 361 |     | <span class='neutral'>    // Updates the currently active fork to given transaction</span>
 362 |     | <span class='neutral'>    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block</span>
 363 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 364 |     | <span class='neutral'>    // Updates the given fork to given block number</span>
 365 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 366 |     | <span class='neutral'>    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block</span>
 367 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 368 |     | <span class='neutral'>    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 369 |     | <span class='neutral'>    // Meaning, changes made to the state of this account will be kept when switching forks</span>
 370 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 371 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 372 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 373 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 374 |     | <span class='neutral'>    // Revokes persistent status from the address, previously added via `makePersistent`</span>
 375 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 376 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 377 |     | <span class='neutral'>    // Returns true if the account is marked as persistent</span>
 378 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 379 |     | <span class='neutral'>    // In forking mode, explicitly grant the given address cheatcode access</span>
 380 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 381 |     | <span class='neutral'>    // Fetches the given transaction from the active fork and executes it on the current state</span>
 382 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 383 |     | <span class='neutral'>    // Fetches the given transaction from the given fork and executes it on the current state</span>
 384 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 385 |     | <span class='neutral'>}</span>
 386 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='unexecuted'></span>
    4 |     | <span class='neutral'>library console {</span>
    5 |     | <span class='unexecuted'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='unexecuted'>    function _sendLogPayload(bytes memory payload) private view {</span>
    8 |     | <span class='unexecuted'>        uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='unexecuted'>        assembly {</span>
   12 |     | <span class='unexecuted'>            let payloadStart := add(payload, 32)</span>
   13 |     | <span class='unexecuted'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   14 |     | <span class='neutral'>        }</span>
   15 |     | <span class='neutral'>    }</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>    function log() internal view {</span>
   18 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   19 |     | <span class='neutral'>    }</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    function logInt(int p0) internal view {</span>
   22 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function logUint(uint p0) internal view {</span>
   26 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='unexecuted'>    function logBytes(bytes memory p0) internal view {</span>
   42 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function log(uint p0) internal view {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(uint p0, uint p1) internal view {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal view {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(uint p0, bool p1) internal view {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, address p1) internal view {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='unexecuted'>    function log(string memory p0, uint p1) internal view {</span>
  206 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(bool p0, uint p1) internal view {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(address p0, uint p1) internal view {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='unexecuted'>    function log(uint p0, uint p1, uint p2) internal view {</span>
  254 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal view {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal view {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal view {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal view {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal view {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal view {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal view {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal view {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal view {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal view {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal view {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal view {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal view {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal view {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal view {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='unexecuted'>    function log(string memory p0, uint p1, uint p2) internal view {</span>
  318 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal view {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal view {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal view {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal view {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal view {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal view {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal view {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal view {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal view {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal view {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal view {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal view {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal view {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal view {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal view {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal view {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal view {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal view {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal view {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal view {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal view {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal view {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal view {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal view {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal view {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal view {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal view {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal view {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal view {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal view {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal view {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal view {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal view {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal view {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal view {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal view {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal view {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal view {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal view {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal view {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal view {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal view {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal view {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal view {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal view {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal view {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal view {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal view {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal view {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal view {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal view {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal view {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal view {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal view {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal view {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal view {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal view {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal view {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal view {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal view {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal view {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal view {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal view {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal view {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal view {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal view {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal view {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal view {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal view {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal view {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal view {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal view {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal view {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal view {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal view {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal view {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal view {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal view {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal view {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal view {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal view {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal view {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal view {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal view {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal view {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal view {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal view {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal view {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal view {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal view {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal view {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal view {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal view {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal view {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal view {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal view {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal view {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal view {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal view {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal view {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal view {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal view {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal view {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal view {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal view {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal view {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal view {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal view {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal view {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal view {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal view {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal view {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal view {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal view {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal view {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal view {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal view {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal view {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal view {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal view {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal view {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal view {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal view {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal view {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal view {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal view {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal view {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal view {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal view {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal view {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal view {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal view {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal view {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal view {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal view {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal view {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal view {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal view {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal view {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal view {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal view {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal view {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal view {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal view {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal view {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal view {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal view {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal view {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal view {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal view {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal view {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal view {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal view {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal view {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal view {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal view {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal view {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal view {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal view {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal view {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal view {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal view {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal view {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal view {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal view {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal view {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal view {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal view {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal view {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal view {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/code/hyper/lib/forge-std/src/console2.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should</span>
    5 |     | <span class='neutral'>/// use `int256` and `uint256`. This modified version fixes that. This version is recommended</span>
    6 |     | <span class='neutral'>/// over `console.sol` if you don&#39;t need compatibility with Hardhat as the logs will show up in</span>
    7 |     | <span class='neutral'>/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.</span>
    8 |     | <span class='unexecuted'>/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178</span>
    9 |     | <span class='neutral'>library console2 {</span>
   10 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
   11 |     | <span class='neutral'></span>
   12 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
   13 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
   14 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   15 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   16 |     | <span class='neutral'>        assembly {</span>
   17 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   18 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   19 |     | <span class='neutral'>        }</span>
   20 |     | <span class='neutral'>    }</span>
   21 |     | <span class='neutral'></span>
   22 |     | <span class='neutral'>    function log() internal view {</span>
   23 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   24 |     | <span class='neutral'>    }</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>    function logInt(int256 p0) internal view {</span>
   27 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   28 |     | <span class='neutral'>    }</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    function logUint(uint256 p0) internal view {</span>
   31 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   32 |     | <span class='neutral'>    }</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   35 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   36 |     | <span class='neutral'>    }</span>
   37 |     | <span class='neutral'></span>
   38 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   39 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   40 |     | <span class='neutral'>    }</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   43 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   44 |     | <span class='neutral'>    }</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   47 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   48 |     | <span class='neutral'>    }</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   51 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   52 |     | <span class='neutral'>    }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   55 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   56 |     | <span class='neutral'>    }</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   59 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   63 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   64 |     | <span class='neutral'>    }</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   67 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   68 |     | <span class='neutral'>    }</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   71 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   75 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   76 |     | <span class='neutral'>    }</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   79 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   80 |     | <span class='neutral'>    }</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   83 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   84 |     | <span class='neutral'>    }</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   87 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   91 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   92 |     | <span class='neutral'>    }</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   95 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   99 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  100 |     | <span class='neutral'>    }</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
  103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  108 |     | <span class='neutral'>    }</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  112 |     | <span class='neutral'>    }</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  124 |     | <span class='neutral'>    }</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  128 |     | <span class='neutral'>    }</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  132 |     | <span class='neutral'>    }</span>
  133 |     | <span class='neutral'></span>
  134 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  144 |     | <span class='neutral'>    }</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  164 |     | <span class='neutral'>    }</span>
  165 |     | <span class='neutral'></span>
  166 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    function log(uint256 p0) internal view {</span>
  179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>    function log(int256 p0) internal view {</span>
  183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
  184 |     | <span class='neutral'>    }</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  192 |     | <span class='neutral'>    }</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal view {</span>
  199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  200 |     | <span class='neutral'>    }</span>
  201 |     | <span class='neutral'></span>
  202 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal view {</span>
  203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  204 |     | <span class='neutral'>    }</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal view {</span>
  207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal view {</span>
  211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal view {</span>
  215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  216 |     | <span class='neutral'>    }</span>
  217 |     | <span class='neutral'></span>
  218 |     | <span class='neutral'>    function log(string memory p0, int256 p1) internal view {</span>
  219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,int256)&quot;, p0, p1));</span>
  220 |     | <span class='neutral'>    }</span>
  221 |     | <span class='neutral'></span>
  222 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  228 |     | <span class='neutral'>    }</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  232 |     | <span class='neutral'>    }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal view {</span>
  235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  236 |     | <span class='neutral'>    }</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  240 |     | <span class='neutral'>    }</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  248 |     | <span class='neutral'>    }</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal view {</span>
  251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  252 |     | <span class='neutral'>    }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  256 |     | <span class='neutral'>    }</span>
  257 |     | <span class='neutral'></span>
  258 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  260 |     | <span class='neutral'>    }</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  264 |     | <span class='neutral'>    }</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal view {</span>
  267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  268 |     | <span class='neutral'>    }</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal view {</span>
  271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  272 |     | <span class='neutral'>    }</span>
  273 |     | <span class='neutral'></span>
  274 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal view {</span>
  275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal view {</span>
  279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal view {</span>
  283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  284 |     | <span class='neutral'>    }</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal view {</span>
  287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal view {</span>
  291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  292 |     | <span class='neutral'>    }</span>
  293 |     | <span class='neutral'></span>
  294 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal view {</span>
  295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal view {</span>
  299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  300 |     | <span class='neutral'>    }</span>
  301 |     | <span class='neutral'></span>
  302 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal view {</span>
  303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal view {</span>
  307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  308 |     | <span class='neutral'>    }</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal view {</span>
  311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  312 |     | <span class='neutral'>    }</span>
  313 |     | <span class='neutral'></span>
  314 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal view {</span>
  315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  316 |     | <span class='neutral'>    }</span>
  317 |     | <span class='neutral'></span>
  318 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal view {</span>
  319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  320 |     | <span class='neutral'>    }</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal view {</span>
  323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal view {</span>
  327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal view {</span>
  331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  332 |     | <span class='neutral'>    }</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal view {</span>
  335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  336 |     | <span class='neutral'>    }</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal view {</span>
  339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  340 |     | <span class='neutral'>    }</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal view {</span>
  343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal view {</span>
  347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  348 |     | <span class='neutral'>    }</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  356 |     | <span class='neutral'>    }</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal view {</span>
  363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  364 |     | <span class='neutral'>    }</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  368 |     | <span class='neutral'>    }</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  372 |     | <span class='neutral'>    }</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  376 |     | <span class='neutral'>    }</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal view {</span>
  379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  380 |     | <span class='neutral'>    }</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  388 |     | <span class='neutral'>    }</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  392 |     | <span class='neutral'>    }</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal view {</span>
  395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  396 |     | <span class='neutral'>    }</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal view {</span>
  399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  400 |     | <span class='neutral'>    }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal view {</span>
  403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  404 |     | <span class='neutral'>    }</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal view {</span>
  407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  408 |     | <span class='neutral'>    }</span>
  409 |     | <span class='neutral'></span>
  410 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal view {</span>
  411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  416 |     | <span class='neutral'>    }</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  420 |     | <span class='neutral'>    }</span>
  421 |     | <span class='neutral'></span>
  422 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  424 |     | <span class='neutral'>    }</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal view {</span>
  427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  428 |     | <span class='neutral'>    }</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  432 |     | <span class='neutral'>    }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  436 |     | <span class='neutral'>    }</span>
  437 |     | <span class='neutral'></span>
  438 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  440 |     | <span class='neutral'>    }</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal view {</span>
  443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  444 |     | <span class='neutral'>    }</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  448 |     | <span class='neutral'>    }</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  452 |     | <span class='neutral'>    }</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  456 |     | <span class='neutral'>    }</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal view {</span>
  459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal view {</span>
  463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  464 |     | <span class='neutral'>    }</span>
  465 |     | <span class='neutral'></span>
  466 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal view {</span>
  467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  468 |     | <span class='neutral'>    }</span>
  469 |     | <span class='neutral'></span>
  470 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal view {</span>
  471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  472 |     | <span class='neutral'>    }</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal view {</span>
  475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  476 |     | <span class='neutral'>    }</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  484 |     | <span class='neutral'>    }</span>
  485 |     | <span class='neutral'></span>
  486 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  488 |     | <span class='neutral'>    }</span>
  489 |     | <span class='neutral'></span>
  490 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal view {</span>
  491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  492 |     | <span class='neutral'>    }</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  500 |     | <span class='neutral'>    }</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  504 |     | <span class='neutral'>    }</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal view {</span>
  507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  508 |     | <span class='neutral'>    }</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  512 |     | <span class='neutral'>    }</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  516 |     | <span class='neutral'>    }</span>
  517 |     | <span class='neutral'></span>
  518 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  520 |     | <span class='neutral'>    }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  524 |     | <span class='neutral'>    }</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  528 |     | <span class='neutral'>    }</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  532 |     | <span class='neutral'>    }</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  536 |     | <span class='neutral'>    }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  544 |     | <span class='neutral'>    }</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  547 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {</span>
  551 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  552 |     | <span class='neutral'>    }</span>
  553 |     | <span class='neutral'></span>
  554 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  555 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  556 |     | <span class='neutral'>    }</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  559 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  560 |     | <span class='neutral'>    }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {</span>
  563 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  564 |     | <span class='neutral'>    }</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {</span>
  567 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  568 |     | <span class='neutral'>    }</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  571 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  572 |     | <span class='neutral'>    }</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {</span>
  575 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  576 |     | <span class='neutral'>    }</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {</span>
  579 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {</span>
  583 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  584 |     | <span class='neutral'>    }</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  587 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  588 |     | <span class='neutral'>    }</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  591 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  592 |     | <span class='neutral'>    }</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  595 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  596 |     | <span class='neutral'>    }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {</span>
  599 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  600 |     | <span class='neutral'>    }</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  603 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  604 |     | <span class='neutral'>    }</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  607 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {</span>
  611 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {</span>
  615 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  616 |     | <span class='neutral'>    }</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  619 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  620 |     | <span class='neutral'>    }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {</span>
  623 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {</span>
  627 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {</span>
  631 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  632 |     | <span class='neutral'>    }</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {</span>
  635 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  636 |     | <span class='neutral'>    }</span>
  637 |     | <span class='neutral'></span>
  638 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {</span>
  639 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  640 |     | <span class='neutral'>    }</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {</span>
  643 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  644 |     | <span class='neutral'>    }</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal view {</span>
  647 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  651 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  655 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  656 |     | <span class='neutral'>    }</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {</span>
  659 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  660 |     | <span class='neutral'>    }</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {</span>
  663 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  664 |     | <span class='neutral'>    }</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  667 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  668 |     | <span class='neutral'>    }</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {</span>
  671 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  672 |     | <span class='neutral'>    }</span>
  673 |     | <span class='neutral'></span>
  674 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {</span>
  675 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  676 |     | <span class='neutral'>    }</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {</span>
  679 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  680 |     | <span class='neutral'>    }</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {</span>
  683 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {</span>
  687 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  688 |     | <span class='neutral'>    }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {</span>
  691 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  692 |     | <span class='neutral'>    }</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal view {</span>
  695 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {</span>
  699 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  700 |     | <span class='neutral'>    }</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {</span>
  703 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  704 |     | <span class='neutral'>    }</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal view {</span>
  707 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  708 |     | <span class='neutral'>    }</span>
  709 |     | <span class='neutral'></span>
  710 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal view {</span>
  711 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  712 |     | <span class='neutral'>    }</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  715 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  716 |     | <span class='neutral'>    }</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {</span>
  719 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  720 |     | <span class='neutral'>    }</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {</span>
  723 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {</span>
  727 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  728 |     | <span class='neutral'>    }</span>
  729 |     | <span class='neutral'></span>
  730 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {</span>
  731 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  732 |     | <span class='neutral'>    }</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {</span>
  735 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  736 |     | <span class='neutral'>    }</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {</span>
  739 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  740 |     | <span class='neutral'>    }</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal view {</span>
  743 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {</span>
  747 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  748 |     | <span class='neutral'>    }</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {</span>
  751 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal view {</span>
  755 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  756 |     | <span class='neutral'>    }</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal view {</span>
  759 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {</span>
  763 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  764 |     | <span class='neutral'>    }</span>
  765 |     | <span class='neutral'></span>
  766 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal view {</span>
  767 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  768 |     | <span class='neutral'>    }</span>
  769 |     | <span class='neutral'></span>
  770 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal view {</span>
  771 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal view {</span>
  775 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  779 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  783 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  784 |     | <span class='neutral'>    }</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  787 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  791 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  795 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  799 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  800 |     | <span class='neutral'>    }</span>
  801 |     | <span class='neutral'></span>
  802 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  803 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  804 |     | <span class='neutral'>    }</span>
  805 |     | <span class='neutral'></span>
  806 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {</span>
  807 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  811 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  812 |     | <span class='neutral'>    }</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  815 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  816 |     | <span class='neutral'>    }</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {</span>
  819 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  820 |     | <span class='neutral'>    }</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {</span>
  823 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  824 |     | <span class='neutral'>    }</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  827 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  828 |     | <span class='neutral'>    }</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {</span>
  831 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  832 |     | <span class='neutral'>    }</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {</span>
  835 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  836 |     | <span class='neutral'>    }</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal view {</span>
  839 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  840 |     | <span class='neutral'>    }</span>
  841 |     | <span class='neutral'></span>
  842 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  843 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  844 |     | <span class='neutral'>    }</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  847 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  848 |     | <span class='neutral'>    }</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  851 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  852 |     | <span class='neutral'>    }</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {</span>
  855 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  856 |     | <span class='neutral'>    }</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  859 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  863 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  867 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  868 |     | <span class='neutral'>    }</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  871 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  872 |     | <span class='neutral'>    }</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  875 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  876 |     | <span class='neutral'>    }</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  879 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  880 |     | <span class='neutral'>    }</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  883 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  887 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {</span>
  891 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  892 |     | <span class='neutral'>    }</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  895 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  896 |     | <span class='neutral'>    }</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  899 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  900 |     | <span class='neutral'>    }</span>
  901 |     | <span class='neutral'></span>
  902 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  903 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  907 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  908 |     | <span class='neutral'>    }</span>
  909 |     | <span class='neutral'></span>
  910 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  911 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  912 |     | <span class='neutral'>    }</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {</span>
  915 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  916 |     | <span class='neutral'>    }</span>
  917 |     | <span class='neutral'></span>
  918 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {</span>
  919 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  920 |     | <span class='neutral'>    }</span>
  921 |     | <span class='neutral'></span>
  922 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  923 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  924 |     | <span class='neutral'>    }</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  927 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  928 |     | <span class='neutral'>    }</span>
  929 |     | <span class='neutral'></span>
  930 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  931 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  935 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  936 |     | <span class='neutral'>    }</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {</span>
  939 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  943 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  944 |     | <span class='neutral'>    }</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  947 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  951 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  952 |     | <span class='neutral'>    }</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {</span>
  955 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  956 |     | <span class='neutral'>    }</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  959 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  960 |     | <span class='neutral'>    }</span>
  961 |     | <span class='neutral'></span>
  962 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  963 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  964 |     | <span class='neutral'>    }</span>
  965 |     | <span class='neutral'></span>
  966 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  967 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  968 |     | <span class='neutral'>    }</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  971 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  972 |     | <span class='neutral'>    }</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {</span>
  975 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {</span>
  979 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal view {</span>
  983 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  984 |     | <span class='neutral'>    }</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {</span>
  987 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  991 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  992 |     | <span class='neutral'>    }</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  995 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  996 |     | <span class='neutral'>    }</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  999 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {</span>
 1003 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
 1007 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
 1011 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1015 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1016 |     | <span class='neutral'>    }</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal view {</span>
 1019 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1023 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1024 |     | <span class='neutral'>    }</span>
 1025 |     | <span class='neutral'></span>
 1026 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1027 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1028 |     | <span class='neutral'>    }</span>
 1029 |     | <span class='neutral'></span>
 1030 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1031 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1032 |     | <span class='neutral'>    }</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1035 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1036 |     | <span class='neutral'>    }</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1039 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1040 |     | <span class='neutral'>    }</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1043 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1044 |     | <span class='neutral'>    }</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1047 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1048 |     | <span class='neutral'>    }</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1051 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1052 |     | <span class='neutral'>    }</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1055 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1056 |     | <span class='neutral'>    }</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1059 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1060 |     | <span class='neutral'>    }</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1063 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1064 |     | <span class='neutral'>    }</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1067 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1068 |     | <span class='neutral'>    }</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1071 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1072 |     | <span class='neutral'>    }</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1075 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1076 |     | <span class='neutral'>    }</span>
 1077 |     | <span class='neutral'></span>
 1078 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal view {</span>
 1079 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1080 |     | <span class='neutral'>    }</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1083 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1084 |     | <span class='neutral'>    }</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1087 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1088 |     | <span class='neutral'>    }</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal view {</span>
 1091 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1092 |     | <span class='neutral'>    }</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal view {</span>
 1095 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1096 |     | <span class='neutral'>    }</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1099 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1100 |     | <span class='neutral'>    }</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1104 |     | <span class='neutral'>    }</span>
 1105 |     | <span class='neutral'></span>
 1106 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1108 |     | <span class='neutral'>    }</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1112 |     | <span class='neutral'>    }</span>
 1113 |     | <span class='neutral'></span>
 1114 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1116 |     | <span class='neutral'>    }</span>
 1117 |     | <span class='neutral'></span>
 1118 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1124 |     | <span class='neutral'>    }</span>
 1125 |     | <span class='neutral'></span>
 1126 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1128 |     | <span class='neutral'>    }</span>
 1129 |     | <span class='neutral'></span>
 1130 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1132 |     | <span class='neutral'>    }</span>
 1133 |     | <span class='neutral'></span>
 1134 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1136 |     | <span class='neutral'>    }</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1140 |     | <span class='neutral'>    }</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1144 |     | <span class='neutral'>    }</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1152 |     | <span class='neutral'>    }</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1156 |     | <span class='neutral'>    }</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1160 |     | <span class='neutral'>    }</span>
 1161 |     | <span class='neutral'></span>
 1162 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1164 |     | <span class='neutral'>    }</span>
 1165 |     | <span class='neutral'></span>
 1166 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1168 |     | <span class='neutral'>    }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'></span>
 1174 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal view {</span>
 1175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1176 |     | <span class='neutral'>    }</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1180 |     | <span class='neutral'>    }</span>
 1181 |     | <span class='neutral'></span>
 1182 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1184 |     | <span class='neutral'>    }</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1188 |     | <span class='neutral'>    }</span>
 1189 |     | <span class='neutral'></span>
 1190 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1192 |     | <span class='neutral'>    }</span>
 1193 |     | <span class='neutral'></span>
 1194 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1200 |     | <span class='neutral'>    }</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1204 |     | <span class='neutral'>    }</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1208 |     | <span class='neutral'>    }</span>
 1209 |     | <span class='neutral'></span>
 1210 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal view {</span>
 1211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1212 |     | <span class='neutral'>    }</span>
 1213 |     | <span class='neutral'></span>
 1214 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1216 |     | <span class='neutral'>    }</span>
 1217 |     | <span class='neutral'></span>
 1218 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1220 |     | <span class='neutral'>    }</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1224 |     | <span class='neutral'>    }</span>
 1225 |     | <span class='neutral'></span>
 1226 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1228 |     | <span class='neutral'>    }</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1232 |     | <span class='neutral'>    }</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal view {</span>
 1235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1236 |     | <span class='neutral'>    }</span>
 1237 |     | <span class='neutral'></span>
 1238 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal view {</span>
 1239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1240 |     | <span class='neutral'>    }</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1244 |     | <span class='neutral'>    }</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1252 |     | <span class='neutral'>    }</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1256 |     | <span class='neutral'>    }</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal view {</span>
 1259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1260 |     | <span class='neutral'>    }</span>
 1261 |     | <span class='neutral'></span>
 1262 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1264 |     | <span class='neutral'>    }</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1268 |     | <span class='neutral'>    }</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1272 |     | <span class='neutral'>    }</span>
 1273 |     | <span class='neutral'></span>
 1274 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal view {</span>
 1275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1276 |     | <span class='neutral'>    }</span>
 1277 |     | <span class='neutral'></span>
 1278 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1280 |     | <span class='neutral'>    }</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1284 |     | <span class='neutral'>    }</span>
 1285 |     | <span class='neutral'></span>
 1286 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1288 |     | <span class='neutral'>    }</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1292 |     | <span class='neutral'>    }</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1296 |     | <span class='neutral'>    }</span>
 1297 |     | <span class='neutral'></span>
 1298 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1300 |     | <span class='neutral'>    }</span>
 1301 |     | <span class='neutral'></span>
 1302 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1304 |     | <span class='neutral'>    }</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1308 |     | <span class='neutral'>    }</span>
 1309 |     | <span class='neutral'></span>
 1310 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1312 |     | <span class='neutral'>    }</span>
 1313 |     | <span class='neutral'></span>
 1314 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1316 |     | <span class='neutral'>    }</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1320 |     | <span class='neutral'>    }</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1324 |     | <span class='neutral'>    }</span>
 1325 |     | <span class='neutral'></span>
 1326 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1328 |     | <span class='neutral'>    }</span>
 1329 |     | <span class='neutral'></span>
 1330 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1332 |     | <span class='neutral'>    }</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal view {</span>
 1335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1336 |     | <span class='neutral'>    }</span>
 1337 |     | <span class='neutral'></span>
 1338 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1340 |     | <span class='neutral'>    }</span>
 1341 |     | <span class='neutral'></span>
 1342 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1344 |     | <span class='neutral'>    }</span>
 1345 |     | <span class='neutral'></span>
 1346 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal view {</span>
 1347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1348 |     | <span class='neutral'>    }</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal view {</span>
 1351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1352 |     | <span class='neutral'>    }</span>
 1353 |     | <span class='neutral'></span>
 1354 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1356 |     | <span class='neutral'>    }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1360 |     | <span class='neutral'>    }</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1364 |     | <span class='neutral'>    }</span>
 1365 |     | <span class='neutral'></span>
 1366 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1368 |     | <span class='neutral'>    }</span>
 1369 |     | <span class='neutral'></span>
 1370 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1372 |     | <span class='neutral'>    }</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1376 |     | <span class='neutral'>    }</span>
 1377 |     | <span class='neutral'></span>
 1378 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1380 |     | <span class='neutral'>    }</span>
 1381 |     | <span class='neutral'></span>
 1382 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1384 |     | <span class='neutral'>    }</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1388 |     | <span class='neutral'>    }</span>
 1389 |     | <span class='neutral'></span>
 1390 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1392 |     | <span class='neutral'>    }</span>
 1393 |     | <span class='neutral'></span>
 1394 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1396 |     | <span class='neutral'>    }</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1400 |     | <span class='neutral'>    }</span>
 1401 |     | <span class='neutral'></span>
 1402 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1404 |     | <span class='neutral'>    }</span>
 1405 |     | <span class='neutral'></span>
 1406 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1408 |     | <span class='neutral'>    }</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1412 |     | <span class='neutral'>    }</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1416 |     | <span class='neutral'>    }</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1420 |     | <span class='neutral'>    }</span>
 1421 |     | <span class='neutral'></span>
 1422 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1424 |     | <span class='neutral'>    }</span>
 1425 |     | <span class='neutral'></span>
 1426 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1428 |     | <span class='neutral'>    }</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal view {</span>
 1431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1432 |     | <span class='neutral'>    }</span>
 1433 |     | <span class='neutral'></span>
 1434 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1436 |     | <span class='neutral'>    }</span>
 1437 |     | <span class='neutral'></span>
 1438 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1440 |     | <span class='neutral'>    }</span>
 1441 |     | <span class='neutral'></span>
 1442 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1444 |     | <span class='neutral'>    }</span>
 1445 |     | <span class='neutral'></span>
 1446 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1448 |     | <span class='neutral'>    }</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1452 |     | <span class='neutral'>    }</span>
 1453 |     | <span class='neutral'></span>
 1454 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1456 |     | <span class='neutral'>    }</span>
 1457 |     | <span class='neutral'></span>
 1458 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1460 |     | <span class='neutral'>    }</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1464 |     | <span class='neutral'>    }</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal view {</span>
 1467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1468 |     | <span class='neutral'>    }</span>
 1469 |     | <span class='neutral'></span>
 1470 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1472 |     | <span class='neutral'>    }</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1476 |     | <span class='neutral'>    }</span>
 1477 |     | <span class='neutral'></span>
 1478 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1480 |     | <span class='neutral'>    }</span>
 1481 |     | <span class='neutral'></span>
 1482 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1484 |     | <span class='neutral'>    }</span>
 1485 |     | <span class='neutral'></span>
 1486 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1488 |     | <span class='neutral'>    }</span>
 1489 |     | <span class='neutral'></span>
 1490 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal view {</span>
 1491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1492 |     | <span class='neutral'>    }</span>
 1493 |     | <span class='neutral'></span>
 1494 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal view {</span>
 1495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1496 |     | <span class='neutral'>    }</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1500 |     | <span class='neutral'>    }</span>
 1501 |     | <span class='neutral'></span>
 1502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1504 |     | <span class='neutral'>    }</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1508 |     | <span class='neutral'>    }</span>
 1509 |     | <span class='neutral'></span>
 1510 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1512 |     | <span class='neutral'>    }</span>
 1513 |     | <span class='neutral'></span>
 1514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal view {</span>
 1515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1516 |     | <span class='neutral'>    }</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1520 |     | <span class='neutral'>    }</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1524 |     | <span class='neutral'>    }</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1528 |     | <span class='neutral'>    }</span>
 1529 |     | <span class='neutral'></span>
 1530 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal view {</span>
 1531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1532 |     | <span class='neutral'>    }</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1536 |     | <span class='neutral'>    }</span>
 1537 |     | <span class='neutral'></span>
 1538 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1540 |     | <span class='neutral'>    }</span>
 1541 |     | <span class='neutral'></span>
 1542 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1544 |     | <span class='neutral'>    }</span>
 1545 |     | <span class='neutral'></span>
 1546 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/root/code/hyper/lib/solmate/lib/ds-test/src/test.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   4 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
   5 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
   6 |     | <span class='neutral'>// (at your option) any later version.</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
   9 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  10 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  11 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  14 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  17 |     | <span class='unexecuted'></span>
  18 |     | <span class='neutral'>contract DSTest {</span>
  19 |     | <span class='neutral'>    event log                    (string);</span>
  20 |     | <span class='neutral'>    event logs                   (bytes);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event log_address            (address);</span>
  23 |     | <span class='neutral'>    event log_bytes32            (bytes32);</span>
  24 |     | <span class='neutral'>    event log_int                (int);</span>
  25 |     | <span class='neutral'>    event log_uint               (uint);</span>
  26 |     | <span class='neutral'>    event log_bytes              (bytes);</span>
  27 |     | <span class='neutral'>    event log_string             (string);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_named_address      (string key, address val);</span>
  30 |     | <span class='neutral'>    event log_named_bytes32      (string key, bytes32 val);</span>
  31 |     | <span class='neutral'>    event log_named_decimal_int  (string key, int val, uint decimals);</span>
  32 |     | <span class='neutral'>    event log_named_decimal_uint (string key, uint val, uint decimals);</span>
  33 |     | <span class='neutral'>    event log_named_int          (string key, int val);</span>
  34 |     | <span class='neutral'>    event log_named_uint         (string key, uint val);</span>
  35 |     | <span class='neutral'>    event log_named_bytes        (string key, bytes val);</span>
  36 |     | <span class='neutral'>    event log_named_string       (string key, string val);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    bool public IS_TEST = true;</span>
  39 |     | <span class='neutral'>    bool private _failed;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    address constant HEVM_ADDRESS =</span>
  42 |     | <span class='unexecuted'>        address(bytes20(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier mayRevert() { _; }</span>
  45 |     | <span class='neutral'>    modifier testopts(string memory) { _; }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function failed() public returns (bool) {</span>
  48 |     | <span class='unexecuted'>        if (_failed) {</span>
  49 |     | <span class='unexecuted'>            return _failed;</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='unexecuted'>            bool globalFailed = false;</span>
  52 |     | <span class='unexecuted'>            if (hasHEVMContext()) {</span>
  53 |     | <span class='unexecuted'>                (, bytes memory retdata) = HEVM_ADDRESS.call(</span>
  54 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
  55 |     | <span class='unexecuted'>                        bytes4(keccak256(&quot;load(address,bytes32)&quot;)),</span>
  56 |     | <span class='unexecuted'>                        abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;))</span>
  57 |     | <span class='neutral'>                    )</span>
  58 |     | <span class='neutral'>                );</span>
  59 |     | <span class='unexecuted'>                globalFailed = abi.decode(retdata, (bool));</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='unexecuted'>            return globalFailed;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    } </span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function fail() internal {</span>
  66 |     | <span class='unexecuted'>        if (hasHEVMContext()) {</span>
  67 |     | <span class='unexecuted'>            (bool status, ) = HEVM_ADDRESS.call(</span>
  68 |     | <span class='unexecuted'>                abi.encodePacked(</span>
  69 |     | <span class='unexecuted'>                    bytes4(keccak256(&quot;store(address,bytes32,bytes32)&quot;)),</span>
  70 |     | <span class='unexecuted'>                    abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;), bytes32(uint256(0x01)))</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>            status; // Silence compiler warnings</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='unexecuted'>        _failed = true;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function hasHEVMContext() internal view returns (bool) {</span>
  79 |     | <span class='neutral'>        uint256 hevmCodeSize = 0;</span>
  80 |     | <span class='neutral'>        assembly {</span>
  81 |     | <span class='unexecuted'>            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='unexecuted'>        return hevmCodeSize &gt; 0;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    modifier logs_gas() {</span>
  87 |     | <span class='neutral'>        uint startGas = gasleft();</span>
  88 |     | <span class='neutral'>        _;</span>
  89 |     | <span class='neutral'>        uint endGas = gasleft();</span>
  90 |     | <span class='neutral'>        emit log_named_uint(&quot;gas&quot;, startGas - endGas);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function assertTrue(bool condition) internal {</span>
  94 |     | <span class='unexecuted'>        if (!condition) {</span>
  95 |     | <span class='unexecuted'>            emit log(&quot;Error: Assertion Failed&quot;);</span>
  96 |     | <span class='unexecuted'>            fail();</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function assertTrue(bool condition, string memory err) internal {</span>
 101 |     | <span class='unexecuted'>        if (!condition) {</span>
 102 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 103 |     | <span class='unexecuted'>            assertTrue(condition);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function assertEq(address a, address b) internal {</span>
 108 |     | <span class='unexecuted'>        if (a != b) {</span>
 109 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [address]&quot;);</span>
 110 |     | <span class='unexecuted'>            emit log_named_address(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='unexecuted'>            emit log_named_address(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='unexecuted'>            fail();</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='unexecuted'>    function assertEq(address a, address b, string memory err) internal {</span>
 116 |     | <span class='unexecuted'>        if (a != b) {</span>
 117 |     | <span class='unexecuted'>            emit log_named_string (&quot;Error&quot;, err);</span>
 118 |     | <span class='unexecuted'>            assertEq(a, b);</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b) internal {</span>
 123 |     | <span class='neutral'>        if (a != b) {</span>
 124 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes32]&quot;);</span>
 125 |     | <span class='neutral'>            emit log_named_bytes32(&quot;  Expected&quot;, b);</span>
 126 |     | <span class='neutral'>            emit log_named_bytes32(&quot;    Actual&quot;, a);</span>
 127 |     | <span class='neutral'>            fail();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b, string memory err) internal {</span>
 131 |     | <span class='neutral'>        if (a != b) {</span>
 132 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 133 |     | <span class='neutral'>            assertEq(a, b);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b) internal {</span>
 137 |     | <span class='neutral'>        assertEq(a, b);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {</span>
 140 |     | <span class='neutral'>        assertEq(a, b, err);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>    function assertEq(int a, int b) internal {</span>
 144 |     | <span class='unexecuted'>        if (a != b) {</span>
 145 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [int]&quot;);</span>
 146 |     | <span class='unexecuted'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 147 |     | <span class='unexecuted'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 148 |     | <span class='unexecuted'>            fail();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='unexecuted'>    function assertEq(int a, int b, string memory err) internal {</span>
 152 |     | <span class='unexecuted'>        if (a != b) {</span>
 153 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 154 |     | <span class='unexecuted'>            assertEq(a, b);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='unexecuted'>    function assertEq(uint a, uint b) internal {</span>
 158 |     | <span class='unexecuted'>        if (a != b) {</span>
 159 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [uint]&quot;);</span>
 160 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 161 |     | <span class='unexecuted'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 162 |     | <span class='unexecuted'>            fail();</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='unexecuted'>    function assertEq(uint a, uint b, string memory err) internal {</span>
 166 |     | <span class='unexecuted'>        if (a != b) {</span>
 167 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 168 |     | <span class='unexecuted'>            assertEq(a, b);</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals) internal {</span>
 172 |     | <span class='neutral'>        if (a != b) {</span>
 173 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal int]&quot;);</span>
 174 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Expected&quot;, b, decimals);</span>
 175 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;    Actual&quot;, a, decimals);</span>
 176 |     | <span class='neutral'>            fail();</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 180 |     | <span class='neutral'>        if (a != b) {</span>
 181 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 182 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals) internal {</span>
 186 |     | <span class='neutral'>        if (a != b) {</span>
 187 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal uint]&quot;);</span>
 188 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Expected&quot;, b, decimals);</span>
 189 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;    Actual&quot;, a, decimals);</span>
 190 |     | <span class='neutral'>            fail();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 194 |     | <span class='neutral'>        if (a != b) {</span>
 195 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 196 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>    function assertGt(uint a, uint b) internal {</span>
 201 |     | <span class='unexecuted'>        if (a &lt;= b) {</span>
 202 |     | <span class='unexecuted'>            emit log(&quot;Error: a &gt; b not satisfied [uint]&quot;);</span>
 203 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 204 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 205 |     | <span class='unexecuted'>            fail();</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'>    function assertGt(uint a, uint b, string memory err) internal {</span>
 209 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 210 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 211 |     | <span class='neutral'>            assertGt(a, b);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>    function assertGt(int a, int b) internal {</span>
 215 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 216 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [int]&quot;);</span>
 217 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 218 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 219 |     | <span class='neutral'>            fail();</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>    function assertGt(int a, int b, string memory err) internal {</span>
 223 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 224 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 225 |     | <span class='neutral'>            assertGt(a, b);</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals) internal {</span>
 229 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 230 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal int]&quot;);</span>
 231 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 232 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 233 |     | <span class='neutral'>            fail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 237 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 238 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 239 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals) internal {</span>
 243 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 244 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal uint]&quot;);</span>
 245 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 246 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 247 |     | <span class='neutral'>            fail();</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 251 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 252 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 253 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    function assertGe(uint a, uint b) internal {</span>
 258 |     | <span class='neutral'>        if (a &lt; b) {</span>
 259 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [uint]&quot;);</span>
 260 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 261 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 262 |     | <span class='neutral'>            fail();</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>    function assertGe(uint a, uint b, string memory err) internal {</span>
 266 |     | <span class='neutral'>        if (a &lt; b) {</span>
 267 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 268 |     | <span class='neutral'>            assertGe(a, b);</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'>    function assertGe(int a, int b) internal {</span>
 272 |     | <span class='neutral'>        if (a &lt; b) {</span>
 273 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [int]&quot;);</span>
 274 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 275 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 276 |     | <span class='neutral'>            fail();</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'>    function assertGe(int a, int b, string memory err) internal {</span>
 280 |     | <span class='neutral'>        if (a &lt; b) {</span>
 281 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 282 |     | <span class='neutral'>            assertGe(a, b);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals) internal {</span>
 286 |     | <span class='neutral'>        if (a &lt; b) {</span>
 287 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal int]&quot;);</span>
 288 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 289 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 290 |     | <span class='neutral'>            fail();</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 294 |     | <span class='neutral'>        if (a &lt; b) {</span>
 295 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 296 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals) internal {</span>
 300 |     | <span class='neutral'>        if (a &lt; b) {</span>
 301 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal uint]&quot;);</span>
 302 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 303 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 304 |     | <span class='neutral'>            fail();</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 308 |     | <span class='neutral'>        if (a &lt; b) {</span>
 309 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 310 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function assertLt(uint a, uint b) internal {</span>
 315 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 316 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [uint]&quot;);</span>
 317 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 318 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 319 |     | <span class='neutral'>            fail();</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'>    function assertLt(uint a, uint b, string memory err) internal {</span>
 323 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 324 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 325 |     | <span class='neutral'>            assertLt(a, b);</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'>    function assertLt(int a, int b) internal {</span>
 329 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 330 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [int]&quot;);</span>
 331 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 332 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 333 |     | <span class='neutral'>            fail();</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>    function assertLt(int a, int b, string memory err) internal {</span>
 337 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 338 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 339 |     | <span class='neutral'>            assertLt(a, b);</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals) internal {</span>
 343 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 344 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal int]&quot;);</span>
 345 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 346 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 347 |     | <span class='neutral'>            fail();</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 351 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 352 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 353 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals) internal {</span>
 357 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 358 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal uint]&quot;);</span>
 359 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 360 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 361 |     | <span class='neutral'>            fail();</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 365 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 366 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 367 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function assertLe(uint a, uint b) internal {</span>
 372 |     | <span class='neutral'>        if (a &gt; b) {</span>
 373 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [uint]&quot;);</span>
 374 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 375 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 376 |     | <span class='neutral'>            fail();</span>
 377 |     | <span class='neutral'>        }</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>    function assertLe(uint a, uint b, string memory err) internal {</span>
 380 |     | <span class='neutral'>        if (a &gt; b) {</span>
 381 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 382 |     | <span class='neutral'>            assertLe(a, b);</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'>    function assertLe(int a, int b) internal {</span>
 386 |     | <span class='neutral'>        if (a &gt; b) {</span>
 387 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [int]&quot;);</span>
 388 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 389 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 390 |     | <span class='neutral'>            fail();</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'>    function assertLe(int a, int b, string memory err) internal {</span>
 394 |     | <span class='neutral'>        if (a &gt; b) {</span>
 395 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 396 |     | <span class='neutral'>            assertLe(a, b);</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals) internal {</span>
 400 |     | <span class='neutral'>        if (a &gt; b) {</span>
 401 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal int]&quot;);</span>
 402 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 403 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 404 |     | <span class='neutral'>            fail();</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 408 |     | <span class='neutral'>        if (a &gt; b) {</span>
 409 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 410 |     | <span class='neutral'>            assertLeDecimal(a, b, decimals);</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals) internal {</span>
 414 |     | <span class='neutral'>        if (a &gt; b) {</span>
 415 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal uint]&quot;);</span>
 416 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 417 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 418 |     | <span class='neutral'>            fail();</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'>    }</span>
 421 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 422 |     | <span class='neutral'>        if (a &gt; b) {</span>
 423 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 424 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertEq(string memory a, string memory b) internal {</span>
 429 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 430 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [string]&quot;);</span>
 431 |     | <span class='neutral'>            emit log_named_string(&quot;  Expected&quot;, b);</span>
 432 |     | <span class='neutral'>            emit log_named_string(&quot;    Actual&quot;, a);</span>
 433 |     | <span class='neutral'>            fail();</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'>    function assertEq(string memory a, string memory b, string memory err) internal {</span>
 437 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 438 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 439 |     | <span class='neutral'>            assertEq(a, b);</span>
 440 |     | <span class='neutral'>        }</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='unexecuted'>    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {</span>
 444 |     | <span class='unexecuted'>        ok = true;</span>
 445 |     | <span class='unexecuted'>        if (a.length == b.length) {</span>
 446 |     | <span class='unexecuted'>            for (uint i = 0; i &lt; a.length; i++) {</span>
 447 |     | <span class='unexecuted'>                if (a[i] != b[i]) {</span>
 448 |     | <span class='unexecuted'>                    ok = false;</span>
 449 |     | <span class='neutral'>                }</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        } else {</span>
 452 |     | <span class='unexecuted'>            ok = false;</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='unexecuted'>    function assertEq0(bytes memory a, bytes memory b) internal {</span>
 456 |     | <span class='unexecuted'>        if (!checkEq0(a, b)) {</span>
 457 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [bytes]&quot;);</span>
 458 |     | <span class='unexecuted'>            emit log_named_bytes(&quot;  Expected&quot;, b);</span>
 459 |     | <span class='unexecuted'>            emit log_named_bytes(&quot;    Actual&quot;, a);</span>
 460 |     | <span class='neutral'>            fail();</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {</span>
 464 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 465 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 466 |     | <span class='neutral'>            assertEq0(a, b);</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'>}</span>
 470 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solmate/src/tokens/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)</span>
   7 |     | <span class='neutral'>/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.</span>
   8 |     | <span class='neutral'>abstract contract ERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                                 EVENTS</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 amount);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 amount);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>                            METADATA STORAGE</span>
  19 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  20 |     | <span class='neutral'></span>
  21 | *r  | <span class='executed'>    string public name;</span>
  22 |     | <span class='neutral'></span>
  23 | *r  | <span class='executed'>    string public symbol;</span>
  24 |     | <span class='neutral'></span>
  25 | *r  | <span class='executed'>    uint8 public immutable decimals;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 | *r  | <span class='executed'>    uint256 public totalSupply;</span>
  32 |     | <span class='neutral'></span>
  33 | *r  | <span class='executed'>    mapping(address =&gt; uint256) public balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 | *r  | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  38 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  39 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    uint256 internal immutable INITIAL_CHAIN_ID;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;</span>
  44 |     | <span class='neutral'></span>
  45 | *r  | <span class='executed'>    mapping(address =&gt; uint256) public nonces;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  48 |     | <span class='neutral'>                               CONSTRUCTOR</span>
  49 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    constructor(</span>
  52 |     | <span class='neutral'>        string memory _name,</span>
  53 |     | <span class='neutral'>        string memory _symbol,</span>
  54 |     | <span class='neutral'>        uint8 _decimals</span>
  55 |     | <span class='neutral'>    ) {</span>
  56 |     | <span class='unexecuted'>        name = _name;</span>
  57 |     | <span class='unexecuted'>        symbol = _symbol;</span>
  58 |     | <span class='unexecuted'>        decimals = _decimals;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = block.chainid;</span>
  61 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  65 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  66 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  67 |     | <span class='neutral'></span>
  68 | *r  | <span class='executed'>    function approve(address spender, uint256 amount) public virtual returns (bool) {</span>
  69 | *   | <span class='executed'>        allowance[msg.sender][spender] = amount;</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>        emit Approval(msg.sender, spender, amount);</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        return true;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 | *r  | <span class='executed'>    function transfer(address to, uint256 amount) public virtual returns (bool) {</span>
  77 | *r  | <span class='executed'>        balanceOf[msg.sender] -= amount;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
  80 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
  81 |     | <span class='neutral'>        unchecked {</span>
  82 | *   | <span class='executed'>            balanceOf[to] += amount;</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'></span>
  85 | *   | <span class='executed'>        emit Transfer(msg.sender, to, amount);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        return true;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 | *r  | <span class='executed'>    function transferFrom(</span>
  91 |     | <span class='neutral'>        address from,</span>
  92 |     | <span class='neutral'>        address to,</span>
  93 |     | <span class='neutral'>        uint256 amount</span>
  94 | *r  | <span class='executed'>    ) public virtual returns (bool) {</span>
  95 | *r  | <span class='executed'>        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
  96 |     | <span class='neutral'></span>
  97 | *r  | <span class='executed'>        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;</span>
  98 |     | <span class='neutral'></span>
  99 | *r  | <span class='executed'>        balanceOf[from] -= amount;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
 102 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
 103 |     | <span class='neutral'>        unchecked {</span>
 104 | *   | <span class='executed'>            balanceOf[to] += amount;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        return true;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 113 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 114 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 115 |     | <span class='neutral'></span>
 116 | r   | <span class='reverted'>    function permit(</span>
 117 |     | <span class='neutral'>        address owner,</span>
 118 |     | <span class='neutral'>        address spender,</span>
 119 |     | <span class='neutral'>        uint256 value,</span>
 120 |     | <span class='neutral'>        uint256 deadline,</span>
 121 |     | <span class='neutral'>        uint8 v,</span>
 122 |     | <span class='neutral'>        bytes32 r,</span>
 123 |     | <span class='neutral'>        bytes32 s</span>
 124 |     | <span class='neutral'>    ) public virtual {</span>
 125 | r   | <span class='reverted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Unchecked because the only math done is incrementing</span>
 128 |     | <span class='neutral'>        // the owner&#39;s nonce which cannot realistically overflow.</span>
 129 |     | <span class='neutral'>        unchecked {</span>
 130 | r   | <span class='reverted'>            address recoveredAddress = ecrecover(</span>
 131 | r   | <span class='reverted'>                keccak256(</span>
 132 | r   | <span class='reverted'>                    abi.encodePacked(</span>
 133 |     | <span class='neutral'>                        &quot;\x19\x01&quot;,</span>
 134 | r   | <span class='reverted'>                        DOMAIN_SEPARATOR(),</span>
 135 | r   | <span class='reverted'>                        keccak256(</span>
 136 | r   | <span class='reverted'>                            abi.encode(</span>
 137 | r   | <span class='reverted'>                                keccak256(</span>
 138 |     | <span class='neutral'>                                    &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 139 |     | <span class='neutral'>                                ),</span>
 140 |     | <span class='neutral'>                                owner,</span>
 141 |     | <span class='neutral'>                                spender,</span>
 142 |     | <span class='neutral'>                                value,</span>
 143 | r   | <span class='reverted'>                                nonces[owner]++,</span>
 144 |     | <span class='neutral'>                                deadline</span>
 145 |     | <span class='neutral'>                            )</span>
 146 |     | <span class='neutral'>                        )</span>
 147 |     | <span class='neutral'>                    )</span>
 148 |     | <span class='neutral'>                ),</span>
 149 |     | <span class='neutral'>                v,</span>
 150 |     | <span class='neutral'>                r,</span>
 151 |     | <span class='neutral'>                s</span>
 152 |     | <span class='neutral'>            );</span>
 153 |     | <span class='neutral'></span>
 154 | r   | <span class='reverted'>            require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>            allowance[recoveredAddress][spender] = value;</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 | *r  | <span class='executed'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 163 | *r  | <span class='executed'>        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 167 |     | <span class='unexecuted'>        return</span>
 168 |     | <span class='unexecuted'>            keccak256(</span>
 169 |     | <span class='unexecuted'>                abi.encode(</span>
 170 |     | <span class='unexecuted'>                    keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 171 |     | <span class='unexecuted'>                    keccak256(bytes(name)),</span>
 172 |     | <span class='unexecuted'>                    keccak256(&quot;1&quot;),</span>
 173 |     | <span class='unexecuted'>                    block.chainid,</span>
 174 |     | <span class='unexecuted'>                    address(this)</span>
 175 |     | <span class='neutral'>                )</span>
 176 |     | <span class='neutral'>            );</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 180 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 181 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 182 |     | <span class='neutral'></span>
 183 | *r  | <span class='executed'>    function _mint(address to, uint256 amount) internal virtual {</span>
 184 | *r  | <span class='executed'>        totalSupply += amount;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
 187 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
 188 |     | <span class='neutral'>        unchecked {</span>
 189 | *r  | <span class='executed'>            balanceOf[to] += amount;</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'></span>
 192 | *r  | <span class='executed'>        emit Transfer(address(0), to, amount);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 | *r  | <span class='executed'>    function _burn(address from, uint256 amount) internal virtual {</span>
 196 | *r  | <span class='executed'>        balanceOf[from] -= amount;</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        // Cannot underflow because a user&#39;s balance</span>
 199 |     | <span class='neutral'>        // will never be larger than the total supply.</span>
 200 |     | <span class='neutral'>        unchecked {</span>
 201 | *   | <span class='executed'>            totalSupply -= amount;</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'></span>
 204 | *   | <span class='executed'>        emit Transfer(from, address(0), amount);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'>}</span>
 207 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solmate/src/tokens/WETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;./ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {SafeTransferLib} from &quot;../utils/SafeTransferLib.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @notice Minimalist and modern Wrapped Ether implementation.</span>
  9 |     | <span class='neutral'>/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)</span>
 10 | *r  | <span class='executed'>/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)</span>
 11 |     | <span class='unexecuted'>contract WETH is ERC20(&quot;Wrapped Ether&quot;, &quot;WETH&quot;, 18) {</span>
 12 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    event Deposit(address indexed from, uint256 amount);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    event Withdrawal(address indexed to, uint256 amount);</span>
 17 |     | <span class='neutral'></span>
 18 | *r  | <span class='executed'>    function deposit() public payable virtual {</span>
 19 | *r  | <span class='executed'>        _mint(msg.sender, msg.value);</span>
 20 |     | <span class='neutral'></span>
 21 | *r  | <span class='executed'>        emit Deposit(msg.sender, msg.value);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 | *r  | <span class='executed'>    function withdraw(uint256 amount) public virtual {</span>
 25 | *r  | <span class='executed'>        _burn(msg.sender, amount);</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>        emit Withdrawal(msg.sender, amount);</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>        msg.sender.safeTransferETH(amount);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    receive() external payable virtual {</span>
 33 | *r  | <span class='executed'>        deposit();</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solmate/src/utils/FixedPointMathLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Arithmetic library with operations for fixed-point numbers.</span>
   5 |     | <span class='unexecuted'>/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)</span>
   6 |     | <span class='neutral'>library FixedPointMathLib {</span>
   7 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
   8 |     | <span class='neutral'>                    SIMPLIFIED FIXED POINT OPERATIONS</span>
   9 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  10 |     | <span class='neutral'></span>
  11 | *r  | <span class='executed'>    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.</span>
  12 |     | <span class='neutral'></span>
  13 | *r  | <span class='executed'>    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  14 | *r  | <span class='executed'>        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 | *r  | <span class='executed'>    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  18 | *r  | <span class='executed'>        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 | *r  | <span class='executed'>    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  22 | *r  | <span class='executed'>        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  26 |     | <span class='unexecuted'>        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 | *r  | <span class='executed'>    function powWad(int256 x, int256 y) internal pure returns (int256) {</span>
  30 |     | <span class='neutral'>        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)</span>
  31 | *r  | <span class='executed'>        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 | *r  | <span class='executed'>    function expWad(int256 x) internal pure returns (int256 r) {</span>
  35 |     | <span class='neutral'>        unchecked {</span>
  36 |     | <span class='neutral'>            // When the result is &lt; 0.5 we return zero. This happens when</span>
  37 |     | <span class='neutral'>            // x &lt;= floor(log(0.5e18) * 1e18) ~ -42e18</span>
  38 | *r  | <span class='executed'>            if (x &lt;= -42139678854452767551) return 0;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>            // When the result is &gt; (2**255 - 1) / 1e18 we can not represent it as an</span>
  41 |     | <span class='neutral'>            // int. This happens when x &gt;= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.</span>
  42 | *r  | <span class='executed'>            if (x &gt;= 135305999368893231589) revert(&quot;EXP_OVERFLOW&quot;);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96</span>
  45 |     | <span class='neutral'>            // for more intermediate precision and a binary basis. This base conversion</span>
  46 |     | <span class='neutral'>            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.</span>
  47 | *r  | <span class='executed'>            x = (x &lt;&lt; 78) / 5**18;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers</span>
  50 |     | <span class='neutral'>            // of two such that exp(x) = exp(x&#39;) * 2**k, where k is an integer.</span>
  51 |     | <span class='neutral'>            // Solving this gives k = round(x / log(2)) and x&#39; = x - k * log(2).</span>
  52 | *r  | <span class='executed'>            int256 k = ((x &lt;&lt; 96) / 54916777467707473351141471128 + 2**95) &gt;&gt; 96;</span>
  53 | *r  | <span class='executed'>            x = x - k * 54916777467707473351141471128;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>            // k is in the range [-61, 195].</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>            // Evaluate using a (6, 7)-term rational approximation.</span>
  58 |     | <span class='neutral'>            // p is made monic, we&#39;ll multiply by a scale factor later.</span>
  59 | *r  | <span class='executed'>            int256 y = x + 1346386616545796478920950773328;</span>
  60 | *r  | <span class='executed'>            y = ((y * x) &gt;&gt; 96) + 57155421227552351082224309758442;</span>
  61 | *r  | <span class='executed'>            int256 p = y + x - 94201549194550492254356042504812;</span>
  62 | *r  | <span class='executed'>            p = ((p * y) &gt;&gt; 96) + 28719021644029726153956944680412240;</span>
  63 | *r  | <span class='executed'>            p = p * x + (4385272521454847904659076985693276 &lt;&lt; 96);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>            // We leave p in 2**192 basis so we don&#39;t need to scale it back up for the division.</span>
  66 | *r  | <span class='executed'>            int256 q = x - 2855989394907223263936484059900;</span>
  67 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 50020603652535783019961831881945;</span>
  68 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) - 533845033583426703283633433725380;</span>
  69 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 3604857256930695427073651918091429;</span>
  70 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) - 14423608567350463180887372962807573;</span>
  71 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 26449188498355588339934803723976023;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>            assembly {</span>
  74 |     | <span class='neutral'>                // Div in assembly because solidity adds a zero check despite the unchecked.</span>
  75 |     | <span class='neutral'>                // The q polynomial won&#39;t have zeros in the domain as all its roots are complex.</span>
  76 |     | <span class='neutral'>                // No scaling is necessary because p is already 2**96 too large.</span>
  77 | *r  | <span class='executed'>                r := sdiv(p, q)</span>
  78 |     | <span class='neutral'>            }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>            // r should be in the range (0.09, 0.25) * 2**96.</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>            // We now need to multiply r by:</span>
  83 |     | <span class='neutral'>            // * the scale factor s = ~6.031367120.</span>
  84 |     | <span class='neutral'>            // * the 2**k factor from the range reduction.</span>
  85 |     | <span class='neutral'>            // * the 1e18 / 2**96 factor for base conversion.</span>
  86 |     | <span class='neutral'>            // We do this all at once, with an intermediate result in 2**213</span>
  87 |     | <span class='neutral'>            // basis, so the final right shift is always by a positive amount.</span>
  88 | *r  | <span class='executed'>            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) &gt;&gt; uint256(195 - k));</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 | *r  | <span class='executed'>    function lnWad(int256 x) internal pure returns (int256 r) {</span>
  93 |     | <span class='neutral'>        unchecked {</span>
  94 | *r  | <span class='executed'>            require(x &gt; 0, &quot;UNDEFINED&quot;);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>            // We want to convert x from 10**18 fixed point to 2**96 fixed point.</span>
  97 |     | <span class='neutral'>            // We do this by multiplying by 2**96 / 10**18. But since</span>
  98 |     | <span class='neutral'>            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here</span>
  99 |     | <span class='neutral'>            // and add ln(2**96 / 10**18) at the end.</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>            // Reduce range of x to (1, 2) * 2**96</span>
 102 |     | <span class='neutral'>            // ln(2^k * x) = k * ln(2) + ln(x)</span>
 103 | *r  | <span class='executed'>            int256 k = int256(log2(uint256(x))) - 96;</span>
 104 | *r  | <span class='executed'>            x &lt;&lt;= uint256(159 - k);</span>
 105 | *r  | <span class='executed'>            x = int256(uint256(x) &gt;&gt; 159);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>            // Evaluate using a (8, 8)-term rational approximation.</span>
 108 |     | <span class='neutral'>            // p is made monic, we will multiply by a scale factor later.</span>
 109 | *r  | <span class='executed'>            int256 p = x + 3273285459638523848632254066296;</span>
 110 | *r  | <span class='executed'>            p = ((p * x) &gt;&gt; 96) + 24828157081833163892658089445524;</span>
 111 | *r  | <span class='executed'>            p = ((p * x) &gt;&gt; 96) + 43456485725739037958740375743393;</span>
 112 | *r  | <span class='executed'>            p = ((p * x) &gt;&gt; 96) - 11111509109440967052023855526967;</span>
 113 | *r  | <span class='executed'>            p = ((p * x) &gt;&gt; 96) - 45023709667254063763336534515857;</span>
 114 | *r  | <span class='executed'>            p = ((p * x) &gt;&gt; 96) - 14706773417378608786704636184526;</span>
 115 | *r  | <span class='executed'>            p = p * x - (795164235651350426258249787498 &lt;&lt; 96);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>            // We leave p in 2**192 basis so we don&#39;t need to scale it back up for the division.</span>
 118 |     | <span class='neutral'>            // q is monic by convention.</span>
 119 | *r  | <span class='executed'>            int256 q = x + 5573035233440673466300451813936;</span>
 120 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 71694874799317883764090561454958;</span>
 121 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 283447036172924575727196451306956;</span>
 122 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 401686690394027663651624208769553;</span>
 123 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 204048457590392012362485061816622;</span>
 124 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 31853899698501571402653359427138;</span>
 125 | *r  | <span class='executed'>            q = ((q * x) &gt;&gt; 96) + 909429971244387300277376558375;</span>
 126 |     | <span class='neutral'>            assembly {</span>
 127 |     | <span class='neutral'>                // Div in assembly because solidity adds a zero check despite the unchecked.</span>
 128 |     | <span class='neutral'>                // The q polynomial is known not to have zeros in the domain.</span>
 129 |     | <span class='neutral'>                // No scaling required because p is already 2**96 too large.</span>
 130 | *r  | <span class='executed'>                r := sdiv(p, q)</span>
 131 |     | <span class='neutral'>            }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>            // r is in the range (0, 0.125) * 2**96</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>            // Finalization, we need to:</span>
 136 |     | <span class='neutral'>            // * multiply by the scale factor s = 5.549…</span>
 137 |     | <span class='neutral'>            // * add ln(2**96 / 10**18)</span>
 138 |     | <span class='neutral'>            // * add k * ln(2)</span>
 139 |     | <span class='neutral'>            // * multiply by 10**18 / 2**96 = 5**18 &gt;&gt; 78</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192</span>
 142 | *r  | <span class='executed'>            r *= 1677202110996718588342820967067443963516166;</span>
 143 |     | <span class='neutral'>            // add ln(2) * k * 5e18 * 2**192</span>
 144 | *r  | <span class='executed'>            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;</span>
 145 |     | <span class='neutral'>            // add ln(2**96 / 10**18) * 5e18 * 2**192</span>
 146 | *r  | <span class='executed'>            r += 600920179829731861736702779321621459595472258049074101567377883020018308;</span>
 147 |     | <span class='neutral'>            // base conversion: mul 2**18 / 2**192</span>
 148 | *r  | <span class='executed'>            r &gt;&gt;= 174;</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 153 |     | <span class='neutral'>                    LOW LEVEL FIXED POINT OPERATIONS</span>
 154 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 155 |     | <span class='neutral'></span>
 156 | *r  | <span class='executed'>    function mulDivDown(</span>
 157 |     | <span class='neutral'>        uint256 x,</span>
 158 |     | <span class='neutral'>        uint256 y,</span>
 159 |     | <span class='neutral'>        uint256 denominator</span>
 160 |     | <span class='neutral'>    ) internal pure returns (uint256 z) {</span>
 161 |     | <span class='neutral'>        assembly {</span>
 162 |     | <span class='neutral'>            // Store x * y in z for now.</span>
 163 | *r  | <span class='executed'>            z := mul(x, y)</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>            // Equivalent to require(denominator != 0 &amp;&amp; (x == 0 || (x * y) / x == y))</span>
 166 | *r  | <span class='executed'>            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {</span>
 167 | r   | <span class='reverted'>                revert(0, 0)</span>
 168 |     | <span class='neutral'>            }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>            // Divide z by the denominator.</span>
 171 | *r  | <span class='executed'>            z := div(z, denominator)</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 | *r  | <span class='executed'>    function mulDivUp(</span>
 176 |     | <span class='neutral'>        uint256 x,</span>
 177 |     | <span class='neutral'>        uint256 y,</span>
 178 |     | <span class='neutral'>        uint256 denominator</span>
 179 |     | <span class='neutral'>    ) internal pure returns (uint256 z) {</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='neutral'>            // Store x * y in z for now.</span>
 182 | *r  | <span class='executed'>            z := mul(x, y)</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>            // Equivalent to require(denominator != 0 &amp;&amp; (x == 0 || (x * y) / x == y))</span>
 185 | *r  | <span class='executed'>            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {</span>
 186 |     | <span class='unexecuted'>                revert(0, 0)</span>
 187 |     | <span class='neutral'>            }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>            // First, divide z - 1 by the denominator and add 1.</span>
 190 |     | <span class='neutral'>            // We allow z - 1 to underflow if z is 0, because we multiply the</span>
 191 |     | <span class='neutral'>            // end result by 0 if z is zero, ensuring we return 0 if z is zero.</span>
 192 | *r  | <span class='executed'>            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))</span>
 193 |     | <span class='neutral'>        }</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function rpow(</span>
 197 |     | <span class='neutral'>        uint256 x,</span>
 198 |     | <span class='neutral'>        uint256 n,</span>
 199 |     | <span class='neutral'>        uint256 scalar</span>
 200 |     | <span class='neutral'>    ) internal pure returns (uint256 z) {</span>
 201 |     | <span class='neutral'>        assembly {</span>
 202 |     | <span class='neutral'>            switch x</span>
 203 |     | <span class='neutral'>            case 0 {</span>
 204 |     | <span class='neutral'>                switch n</span>
 205 |     | <span class='neutral'>                case 0 {</span>
 206 |     | <span class='neutral'>                    // 0 ** 0 = 1</span>
 207 |     | <span class='neutral'>                    z := scalar</span>
 208 |     | <span class='neutral'>                }</span>
 209 |     | <span class='neutral'>                default {</span>
 210 |     | <span class='neutral'>                    // 0 ** n = 0</span>
 211 |     | <span class='neutral'>                    z := 0</span>
 212 |     | <span class='neutral'>                }</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='neutral'>            default {</span>
 215 |     | <span class='neutral'>                switch mod(n, 2)</span>
 216 |     | <span class='neutral'>                case 0 {</span>
 217 |     | <span class='neutral'>                    // If n is even, store scalar in z for now.</span>
 218 |     | <span class='neutral'>                    z := scalar</span>
 219 |     | <span class='neutral'>                }</span>
 220 |     | <span class='neutral'>                default {</span>
 221 |     | <span class='neutral'>                    // If n is odd, store x in z for now.</span>
 222 |     | <span class='neutral'>                    z := x</span>
 223 |     | <span class='neutral'>                }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>                // Shifting right by 1 is like dividing by 2.</span>
 226 |     | <span class='neutral'>                let half := shr(1, scalar)</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>                for {</span>
 229 |     | <span class='neutral'>                    // Shift n right by 1 before looping to halve it.</span>
 230 |     | <span class='neutral'>                    n := shr(1, n)</span>
 231 |     | <span class='neutral'>                } n {</span>
 232 |     | <span class='neutral'>                    // Shift n right by 1 each iteration to halve it.</span>
 233 |     | <span class='neutral'>                    n := shr(1, n)</span>
 234 |     | <span class='neutral'>                } {</span>
 235 |     | <span class='neutral'>                    // Revert immediately if x ** 2 would overflow.</span>
 236 |     | <span class='neutral'>                    // Equivalent to iszero(eq(div(xx, x), x)) here.</span>
 237 |     | <span class='neutral'>                    if shr(128, x) {</span>
 238 |     | <span class='neutral'>                        revert(0, 0)</span>
 239 |     | <span class='neutral'>                    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>                    // Store x squared.</span>
 242 |     | <span class='neutral'>                    let xx := mul(x, x)</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>                    // Round to the nearest number.</span>
 245 |     | <span class='neutral'>                    let xxRound := add(xx, half)</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>                    // Revert if xx + half overflowed.</span>
 248 |     | <span class='neutral'>                    if lt(xxRound, xx) {</span>
 249 |     | <span class='neutral'>                        revert(0, 0)</span>
 250 |     | <span class='neutral'>                    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>                    // Set x to scaled xxRound.</span>
 253 |     | <span class='neutral'>                    x := div(xxRound, scalar)</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>                    // If n is even:</span>
 256 |     | <span class='neutral'>                    if mod(n, 2) {</span>
 257 |     | <span class='neutral'>                        // Compute z * x.</span>
 258 |     | <span class='neutral'>                        let zx := mul(z, x)</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>                        // If z * x overflowed:</span>
 261 |     | <span class='neutral'>                        if iszero(eq(div(zx, x), z)) {</span>
 262 |     | <span class='neutral'>                            // Revert if x is non-zero.</span>
 263 |     | <span class='neutral'>                            if iszero(iszero(x)) {</span>
 264 |     | <span class='neutral'>                                revert(0, 0)</span>
 265 |     | <span class='neutral'>                            }</span>
 266 |     | <span class='neutral'>                        }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>                        // Round to the nearest number.</span>
 269 |     | <span class='neutral'>                        let zxRound := add(zx, half)</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>                        // Revert if zx + half overflowed.</span>
 272 |     | <span class='neutral'>                        if lt(zxRound, zx) {</span>
 273 |     | <span class='neutral'>                            revert(0, 0)</span>
 274 |     | <span class='neutral'>                        }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>                        // Return properly scaled zxRound.</span>
 277 |     | <span class='neutral'>                        z := div(zxRound, scalar)</span>
 278 |     | <span class='neutral'>                    }</span>
 279 |     | <span class='neutral'>                }</span>
 280 |     | <span class='neutral'>            }</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 285 |     | <span class='neutral'>                        GENERAL NUMBER UTILITIES</span>
 286 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 287 |     | <span class='neutral'></span>
 288 | *r  | <span class='executed'>    function sqrt(uint256 x) internal pure returns (uint256 z) {</span>
 289 |     | <span class='neutral'>        assembly {</span>
 290 | *r  | <span class='executed'>            let y := x // We start y at x, which will help us make our initial estimate.</span>
 291 |     | <span class='neutral'></span>
 292 | *r  | <span class='executed'>            z := 181 // The &quot;correct&quot; value is 1, but this saves a multiplication later.</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad</span>
 295 |     | <span class='neutral'>            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>            // We check y &gt;= 2^(k + 8) but shift right by k bits</span>
 298 |     | <span class='neutral'>            // each branch to ensure that if x &gt;= 256, then y &gt;= 256.</span>
 299 | *r  | <span class='executed'>            if iszero(lt(y, 0x10000000000000000000000000000000000)) {</span>
 300 |     | <span class='unexecuted'>                y := shr(128, y)</span>
 301 |     | <span class='unexecuted'>                z := shl(64, z)</span>
 302 |     | <span class='neutral'>            }</span>
 303 | *r  | <span class='executed'>            if iszero(lt(y, 0x1000000000000000000)) {</span>
 304 |     | <span class='unexecuted'>                y := shr(64, y)</span>
 305 |     | <span class='unexecuted'>                z := shl(32, z)</span>
 306 |     | <span class='neutral'>            }</span>
 307 | *r  | <span class='executed'>            if iszero(lt(y, 0x10000000000)) {</span>
 308 | *r  | <span class='executed'>                y := shr(32, y)</span>
 309 | *r  | <span class='executed'>                z := shl(16, z)</span>
 310 |     | <span class='neutral'>            }</span>
 311 | *r  | <span class='executed'>            if iszero(lt(y, 0x1000000)) {</span>
 312 | *r  | <span class='executed'>                y := shr(16, y)</span>
 313 | *r  | <span class='executed'>                z := shl(8, z)</span>
 314 |     | <span class='neutral'>            }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>            // Goal was to get z*z*y within a small factor of x. More iterations could</span>
 317 |     | <span class='neutral'>            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).</span>
 318 |     | <span class='neutral'>            // We ensured y &gt;= 256 so that the relative difference between y and y+1 is small.</span>
 319 |     | <span class='neutral'>            // That&#39;s not possible if x &lt; 256 but we can just verify those cases exhaustively.</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>            // Now, z*z*y &lt;= x &lt; z*z*(y+1), and y &lt;= 2^(16+8), and either y &gt;= 256, or x &lt; 256.</span>
 322 |     | <span class='neutral'>            // Correctness can be checked exhaustively for x &lt; 256, so we assume y &gt;= 256.</span>
 323 |     | <span class='neutral'>            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range</span>
 326 |     | <span class='neutral'>            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate</span>
 329 |     | <span class='neutral'>            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>            // There is no overflow risk here since y &lt; 2^136 after the first branch above.</span>
 332 | *r  | <span class='executed'>            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.</span>
 335 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 336 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 337 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 338 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 339 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 340 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 341 | *r  | <span class='executed'>            z := shr(1, add(z, div(x, z)))</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='neutral'>            // If x+1 is a perfect square, the Babylonian method cycles between</span>
 344 |     | <span class='neutral'>            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.</span>
 345 |     | <span class='neutral'>            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division</span>
 346 |     | <span class='neutral'>            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.</span>
 347 |     | <span class='neutral'>            // If you don&#39;t care whether the floor or ceil square root is returned, you can remove this statement.</span>
 348 | *r  | <span class='executed'>            z := sub(z, lt(div(x, z), z))</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 | *r  | <span class='executed'>    function log2(uint256 x) internal pure returns (uint256 r) {</span>
 353 | *r  | <span class='executed'>        require(x &gt; 0, &quot;UNDEFINED&quot;);</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>        assembly {</span>
 356 | *r  | <span class='executed'>            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))</span>
 357 | *r  | <span class='executed'>            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))</span>
 358 | *r  | <span class='executed'>            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))</span>
 359 | *r  | <span class='executed'>            r := or(r, shl(4, lt(0xffff, shr(r, x))))</span>
 360 | *r  | <span class='executed'>            r := or(r, shl(3, lt(0xff, shr(r, x))))</span>
 361 | *r  | <span class='executed'>            r := or(r, shl(2, lt(0xf, shr(r, x))))</span>
 362 | *r  | <span class='executed'>            r := or(r, shl(1, lt(0x3, shr(r, x))))</span>
 363 | *r  | <span class='executed'>            r := or(r, lt(0x1, shr(r, x)))</span>
 364 |     | <span class='neutral'>        }</span>
 365 |     | <span class='neutral'>    }</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='neutral'>            // z will equal 0 if y is 0, unlike in Solidity where it will revert.</span>
 370 |     | <span class='neutral'>            z := mod(x, y)</span>
 371 |     | <span class='neutral'>        }</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 375 |     | <span class='neutral'>        assembly {</span>
 376 |     | <span class='neutral'>            // z will equal 0 if y is 0, unlike in Solidity where it will revert.</span>
 377 |     | <span class='neutral'>            z := div(x, y)</span>
 378 |     | <span class='neutral'>        }</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    /// @dev Will return 0 instead of reverting if y is zero.</span>
 382 |     | <span class='neutral'>    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 383 |     | <span class='neutral'>        assembly {</span>
 384 |     | <span class='neutral'>            // Add 1 to x * y if x % y &gt; 0.</span>
 385 |     | <span class='neutral'>            z := add(gt(mod(x, y), 0), div(x, y))</span>
 386 |     | <span class='neutral'>        }</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'>}</span>
 389 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solmate/src/utils/SafeCastLib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Safe unsigned integer casting library that reverts on overflow.</span>
  5 |     | <span class='unexecuted'>/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)</span>
  6 |     | <span class='neutral'>library SafeCastLib {</span>
  7 |     | <span class='neutral'>    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {</span>
  8 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 248);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>        y = uint248(x);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {</span>
 14 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 224);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>        y = uint224(x);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {</span>
 20 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 192);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>        y = uint192(x);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {</span>
 26 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 160);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        y = uint160(x);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 | *r  | <span class='executed'>    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {</span>
 32 | *r  | <span class='executed'>        require(x &lt; 1 &lt;&lt; 128);</span>
 33 |     | <span class='neutral'></span>
 34 | *r  | <span class='executed'>        y = uint128(x);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {</span>
 38 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 96);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>        y = uint96(x);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {</span>
 44 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 64);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>        y = uint64(x);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 | *r  | <span class='executed'>    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {</span>
 50 | *r  | <span class='executed'>        require(x &lt; 1 &lt;&lt; 32);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        y = uint32(x);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {</span>
 56 |     | <span class='neutral'>        require(x &lt; 1 &lt;&lt; 8);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>        y = uint8(x);</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solmate/src/utils/SafeTransferLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC20} from &quot;../tokens/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.</span>
   7 |     | <span class='neutral'>/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)</span>
   8 |     | <span class='unexecuted'>/// @dev Caution! This library won&#39;t check that a token has code, responsibility is delegated to the caller.</span>
   9 |     | <span class='neutral'>library SafeTransferLib {</span>
  10 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  11 |     | <span class='neutral'>                             ETH OPERATIONS</span>
  12 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  13 |     | <span class='neutral'></span>
  14 | *   | <span class='executed'>    function safeTransferETH(address to, uint256 amount) internal {</span>
  15 | *   | <span class='executed'>        bool success;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>        assembly {</span>
  18 |     | <span class='neutral'>            // Transfer the ETH and store if it succeeded or not.</span>
  19 | *   | <span class='executed'>            success := call(gas(), to, amount, 0, 0, 0, 0)</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>        require(success, &quot;ETH_TRANSFER_FAILED&quot;);</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  26 |     | <span class='neutral'>                            ERC20 OPERATIONS</span>
  27 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  28 |     | <span class='neutral'></span>
  29 | *r  | <span class='executed'>    function safeTransferFrom(</span>
  30 |     | <span class='neutral'>        ERC20 token,</span>
  31 |     | <span class='neutral'>        address from,</span>
  32 |     | <span class='neutral'>        address to,</span>
  33 |     | <span class='neutral'>        uint256 amount</span>
  34 |     | <span class='neutral'>    ) internal {</span>
  35 | *r  | <span class='executed'>        bool success;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        assembly {</span>
  38 |     | <span class='neutral'>            // We&#39;ll write our calldata to this slot below, but restore it later.</span>
  39 | *r  | <span class='executed'>            let memPointer := mload(0x40)</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
  42 | *r  | <span class='executed'>            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)</span>
  43 | *r  | <span class='executed'>            mstore(4, from) // Append the &quot;from&quot; argument.</span>
  44 | *r  | <span class='executed'>            mstore(36, to) // Append the &quot;to&quot; argument.</span>
  45 | *r  | <span class='executed'>            mstore(68, amount) // Append the &quot;amount&quot; argument.</span>
  46 |     | <span class='neutral'></span>
  47 | *r  | <span class='executed'>            success := and(</span>
  48 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
  49 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
  50 | *r  | <span class='executed'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
  51 |     | <span class='neutral'>                // We use 100 because that&#39;s the total length of our calldata (4 + 32 * 3)</span>
  52 |     | <span class='neutral'>                // Counterintuitively, this call() must be positioned after the or() in the</span>
  53 |     | <span class='neutral'>                // surrounding and() because and() evaluates its arguments from right to left.</span>
  54 | *r  | <span class='executed'>                call(gas(), token, 0, 0, 100, 0, 32)</span>
  55 |     | <span class='neutral'>            )</span>
  56 |     | <span class='neutral'></span>
  57 | *r  | <span class='executed'>            mstore(0x60, 0) // Restore the zero slot to zero.</span>
  58 | *r  | <span class='executed'>            mstore(0x40, memPointer) // Restore the memPointer.</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'></span>
  61 | *r  | <span class='executed'>        require(success, &quot;TRANSFER_FROM_FAILED&quot;);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 | *r  | <span class='executed'>    function safeTransfer(</span>
  65 |     | <span class='neutral'>        ERC20 token,</span>
  66 |     | <span class='neutral'>        address to,</span>
  67 |     | <span class='neutral'>        uint256 amount</span>
  68 |     | <span class='neutral'>    ) internal {</span>
  69 | *r  | <span class='executed'>        bool success;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        assembly {</span>
  72 |     | <span class='neutral'>            // We&#39;ll write our calldata to this slot below, but restore it later.</span>
  73 | *r  | <span class='executed'>            let memPointer := mload(0x40)</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
  76 | *r  | <span class='executed'>            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)</span>
  77 | *r  | <span class='executed'>            mstore(4, to) // Append the &quot;to&quot; argument.</span>
  78 | *r  | <span class='executed'>            mstore(36, amount) // Append the &quot;amount&quot; argument.</span>
  79 |     | <span class='neutral'></span>
  80 | *r  | <span class='executed'>            success := and(</span>
  81 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
  82 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
  83 | *r  | <span class='executed'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
  84 |     | <span class='neutral'>                // We use 68 because that&#39;s the total length of our calldata (4 + 32 * 2)</span>
  85 |     | <span class='neutral'>                // Counterintuitively, this call() must be positioned after the or() in the</span>
  86 |     | <span class='neutral'>                // surrounding and() because and() evaluates its arguments from right to left.</span>
  87 | *r  | <span class='executed'>                call(gas(), token, 0, 0, 68, 0, 32)</span>
  88 |     | <span class='neutral'>            )</span>
  89 |     | <span class='neutral'></span>
  90 | *r  | <span class='executed'>            mstore(0x60, 0) // Restore the zero slot to zero.</span>
  91 | *r  | <span class='executed'>            mstore(0x40, memPointer) // Restore the memPointer.</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 | *r  | <span class='executed'>        require(success, &quot;TRANSFER_FAILED&quot;);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function safeApprove(</span>
  98 |     | <span class='neutral'>        ERC20 token,</span>
  99 |     | <span class='neutral'>        address to,</span>
 100 |     | <span class='neutral'>        uint256 amount</span>
 101 |     | <span class='neutral'>    ) internal {</span>
 102 |     | <span class='neutral'>        bool success;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        assembly {</span>
 105 |     | <span class='neutral'>            // We&#39;ll write our calldata to this slot below, but restore it later.</span>
 106 |     | <span class='neutral'>            let memPointer := mload(0x40)</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
 109 |     | <span class='neutral'>            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)</span>
 110 |     | <span class='neutral'>            mstore(4, to) // Append the &quot;to&quot; argument.</span>
 111 |     | <span class='neutral'>            mstore(36, amount) // Append the &quot;amount&quot; argument.</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>            success := and(</span>
 114 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
 115 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
 116 |     | <span class='neutral'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
 117 |     | <span class='neutral'>                // We use 68 because that&#39;s the total length of our calldata (4 + 32 * 2)</span>
 118 |     | <span class='neutral'>                // Counterintuitively, this call() must be positioned after the or() in the</span>
 119 |     | <span class='neutral'>                // surrounding and() because and() evaluates its arguments from right to left.</span>
 120 |     | <span class='neutral'>                call(gas(), token, 0, 0, 68, 0, 32)</span>
 121 |     | <span class='neutral'>            )</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>            mstore(0x60, 0) // Restore the zero slot to zero.</span>
 124 |     | <span class='neutral'>            mstore(0x40, memPointer) // Restore the memPointer.</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        require(success, &quot;APPROVE_FAILED&quot;);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solstat/src/Gaussian.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../../solmate/src/utils/FixedPointMathLib.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Units.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title Gaussian Math Library.</span>
   9 |     | <span class='neutral'> * @author @alexangelj</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * @notice Models the normal distribution using the special Complimentary Error Function.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * @dev Only implements a distribution with mean (µ) = 0 and variance (σ) = 1.</span>
  14 |     | <span class='neutral'> * Uses Numerical Recipes as a framework and reference C implemenation.</span>
  15 |     | <span class='neutral'> * Numerical Recipes cites the original textbook written by Abramowitz and Stegun,</span>
  16 |     | <span class='neutral'> * &quot;Handbook of Mathematical Functions&quot;, which should be read to understand these</span>
  17 |     | <span class='neutral'> * special functions and the implications of their numerical approximations.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * @custom:source Handbook of Mathematical Functions https://personal.math.ubc.ca/~cbm/aands/abramowitz_and_stegun.pdf.</span>
  20 |     | <span class='neutral'> * @custom:source Numerical Recipes https://e-maxx.ru/bookz/files/numerical_recipes.pdf.</span>
  21 |     | <span class='neutral'> * @custom:source Inspired by https://github.com/errcw/gaussian.</span>
  22 |     | <span class='unexecuted'> */</span>
  23 |     | <span class='neutral'>library Gaussian {</span>
  24 |     | <span class='neutral'>    using FixedPointMathLib for int256;</span>
  25 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    error Infinity();</span>
  28 |     | <span class='neutral'>    error NegativeInfinity();</span>
  29 |     | <span class='neutral'></span>
  30 | *r  | <span class='executed'>    uint256 internal constant HALF_WAD = 0.5 ether;</span>
  31 |     | <span class='neutral'>    uint256 internal constant PI = 3_141592653589793238;</span>
  32 |     | <span class='neutral'>    int256 internal constant SQRT_2PI = 2_506628274631000502;</span>
  33 |     | <span class='neutral'>    int256 internal constant SIGN = -1;</span>
  34 |     | <span class='neutral'>    int256 internal constant SCALAR = 1e18;</span>
  35 |     | <span class='neutral'>    int256 internal constant HALF_SCALAR = 1e9;</span>
  36 |     | <span class='neutral'>    int256 internal constant SCALAR_SQRD = 1e36;</span>
  37 |     | <span class='neutral'>    int256 internal constant HALF = 5e17;</span>
  38 | *r  | <span class='executed'>    int256 internal constant ONE = 1e18;</span>
  39 | *r  | <span class='executed'>    int256 internal constant TWO = 2e18;</span>
  40 |     | <span class='neutral'>    int256 internal constant NEGATIVE_TWO = -2e18;</span>
  41 |     | <span class='neutral'>    int256 internal constant SQRT2 = 1_414213562373095048; // √2 with 18 decimals of precision.</span>
  42 |     | <span class='neutral'>    int256 internal constant ERFC_A = 1_265512230000000000;</span>
  43 |     | <span class='neutral'>    int256 internal constant ERFC_B = 1_000023680000000000;</span>
  44 |     | <span class='neutral'>    int256 internal constant ERFC_C = 374091960000000000; // 1e-1</span>
  45 |     | <span class='neutral'>    int256 internal constant ERFC_D = 96784180000000000; // 1e-2</span>
  46 |     | <span class='neutral'>    int256 internal constant ERFC_E = -186288060000000000; // 1e-1</span>
  47 |     | <span class='neutral'>    int256 internal constant ERFC_F = 278868070000000000; // 1e-1</span>
  48 |     | <span class='neutral'>    int256 internal constant ERFC_G = -1_135203980000000000;</span>
  49 |     | <span class='neutral'>    int256 internal constant ERFC_H = 1_488515870000000000;</span>
  50 |     | <span class='neutral'>    int256 internal constant ERFC_I = -822152230000000000; // 1e-1</span>
  51 |     | <span class='neutral'>    int256 internal constant ERFC_J = 170872770000000000; // 1e-1</span>
  52 |     | <span class='neutral'>    int256 internal constant IERFC_A = -707110000000000000; // 1e-1</span>
  53 |     | <span class='neutral'>    int256 internal constant IERFC_B = 2_307530000000000000;</span>
  54 |     | <span class='neutral'>    int256 internal constant IERFC_C = 270610000000000000; // 1e-1</span>
  55 |     | <span class='neutral'>    int256 internal constant IERFC_D = 992290000000000000; // 1e-1</span>
  56 |     | <span class='neutral'>    int256 internal constant IERFC_E = 44810000000000000; // 1e-2</span>
  57 |     | <span class='neutral'>    int256 internal constant IERFC_F = 1_128379167095512570;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @notice Approximation of the Complimentary Error Function.</span>
  61 |     | <span class='neutral'>     * Related to the Error Function: `erfc(x) = 1 - erf(x)`.</span>
  62 |     | <span class='neutral'>     * Both cumulative distribution and error functions are integrals</span>
  63 |     | <span class='neutral'>     * which cannot be expressed in elementary terms. They are called special functions.</span>
  64 |     | <span class='neutral'>     * The error and complimentary error functions have numerical approximations</span>
  65 |     | <span class='neutral'>     * which is what is used in this library to compute the cumulative distribution function.</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * @dev This is a special function with its own identities.</span>
  68 |     | <span class='neutral'>     * Identity: `erfc(-x) = 2 - erfc(x)`.</span>
  69 |     | <span class='neutral'>     * Special Values:</span>
  70 |     | <span class='neutral'>     * erfc(-infinity)	=	2</span>
  71 |     | <span class='neutral'>     * erfc(0)      	=	1</span>
  72 |     | <span class='neutral'>     * erfc(infinity)	=	0</span>
  73 |     | <span class='neutral'>     *</span>
  74 |     | <span class='neutral'>     * @custom:epsilon Fractional error less than 1.2e-7.</span>
  75 |     | <span class='neutral'>     * @custom:source Numerical Recipes in C 2e p221.</span>
  76 |     | <span class='neutral'>     * @custom:source https://mathworld.wolfram.com/Erfc.html.</span>
  77 |     | <span class='neutral'>     */</span>
  78 | *r  | <span class='executed'>    function erfc(int256 input) internal pure returns (int256 output) {</span>
  79 | *r  | <span class='executed'>        uint256 z = abs(input);</span>
  80 | *r  | <span class='executed'>        int256 t;</span>
  81 |     | <span class='neutral'>        int256 step;</span>
  82 |     | <span class='neutral'>        int256 k;</span>
  83 |     | <span class='neutral'>        assembly {</span>
  84 | *r  | <span class='executed'>            let quo := sdiv(mul(z, ONE), TWO) // 1 / (1 + z / 2).</span>
  85 | *r  | <span class='executed'>            let den := add(ONE, quo)</span>
  86 | *r  | <span class='executed'>            t := sdiv(SCALAR_SQRD, den)</span>
  87 |     | <span class='neutral'></span>
  88 | *r  | <span class='executed'>            function muli(pxn, pxd) -&gt; res {</span>
  89 | *r  | <span class='executed'>                res := sdiv(mul(pxn, pxd), ONE)</span>
  90 |     | <span class='neutral'>            }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>            {</span>
  93 | *r  | <span class='executed'>                step := add(</span>
  94 | *r  | <span class='executed'>                    ERFC_F,</span>
  95 | *r  | <span class='executed'>                    muli(</span>
  96 | *r  | <span class='executed'>                        t,</span>
  97 | *r  | <span class='executed'>                        add(</span>
  98 |     | <span class='neutral'>                            ERFC_G,</span>
  99 | *r  | <span class='executed'>                            muli(</span>
 100 | *r  | <span class='executed'>                                t,</span>
 101 | *r  | <span class='executed'>                                add(</span>
 102 | *r  | <span class='executed'>                                    ERFC_H,</span>
 103 | *r  | <span class='executed'>                                    muli(t, add(ERFC_I, muli(t, ERFC_J)))</span>
 104 |     | <span class='neutral'>                                )</span>
 105 |     | <span class='neutral'>                            )</span>
 106 |     | <span class='neutral'>                        )</span>
 107 |     | <span class='neutral'>                    )</span>
 108 |     | <span class='neutral'>                )</span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='neutral'>            {</span>
 111 | *r  | <span class='executed'>                step := muli(</span>
 112 |     | <span class='neutral'>                    t,</span>
 113 | *r  | <span class='executed'>                    add(</span>
 114 | *r  | <span class='executed'>                        ERFC_B,</span>
 115 |     | <span class='neutral'>                        muli(</span>
 116 |     | <span class='neutral'>                            t,</span>
 117 | *r  | <span class='executed'>                            add(</span>
 118 | *r  | <span class='executed'>                                ERFC_C,</span>
 119 |     | <span class='neutral'>                                muli(</span>
 120 |     | <span class='neutral'>                                    t,</span>
 121 | *r  | <span class='executed'>                                    add(</span>
 122 | *r  | <span class='executed'>                                        ERFC_D,</span>
 123 | *r  | <span class='executed'>                                        muli(t, add(ERFC_E, muli(t, step)))</span>
 124 |     | <span class='neutral'>                                    )</span>
 125 |     | <span class='neutral'>                                )</span>
 126 |     | <span class='neutral'>                            )</span>
 127 |     | <span class='neutral'>                        )</span>
 128 |     | <span class='neutral'>                    )</span>
 129 |     | <span class='neutral'>                )</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'></span>
 132 | *r  | <span class='executed'>            k := add(sub(mul(SIGN, muli(z, z)), ERFC_A), step)</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'></span>
 135 | *r  | <span class='executed'>        int256 expWad = FixedPointMathLib.expWad(k);</span>
 136 | *r  | <span class='executed'>        int256 r;</span>
 137 | *r  | <span class='executed'>        assembly {</span>
 138 | *r  | <span class='executed'>            r := sdiv(mul(t, expWad), ONE)</span>
 139 | *r  | <span class='executed'>            switch iszero(slt(input, 0))</span>
 140 | *r  | <span class='executed'>            case 0 {</span>
 141 | *r  | <span class='executed'>                output := sub(TWO, r)</span>
 142 |     | <span class='neutral'>            }</span>
 143 | *r  | <span class='executed'>            case 1 {</span>
 144 | *r  | <span class='executed'>                output := r</span>
 145 |     | <span class='neutral'>            }</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @notice Approximation of the Inverse Complimentary Error Function - erfc^(-1).</span>
 151 |     | <span class='neutral'>     *</span>
 152 |     | <span class='neutral'>     * @dev Equal to `ierfc(erfc(x)) = erfc(ierfc(x))` for 0 &lt; x &lt; 2.</span>
 153 |     | <span class='neutral'>     * Related to the Inverse Error Function: `ierfc(1 - x) = ierf(x)`.</span>
 154 |     | <span class='neutral'>     * This is a special function with its own identities.</span>
 155 |     | <span class='neutral'>     * Domain:      0 &lt; x &lt; 2</span>
 156 |     | <span class='neutral'>     * Special values:</span>
 157 |     | <span class='neutral'>     * ierfc(0)	=	infinity</span>
 158 |     | <span class='neutral'>     * ierfc(1)	=	0</span>
 159 |     | <span class='neutral'>     * ierfc(2)	=	-infinity</span>
 160 |     | <span class='neutral'>     *</span>
 161 |     | <span class='neutral'>     * @custom:source Numerical Recipes 3e p265.</span>
 162 |     | <span class='neutral'>     * @custom:source https://mathworld.wolfram.com/InverseErfc.html.</span>
 163 |     | <span class='neutral'>     */</span>
 164 | *r  | <span class='executed'>    function ierfc(int256 x) internal pure returns (int256 z) {</span>
 165 |     | <span class='neutral'>        assembly {</span>
 166 |     | <span class='neutral'>            // x &gt;= 2, iszero(x &lt; 2 ? 1 : 0) ? 1 : 0.</span>
 167 | *r  | <span class='executed'>            if iszero(slt(x, TWO)) {</span>
 168 |     | <span class='neutral'>                z := mul(add(not(100), 1), SCALAR)</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>            // x &lt;= 0.</span>
 172 | *r  | <span class='executed'>            if iszero(sgt(x, 0)) {</span>
 173 |     | <span class='unexecuted'>                z := mul(100, SCALAR)</span>
 174 |     | <span class='neutral'>            }</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'></span>
 177 | *r  | <span class='executed'>        if (z != 0) return z;</span>
 178 |     | <span class='neutral'></span>
 179 | *r  | <span class='executed'>        int256 xx; // (x &lt; ONE) ? x : TWO - x.</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 | *r  | <span class='executed'>            switch iszero(slt(x, ONE))</span>
 182 | *r  | <span class='executed'>            case 0 {</span>
 183 |     | <span class='unexecuted'>                xx := x</span>
 184 |     | <span class='neutral'>            }</span>
 185 | *r  | <span class='executed'>            case 1 {</span>
 186 | *r  | <span class='executed'>                xx := sub(TWO, x)</span>
 187 |     | <span class='neutral'>            }</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'></span>
 190 | *r  | <span class='executed'>        int256 logInput = diviWad(xx, TWO);</span>
 191 | *r  | <span class='executed'>        if (logInput == 0) revert Infinity();</span>
 192 | *r  | <span class='executed'>        int256 ln = FixedPointMathLib.lnWad(logInput);</span>
 193 | *r  | <span class='executed'>        uint256 t = uint256(muliWad(NEGATIVE_TWO, ln)).sqrt();</span>
 194 |     | <span class='neutral'>        assembly {</span>
 195 | *r  | <span class='executed'>            t := mul(t, HALF_SCALAR)</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'></span>
 198 | *r  | <span class='executed'>        int256 r;</span>
 199 |     | <span class='neutral'>        assembly {</span>
 200 |     | <span class='unexecuted'>            function muli(pxn, pxd) -&gt; res {</span>
 201 |     | <span class='unexecuted'>                res := sdiv(mul(pxn, pxd), ONE)</span>
 202 |     | <span class='neutral'>            }</span>
 203 |     | <span class='neutral'></span>
 204 | *r  | <span class='executed'>            r := muli(</span>
 205 |     | <span class='neutral'>                IERFC_A,</span>
 206 | *r  | <span class='executed'>                sub(</span>
 207 | *r  | <span class='executed'>                    sdiv(</span>
 208 | *r  | <span class='executed'>                        mul(add(IERFC_B, muli(t, IERFC_C)), ONE),</span>
 209 | *r  | <span class='executed'>                        add(ONE, muli(t, add(IERFC_D, muli(t, IERFC_E))))</span>
 210 |     | <span class='neutral'>                    ),</span>
 211 | *r  | <span class='executed'>                    t</span>
 212 |     | <span class='neutral'>                )</span>
 213 |     | <span class='neutral'>            )</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'></span>
 216 | *r  | <span class='executed'>        uint256 itr;</span>
 217 | *r  | <span class='executed'>        while (itr &lt; 2) {</span>
 218 | *r  | <span class='executed'>            int256 err = erfc(r);</span>
 219 |     | <span class='neutral'>            assembly {</span>
 220 | *r  | <span class='executed'>                err := sub(err, xx)</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='neutral'></span>
 223 | *r  | <span class='executed'>            int256 input;</span>
 224 |     | <span class='neutral'>            assembly {</span>
 225 | *r  | <span class='executed'>                input := add(not(sdiv(mul(r, r), ONE)), 1) // -(r * r).</span>
 226 |     | <span class='neutral'>            }</span>
 227 |     | <span class='neutral'></span>
 228 | *r  | <span class='executed'>            int256 expWad = input.expWad();</span>
 229 |     | <span class='neutral'></span>
 230 | *r  | <span class='executed'>            assembly {</span>
 231 |     | <span class='neutral'>                function muli(pxn, pxd) -&gt; res {</span>
 232 |     | <span class='neutral'>                    res := sdiv(mul(pxn, pxd), ONE)</span>
 233 |     | <span class='neutral'>                }</span>
 234 |     | <span class='neutral'></span>
 235 | *r  | <span class='executed'>                r := add(</span>
 236 | *r  | <span class='executed'>                    r,</span>
 237 | *r  | <span class='executed'>                    sdiv(</span>
 238 | *r  | <span class='executed'>                        mul(err, ONE),</span>
 239 | *r  | <span class='executed'>                        sub(muli(IERFC_F, expWad), muli(r, err))</span>
 240 |     | <span class='neutral'>                    )</span>
 241 |     | <span class='neutral'>                )</span>
 242 |     | <span class='neutral'></span>
 243 | *r  | <span class='executed'>                itr := add(itr, 1)</span>
 244 |     | <span class='neutral'>            }</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>        assembly {</span>
 248 | *r  | <span class='executed'>            switch iszero(slt(x, ONE)) // x &lt; ONE ? r : -r.</span>
 249 | *r  | <span class='executed'>            case 0 {</span>
 250 |     | <span class='unexecuted'>                z := r</span>
 251 |     | <span class='neutral'>            }</span>
 252 | *r  | <span class='executed'>            case 1 {</span>
 253 | *r  | <span class='executed'>                z := add(not(r), 1)</span>
 254 |     | <span class='neutral'>            }</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    /**</span>
 259 |     | <span class='neutral'>     * @notice Approximation of the Cumulative Distribution Function.</span>
 260 |     | <span class='neutral'>     *</span>
 261 |     | <span class='neutral'>     * @dev Equal to `D(x) = 0.5[ 1 + erf((x - µ) / σ√2)]`.</span>
 262 |     | <span class='neutral'>     * Only computes cdf of a distribution with µ = 0 and σ = 1.</span>
 263 |     | <span class='neutral'>     *</span>
 264 |     | <span class='neutral'>     * @custom:error Maximum error of 1.2e-7.</span>
 265 |     | <span class='neutral'>     * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.</span>
 266 |     | <span class='neutral'>     */</span>
 267 | *r  | <span class='executed'>    function cdf(int256 x) internal pure returns (int256 z) {</span>
 268 |     | <span class='neutral'>        int256 negated;</span>
 269 |     | <span class='neutral'>        assembly {</span>
 270 | *r  | <span class='executed'>            let res := sdiv(mul(x, ONE), SQRT2)</span>
 271 | *r  | <span class='executed'>            negated := add(not(res), 1)</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'></span>
 274 | *r  | <span class='executed'>        int256 _erfc = erfc(negated);</span>
 275 |     | <span class='neutral'>        assembly {</span>
 276 | *r  | <span class='executed'>            z := sdiv(mul(ONE, _erfc), TWO)</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    /**</span>
 281 |     | <span class='neutral'>     * @notice Approximation of the Probability Density Function.</span>
 282 |     | <span class='neutral'>     *</span>
 283 |     | <span class='neutral'>     * @dev Equal to `Z(x) = (1 / σ√2π)e^( (-(x - µ)^2) / 2σ^2 )`.</span>
 284 |     | <span class='neutral'>     * Only computes pdf of a distribution with µ = 0 and σ = 1.</span>
 285 |     | <span class='neutral'>     *</span>
 286 |     | <span class='neutral'>     * @custom:error Maximum error of 1.2e-7.</span>
 287 |     | <span class='neutral'>     * @custom:source https://mathworld.wolfram.com/ProbabilityDensityFunction.html.</span>
 288 |     | <span class='neutral'>     */</span>
 289 |     | <span class='neutral'>    function pdf(int256 x) internal pure returns (int256 z) {</span>
 290 |     | <span class='neutral'>        int256 e;</span>
 291 |     | <span class='neutral'>        assembly {</span>
 292 |     | <span class='neutral'>            e := sdiv(mul(add(not(x), 1), x), TWO) // (-x * x) / 2.</span>
 293 |     | <span class='neutral'>        }</span>
 294 |     | <span class='neutral'>        e = FixedPointMathLib.expWad(e);</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>        assembly {</span>
 297 |     | <span class='neutral'>            z := sdiv(mul(e, ONE), SQRT_2PI)</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    /**</span>
 302 |     | <span class='neutral'>     * @notice Approximation of the Percent Point Function.</span>
 303 |     | <span class='neutral'>     *</span>
 304 |     | <span class='neutral'>     * @dev Equal to `D(x)^(-1) = µ - σ√2(ierfc(2x))`.</span>
 305 |     | <span class='neutral'>     * Only computes ppf of a distribution with µ = 0 and σ = 1.</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * @custom:error Maximum error of 1.2e-7.</span>
 308 |     | <span class='neutral'>     * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.</span>
 309 |     | <span class='neutral'>     */</span>
 310 | *r  | <span class='executed'>    function ppf(int256 x) internal pure returns (int256 z) {</span>
 311 | *r  | <span class='executed'>        if (x == int256(HALF_WAD)) return int256(0); // returns 3.75e-8, but we know it&#39;s zero.</span>
 312 | *r  | <span class='executed'>        if (x &gt;= ONE) revert Infinity();</span>
 313 | *r  | <span class='executed'>        if (x == 0) revert NegativeInfinity();</span>
 314 |     | <span class='neutral'>        assembly {</span>
 315 | *r  | <span class='executed'>            x := mul(x, 2)</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='neutral'></span>
 318 | *r  | <span class='executed'>        int256 _ierfc = ierfc(x);</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>        assembly {</span>
 321 | *r  | <span class='executed'>            let res := sdiv(mul(SQRT2, _ierfc), ONE)</span>
 322 | *r  | <span class='executed'>            z := add(not(res), 1) // -res.</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'>}</span>
 326 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solstat/src/Invariant.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Gaussian.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title Invariant of Primitive RMM.</span>
   8 |     | <span class='neutral'> * @author @alexangelj</span>
   9 |     | <span class='neutral'> * @notice Invariant is `k` with the trading function `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * @dev Terms which can potentially be ambiguous are given discrete names.</span>
  12 |     | <span class='neutral'> * This makes it easier to search for terms and update terms.</span>
  13 |     | <span class='neutral'> * Variables can sometimes not be trusted to be or act like their names.</span>
  14 |     | <span class='neutral'> * This naming scheme avoids this problem using a glossary to define them.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * // -------------------- Glossary --------------------- //</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * `R_x` - Amount of asset token reserves per single unit of liquidity.</span>
  19 |     | <span class='neutral'> * `R_y` - Amount of quote token reserves per single unit of liquidity.</span>
  20 |     | <span class='neutral'> * `stk` - Strike price of the pool. The terminal price of each asset token.</span>
  21 |     | <span class='neutral'> * `vol` - Implied volatility of the pool. Higher vol = higher price impact on swaps.</span>
  22 |     | <span class='neutral'> * `tau` - Time until the pool expires. Amount of seconds until the pool&#39;s curve becomes flat around `stk`.</span>
  23 |     | <span class='neutral'> * `inv` - Invariant of the pool. Difference between theoretical $ value and actual $ value per liquidity.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * `WAD` - Signed or unsigned fixed point number with up to 18 decimals and up to 256 total bits wide.</span>
  26 |     | <span class='neutral'> * `YEAR`- Equal to the amount of seconds in a year. Used in `invariant` function.</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='neutral'> * // -------------------- Units ------------------------ //</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> * `R_x` - Units are unsigned WAD. Represents value of tokens, decimals matter.</span>
  31 |     | <span class='neutral'> * `R_y` - Units are unsigned WAD. Represents value of tokens, decimals matter.</span>
  32 |     | <span class='neutral'> * `stk` - Units are unsigned WAD. Represents value of tokens, decimals matter.</span>
  33 |     | <span class='neutral'> * `vol` - Units are unsigned WAD. Represents a percentage in which 100% = WAD.</span>
  34 |     | <span class='neutral'> * `tau` - Units are YEAR. Represents a time unit which `1.0` is equal to YEAR.</span>
  35 |     | <span class='neutral'> * `inv` - Units are signed WAD. Initial value of zero and decreases over time.</span>
  36 |     | <span class='neutral'> *</span>
  37 |     | <span class='neutral'> * // -------------------- Denoted By ----------------- //</span>
  38 |     | <span class='neutral'> *</span>
  39 |     | <span class='neutral'> * `R_x` - Denoted by `x`.</span>
  40 |     | <span class='neutral'> * `R_y` - Denoted by `y`.</span>
  41 |     | <span class='neutral'> * `stk` - Denoted by `K`.</span>
  42 |     | <span class='neutral'> * `vol` - Denoted by `σ`.</span>
  43 |     | <span class='neutral'> * `tau` - Denoted by `τ`.</span>
  44 |     | <span class='neutral'> * `inv` - Denoted by `k`.</span>
  45 |     | <span class='neutral'> *</span>
  46 |     | <span class='neutral'> * // -------------------- Error Bounds ----------------- //</span>
  47 |     | <span class='neutral'> *</span>
  48 |     | <span class='neutral'> * `inv` - Up to 1e-9.</span>
  49 |     | <span class='neutral'> *</span>
  50 |     | <span class='neutral'> * // ------------------------ ~ ------------------------ //</span>
  51 |     | <span class='unexecuted'> */</span>
  52 |     | <span class='neutral'>library Invariant {</span>
  53 |     | <span class='neutral'>    using Gaussian for int256; // Uses the `cdf` and `pdf` functions.</span>
  54 |     | <span class='neutral'>    using FixedPointMathLib for uint256; // Uses the `sqrt` function.</span>
  55 |     | <span class='neutral'></span>
  56 | *r  | <span class='executed'>    uint256 internal constant WAD = 1 ether;</span>
  57 |     | <span class='neutral'>    uint256 internal constant DOUBLE_WAD = 2 ether;</span>
  58 |     | <span class='unexecuted'>    int256 internal constant ONE = 1 ether;</span>
  59 |     | <span class='neutral'>    int256 internal constant YEAR = 31556952;</span>
  60 |     | <span class='neutral'>    int256 internal constant HALF_SCALAR = 1e9;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Reverts when an input value is out of bounds of its acceptable range.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    error OOB();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @notice Uses reserves `R_x` to compute reserves `R_y`.</span>
  69 |     | <span class='neutral'>     *</span>
  70 |     | <span class='neutral'>     * @dev Computes `y` in `y = KΦ(Φ⁻¹(1-x) - σ√τ) + k`.</span>
  71 |     | <span class='neutral'>     * Primary function use to compute the invariant.</span>
  72 |     | <span class='neutral'>     * Simplifies to `K(1 -x) + k` when time to expiry is zero.</span>
  73 |     | <span class='neutral'>     * Reverts if `R_x` is greater than one. Units are a fixed point number with 18 decimals.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * We handle some special cases, try this:</span>
  76 |     | <span class='neutral'>     * `normalcdlower(normalicdlower(1) - 0.1)` in https://keisan.casio.com/calculator</span>
  77 |     | <span class='neutral'>     * Gaussian.sol reverts for `ppf(1)` and `ppf(0)`, so we handle those cases.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * @param R_x Quantity of token reserve `x` within the bounds of [0, 1].</span>
  80 |     | <span class='neutral'>     * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.</span>
  81 |     | <span class='neutral'>     * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.</span>
  82 |     | <span class='neutral'>     * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.</span>
  83 |     | <span class='neutral'>     * @param inv Current invariant given the actual `R_x`. Zero if computing invariant itself.</span>
  84 |     | <span class='neutral'>     * @return R_y Quantity of token reserve `y` within the bounds of [0, stk].</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * @custom:error Technically, none. This is the source of truth for the trading function.</span>
  87 |     | <span class='neutral'>     * @custom:source https://primitive.xyz/whitepaper</span>
  88 |     | <span class='neutral'>     */</span>
  89 | *r  | <span class='executed'>    function getY(</span>
  90 |     | <span class='neutral'>        uint256 R_x,</span>
  91 |     | <span class='neutral'>        uint256 stk,</span>
  92 |     | <span class='neutral'>        uint256 vol,</span>
  93 |     | <span class='neutral'>        uint256 tau,</span>
  94 |     | <span class='neutral'>        int256 inv</span>
  95 | *r  | <span class='executed'>    ) internal pure returns (uint256 R_y) {</span>
  96 | *r  | <span class='executed'>        if (R_x &gt; WAD) revert OOB(); // Negative input for `ppf` is invalid.</span>
  97 | *r  | <span class='executed'>        if (R_x == WAD) return uint256(int256(stk) + inv); // For `ppf(0)` case, because 1 - R_x == 0, and `y = K * 1 + k` simplifies to `y = K + k`</span>
  98 | *r  | <span class='executed'>        if (R_x == 0) return uint256(inv); // For `ppf(1)` case, because 1 - 0 == 1, and `y = K * 0 + k` simplifies to `y = k`.</span>
  99 | *r  | <span class='executed'>        if (tau != 0) {</span>
 100 |     | <span class='neutral'>            // Short circuits because tau != 0 is more likely.</span>
 101 | *r  | <span class='executed'>            uint256 sec;</span>
 102 |     | <span class='neutral'>            assembly {</span>
 103 | *r  | <span class='executed'>                sec := sdiv(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.</span>
 104 |     | <span class='neutral'>            }</span>
 105 |     | <span class='neutral'></span>
 106 | *r  | <span class='executed'>            uint256 sdr = sec.sqrt(); // √τ.</span>
 107 |     | <span class='neutral'>            assembly {</span>
 108 | *r  | <span class='executed'>                sdr := mul(sdr, HALF_SCALAR) // Unit math: sdr * HALF_SCALAR = SCALAR.</span>
 109 | *r  | <span class='executed'>                sdr := sdiv(mul(vol, sdr), ONE) // σ√τ.</span>
 110 |     | <span class='neutral'>            }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>            int256 phi;</span>
 113 |     | <span class='neutral'>            assembly {</span>
 114 | *r  | <span class='executed'>                phi := sub(ONE, R_x)</span>
 115 |     | <span class='neutral'>            }</span>
 116 | *r  | <span class='executed'>            phi = phi.ppf(); // Φ⁻¹(1-x).</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>            int256 cdf;</span>
 119 |     | <span class='neutral'>            assembly {</span>
 120 | *r  | <span class='executed'>                cdf := sub(phi, sdr) // Φ⁻¹(1-x) - σ√τ.</span>
 121 |     | <span class='neutral'>            }</span>
 122 | *r  | <span class='executed'>            cdf = cdf.cdf(); // Φ(Φ⁻¹(1-x) - σ√τ).</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>            assembly {</span>
 125 | *r  | <span class='executed'>                R_y := add(sdiv(mul(stk, cdf), ONE), inv)</span>
 126 |     | <span class='neutral'>            }</span>
 127 |     | <span class='neutral'>        } else {</span>
 128 |     | <span class='neutral'>            assembly {</span>
 129 |     | <span class='unexecuted'>                R_y := add(sdiv(mul(stk, sub(ONE, R_x)), ONE), inv)</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     * @notice Uses reserves `R_y` to compute reserves `R_x`.</span>
 136 |     | <span class='neutral'>     *</span>
 137 |     | <span class='neutral'>     * @dev Computes `x` in `x = 1 - Φ(Φ⁻¹( (y + k) / K ) + σ√τ)`.</span>
 138 |     | <span class='neutral'>     * Not used in invariant function. Used for computing swap outputs.</span>
 139 |     | <span class='neutral'>     * Simplifies to `1 - ( (y + k) / K )` when time to expiry is zero.</span>
 140 |     | <span class='neutral'>     * Reverts if `R_y` is greater than one. Units are WAD.</span>
 141 |     | <span class='neutral'>     *</span>
 142 |     | <span class='neutral'>     * Dangerous! There are important bounds to using this function.</span>
 143 |     | <span class='neutral'>     *</span>
 144 |     | <span class='neutral'>     * @param R_y Quantity of token reserve `y` within the bounds of [0, stk].</span>
 145 |     | <span class='neutral'>     * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.</span>
 146 |     | <span class='neutral'>     * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.</span>
 147 |     | <span class='neutral'>     * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.</span>
 148 |     | <span class='neutral'>     * @param inv Current invariant given the actual reserves `R_y`.</span>
 149 |     | <span class='neutral'>     * @return R_x Quantity of token reserve `x` within the bounds of [0, 1].</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * @custom:error Up to 1e-6. This an **approximated** &quot;inverse&quot; of the `getY` function.</span>
 152 |     | <span class='neutral'>     * @custom:source https://primitive.xyz/whitepaper</span>
 153 |     | <span class='neutral'>     */</span>
 154 |     | <span class='unexecuted'>    function getX(</span>
 155 |     | <span class='neutral'>        uint256 R_y,</span>
 156 |     | <span class='neutral'>        uint256 stk,</span>
 157 |     | <span class='neutral'>        uint256 vol,</span>
 158 |     | <span class='neutral'>        uint256 tau,</span>
 159 |     | <span class='neutral'>        int256 inv</span>
 160 |     | <span class='unexecuted'>    ) internal pure returns (uint256 R_x) {</span>
 161 |     | <span class='neutral'>        // Short circuits because tau != 0 is more likely.</span>
 162 |     | <span class='unexecuted'>        if (tau != 0) {</span>
 163 |     | <span class='unexecuted'>            uint256 sec;</span>
 164 |     | <span class='neutral'>            assembly {</span>
 165 |     | <span class='unexecuted'>                sec := div(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.</span>
 166 |     | <span class='neutral'>            }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>            uint256 sdr = sec.sqrt(); // √τ.</span>
 169 |     | <span class='neutral'>            assembly {</span>
 170 |     | <span class='unexecuted'>                sdr := mul(sdr, HALF_SCALAR) // Unit math: HALF_SCALAR * HALF_SCALAR = SCALAR.</span>
 171 |     | <span class='unexecuted'>                sdr := div(mul(vol, sdr), ONE) // σ√τ.</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>            int256 phi;</span>
 175 |     | <span class='neutral'>            assembly {</span>
 176 |     | <span class='unexecuted'>                phi := sdiv(mul(add(R_y, inv), ONE), stk) // (y + k) / K.</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>            if (phi &lt; 0) revert OOB(); // Negative input for `ppf` is invalid.</span>
 180 |     | <span class='unexecuted'>            if (phi &gt; ONE) revert OOB();</span>
 181 |     | <span class='unexecuted'>            if (phi == ONE) return 0; // `x = 1 - Φ(Φ⁻¹( 1 ) + σ√τ)` simplifies to  `x = 0`.</span>
 182 |     | <span class='unexecuted'>            if (phi == 0) return WAD; // `x = 1 - Φ(Φ⁻¹( 0 ) + σ√τ)` simplifies to `x = 1`.</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>            phi = phi.ppf(); // Φ⁻¹( (y + k) / K ).</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>            int256 cdf;</span>
 187 |     | <span class='neutral'>            assembly {</span>
 188 |     | <span class='unexecuted'>                cdf := add(phi, sdr) // Φ⁻¹( (y + k) / K ) + σ√τ.</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='unexecuted'>            cdf = cdf.cdf(); // Φ(Φ⁻¹( (y + k) / K ) + σ√τ).</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>            assembly {</span>
 193 |     | <span class='unexecuted'>                R_x := sub(ONE, cdf)</span>
 194 |     | <span class='neutral'>            }</span>
 195 |     | <span class='neutral'>        } else {</span>
 196 |     | <span class='neutral'>            assembly {</span>
 197 |     | <span class='unexecuted'>                R_x := sub(ONE, sdiv(mul(add(R_y, inv), ONE), stk))</span>
 198 |     | <span class='neutral'>            }</span>
 199 |     | <span class='neutral'>        }</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @notice Computes the invariant of the RMM trading function.</span>
 204 |     | <span class='neutral'>     *</span>
 205 |     | <span class='neutral'>     * @dev Computes `k` in `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.</span>
 206 |     | <span class='neutral'>     * Used to validate swaps, the most critical function.</span>
 207 |     | <span class='neutral'>     *</span>
 208 |     | <span class='neutral'>     * @custom:source https://rmm.eth.xyz</span>
 209 |     | <span class='neutral'>     */</span>
 210 |     | <span class='unexecuted'>    function invariant(</span>
 211 |     | <span class='neutral'>        uint256 R_y,</span>
 212 |     | <span class='neutral'>        uint256 R_x,</span>
 213 |     | <span class='neutral'>        uint256 stk,</span>
 214 |     | <span class='neutral'>        uint256 vol,</span>
 215 |     | <span class='neutral'>        uint256 tau</span>
 216 |     | <span class='unexecuted'>    ) internal pure returns (int256 inv) {</span>
 217 |     | <span class='unexecuted'>        uint256 y = getY(R_x, stk, vol, tau, inv); // `inv` is 0 because we are solving `inv`, aka `k`.</span>
 218 |     | <span class='neutral'>        assembly {</span>
 219 |     | <span class='unexecuted'>            inv := sub(R_y, y)</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>}</span>
 223 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/lib/solstat/src/Units.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>error Min();</span>
  5 | *r  | <span class='executed'></span>
  6 | *r  | <span class='executed'>function abs(int256 input) pure returns (uint256 output) {</span>
  7 | *r  | <span class='executed'>    if (input == type(int256).min) revert Min();</span>
  8 | *r  | <span class='executed'>    if (input &lt; 0) {</span>
  9 |     | <span class='neutral'>        assembly {</span>
 10 | *r  | <span class='executed'>            output := add(not(input), 1)</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'>    } else {</span>
 13 |     | <span class='neutral'>        assembly {</span>
 14 |     | <span class='unexecuted'>            output := input</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>
 19 | *r  | <span class='executed'>/// @dev From solmate@v7, changes last `div` to `sdiv`.</span>
 20 |     | <span class='neutral'>function muli(</span>
 21 |     | <span class='neutral'>    int256 x,</span>
 22 |     | <span class='neutral'>    int256 y,</span>
 23 |     | <span class='neutral'>    int256 denominator</span>
 24 |     | <span class='neutral'>) pure returns (int256 z) {</span>
 25 |     | <span class='neutral'>    assembly {</span>
 26 |     | <span class='neutral'>        // Store x * y in z for now.</span>
 27 | *r  | <span class='executed'>        z := mul(x, y)</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        // Equivalent to require(denominator != 0 &amp;&amp; (x == 0 || (x * y) / x == y))</span>
 30 | *r  | <span class='executed'>        if iszero(</span>
 31 | *r  | <span class='executed'>            and(iszero(iszero(denominator)), or(iszero(x), eq(sdiv(z, x), y)))</span>
 32 |     | <span class='neutral'>        ) {</span>
 33 |     | <span class='unexecuted'>            revert(0, 0)</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>        // Divide z by the denominator.</span>
 37 | *r  | <span class='executed'>        z := sdiv(z, denominator)</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 | *r  | <span class='executed'></span>
 41 | *r  | <span class='executed'>function muliWad(int256 x, int256 y) pure returns (int256 z) {</span>
 42 | *r  | <span class='executed'>    z = muli(x, y, 1 ether);</span>
 43 |     | <span class='neutral'>}</span>
 44 | *r  | <span class='executed'></span>
 45 | *r  | <span class='executed'>function diviWad(int256 x, int256 y) pure returns (int256 z) {</span>
 46 | *r  | <span class='executed'>    z = muli(x, 1 ether, y);</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/InvariantAllocateUnallocate.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./setup/InvariantTargetContract.sol&quot;;</span>
   5 |     | <span class='unexecuted'></span>
   6 |     | <span class='neutral'>contract InvariantAllocateUnallocate is InvariantTargetContract {</span>
   7 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>    function allocate(uint deltaLiquidity, uint index) public {</span>
  10 |     | <span class='unexecuted'>        deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>        // Allocate to a random pool.</span>
  13 |     | <span class='neutral'>        // VERY IMPORTANT</span>
  14 |     | <span class='unexecuted'>        setPoolId(ctx.getRandomPoolId(index));</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>        _assertAllocate(deltaLiquidity);</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    // avoid stack too deep</span>
  20 |     | <span class='neutral'>    uint expectedDeltaAsset;</span>
  21 |     | <span class='neutral'>    uint expectedDeltaQuote;</span>
  22 |     | <span class='neutral'>    bool transferAssetIn;</span>
  23 |     | <span class='neutral'>    bool transferQuoteIn;</span>
  24 |     | <span class='neutral'>    int assetCredit;</span>
  25 |     | <span class='neutral'>    int quoteCredit;</span>
  26 |     | <span class='neutral'>    uint deltaAsset;</span>
  27 |     | <span class='neutral'>    uint deltaQuote;</span>
  28 |     | <span class='neutral'>    uint userAssetBalance;</span>
  29 |     | <span class='neutral'>    uint userQuoteBalance;</span>
  30 |     | <span class='neutral'>    uint physicalAssetPayment;</span>
  31 |     | <span class='neutral'>    uint physicalQuotePayment;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    HyperState prev;</span>
  34 |     | <span class='neutral'>    HyperState post;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function _assertAllocate(uint deltaLiquidity) internal {</span>
  37 |     | <span class='neutral'>        // TODO: cleanup reset of these</span>
  38 |     | <span class='unexecuted'>        transferAssetIn = true;</span>
  39 |     | <span class='unexecuted'>        transferQuoteIn = true;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // Preconditions</span>
  42 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyper__), __poolId__);</span>
  43 |     | <span class='unexecuted'>        assertTrue(pool.lastTimestamp != 0, &quot;Pool not initialized&quot;);</span>
  44 |     | <span class='unexecuted'>        assertTrue(pool.lastPrice != 0, &quot;Pool not created with a price&quot;);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // Amounts of tokens that will be allocated to pool.</span>
  47 |     | <span class='unexecuted'>        (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(</span>
  48 |     | <span class='unexecuted'>            __poolId__,</span>
  49 |     | <span class='neutral'>            int128(uint128(deltaLiquidity))</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // If net balance &gt; 0, there are tokens in the contract which are not in a pool or balance.</span>
  53 |     | <span class='neutral'>        // They will be credited to the msg.sender of the next call.</span>
  54 |     | <span class='unexecuted'>        assetCredit = __hyper__.getNetBalance(address(__asset__));</span>
  55 |     | <span class='unexecuted'>        quoteCredit = __hyper__.getNetBalance(address(__quote__));</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // Net balances should always be positive outside of execution.</span>
  58 |     | <span class='unexecuted'>        assertTrue(assetCredit &gt;= 0, &quot;negative-net-asset-tokens&quot;);</span>
  59 |     | <span class='unexecuted'>        assertTrue(quoteCredit &gt;= 0, &quot;negative-net-quote-tokens&quot;);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // Internal balance of tokens spendable by user.</span>
  62 |     | <span class='unexecuted'>        userAssetBalance = getBalance(address(__hyper__), address(this), address(__asset__));</span>
  63 |     | <span class='unexecuted'>        userQuoteBalance = getBalance(address(__hyper__), address(this), address(__quote__));</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        // If there is a net balance, user can use it to pay their cost.</span>
  66 |     | <span class='neutral'>        // Total payment the user must make.</span>
  67 |     | <span class='unexecuted'>        physicalAssetPayment = uint(assetCredit) &gt; expectedDeltaAsset ? 0 : expectedDeltaAsset - uint(assetCredit);</span>
  68 |     | <span class='unexecuted'>        physicalQuotePayment = uint(quoteCredit) &gt; expectedDeltaQuote ? 0 : expectedDeltaQuote - uint(quoteCredit);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        physicalAssetPayment = uint(userAssetBalance) &gt; physicalAssetPayment</span>
  71 |     | <span class='unexecuted'>            ? 0</span>
  72 |     | <span class='unexecuted'>            : physicalAssetPayment - uint(userAssetBalance);</span>
  73 |     | <span class='unexecuted'>        physicalQuotePayment = uint(userQuoteBalance) &gt; physicalQuotePayment</span>
  74 |     | <span class='unexecuted'>            ? 0</span>
  75 |     | <span class='unexecuted'>            : physicalQuotePayment - uint(userQuoteBalance);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // If user can pay for the allocate using their internal balance of tokens, don&#39;t need to transfer tokens in.</span>
  78 |     | <span class='neutral'>        // Won&#39;t need to transfer in tokens if user payment is zero.</span>
  79 |     | <span class='unexecuted'>        if (physicalAssetPayment == 0) transferAssetIn = false;</span>
  80 |     | <span class='unexecuted'>        if (physicalQuotePayment == 0) transferQuoteIn = false;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // If the user has to pay externally, give them tokens.</span>
  83 |     | <span class='unexecuted'>        if (transferAssetIn) __asset__.mint(address(this), physicalAssetPayment);</span>
  84 |     | <span class='unexecuted'>        if (transferQuoteIn) __quote__.mint(address(this), physicalQuotePayment);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // Execution</span>
  87 |     | <span class='unexecuted'>        prev = getState();</span>
  88 |     | <span class='unexecuted'>        (deltaAsset, deltaQuote) = __hyper__.allocate(__poolId__, deltaLiquidity);</span>
  89 |     | <span class='unexecuted'>        post = getState();</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // Postconditions</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        assertEq(deltaAsset, expectedDeltaAsset, &quot;pool-delta-asset&quot;);</span>
  94 |     | <span class='unexecuted'>        assertEq(deltaQuote, expectedDeltaQuote, &quot;pool-delta-quote&quot;);</span>
  95 |     | <span class='unexecuted'>        assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, &quot;pool-total-liquidity&quot;);</span>
  96 |     | <span class='unexecuted'>        assertTrue(post.totalPoolLiquidity &gt; prev.totalPoolLiquidity, &quot;pool-liquidity-increases&quot;);</span>
  97 |     | <span class='unexecuted'>        assertEq(</span>
  98 |     | <span class='unexecuted'>            post.callerPositionLiquidity,</span>
  99 |     | <span class='unexecuted'>            prev.callerPositionLiquidity + deltaLiquidity,</span>
 100 |     | <span class='neutral'>            &quot;position-liquidity-increases&quot;</span>
 101 |     | <span class='neutral'>        );</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        assertEq(post.reserveAsset, prev.reserveAsset + physicalAssetPayment + uint(assetCredit), &quot;reserve-asset&quot;);</span>
 104 |     | <span class='unexecuted'>        assertEq(post.reserveQuote, prev.reserveQuote + physicalQuotePayment + uint(quoteCredit), &quot;reserve-quote&quot;);</span>
 105 |     | <span class='unexecuted'>        assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + physicalAssetPayment, &quot;physical-asset&quot;);</span>
 106 |     | <span class='unexecuted'>        assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + physicalQuotePayment, &quot;physical-quote&quot;);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;</span>
 109 |     | <span class='unexecuted'>        uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;</span>
 110 |     | <span class='unexecuted'>        assertTrue(feeDelta0 == feeDelta1, &quot;asset-growth&quot;);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;</span>
 113 |     | <span class='unexecuted'>        uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;</span>
 114 |     | <span class='unexecuted'>        assertTrue(feeDelta2 == feeDelta3, &quot;quote-growth&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        emit FinishedCall(&quot;Allocate&quot;);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        checkVirtualInvariant();</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    event FinishedCall(string);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function unallocate(uint deltaLiquidity, uint index) external {</span>
 124 |     | <span class='unexecuted'>        deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        // Unallocate from a random pool.</span>
 127 |     | <span class='neutral'>        // VERY IMPORTANT</span>
 128 |     | <span class='unexecuted'>        setPoolId(ctx.getRandomPoolId(index));</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        _assertUnallocate(deltaLiquidity);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function _assertUnallocate(uint deltaLiquidity) internal {</span>
 134 |     | <span class='neutral'>        // TODO: Add use max flag support.</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // Get some liquidity.</span>
 137 |     | <span class='unexecuted'>        HyperPosition memory pos = getPosition(address(__hyper__), address(this), __poolId__);</span>
 138 |     | <span class='unexecuted'>        require(pos.freeLiquidity &gt;= deltaLiquidity, &quot;Not enough liquidity&quot;);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        if (pos.freeLiquidity &gt;= deltaLiquidity) {</span>
 141 |     | <span class='neutral'>            // Preconditions</span>
 142 |     | <span class='unexecuted'>            HyperPool memory pool = getPool(address(__hyper__), __poolId__);</span>
 143 |     | <span class='unexecuted'>            assertTrue(pool.lastTimestamp != 0, &quot;Pool not initialized&quot;);</span>
 144 |     | <span class='unexecuted'>            assertTrue(pool.lastPrice != 0, &quot;Pool not created with a price&quot;);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>            // Unallocate</span>
 147 |     | <span class='unexecuted'>            uint timestamp = block.timestamp + 4; // todo: fix default jit policy</span>
 148 |     | <span class='unexecuted'>            vm.warp(timestamp);</span>
 149 |     | <span class='unexecuted'>            __hyper__.setTimestamp(uint128(timestamp));</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>            (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(</span>
 152 |     | <span class='unexecuted'>                __poolId__,</span>
 153 |     | <span class='unexecuted'>                -int128(uint128(deltaLiquidity))</span>
 154 |     | <span class='neutral'>            );</span>
 155 |     | <span class='unexecuted'>            prev = getState();</span>
 156 |     | <span class='unexecuted'>            (uint unallocatedAsset, uint unallocatedQuote) = __hyper__.unallocate(__poolId__, deltaLiquidity);</span>
 157 |     | <span class='unexecuted'>            HyperState memory end = getState();</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>            assertEq(unallocatedAsset, expectedDeltaAsset, &quot;asset-delta&quot;);</span>
 160 |     | <span class='unexecuted'>            assertEq(unallocatedQuote, expectedDeltaQuote, &quot;quote-delta&quot;);</span>
 161 |     | <span class='unexecuted'>            assertEq(end.reserveAsset, prev.reserveAsset - unallocatedAsset, &quot;reserve-asset&quot;);</span>
 162 |     | <span class='unexecuted'>            assertEq(end.reserveQuote, prev.reserveQuote - unallocatedQuote, &quot;reserve-quote&quot;);</span>
 163 |     | <span class='unexecuted'>            assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity - deltaLiquidity, &quot;total-liquidity&quot;);</span>
 164 |     | <span class='unexecuted'>            assertTrue(prev.totalPositionLiquidity &gt;= deltaLiquidity, &quot;total-pos-liq-underflow&quot;);</span>
 165 |     | <span class='unexecuted'>            assertTrue(prev.callerPositionLiquidity &gt;= deltaLiquidity, &quot;caller-pos-liq-underflow&quot;);</span>
 166 |     | <span class='unexecuted'>            assertEq(</span>
 167 |     | <span class='unexecuted'>                end.totalPositionLiquidity,</span>
 168 |     | <span class='unexecuted'>                prev.totalPositionLiquidity - deltaLiquidity,</span>
 169 |     | <span class='neutral'>                &quot;total-position-liquidity&quot;</span>
 170 |     | <span class='neutral'>            );</span>
 171 |     | <span class='unexecuted'>            assertEq(</span>
 172 |     | <span class='unexecuted'>                end.callerPositionLiquidity,</span>
 173 |     | <span class='unexecuted'>                prev.callerPositionLiquidity - deltaLiquidity,</span>
 174 |     | <span class='neutral'>                &quot;caller-position-liquidity&quot;</span>
 175 |     | <span class='neutral'>            );</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='unexecuted'>        emit FinishedCall(&quot;Unallocate&quot;);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>        checkVirtualInvariant();</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>    function checkVirtualInvariant() internal {</span>
 183 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyper__), __poolId__);</span>
 184 |     | <span class='neutral'>        // TODO: Breaks when we call this function on a pool with zero liquidity...</span>
 185 |     | <span class='unexecuted'>        (uint dAsset, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);</span>
 186 |     | <span class='unexecuted'>        emit log(&quot;dAsset&quot;, dAsset);</span>
 187 |     | <span class='unexecuted'>        emit log(&quot;dQuote&quot;, dQuote);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));</span>
 190 |     | <span class='unexecuted'>        uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        emit log(&quot;bAsset&quot;, bAsset);</span>
 193 |     | <span class='unexecuted'>        emit log(&quot;bQuote&quot;, bQuote);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>        int diffAsset = int(bAsset) - int(dAsset);</span>
 196 |     | <span class='unexecuted'>        int diffQuote = int(bQuote) - int(dQuote);</span>
 197 |     | <span class='unexecuted'>        emit log(&quot;diffAsset&quot;, diffAsset);</span>
 198 |     | <span class='unexecuted'>        emit log(&quot;diffQuote&quot;, diffQuote);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        assertTrue(bAsset &gt;= dAsset, &quot;invariant-virtual-reserves-asset&quot;);</span>
 201 |     | <span class='unexecuted'>        assertTrue(bQuote &gt;= dQuote, &quot;invariant-virtual-reserves-quote&quot;);</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        emit FinishedCall(&quot;Check Virtual Invariant&quot;);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    event log(string, uint);</span>
 207 |     | <span class='neutral'>    event log(string, int);</span>
 208 |     | <span class='neutral'>}</span>
 209 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/InvariantCreatePool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot; as HyperTypes;</span>
   5 |     | <span class='neutral'>import &quot;contracts/Enigma.sol&quot; as Enigma;</span>
   6 |     | <span class='neutral'>import &quot;./setup/InvariantTargetContract.sol&quot;;</span>
   7 |     | <span class='unexecuted'></span>
   8 |     | <span class='neutral'>contract InvariantCreatePool is InvariantTargetContract {</span>
   9 |     | <span class='neutral'>    Forwarder forwarder;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {</span>
  12 |     | <span class='unexecuted'>        forwarder = new Forwarder();</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function create_pool(</span>
  16 |     | <span class='neutral'>        uint index,</span>
  17 |     | <span class='neutral'>        uint128 price,</span>
  18 |     | <span class='neutral'>        uint128 strike,</span>
  19 |     | <span class='neutral'>        uint24 sigma,</span>
  20 |     | <span class='neutral'>        uint32 maturity,</span>
  21 |     | <span class='neutral'>        uint32 gamma,</span>
  22 |     | <span class='neutral'>        uint32 priorityGamma</span>
  23 |     | <span class='unexecuted'>    ) external {</span>
  24 |     | <span class='unexecuted'>        vm.assume(strike != 0);</span>
  25 |     | <span class='unexecuted'>        vm.assume(sigma != 0);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        maturity = uint32(block.timestamp + bound(maturity, 1, 365 days));</span>
  28 |     | <span class='unexecuted'>        price = uint128(bound(price, 1, 1e36));</span>
  29 |     | <span class='unexecuted'>        gamma = uint32(bound(sigma, 1e4 - HyperTypes.MAX_FEE, 1e4 - HyperTypes.MIN_FEE));</span>
  30 |     | <span class='unexecuted'>        priorityGamma = uint32(bound(sigma, gamma, 1e4 - HyperTypes.MIN_FEE));</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Random user</span>
  33 |     | <span class='unexecuted'>        address caller = ctx.getRandomUser(index);</span>
  34 |     | <span class='unexecuted'>        address[] memory tokens = new address[](3);</span>
  35 |     | <span class='unexecuted'>        tokens[0] = address(ctx.__asset__());</span>
  36 |     | <span class='unexecuted'>        tokens[1] = address(ctx.__quote__());</span>
  37 |     | <span class='neutral'>        //tokens[0] = address(ctx.__weth__());</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        address[] memory shuffled = shuffle(index, tokens);</span>
  40 |     | <span class='unexecuted'>        address token0 = shuffled[0];</span>
  41 |     | <span class='unexecuted'>        address token1 = shuffled[1];</span>
  42 |     | <span class='unexecuted'>        assertTrue(token0 != token1, &quot;same-token&quot;);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>        CreateArgs memory args = CreateArgs(</span>
  45 |     | <span class='neutral'>            caller,</span>
  46 |     | <span class='neutral'>            token0,</span>
  47 |     | <span class='neutral'>            token1,</span>
  48 |     | <span class='neutral'>            price,</span>
  49 |     | <span class='neutral'>            strike,</span>
  50 |     | <span class='neutral'>            sigma,</span>
  51 |     | <span class='neutral'>            maturity,</span>
  52 |     | <span class='neutral'>            gamma,</span>
  53 |     | <span class='neutral'>            priorityGamma</span>
  54 |     | <span class='neutral'>        );</span>
  55 |     | <span class='unexecuted'>        _assertCreatePool(args);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function shuffle(uint random, address[] memory array) internal view returns (address[] memory output) {</span>
  59 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; array.length; i++) {</span>
  60 |     | <span class='unexecuted'>            uint256 n = i + (random % (array.length - i));</span>
  61 |     | <span class='unexecuted'>            address temp = array[n];</span>
  62 |     | <span class='unexecuted'>            array[n] = array[i];</span>
  63 |     | <span class='unexecuted'>            array[i] = temp;</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        output = array;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    struct CreateArgs {</span>
  70 |     | <span class='neutral'>        address caller;</span>
  71 |     | <span class='neutral'>        address token0;</span>
  72 |     | <span class='neutral'>        address token1;</span>
  73 |     | <span class='neutral'>        uint128 price;</span>
  74 |     | <span class='neutral'>        uint128 strike;</span>
  75 |     | <span class='neutral'>        uint24 sigma;</span>
  76 |     | <span class='neutral'>        uint32 maturity;</span>
  77 |     | <span class='neutral'>        uint32 gamma;</span>
  78 |     | <span class='neutral'>        uint32 priorityGamma;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    bytes[] instructions;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function _assertCreatePool(CreateArgs memory args) internal {</span>
  84 |     | <span class='unexecuted'>        bool isMutable = true;</span>
  85 |     | <span class='unexecuted'>        uint24 pairId = __hyper__.getPairId(args.token0, args.token1);</span>
  86 |     | <span class='neutral'>        {</span>
  87 |     | <span class='neutral'>            // HyperPair not created? Push a create pair call to the stack.</span>
  88 |     | <span class='unexecuted'>            if (pairId == 0) instructions.push(Enigma.encodeCreatePair(args.token0, args.token1));</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>            // Push create pool to stack</span>
  91 |     | <span class='unexecuted'>            instructions.push(</span>
  92 |     | <span class='unexecuted'>                Enigma.encodeCreatePool(</span>
  93 |     | <span class='unexecuted'>                    pairId,</span>
  94 |     | <span class='unexecuted'>                    address(this),</span>
  95 |     | <span class='unexecuted'>                    1, // priorityFee</span>
  96 |     | <span class='unexecuted'>                    1, // fee</span>
  97 |     | <span class='unexecuted'>                    1, // vol</span>
  98 |     | <span class='unexecuted'>                    1, // dur</span>
  99 |     | <span class='unexecuted'>                    5,</span>
 100 |     | <span class='unexecuted'>                    int24(20_000),</span>
 101 |     | <span class='unexecuted'>                    args.price</span>
 102 |     | <span class='neutral'>                )</span>
 103 |     | <span class='neutral'>            ); // temp</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='unexecuted'>        bytes memory payload = Enigma.encodeJumpInstruction(instructions);</span>
 106 |     | <span class='unexecuted'>        vm.prank(args.caller);</span>
 107 |     | <span class='unexecuted'>        console.logBytes(payload);</span>
 108 |     | <span class='unexecuted'>        (bool success, bytes memory reason) = address(__hyper__).call(payload);</span>
 109 |     | <span class='neutral'>        assembly {</span>
 110 |     | <span class='unexecuted'>            log0(add(32, reason), mload(reason))</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        //bool success = forwarder.forward(address(__hyper__), payload); // TODO: Fallback function does not bubble up custom errors.</span>
 114 |     | <span class='unexecuted'>        assertTrue(success, &quot;hyper-call-failed&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // Refetch the poolId. Current poolId could be &quot;magic&quot; zero variable.</span>
 117 |     | <span class='unexecuted'>        pairId = __hyper__.getPairId(args.token0, args.token1);</span>
 118 |     | <span class='unexecuted'>        assertTrue(pairId != 0, &quot;pair-not-created&quot;);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // todo: make sure we create the last pool...</span>
 121 |     | <span class='unexecuted'>        uint64 poolId = Enigma.encodePoolId(pairId, isMutable, uint32(__hyper__.getPoolNonce()));</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // Add the created pool to the list of pools.</span>
 124 |     | <span class='unexecuted'>        assertTrue(getPool(address(__hyper__), poolId).lastPrice != 0, &quot;pool-price-zero&quot;);</span>
 125 |     | <span class='unexecuted'>        ctx.addPoolId(poolId);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Reset instructions so we don&#39;t use some old payload data...</span>
 128 |     | <span class='unexecuted'>        delete instructions;</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>}</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>interface DoJump {</span>
 133 |     | <span class='neutral'>    function doJumpProcess(bytes calldata data) external payable;</span>
 134 |     | <span class='neutral'>}</span>
 135 |     | <span class='unexecuted'></span>
 136 |     | <span class='neutral'>contract Forwarder {</span>
 137 |     | <span class='unexecuted'>    function forward(address hyper, bytes calldata data) external payable returns (bool) {</span>
 138 |     | <span class='unexecuted'>        try DoJump(hyper).doJumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {</span>
 139 |     | <span class='neutral'>            assembly {</span>
 140 |     | <span class='unexecuted'>                revert(add(32, reason), mload(reason))</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='unexecuted'>        return true;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/InvariantDeposit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/InvariantTargetContract.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract InvariantDeposit is InvariantTargetContract {</span>
  7 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function deposit(uint amount, uint index) external {</span>
 10 |     | <span class='unexecuted'>        amount = bound(amount, 1, 1e36);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>        address target = ctx.getRandomUser(index);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>        vm.deal(target, amount);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>        address weth = __hyper__.WETH();</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>        uint preBal = getBalance(address(__hyper__), target, weth);</span>
 19 |     | <span class='unexecuted'>        uint preRes = getReserve(address(__hyper__), weth);</span>
 20 |     | <span class='unexecuted'>        vm.prank(target);</span>
 21 |     | <span class='unexecuted'>        __hyper__.deposit{value: amount}();</span>
 22 |     | <span class='unexecuted'>        uint postRes = getReserve(address(__hyper__), weth);</span>
 23 |     | <span class='unexecuted'>        uint postBal = getBalance(address(__hyper__), target, weth);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        assertEq(postRes, preRes + amount, &quot;weth-reserve&quot;);</span>
 26 |     | <span class='unexecuted'>        assertEq(postBal, preBal + amount, &quot;weth-balance&quot;);</span>
 27 |     | <span class='unexecuted'>        assertEq(address(__hyper__).balance, 0, &quot;eth-balance&quot;);</span>
 28 |     | <span class='unexecuted'>        assertEq(getPhysicalBalance(address(__hyper__), weth), postRes, &quot;weth-physical&quot;);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/InvariantFundDraw.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/InvariantTargetContract.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract InvariantFundDraw is InvariantTargetContract {</span>
  7 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function fund_asset(uint amount, uint index) public {</span>
 10 |     | <span class='unexecuted'>        amount = bound(amount, 1, 1e36);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>        address target = ctx.getRandomUser(index);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>        // If net balance &gt; 0, there are tokens in the contract which are not in a pool or balance.</span>
 15 |     | <span class='neutral'>        // They will be credited to the msg.sender of the next call.</span>
 16 |     | <span class='unexecuted'>        int netAssetBalance = __hyper__.getNetBalance(address(__asset__));</span>
 17 |     | <span class='unexecuted'>        int netQuoteBalance = __hyper__.getNetBalance(address(__quote__));</span>
 18 |     | <span class='unexecuted'>        assertTrue(netAssetBalance &gt;= 0, &quot;negative-net-asset-tokens&quot;);</span>
 19 |     | <span class='unexecuted'>        assertTrue(netQuoteBalance &gt;= 0, &quot;negative-net-quote-tokens&quot;);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>        vm.prank(target);</span>
 22 |     | <span class='unexecuted'>        __asset__.approve(address(__hyper__), amount);</span>
 23 |     | <span class='unexecuted'>        deal(address(__asset__), target, amount);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        uint preRes = getReserve(address(__hyper__), address(__asset__));</span>
 26 |     | <span class='unexecuted'>        uint preBal = getBalance(address(__hyper__), target, address(__asset__));</span>
 27 |     | <span class='unexecuted'>        vm.prank(target);</span>
 28 |     | <span class='unexecuted'>        __hyper__.fund(address(__asset__), amount);</span>
 29 |     | <span class='unexecuted'>        uint postRes = getReserve(address(__hyper__), address(__asset__));</span>
 30 |     | <span class='unexecuted'>        uint postBal = getBalance(address(__hyper__), target, address(__asset__));</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        assertEq(postBal, preBal + amount + uint(netAssetBalance), &quot;fund-delta-asset-balance&quot;);</span>
 33 |     | <span class='unexecuted'>        assertEq(postRes, preRes + amount + uint(netQuoteBalance), &quot;fund-delta-asset-reserve&quot;);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function fund_quote(uint amount, uint index) public {</span>
 37 |     | <span class='unexecuted'>        amount = bound(amount, 1, 1e36);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        address target = ctx.getRandomUser(index);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>        vm.prank(target);</span>
 42 |     | <span class='unexecuted'>        __quote__.approve(address(__hyper__), amount);</span>
 43 |     | <span class='unexecuted'>        deal(address(__quote__), target, amount);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        uint preRes = getReserve(address(__hyper__), address(__quote__));</span>
 46 |     | <span class='unexecuted'>        uint preBal = getBalance(address(__hyper__), target, address(__quote__));</span>
 47 |     | <span class='unexecuted'>        vm.prank(target);</span>
 48 |     | <span class='unexecuted'>        __hyper__.fund(address(__quote__), amount);</span>
 49 |     | <span class='unexecuted'>        uint postRes = getReserve(address(__hyper__), address(__quote__));</span>
 50 |     | <span class='unexecuted'>        uint postBal = getBalance(address(__hyper__), target, address(__quote__));</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        assertEq(postBal, preBal + amount, &quot;fund-delta-quote-balance&quot;);</span>
 53 |     | <span class='unexecuted'>        assertEq(postRes, preRes + amount, &quot;fund-delta-quote-reserve&quot;);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/InvariantSendTokens.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/InvariantTargetContract.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract InvariantSendTokens is InvariantTargetContract {</span>
  7 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event SentTokens(address indexed token, uint amount);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function sendAssetTokens(uint amount) external {</span>
 12 |     | <span class='unexecuted'>        amount = bound(amount, 1, 2 ** 127);</span>
 13 |     | <span class='unexecuted'>        transfer(__asset__, amount);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function sendQuoteTokens(uint amount) external {</span>
 17 |     | <span class='unexecuted'>        amount = bound(amount, 1, 2 ** 127);</span>
 18 |     | <span class='unexecuted'>        transfer(__quote__, amount);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function transfer(TestERC20 token, uint amount) internal {</span>
 22 |     | <span class='unexecuted'>        token.mint(address(__hyper__), amount);</span>
 23 |     | <span class='unexecuted'>        emit SentTokens(address(token), amount);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/InvariantWarper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/InvariantTargetContract.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract InvariantWarper is InvariantTargetContract {</span>
  7 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function warper(uint amount) external {</span>
 10 |     | <span class='unexecuted'>        ctx.customWarp(block.timestamp + bound(amount, 1, 365 days));</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function warpAfterMaturity(uint amount) external {</span>
 14 |     | <span class='unexecuted'>        amount = bound(amount, 1 days, 700 days);</span>
 15 |     | <span class='unexecuted'>        uint tau = HyperTau(address(__hyper__)).computeCurrentTau(__poolId__);</span>
 16 |     | <span class='unexecuted'>        ctx.customWarp(block.timestamp + tau + amount);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>interface HyperTau {</span>
 21 |     | <span class='neutral'>    function computeCurrentTau(uint64 poolId) external view returns (uint);</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/TestE2EInvariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./setup/TestE2ESetup.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./setup/TestInvariantSetup.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import {InvariantAllocateUnallocate} from &quot;./InvariantAllocateUnallocate.sol&quot;;</span>
   8 |     | <span class='neutral'>import {InvariantFundDraw} from &quot;./InvariantFundDraw.sol&quot;;</span>
   9 |     | <span class='neutral'>import {InvariantDeposit} from &quot;./InvariantDeposit.sol&quot;;</span>
  10 |     | <span class='neutral'>import {InvariantSendTokens} from &quot;./InvariantSendTokens.sol&quot;;</span>
  11 |     | <span class='neutral'>import {InvariantWarper} from &quot;./InvariantWarper.sol&quot;;</span>
  12 |     | <span class='neutral'>import {InvariantCreatePool} from &quot;./InvariantCreatePool.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>bytes32 constant SLOT_LOCKED = bytes32(uint(5));</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/**</span>
  17 |     | <span class='neutral'> * @dev Most important test suite, verifies the critical invariants of Hyper.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * Invariant 1. balanceOf &gt;= getReserve for all tokens.</span>
  20 |     | <span class='neutral'> * Invariant 2. AccountSystem.settled == true.</span>
  21 |     | <span class='neutral'> * Invariant 3. AccountSystem.prepared == false.</span>
  22 |     | <span class='neutral'> * Invariant 4. (balanceOf(asset), balanceOf(quote)) &gt;= hyper.getVirtualReserves, for all pools.</span>
  23 |     | <span class='neutral'> * Invariant 5. ∑ hyper.positions(owner, poolId).freeLiquidity == hyper.pools(poolId).liquidity, for all pools.</span>
  24 |     | <span class='unexecuted'> */</span>
  25 |     | <span class='neutral'>contract TestE2EInvariant is TestInvariantSetup, TestE2ESetup {</span>
  26 |     | <span class='neutral'>    InvariantAllocateUnallocate internal _allocateUnallocate;</span>
  27 |     | <span class='neutral'>    InvariantFundDraw internal _fundDraw;</span>
  28 |     | <span class='neutral'>    InvariantDeposit internal _deposit;</span>
  29 |     | <span class='neutral'>    InvariantSendTokens internal _sendTokens;</span>
  30 |     | <span class='neutral'>    InvariantWarper internal _warper;</span>
  31 |     | <span class='neutral'>    InvariantCreatePool internal _createPool;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    uint64[] public __poolIds__;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function setUp() public override {</span>
  36 |     | <span class='unexecuted'>        super.setUp();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        (address hyper, address asset, address quote) = (address(__hyper__), address(__asset__), address(__quote__));</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        _allocateUnallocate = new InvariantAllocateUnallocate(hyper, asset, quote);</span>
  41 |     | <span class='unexecuted'>        _fundDraw = new InvariantFundDraw(hyper, asset, quote);</span>
  42 |     | <span class='unexecuted'>        _deposit = new InvariantDeposit(hyper, asset, quote);</span>
  43 |     | <span class='unexecuted'>        _sendTokens = new InvariantSendTokens(hyper, asset, quote);</span>
  44 |     | <span class='unexecuted'>        _warper = new InvariantWarper(hyper, asset, quote);</span>
  45 |     | <span class='unexecuted'>        _createPool = new InvariantCreatePool(hyper, asset, quote);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        addTargetContract(address(_allocateUnallocate));</span>
  48 |     | <span class='unexecuted'>        addTargetContract(address(_fundDraw));</span>
  49 |     | <span class='unexecuted'>        addTargetContract(address(_deposit));</span>
  50 |     | <span class='unexecuted'>        addTargetContract(address(_sendTokens));</span>
  51 |     | <span class='unexecuted'>        addTargetContract(address(_warper));</span>
  52 |     | <span class='unexecuted'>        addTargetContract(address(_createPool));</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        __users__.push(address(_allocateUnallocate));</span>
  55 |     | <span class='unexecuted'>        __users__.push(address(_fundDraw));</span>
  56 |     | <span class='unexecuted'>        __users__.push(address(_deposit));</span>
  57 |     | <span class='unexecuted'>        __users__.push(address(_sendTokens));</span>
  58 |     | <span class='unexecuted'>        __users__.push(address(_warper));</span>
  59 |     | <span class='unexecuted'>        __users__.push(address(_createPool));</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        addPoolId(__poolId__);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function invariant_assert_pools_created() public {</span>
  65 |     | <span class='unexecuted'>        assertTrue(__poolIds__.length &gt; 0);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    function invariant_asset_balance_gte_reserves() public {</span>
  69 |     | <span class='unexecuted'>        (uint reserve, uint physical, ) = getBalances(address(__asset__));</span>
  70 |     | <span class='unexecuted'>        assertTrue(physical &gt;= reserve, &quot;invariant-asset-physical-balance&quot;);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function invariant_quote_balance_gte_reserves() public {</span>
  74 |     | <span class='unexecuted'>        (uint reserve, uint physical, ) = getBalances(address(__quote__));</span>
  75 |     | <span class='unexecuted'>        assertTrue(physical &gt;= reserve, &quot;invariant-quote-physical-balance&quot;);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function invariant_account_settled() public {</span>
  79 |     | <span class='unexecuted'>        (, bool settled) = __hyper__.__account__();</span>
  80 |     | <span class='unexecuted'>        assertTrue(settled, &quot;invariant-settled&quot;);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function invariant_account_prepared() public {</span>
  84 |     | <span class='unexecuted'>        (bool prepared, ) = __hyper__.__account__();</span>
  85 |     | <span class='unexecuted'>        assertTrue(!prepared, &quot;invariant-prepared&quot;);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function invariant_virtual_pool_asset_reserves() public {</span>
  89 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyper__), __poolId__);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        if (pool.liquidity &gt; 0) {</span>
  92 |     | <span class='unexecuted'>            (uint dAsset, ) = __hyper__.getVirtualReserves(__poolId__);</span>
  93 |     | <span class='unexecuted'>            uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));</span>
  94 |     | <span class='unexecuted'>            assertTrue(bAsset &gt;= dAsset, &quot;invariant-virtual-reserves-asset&quot;);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>    function invariant_virtual_pool_quote_reserves() public {</span>
  99 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyper__), __poolId__);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        if (pool.liquidity &gt; 0) {</span>
 102 |     | <span class='unexecuted'>            (, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);</span>
 103 |     | <span class='unexecuted'>            uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));</span>
 104 |     | <span class='unexecuted'>            assertTrue(bQuote &gt;= dQuote, &quot;invariant-virtual-reserves-quote&quot;);</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function invariant_liquidity_sum() public {</span>
 109 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyper__), __poolId__);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        uint sum;</span>
 112 |     | <span class='unexecuted'>        for (uint i; i != __users__.length; ++i) {</span>
 113 |     | <span class='unexecuted'>            HyperPosition memory pos = getPosition(address(__hyper__), __users__[i], __poolId__);</span>
 114 |     | <span class='unexecuted'>            sum += pos.freeLiquidity;</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        assertTrue(sum == pool.liquidity, &quot;invariant-liquidity-sum&quot;);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function invariant_reentrancy() public {</span>
 121 |     | <span class='unexecuted'>        bytes32 locked = vm.load(address(__hyper__), SLOT_LOCKED);</span>
 122 |     | <span class='unexecuted'>        assertEq(uint(locked), 1, &quot;invariant-locked&quot;);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        uint balance = address(__hyper__).balance;</span>
 125 |     | <span class='unexecuted'>        assertEq(balance, 0, &quot;invariant-ether&quot;);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>    function getBalances(address token) internal view returns (uint reserve, uint physical, uint balances) {</span>
 129 |     | <span class='unexecuted'>        reserve = getReserve(address(__hyper__), token);</span>
 130 |     | <span class='unexecuted'>        physical = getPhysicalBalance(address(__hyper__), token);</span>
 131 |     | <span class='unexecuted'>        balances = getBalanceSum(address(__hyper__), token, __users__);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function addPoolId(uint64 poolId) public {</span>
 135 |     | <span class='unexecuted'>        assertTrue(poolId != 0, &quot;zero poolId&quot;);</span>
 136 |     | <span class='unexecuted'>        __poolIds__.push(poolId);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function getRandomUser(uint id) public returns (address) {</span>
 140 |     | <span class='unexecuted'>        assertTrue(__users__.length &gt; 0);</span>
 141 |     | <span class='unexecuted'>        uint index = id % __users__.length;</span>
 142 |     | <span class='unexecuted'>        address user = __users__[index];</span>
 143 |     | <span class='neutral'>        return user;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function getRandomPoolId(uint id) public returns (uint64) {</span>
 147 |     | <span class='unexecuted'>        assertTrue(__poolIds__.length &gt; 0);</span>
 148 |     | <span class='unexecuted'>        uint index = id % __poolIds__.length;</span>
 149 |     | <span class='unexecuted'>        uint64 poolId = __poolIds__[index];</span>
 150 |     | <span class='neutral'>        return poolId;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/TestInvariantBasic.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./setup/TestInvariantSetup.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>/** @dev Example invariant testing contract, for reference only. https://github.com/foundry-rs/foundry/pull/1572#discussion_r869737535 */</span>
  8 |     | <span class='neutral'>contract InvariantBreaker is Test {</span>
  9 |     | <span class='unexecuted'>    bool public flag0 = true;</span>
 10 |     | <span class='unexecuted'>    bool public flag1 = true;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function set0(int val) public returns (bool) {</span>
 13 |     | <span class='unexecuted'>        if (val % 100 == 0) flag0 = false;</span>
 14 |     | <span class='unexecuted'>        return flag0;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function set1(int val) public returns (bool) {</span>
 18 |     | <span class='unexecuted'>        if (val % 10 == 0 &amp;&amp; !flag0) flag1 = false;</span>
 19 |     | <span class='unexecuted'>        return flag1;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>/** @dev Example invariant test. Always fails! */</span>
 24 |     | <span class='neutral'>contract TestInvariantBasic is TestInvariantSetup, Test {</span>
 25 |     | <span class='neutral'>    InvariantBreaker inv;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function setUp() public {</span>
 28 |     | <span class='unexecuted'>        inv = new InvariantBreaker();</span>
 29 |     | <span class='neutral'>        addTargetContract(address(inv));</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function invariant_neverFalse() public view {</span>
 33 |     | <span class='neutral'>        // note: uncomment to test invariant testing</span>
 34 |     | <span class='neutral'>        // require(inv.flag1());</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/setup/InvariantTargetContract.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperView.sol&quot;;</span>
  6 |     | <span class='neutral'>import {HyperPool, HyperPosition, HyperTimeOverride, TestERC20} from &quot;test/helpers/HyperTestOverrides.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface Context {</span>
  9 |     | <span class='neutral'>    function users() external view returns (address[] memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function getRandomPoolId(uint id) external view returns (uint64);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function setPoolId(uint64 poolId) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function addPoolId(uint64 poolId) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function customWarp(uint time) external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function getRandomUser(uint id) external view returns (address);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function __weth__() external view returns (TestERC20);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function __asset__() external view returns (TestERC20);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function __quote__() external view returns (TestERC20);</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>/** @dev Target contract must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */</span>
 29 |     | <span class='neutral'>contract InvariantTargetContract is HelperHyperView, Test {</span>
 30 |     | <span class='neutral'>    Context ctx;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    uint64 public __poolId__ = 0x0000010000000001;</span>
 33 |     | <span class='unexecuted'>    HyperTimeOverride public __hyper__; // Actual contract</span>
 34 |     | <span class='unexecuted'>    TestERC20 public __quote__;</span>
 35 |     | <span class='unexecuted'>    TestERC20 public __asset__;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    constructor(address hyper_, address asset_, address quote_) {</span>
 38 |     | <span class='unexecuted'>        ctx = Context(msg.sender);</span>
 39 |     | <span class='unexecuted'>        __hyper__ = HyperTimeOverride(payable(hyper_));</span>
 40 |     | <span class='unexecuted'>        __asset__ = TestERC20(asset_);</span>
 41 |     | <span class='unexecuted'>        __quote__ = TestERC20(quote_);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        __asset__.approve(hyper_, type(uint).max);</span>
 44 |     | <span class='unexecuted'>        __quote__.approve(hyper_, type(uint).max);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /** @dev Uses the initialized context for the getState function. */</span>
 48 |     | <span class='unexecuted'>    function getState() internal view returns (HyperState memory) {</span>
 49 |     | <span class='unexecuted'>        return getState(address(__hyper__), __poolId__, address(this), ctx.users());</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>    function setPoolId(uint64 poolId) internal {</span>
 53 |     | <span class='unexecuted'>        ctx.setPoolId(poolId); // TODO: duplicating for now...</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>        HyperPair memory pair = getPair(address(__hyper__), Processor.decodePairIdFromPoolId(poolId));</span>
 56 |     | <span class='unexecuted'>        __asset__ = TestERC20(pair.tokenAsset);</span>
 57 |     | <span class='unexecuted'>        __quote__ = TestERC20(pair.tokenQuote);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/setup/TestE2ESetup.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;solmate/tokens/WETH.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;contracts/libraries/Price.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   9 |     | <span class='neutral'>import {TestERC20, HyperTimeOverride, FixedPointMathLib} from &quot;test/helpers/HyperTestOverrides.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperActions.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperInvariants.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperProfiles.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperView.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>uint constant STARTING_BALANCE = 0;</span>
  17 |     | <span class='unexecuted'></span>
  18 |     | <span class='neutral'>contract Helpers is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView {}</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>/** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */</span>
  21 |     | <span class='neutral'>contract TestE2ESetup is Helpers, Test {</span>
  22 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  23 |     | <span class='neutral'>    using FixedPointMathLib for int256;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // ===== Global Variables ===== //</span>
  26 |     | <span class='unexecuted'>    uint64 public __poolId__ = 0x0000010000000001;</span>
  27 |     | <span class='unexecuted'>    address[] public __users__;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    WETH public __weth__;</span>
  30 |     | <span class='unexecuted'>    TestERC20 public __quote__;</span>
  31 |     | <span class='unexecuted'>    TestERC20 public __asset__;</span>
  32 |     | <span class='unexecuted'>    HyperTimeOverride public __hyper__; // Actual contract</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // ===== Set up ===== //</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function setUp() public virtual {</span>
  37 |     | <span class='unexecuted'>        initContracts();</span>
  38 |     | <span class='unexecuted'>        initUsers();</span>
  39 |     | <span class='unexecuted'>        initScenarios();</span>
  40 |     | <span class='unexecuted'>        initPrerequisites();</span>
  41 |     | <span class='neutral'>        afterSetUp();</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /** @dev Requires tokens to be spent and spenders to be approved. */</span>
  45 |     | <span class='unexecuted'>    function initPrerequisites() internal {</span>
  46 |     | <span class='unexecuted'>        approveTokens();</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */</span>
  50 |     | <span class='neutral'>    receive() external payable {</span>
  51 |     | <span class='unexecuted'>        receiveOverride();</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /** @dev Uses the initialized context for the getState function. */</span>
  55 |     | <span class='neutral'>    function getState() internal view virtual returns (HyperState memory) {</span>
  56 |     | <span class='neutral'>        return getState(address(__hyper__), __poolId__, address(this), __users__);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /** @dev Hook to run after test setup. */</span>
  60 |     | <span class='unexecuted'>    function afterSetUp() public virtual {}</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /** @dev Replace receive ether logic. */</span>
  63 |     | <span class='unexecuted'>    function receiveOverride() public virtual {}</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // ===== Contracts Context ===== //</span>
  66 |     | <span class='unexecuted'>    function initContracts() internal {</span>
  67 |     | <span class='unexecuted'>        __weth__ = new WETH();</span>
  68 |     | <span class='unexecuted'>        __hyper__ = new HyperTimeOverride(address(__weth__));</span>
  69 |     | <span class='unexecuted'>        __quote__ = new TestERC20(&quot;USD Coin&quot;, &quot;USDC&quot;, 6);</span>
  70 |     | <span class='unexecuted'>        __asset__ = new TestERC20(&quot;18 Decimals&quot;, &quot;18DEC&quot;, 18);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        setLabels();</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function setLabels() internal {</span>
  76 |     | <span class='unexecuted'>        vm.label(address(this), &quot;Self&quot;);</span>
  77 |     | <span class='unexecuted'>        vm.label(address(__weth__), &quot;Weth&quot;);</span>
  78 |     | <span class='unexecuted'>        vm.label(address(__hyper__), &quot;HyperTimeOverride&quot;);</span>
  79 |     | <span class='unexecuted'>        vm.label(address(__quote__), &quot;QuoteToken&quot;);</span>
  80 |     | <span class='unexecuted'>        vm.label(address(__asset__), &quot;AssetToken&quot;);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    // ===== Users ===== //</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function users() public view virtual returns (address[] memory) {</span>
  86 |     | <span class='unexecuted'>        return __users__;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function initUsers() internal {</span>
  90 |     | <span class='unexecuted'>        address self = address(this);</span>
  91 |     | <span class='unexecuted'>        address alicent = address(0x0001);</span>
  92 |     | <span class='unexecuted'>        address boba = address(0x0002);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        addUser(self, &quot;Self&quot;);</span>
  95 |     | <span class='unexecuted'>        addUser(alicent, &quot;Alicent&quot;);</span>
  96 |     | <span class='unexecuted'>        addUser(boba, &quot;Boba&quot;);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function addUser(address user, string memory label) public {</span>
 100 |     | <span class='unexecuted'>        vm.label(user, label);</span>
 101 |     | <span class='unexecuted'>        __users__.push(user);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // ===== Test Scenarios ===== //</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function initScenarios() internal {</span>
 107 |     | <span class='unexecuted'>        __hyper__.setTimestamp(uint128(block.timestamp)); // Important</span>
 108 |     | <span class='neutral'>        // Create default pool</span>
 109 |     | <span class='unexecuted'>        bytes memory data = createPool(</span>
 110 |     | <span class='unexecuted'>            address(__asset__),</span>
 111 |     | <span class='unexecuted'>            address(__quote__),</span>
 112 |     | <span class='neutral'>            address(0),</span>
 113 |     | <span class='unexecuted'>            uint16(1e4 - DEFAULT_PRIORITY_GAMMA),</span>
 114 |     | <span class='unexecuted'>            uint16(1e4 - DEFAULT_GAMMA),</span>
 115 |     | <span class='neutral'>            uint16(DEFAULT_SIGMA),</span>
 116 |     | <span class='neutral'>            uint16(DEFAULT_DURATION_DAYS),</span>
 117 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 118 |     | <span class='neutral'>            DEFAULT_TICK,</span>
 119 |     | <span class='neutral'>            DEFAULT_PRICE</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        (bool success, ) = address(__hyper__).call(data);</span>
 123 |     | <span class='unexecuted'>        assertTrue(success, &quot;create pool call failed&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    // ===== Utils ===== //</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    /** @dev Does not include weth. */</span>
 129 |     | <span class='unexecuted'>    function approveTokens() internal {</span>
 130 |     | <span class='unexecuted'>        for (uint z; z != __users__.length; ++z) {</span>
 131 |     | <span class='unexecuted'>            vm.prank(__users__[z]); // Sets caller</span>
 132 |     | <span class='unexecuted'>            __asset__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.</span>
 133 |     | <span class='unexecuted'>            __quote__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /** @dev Does not include weth. */</span>
 138 |     | <span class='neutral'>    function fundUsers(uint deltaAsset, uint deltaQuote) internal {</span>
 139 |     | <span class='neutral'>        for (uint i; i != __users__.length; ++i) {</span>
 140 |     | <span class='neutral'>            deal(address(__asset__), __users__[i], deltaAsset); // TODO: Use regular ERC20, since we can deal.</span>
 141 |     | <span class='neutral'>            deal(address(__quote__), __users__[i], deltaQuote); // TODO: Use regular ERC20, since we can deal.</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>    function customWarp(uint time) public virtual {</span>
 146 |     | <span class='unexecuted'>        vm.warp(time);</span>
 147 |     | <span class='unexecuted'>        __hyper__.setTimestamp(uint128(time));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    event SetNewPoolId(uint64);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /** @dev Sets the pool id and assets in TestE2ESetup state. Affects all tests! */</span>
 153 |     | <span class='unexecuted'>    function setPoolId(uint64 poolId) public {</span>
 154 |     | <span class='unexecuted'>        __poolId__ = poolId;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        HyperPair memory pair = getPair(address(__hyper__), Enigma.decodePairIdFromPoolId(poolId));</span>
 157 |     | <span class='unexecuted'>        __asset__ = TestERC20(pair.tokenAsset);</span>
 158 |     | <span class='unexecuted'>        __quote__ = TestERC20(pair.tokenQuote);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        emit SetNewPoolId(poolId);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>}</span>
 163 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/E2E/setup/TestInvariantSetup.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>/** @dev Invariant tests must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */</span>
  5 |     | <span class='neutral'>contract TestInvariantSetup {</span>
  6 |     | <span class='neutral'>    address[] private _targetContracts;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>    function addTargetContract(address target) internal {</span>
  9 |     | <span class='unexecuted'>        _targetContracts.push(target);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function targetContracts() public view returns (address[] memory) {</span>
 13 |     | <span class='unexecuted'>        require(_targetContracts.length != uint(0), &quot;no-target-contracts&quot;);</span>
 14 |     | <span class='unexecuted'>        return _targetContracts;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/crytic/TestE2EHyper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/* import &quot;./setup/TestEchidnaSetup.sol&quot;; */</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestE2EHyper {</span>
  7 |     | <span class='neutral'>    event AssertionFailed();</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function echidna_jit_policy() public returns (bool) {</span>
 10 |     | <span class='unexecuted'>        if (5 != 4) emit AssertionFailed();</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/crytic/setup/TestEchidnaSetup.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;solmate/tokens/WETH.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;contracts/libraries/Price.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperActions.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperInvariants.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperProfiles.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperView.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>import {TestERC20, HyperTimeOverride} from &quot;test/helpers/HyperTestOverrides.sol&quot;;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>uint constant STARTING_BALANCE = 4000e18;</span>
 15 |     | <span class='unexecuted'></span>
 16 |     | <span class='neutral'>contract TestEchidnaEvents {</span>
 17 |     | <span class='neutral'>    event AssertionFailed();</span>
 18 |     | <span class='neutral'>    event AssertionFailed(uint);</span>
 19 |     | <span class='neutral'>    event AssertionFailed(uint, uint);</span>
 20 |     | <span class='neutral'>    event AssertionFailed(uint, uint, uint);</span>
 21 |     | <span class='neutral'>    event AssertionFailed(string, uint);</span>
 22 |     | <span class='neutral'>    event AssertionFailed(bytes);</span>
 23 |     | <span class='neutral'>    event AssertionFailed(int);</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='unexecuted'></span>
 26 |     | <span class='neutral'>contract Addresses {</span>
 27 |     | <span class='unexecuted'>    User public __user__;</span>
 28 |     | <span class='unexecuted'>    WETH public __weth__;</span>
 29 |     | <span class='unexecuted'>    HyperTimeOverride public __hyper__;</span>
 30 |     | <span class='unexecuted'>    TestERC20 public __usdc__;</span>
 31 |     | <span class='unexecuted'>    TestERC20 public __token_18__;</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='unexecuted'></span>
 34 |     | <span class='neutral'>contract User {}</span>
 35 |     | <span class='unexecuted'></span>
 36 |     | <span class='neutral'>contract TestEchidnaSetup is</span>
 37 |     | <span class='neutral'>    TestEchidnaEvents,</span>
 38 |     | <span class='neutral'>    HelperHyperActions,</span>
 39 |     | <span class='neutral'>    HelperHyperInvariants,</span>
 40 |     | <span class='neutral'>    HelperHyperProfiles,</span>
 41 |     | <span class='neutral'>    HelperHyperView,</span>
 42 |     | <span class='neutral'>    Addresses</span>
 43 |     | <span class='neutral'>{</span>
 44 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
 45 |     | <span class='neutral'>    using FixedPointMathLib for int256;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    constructor() {</span>
 48 |     | <span class='unexecuted'>        initContracts();</span>
 49 |     | <span class='unexecuted'>        fundUsers();</span>
 50 |     | <span class='unexecuted'>        approveSpenders();</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        afterSetUp();</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function initContracts() internal {</span>
 56 |     | <span class='unexecuted'>        __user__ = new User();</span>
 57 |     | <span class='unexecuted'>        __weth__ = new WETH();</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>        // --- Hyper Contracts --- //</span>
 60 |     | <span class='unexecuted'>        __hyper__ = new HyperTimeOverride(address(__weth__));</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>        // --- Tokens --- //</span>
 63 |     | <span class='unexecuted'>        __usdc__ = new TestERC20(&quot;USD Coin&quot;, &quot;USDC&quot;, 6);</span>
 64 |     | <span class='unexecuted'>        __token_18__ = new TestERC20(&quot;18 Decimals&quot;, &quot;18DEC&quot;, 18);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */</span>
 68 |     | <span class='neutral'>    receive() external payable {</span>
 69 |     | <span class='neutral'>        receiveOverride();</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /** @dev Hook to run after test setup. */</span>
 73 |     | <span class='unexecuted'>    function afterSetUp() public virtual {}</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    /** @dev Hook to implement to handle receive differently. */</span>
 76 |     | <span class='neutral'>    function receiveOverride() public virtual {}</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>    function deal(TestERC20 token, address to, uint amount) internal {</span>
 79 |     | <span class='unexecuted'>        token.mint(to, amount);</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    /** @dev Does not include weth. */</span>
 83 |     | <span class='unexecuted'>    function fundUsers() internal {</span>
 84 |     | <span class='unexecuted'>        deal(__token_18__, address(__user__), STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.</span>
 85 |     | <span class='unexecuted'>        deal(__usdc__, address(__user__), STARTING_BALANCE);</span>
 86 |     | <span class='neutral'>    }</span>
 87 |     | <span class='neutral'></span>
 88 |     | <span class='neutral'>    /** @dev Does not include weth. */</span>
 89 |     | <span class='unexecuted'>    function approveSpenders() internal {</span>
 90 |     | <span class='unexecuted'>        TestERC20(__token_18__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.</span>
 91 |     | <span class='unexecuted'>        TestERC20(__usdc__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.</span>
 92 |     | <span class='neutral'>    }</span>
 93 |     | <span class='neutral'>}</span>
 94 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperAllocate.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {HyperPool, JUST_IN_TIME_LIQUIDITY_POLICY, HyperPair} from &quot;contracts/HyperLib.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>struct Amounts {</span>
   8 |     | <span class='neutral'>    uint expectedDelta0;</span>
   9 |     | <span class='neutral'>    uint expectedDelta1;</span>
  10 |     | <span class='neutral'>    uint computedDelta0;</span>
  11 |     | <span class='neutral'>    uint computedDelta1;</span>
  12 |     | <span class='neutral'>    uint prevReserve0;</span>
  13 |     | <span class='neutral'>    uint prevReserve1;</span>
  14 |     | <span class='neutral'>    uint postReserve0;</span>
  15 |     | <span class='neutral'>    uint postReserve1;</span>
  16 |     | <span class='neutral'>}</span>
  17 |     | <span class='unexecuted'></span>
  18 |     | <span class='neutral'>contract TestHyperAllocate is TestHyperSetup {</span>
  19 |     | <span class='neutral'>    using SafeCastLib for uint;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    Amounts _amounts;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    modifier afterTest() {</span>
  24 |     | <span class='neutral'>        _;</span>
  25 |     | <span class='unexecuted'>        delete _amounts;</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function testAllocateNonStandardDecimals() public postTestInvariantChecks afterTest {</span>
  29 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
  30 |     | <span class='unexecuted'>        assertTrue(pool.lastTimestamp != 0, &quot;pool-created&quot;);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>        HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId &gt;&gt; 40));</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>        address hyper = address(__hyperTestingContract__);</span>
  35 |     | <span class='unexecuted'>        uint64 poolId = defaultScenario.poolId;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        uint128 liquidity = DEFAULT_LIQUIDITY;</span>
  38 |     | <span class='unexecuted'>        (_amounts.computedDelta0, _amounts.computedDelta1) = pool.getAmountsWad(); // one liquidity wad</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        (_amounts.expectedDelta0, _amounts.expectedDelta1) = (</span>
  41 |     | <span class='unexecuted'>            Assembly.scaleFromWadDown(_amounts.computedDelta0, pair.decimalsAsset),</span>
  42 |     | <span class='unexecuted'>            Assembly.scaleFromWadDown(_amounts.computedDelta1, pair.decimalsQuote)</span>
  43 |     | <span class='neutral'>        );</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        (_amounts.prevReserve0, _amounts.prevReserve1) = (</span>
  46 |     | <span class='unexecuted'>            getReserve(hyper, pair.tokenAsset),</span>
  47 |     | <span class='unexecuted'>            getReserve(hyper, pair.tokenQuote)</span>
  48 |     | <span class='neutral'>        );</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(poolId, liquidity);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>        (_amounts.postReserve0, _amounts.postReserve1) = (</span>
  53 |     | <span class='unexecuted'>            getReserve(hyper, pair.tokenAsset),</span>
  54 |     | <span class='unexecuted'>            getReserve(hyper, pair.tokenQuote)</span>
  55 |     | <span class='neutral'>        );</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        assertEq(_amounts.postReserve0, _amounts.prevReserve0 + _amounts.expectedDelta0, &quot;asset-reserves&quot;);</span>
  58 |     | <span class='unexecuted'>        assertEq(_amounts.postReserve1, _amounts.prevReserve1 + _amounts.expectedDelta1, &quot;quote-reserves&quot;);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function testAllocateFull() public postTestInvariantChecks {</span>
  62 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
  63 |     | <span class='unexecuted'>        assertTrue(pool.lastTimestamp != 0, &quot;pool-created&quot;);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        uint256 price = pool.lastPrice;</span>
  66 |     | <span class='unexecuted'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId));</span>
  67 |     | <span class='unexecuted'>        HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId &gt;&gt; 40));</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        uint tau = pool.lastTau(); // seconds</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        uint256 theoreticalR2 = Price.getXWithPrice(</span>
  72 |     | <span class='unexecuted'>            price,</span>
  73 |     | <span class='unexecuted'>            Price.computePriceWithTick(pool.params.maxTick),</span>
  74 |     | <span class='unexecuted'>            pool.params.volatility,</span>
  75 |     | <span class='unexecuted'>            tau</span>
  76 |     | <span class='neutral'>        );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        uint delLiquidity = 4_000_000;</span>
  79 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, delLiquidity);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  82 |     | <span class='unexecuted'>        uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  83 |     | <span class='unexecuted'>        assertTrue(globalR1 &gt; 0);</span>
  84 |     | <span class='unexecuted'>        assertTrue(globalR2 &gt; 0);</span>
  85 |     | <span class='unexecuted'>        assertApproxEqAbs(globalR2, (theoreticalR2 * delLiquidity) / 1e18, 1, &quot;asset-reserve-theoretic&quot;);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function testAllocateUseMax() public postTestInvariantChecks {</span>
  89 |     | <span class='unexecuted'>        uint assetBalance = defaultScenario.asset.balanceOf(address(this));</span>
  90 |     | <span class='unexecuted'>        uint quoteBalance = defaultScenario.quote.balanceOf(address(this));</span>
  91 |     | <span class='unexecuted'>        uint maxLiquidity = __hyperTestingContract__.getMaxLiquidity(</span>
  92 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  93 |     | <span class='neutral'>            assetBalance,</span>
  94 |     | <span class='neutral'>            quoteBalance</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        (address asset, address quote) = (address(defaultScenario.asset), address(defaultScenario.quote));</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        __hyperTestingContract__.fund(asset, assetBalance);</span>
 100 |     | <span class='unexecuted'>        __hyperTestingContract__.fund(quote, quoteBalance);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);</span>
 103 |     | <span class='unexecuted'>        quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);</span>
 104 |     | <span class='unexecuted'>        maxLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, assetBalance, quoteBalance);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getLiquidityDeltas(</span>
 107 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 108 |     | <span class='unexecuted'>            -int128(maxLiquidity.safeCastTo128()) // negative delta rounds output amounts down</span>
 109 |     | <span class='neutral'>        );</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, type(uint256).max);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 114 |     | <span class='unexecuted'>        assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);</span>
 115 |     | <span class='unexecuted'>        quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);</span>
 116 |     | <span class='unexecuted'>        (uint128 reserveAsset, uint128 reserveQuote) = pool.getVirtualReserves();</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        assertEq(deltaAsset, reserveAsset, &quot;delta-asset&quot;);</span>
 119 |     | <span class='unexecuted'>        assertEq(deltaQuote, reserveQuote, &quot;delta-quote&quot;);</span>
 120 |     | <span class='unexecuted'>        assertEq(maxLiquidity, pool.liquidity, &quot;delta-liquidity&quot;);</span>
 121 |     | <span class='unexecuted'>        assertEq(</span>
 122 |     | <span class='unexecuted'>            assetBalance,</span>
 123 |     | <span class='unexecuted'>            getReserve(address(__hyperTestingContract__), asset) - (deltaAsset + 1), // round up</span>
 124 |     | <span class='neutral'>            &quot;asset-balance&quot;</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='unexecuted'>        assertEq(</span>
 127 |     | <span class='unexecuted'>            quoteBalance,</span>
 128 |     | <span class='unexecuted'>            getReserve(address(__hyperTestingContract__), quote) - (deltaQuote + 1), // round up</span>
 129 |     | <span class='neutral'>            &quot;quote-balance&quot;</span>
 130 |     | <span class='neutral'>        );</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * note: Found an interesting overflow bug!</span>
 135 |     | <span class='neutral'>     * 170141183460469231731687303715884105728 is equal to 2^127.</span>
 136 |     | <span class='neutral'>     * Values between 2^127 and 2^128 will break allocate, because of the implicit conversion</span>
 137 |     | <span class='neutral'>     * from uint128 to int128 causing an overflow.</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='unexecuted'>    function testFuzzAllocateUnallocateSuccessful(uint128 deltaLiquidity) public postTestInvariantChecks {</span>
 140 |     | <span class='unexecuted'>        vm.assume(deltaLiquidity != 0);</span>
 141 |     | <span class='unexecuted'>        vm.assume(deltaLiquidity &lt; (2 ** 126 - 1e36)); // note: if its 2^127, it could still overflow since liquidity is multiplied against token amounts in getLiquidityDeltas.</span>
 142 |     | <span class='neutral'>        // TODO: Add use max flag support.</span>
 143 |     | <span class='unexecuted'>        _assertAllocate(deltaLiquidity);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /** @dev ALlocates then asserts the invariants. */</span>
 147 |     | <span class='unexecuted'>    function _assertAllocate(uint128 deltaLiquidity) internal {</span>
 148 |     | <span class='neutral'>        // Preconditions</span>
 149 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 150 |     | <span class='unexecuted'>        assertTrue(pool.lastTimestamp != 0, &quot;Pool not initialized&quot;);</span>
 151 |     | <span class='unexecuted'>        assertTrue(pool.lastPrice != 0, &quot;Pool not created with a price&quot;);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        (uint expectedDeltaAsset, uint expectedDeltaQuote) = __hyperTestingContract__.getLiquidityDeltas(</span>
 154 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 155 |     | <span class='neutral'>            int128(deltaLiquidity)</span>
 156 |     | <span class='neutral'>        );</span>
 157 |     | <span class='unexecuted'>        defaultScenario.asset.mint(address(this), expectedDeltaAsset);</span>
 158 |     | <span class='unexecuted'>        defaultScenario.quote.mint(address(this), expectedDeltaQuote);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // Execution</span>
 161 |     | <span class='unexecuted'>        HyperState memory prev = getState();</span>
 162 |     | <span class='unexecuted'>        (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.allocate(defaultScenario.poolId, deltaLiquidity);</span>
 163 |     | <span class='unexecuted'>        HyperState memory post = getState();</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        // Postconditions</span>
 166 |     | <span class='unexecuted'>        {</span>
 167 |     | <span class='unexecuted'>            assertEq(deltaAsset, expectedDeltaAsset, &quot;pool-delta-asset&quot;);</span>
 168 |     | <span class='unexecuted'>            assertEq(deltaQuote, expectedDeltaQuote, &quot;pool-delta-quote&quot;);</span>
 169 |     | <span class='unexecuted'>            assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, &quot;pool-total-liquidity&quot;);</span>
 170 |     | <span class='unexecuted'>            assertTrue(post.totalPoolLiquidity &gt; prev.totalPoolLiquidity, &quot;pool-liquidity-increases&quot;);</span>
 171 |     | <span class='unexecuted'>            assertEq(</span>
 172 |     | <span class='unexecuted'>                post.callerPositionLiquidity,</span>
 173 |     | <span class='unexecuted'>                prev.callerPositionLiquidity + deltaLiquidity,</span>
 174 |     | <span class='neutral'>                &quot;position-liquidity-increases&quot;</span>
 175 |     | <span class='neutral'>            );</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>            assertEq(post.reserveAsset, prev.reserveAsset + expectedDeltaAsset, &quot;reserve-asset&quot;);</span>
 178 |     | <span class='unexecuted'>            assertEq(post.reserveQuote, prev.reserveQuote + expectedDeltaQuote, &quot;reserve-quote&quot;);</span>
 179 |     | <span class='unexecuted'>            assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + expectedDeltaAsset, &quot;physical-asset&quot;);</span>
 180 |     | <span class='unexecuted'>            assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + expectedDeltaQuote, &quot;physical-quote&quot;);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>            uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;</span>
 183 |     | <span class='unexecuted'>            uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;</span>
 184 |     | <span class='unexecuted'>            assertTrue(feeDelta0 == feeDelta1, &quot;asset-growth&quot;);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>            uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;</span>
 187 |     | <span class='unexecuted'>            uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;</span>
 188 |     | <span class='unexecuted'>            assertTrue(feeDelta2 == feeDelta3, &quot;quote-growth&quot;);</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        // Unallocate</span>
 192 |     | <span class='unexecuted'>        customWarp(block.timestamp + JUST_IN_TIME_LIQUIDITY_POLICY); // TODO: make this public function.</span>
 193 |     | <span class='unexecuted'>        (uint unallocatedAsset, uint unallocatedQuote) = __hyperTestingContract__.unallocate(</span>
 194 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 195 |     | <span class='neutral'>            deltaLiquidity</span>
 196 |     | <span class='neutral'>        );</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        // remove all credits, since unallocate will increase this amount.</span>
 199 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(</span>
 200 |     | <span class='unexecuted'>            address(defaultScenario.asset),</span>
 201 |     | <span class='unexecuted'>            __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),</span>
 202 |     | <span class='unexecuted'>            address(this)</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(</span>
 205 |     | <span class='unexecuted'>            address(defaultScenario.quote),</span>
 206 |     | <span class='unexecuted'>            __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),</span>
 207 |     | <span class='unexecuted'>            address(this)</span>
 208 |     | <span class='neutral'>        );</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        {</span>
 211 |     | <span class='unexecuted'>            HyperState memory end = getState();</span>
 212 |     | <span class='unexecuted'>            assertApproxEqAbs(unallocatedAsset, deltaAsset, 1, &quot;unallocate-delta-asset&quot;);</span>
 213 |     | <span class='unexecuted'>            assertApproxEqAbs(unallocatedQuote, deltaQuote, 1, &quot;unallocate-delta-quote&quot;);</span>
 214 |     | <span class='unexecuted'>            assertApproxEqAbs(end.reserveAsset, prev.reserveAsset, 1, &quot;unallocate-reserve-asset&quot;);</span>
 215 |     | <span class='unexecuted'>            assertApproxEqAbs(end.reserveQuote, prev.reserveQuote, 1, &quot;unallocate-reserve-quote&quot;);</span>
 216 |     | <span class='unexecuted'>            assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity, &quot;unallocate-pool-liquidity&quot;);</span>
 217 |     | <span class='unexecuted'>            assertEq(end.totalPositionLiquidity, prev.totalPositionLiquidity, &quot;unallocate-sum-position-liquidity&quot;);</span>
 218 |     | <span class='unexecuted'>            assertEq(end.callerPositionLiquidity, prev.callerPositionLiquidity, &quot;unallocate-caller-position-liquidity&quot;);</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'>}</span>
 222 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperClaim.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
   5 |     | <span class='unexecuted'></span>
   6 |     | <span class='neutral'>contract TestHyperClaim is TestHyperSetup {</span>
   7 |     | <span class='neutral'>    using FixedPointMathLib for uint;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>    function testClaimNoPosition_reverts() public {</span>
  10 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(NonExistentPosition.selector, address(this), defaultScenario.poolId));</span>
  11 |     | <span class='unexecuted'>        __hyperTestingContract__.claim(defaultScenario.poolId, 0, 0);</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function testClaim_successful_PositionOwedAmountsReturnsZero() public {</span>
  15 |     | <span class='unexecuted'>        basicAllocate();</span>
  16 |     | <span class='unexecuted'>        basicSwap();</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>        // Has asset tokens owed</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>        HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);</span>
  21 |     | <span class='unexecuted'>        HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);</span>
  22 |     | <span class='unexecuted'>        uint tokensOwed = Assembly</span>
  23 |     | <span class='unexecuted'>            .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)</span>
  24 |     | <span class='unexecuted'>            .mulWadDown(pool.liquidity);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>        uint pre = _getBalance(hx(), address(this), (defaultScenario.asset));</span>
  27 |     | <span class='unexecuted'>        __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);</span>
  28 |     | <span class='unexecuted'>        uint post = _getBalance(hx(), address(this), (defaultScenario.asset));</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>        pos = _getPosition(hs(), address(this), defaultScenario.poolId);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>        assertEq(post, pre + tokensOwed, &quot;delta&quot;);</span>
  33 |     | <span class='unexecuted'>        assertEq(post, tokensOwed, &quot;claimed-bal&quot;);</span>
  34 |     | <span class='unexecuted'>        assertEq(pos.tokensOwedAsset, 0, &quot;zero-claim&quot;);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function testClaimGetBalanceReturnsFeeAmount_asset() public {</span>
  38 |     | <span class='unexecuted'>        basicAllocate();</span>
  39 |     | <span class='unexecuted'>        basicSwap();</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // Has asset tokens owed</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>        HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);</span>
  44 |     | <span class='unexecuted'>        HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);</span>
  45 |     | <span class='unexecuted'>        uint tokensOwed = Assembly</span>
  46 |     | <span class='unexecuted'>            .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)</span>
  47 |     | <span class='unexecuted'>            .mulWadDown(pool.liquidity);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);</span>
  50 |     | <span class='unexecuted'>        uint post = _getBalance(hx(), address(this), (defaultScenario.asset));</span>
  51 |     | <span class='unexecuted'>        assertEq(post, tokensOwed, &quot;claimed-bal&quot;);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function testClaimGetBalanceReturnsFeeAmount_quote() public {</span>
  55 |     | <span class='unexecuted'>        basicAllocate();</span>
  56 |     | <span class='unexecuted'>        basicSwapQuoteIn();</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        // Has asset tokens owed</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);</span>
  61 |     | <span class='unexecuted'>        HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);</span>
  62 |     | <span class='unexecuted'>        uint tokensOwed = Assembly</span>
  63 |     | <span class='unexecuted'>            .computeCheckpointDistance(pool.feeGrowthGlobalQuote, pos.feeGrowthQuoteLast)</span>
  64 |     | <span class='unexecuted'>            .mulWadDown(pool.liquidity);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        __hyperTestingContract__.claim(defaultScenario.poolId, 0, tokensOwed);</span>
  67 |     | <span class='unexecuted'>        uint post = _getBalance(hx(), address(this), defaultScenario.quote);</span>
  68 |     | <span class='neutral'>        assertEq(post, tokensOwed, &quot;claimed-bal&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>    function testClaimGetBalanceReturnsFeeAmount_reward() public {</span>
  72 |     | <span class='neutral'>        // Rewards only accrue to controlled pools</span>
  73 |     | <span class='unexecuted'>        createControlledPool();</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        TestScenario memory scenario = scenarios[1]; // assumes it was the second one...</span>
  76 |     | <span class='unexecuted'>        assertTrue(</span>
  77 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(scenario.label)) == keccak256(abi.encodePacked(&quot;Controlled&quot;)),</span>
  78 |     | <span class='neutral'>            &quot;not controlled?&quot;</span>
  79 |     | <span class='neutral'>        );</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        __weth__.deposit{value: 0.01 ether}();</span>
  82 |     | <span class='unexecuted'>        __weth__.approve(address(__hyperTestingContract__), type(uint256).max);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        _alloc(scenario.poolId);</span>
  85 |     | <span class='unexecuted'>        __hyperTestingContract__.stake(scenario.poolId, 1 ether);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // pass some time for staking</span>
  88 |     | <span class='unexecuted'>        customWarp(__hyperTestingContract__.timestamp() + 1);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        _swap(scenario.poolId); // swapping in controlled pool should increment reward token (weth)</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // Has asset tokens owed</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        HyperPosition memory pos = _getPosition(hs(), address(this), scenario.poolId);</span>
  95 |     | <span class='unexecuted'>        HyperPool memory pool = _getPool(hs(), scenario.poolId);</span>
  96 |     | <span class='unexecuted'>        uint tokensOwed = Assembly</span>
  97 |     | <span class='unexecuted'>            .computeCheckpointDistance(pool.feeGrowthGlobalReward, pos.feeGrowthRewardLast)</span>
  98 |     | <span class='unexecuted'>            .mulWadDown(pool.liquidity);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        __hyperTestingContract__.claim(scenario.poolId, 0, 0);</span>
 101 |     | <span class='unexecuted'>        uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));</span>
 102 |     | <span class='unexecuted'>        assertEq(post, tokensOwed, &quot;claimed-bal&quot;);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function testClaimCreditsAssetBalance() public postTestInvariantChecks {</span>
 106 |     | <span class='unexecuted'>        basicAllocate();</span>
 107 |     | <span class='unexecuted'>        basicSwap(); // swaps __asset__ in, so pays fees in asset.</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        HyperPool memory pool = defaultPool();</span>
 110 |     | <span class='unexecuted'>        uint real0 = _getReserve(hx(), defaultScenario.asset);</span>
 111 |     | <span class='unexecuted'>        uint real1 = _getReserve(hx(), defaultScenario.quote);</span>
 112 |     | <span class='unexecuted'>        (uint res0, uint res1) = pool.getVirtualReserves();</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        basicUnallocate();</span>
 115 |     | <span class='unexecuted'>        maxDraw(); // zero balance to ensure we aren&#39;t paying ourself.</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        HyperPosition memory pos = defaultPosition();</span>
 118 |     | <span class='unexecuted'>        pool = defaultPool();</span>
 119 |     | <span class='unexecuted'>        (uint fee0, uint fee1) = (pos.tokensOwedAsset, pos.tokensOwedQuote);</span>
 120 |     | <span class='unexecuted'>        assertTrue(fee0 &gt; 0, &quot;fee0-zero&quot;);</span>
 121 |     | <span class='unexecuted'>        assertTrue(pool.liquidity == 0, &quot;non-zero-liquidity&quot;);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // Claim</span>
 124 |     | <span class='unexecuted'>        uint prevReserve = _getReserve(hx(), defaultScenario.asset);</span>
 125 |     | <span class='unexecuted'>        uint prevBalance = _getBalance(hx(), address(this), defaultScenario.asset);</span>
 126 |     | <span class='unexecuted'>        __hyperTestingContract__.claim(defaultScenario.poolId, fee0, fee1);</span>
 127 |     | <span class='unexecuted'>        uint nextBalance = _getBalance(hx(), address(this), defaultScenario.asset);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        maxDraw(); // clear reserve</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        uint nextReserve = _getReserve(hx(), defaultScenario.asset);</span>
 132 |     | <span class='unexecuted'>        assertTrue(nextBalance &gt; prevBalance, &quot;no fee claimed&quot;);</span>
 133 |     | <span class='unexecuted'>        assertTrue(nextReserve &lt; prevReserve, &quot;no fee removed&quot;);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperCreate.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Vm.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
   6 |     | <span class='unexecuted'></span>
   7 |     | <span class='neutral'>contract TestHyperCreate is TestHyperSetup {</span>
   8 |     | <span class='unexecuted'>    function testFuzzCreatePol(</span>
   9 |     | <span class='neutral'>        uint16 priorityFee,</span>
  10 |     | <span class='neutral'>        uint16 fee,</span>
  11 |     | <span class='neutral'>        uint16 jit,</span>
  12 |     | <span class='neutral'>        uint16 duration,</span>
  13 |     | <span class='neutral'>        uint16 volatility,</span>
  14 |     | <span class='neutral'>        int24 maxTick,</span>
  15 |     | <span class='neutral'>        uint128 price</span>
  16 |     | <span class='unexecuted'>    ) public {</span>
  17 |     | <span class='unexecuted'>        fee = uint16(bound(fee, MIN_FEE, MAX_FEE));</span>
  18 |     | <span class='unexecuted'>        priorityFee = uint16(bound(priorityFee, 1, fee));</span>
  19 |     | <span class='unexecuted'>        jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));</span>
  20 |     | <span class='unexecuted'>        duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));</span>
  21 |     | <span class='unexecuted'>        volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));</span>
  22 |     | <span class='unexecuted'>        maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));</span>
  23 |     | <span class='unexecuted'>        vm.assume(price &gt; 0);</span>
  24 |     | <span class='unexecuted'>        vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.</span>
  25 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePool(</span>
  26 |     | <span class='unexecuted'>            uint24(1),</span>
  27 |     | <span class='unexecuted'>            address(this),</span>
  28 |     | <span class='unexecuted'>            priorityFee,</span>
  29 |     | <span class='unexecuted'>            fee,</span>
  30 |     | <span class='unexecuted'>            volatility,</span>
  31 |     | <span class='unexecuted'>            duration,</span>
  32 |     | <span class='unexecuted'>            jit,</span>
  33 |     | <span class='unexecuted'>            maxTick,</span>
  34 |     | <span class='unexecuted'>            price</span>
  35 |     | <span class='neutral'>        );</span>
  36 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  37 |     | <span class='unexecuted'>        uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(2));</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        HyperPool memory pool = _getPool(hs(), poolId);</span>
  40 |     | <span class='unexecuted'>        HyperCurve memory actual = pool.params;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        assertTrue(success, &quot;fuzz create pool failed&quot;);</span>
  43 |     | <span class='unexecuted'>        assertEq(pool.controller, address(this), &quot;controller&quot;);</span>
  44 |     | <span class='unexecuted'>        assertEq(actual.priorityFee, priorityFee, &quot;priorityFee&quot;);</span>
  45 |     | <span class='unexecuted'>        assertEq(actual.fee, fee, &quot;fee&quot;);</span>
  46 |     | <span class='unexecuted'>        assertEq(actual.volatility, volatility, &quot;volatility&quot;);</span>
  47 |     | <span class='unexecuted'>        assertEq(actual.duration, duration, &quot;duration&quot;);</span>
  48 |     | <span class='unexecuted'>        assertEq(actual.jit, jit, &quot;jit&quot;);</span>
  49 |     | <span class='unexecuted'>        assertEq(actual.maxTick, maxTick, &quot;maxTick&quot;);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function testCreatePoolNonControlledHasDefaultJit() public {</span>
  53 |     | <span class='unexecuted'>        __hyperTestingContract__.setJitPolicy(JUST_IN_TIME_LIQUIDITY_POLICY); // for assertion below.</span>
  54 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePool(uint24(1), address(0), 1, 100, 100, 100, 100, 100, 100);</span>
  55 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  56 |     | <span class='unexecuted'>        assertTrue(success, &quot;create failed&quot;);</span>
  57 |     | <span class='unexecuted'>        assertEq(_getPool(hs(), defaultScenario.poolId + 1).params.jit, JUST_IN_TIME_LIQUIDITY_POLICY);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function testCreatePoolZeroPriceReverts() public {</span>
  61 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 1, 1, 1, 1, 1, 1, 0);</span>
  62 |     | <span class='unexecuted'>        vm.expectRevert(ZeroPrice.selector);</span>
  63 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  64 |     | <span class='neutral'>        assertTrue(!success);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    function testCreatePoolPriorityFeeInvalidFeeReverts() public {</span>
  68 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 0, 1, 1, 1, 1, 1, 1);</span>
  69 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, 0));</span>
  70 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  71 |     | <span class='unexecuted'>        assertTrue(!success);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function testFuzzChangeParameters(</span>
  75 |     | <span class='neutral'>        uint16 priorityFee,</span>
  76 |     | <span class='neutral'>        uint16 fee,</span>
  77 |     | <span class='neutral'>        uint16 jit,</span>
  78 |     | <span class='neutral'>        uint16 duration,</span>
  79 |     | <span class='neutral'>        uint16 volatility,</span>
  80 |     | <span class='neutral'>        int24 maxTick</span>
  81 |     | <span class='unexecuted'>    ) public {</span>
  82 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
  83 |     | <span class='unexecuted'>        fee = uint16(bound(fee, MIN_FEE, MAX_FEE));</span>
  84 |     | <span class='unexecuted'>        priorityFee = uint16(bound(priorityFee, 1, fee));</span>
  85 |     | <span class='unexecuted'>        jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));</span>
  86 |     | <span class='unexecuted'>        duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));</span>
  87 |     | <span class='unexecuted'>        volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));</span>
  88 |     | <span class='unexecuted'>        maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));</span>
  89 |     | <span class='unexecuted'>        vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);</span>
  92 |     | <span class='unexecuted'>        HyperCurve memory actual = _getPool(hs(), poolId).params;</span>
  93 |     | <span class='unexecuted'>        assertEq(actual.priorityFee, priorityFee, &quot;priorityFee&quot;);</span>
  94 |     | <span class='unexecuted'>        assertEq(actual.fee, fee, &quot;fee&quot;);</span>
  95 |     | <span class='unexecuted'>        assertEq(actual.volatility, volatility, &quot;volatility&quot;);</span>
  96 |     | <span class='unexecuted'>        assertEq(actual.duration, duration, &quot;duration&quot;);</span>
  97 |     | <span class='unexecuted'>        assertEq(actual.jit, jit, &quot;jit&quot;);</span>
  98 |     | <span class='unexecuted'>        assertEq(actual.maxTick, maxTick, &quot;maxTick&quot;);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function testChangeParametersPriorityFeeSuccess() public {</span>
 102 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 103 |     | <span class='unexecuted'>        uint16 prev = _getPool(hs(), poolId).params.priorityFee;</span>
 104 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(poolId, DEFAULT_FEE + 10, DEFAULT_FEE + 20, 0, 0, 0, 0);</span>
 105 |     | <span class='unexecuted'>        uint16 post = _getPool(hs(), poolId).params.priorityFee;</span>
 106 |     | <span class='unexecuted'>        assertEq(post, prev + 10, &quot;priority-fee-change&quot;);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function testChangeParametersSuccessKeepsPoolSolvency() public {</span>
 110 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 111 |     | <span class='unexecuted'>        (uint prev0, uint prev1) = __hyperTestingContract__.getVirtualReserves(poolId);</span>
 112 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 113 |     | <span class='unexecuted'>            poolId,</span>
 114 |     | <span class='neutral'>            0,</span>
 115 |     | <span class='neutral'>            0,</span>
 116 |     | <span class='unexecuted'>            DEFAULT_VOLATILITY * 2,</span>
 117 |     | <span class='unexecuted'>            DEFAULT_DURATION + 30,</span>
 118 |     | <span class='unexecuted'>            0,</span>
 119 |     | <span class='unexecuted'>            DEFAULT_TICK + 500</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='unexecuted'>        (uint post0, uint post1) = __hyperTestingContract__.getVirtualReserves(poolId);</span>
 122 |     | <span class='unexecuted'>        assertEq(post0, prev0, &quot;virtual-asset-balance-altered&quot;);</span>
 123 |     | <span class='unexecuted'>        assertEq(post1, prev1, &quot;virtual-quote-balance-altered&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function testChangeParametersNotControllerReverts() public {</span>
 127 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 128 |     | <span class='unexecuted'>        uint16 failureArg = 1;</span>
 129 |     | <span class='unexecuted'>        vm.expectRevert(NotController.selector);</span>
 130 |     | <span class='unexecuted'>        vm.prank(address(0x0006));</span>
 131 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 132 |     | <span class='unexecuted'>            poolId,</span>
 133 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 134 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 135 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 136 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 137 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 138 |     | <span class='neutral'>            DEFAULT_TICK</span>
 139 |     | <span class='neutral'>        );</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function testChangeParametersInvalidVolatilityReverts() public {</span>
 143 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 144 |     | <span class='unexecuted'>        uint16 failureArg = 1;</span>
 145 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));</span>
 146 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 147 |     | <span class='unexecuted'>            poolId,</span>
 148 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 149 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 150 |     | <span class='neutral'>            1,</span>
 151 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 152 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 153 |     | <span class='neutral'>            DEFAULT_TICK</span>
 154 |     | <span class='neutral'>        );</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>    function testChangeParametersInvalidDurationReverts() public {</span>
 158 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 159 |     | <span class='unexecuted'>        uint16 failureArg = 5000;</span>
 160 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidDuration.selector, failureArg));</span>
 161 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 162 |     | <span class='unexecuted'>            poolId,</span>
 163 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 164 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 165 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 166 |     | <span class='unexecuted'>            5000,</span>
 167 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 168 |     | <span class='neutral'>            DEFAULT_TICK</span>
 169 |     | <span class='neutral'>        );</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>    function testChangeParametersInvalidTickReverts() public {</span>
 173 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 174 |     | <span class='unexecuted'>        int24 failureArg = 1000000;</span>
 175 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidTick.selector, uint24(failureArg)));</span>
 176 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 177 |     | <span class='unexecuted'>            poolId,</span>
 178 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 179 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 180 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 181 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 182 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 183 |     | <span class='unexecuted'>            failureArg</span>
 184 |     | <span class='neutral'>        );</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    function testChangeParametersInvalidJitReverts() public {</span>
 188 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 189 |     | <span class='unexecuted'>        uint16 failureArg = 10000;</span>
 190 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidJit.selector, failureArg));</span>
 191 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 192 |     | <span class='unexecuted'>            poolId,</span>
 193 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 194 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 195 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 196 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 197 |     | <span class='unexecuted'>            failureArg,</span>
 198 |     | <span class='neutral'>            DEFAULT_TICK</span>
 199 |     | <span class='neutral'>        );</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function testChangeParametersPriorityFeeAboveFeeReverts() public {</span>
 203 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 204 |     | <span class='unexecuted'>        HyperCurve memory curve = HyperCurve({</span>
 205 |     | <span class='neutral'>            maxTick: DEFAULT_TICK,</span>
 206 |     | <span class='neutral'>            jit: DEFAULT_JIT,</span>
 207 |     | <span class='unexecuted'>            fee: 55,</span>
 208 |     | <span class='neutral'>            duration: DEFAULT_DURATION,</span>
 209 |     | <span class='neutral'>            volatility: DEFAULT_VOLATILITY,</span>
 210 |     | <span class='unexecuted'>            priorityFee: 56,</span>
 211 |     | <span class='unexecuted'>            createdAt: 100000000</span>
 212 |     | <span class='neutral'>        });</span>
 213 |     | <span class='unexecuted'>        (, bytes memory revertData) = curve.checkParameters();</span>
 214 |     | <span class='unexecuted'>        assertEq(revertData, abi.encodeWithSelector(InvalidFee.selector, curve.priorityFee));</span>
 215 |     | <span class='unexecuted'>        vm.expectRevert(revertData);</span>
 216 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 217 |     | <span class='unexecuted'>            poolId,</span>
 218 |     | <span class='unexecuted'>            curve.priorityFee,</span>
 219 |     | <span class='unexecuted'>            curve.fee,</span>
 220 |     | <span class='unexecuted'>            curve.volatility,</span>
 221 |     | <span class='unexecuted'>            curve.duration,</span>
 222 |     | <span class='unexecuted'>            curve.jit,</span>
 223 |     | <span class='unexecuted'>            curve.maxTick</span>
 224 |     | <span class='neutral'>        );</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>    function testChangeParametersInvalidFeeReverts() public {</span>
 228 |     | <span class='unexecuted'>        uint16 failureArg = 2 ** 16 - 10;</span>
 229 |     | <span class='unexecuted'>        uint64 poolId = _createDefaultPool();</span>
 230 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));</span>
 231 |     | <span class='unexecuted'>        __hyperTestingContract__.changeParameters(</span>
 232 |     | <span class='unexecuted'>            poolId,</span>
 233 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 234 |     | <span class='unexecuted'>            failureArg,</span>
 235 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 236 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 237 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 238 |     | <span class='neutral'>            DEFAULT_TICK</span>
 239 |     | <span class='neutral'>        );</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='unexecuted'>    function _createDefaultPool() internal returns (uint64 poolId) {</span>
 243 |     | <span class='unexecuted'>        uint24 pairId = uint24(1);</span>
 244 |     | <span class='unexecuted'>        bytes memory createData = Enigma.encodeCreatePool(</span>
 245 |     | <span class='neutral'>            pairId, // assumes first pair is created</span>
 246 |     | <span class='unexecuted'>            address(this),</span>
 247 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 248 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 249 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 250 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 251 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 252 |     | <span class='neutral'>            DEFAULT_TICK,</span>
 253 |     | <span class='neutral'>            DEFAULT_PRICE</span>
 254 |     | <span class='neutral'>        );</span>
 255 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(createData);</span>
 256 |     | <span class='unexecuted'>        assertTrue(success, &quot;did not create pool&quot;);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>        poolId = Enigma.encodePoolId(pairId, true, uint32(2));</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'>}</span>
 261 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperDeploy.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Vm.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract TestHyperDeploy is TestHyperSetup {</span>
  8 |     | <span class='neutral'>    event Deployed(string, address);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    function testDeploy() public {</span>
 11 |     | <span class='unexecuted'>        address weth = address(new WETH());</span>
 12 |     | <span class='unexecuted'>        address usdc = address(new TestERC20(&quot;USDC&quot;, &quot;USD Coin&quot;, 6));</span>
 13 |     | <span class='unexecuted'>        Hyper hyper = new Hyper(weth);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>        emit Deployed(&quot;Deployed weth at: &quot;, weth);</span>
 16 |     | <span class='unexecuted'>        emit Deployed(&quot;Deployed hyper at: &quot;, address(hyper));</span>
 17 |     | <span class='unexecuted'>        emit Deployed(&quot;Deployed usdc at: &quot;, usdc);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>        assertEq(hyper.WETH(), weth, &quot;weth address&quot;);</span>
 20 |     | <span class='unexecuted'>        (, bool settled) = hyper.__account__();</span>
 21 |     | <span class='unexecuted'>        assertTrue(settled, &quot;settled&quot;);</span>
 22 |     | <span class='neutral'>        // todo: fix version</span>
 23 |     | <span class='neutral'>        //assertTrue(bytes32(abi.encodePacked(hyper.VERSION())) == bytes32(abi.encodePacked(&quot;beta-v0.0.1&quot;)));</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperDeposit.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Vm.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract TestHyperDeposit is TestHyperSetup {</span>
  8 |     | <span class='unexecuted'>    function testDepositMsgValueZero_reverts() public {</span>
  9 |     | <span class='unexecuted'>        vm.expectRevert(ZeroValue.selector);</span>
 10 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 0}();</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function testDepositWethTotalSupplyReturnsMsgValue() public {</span>
 14 |     | <span class='unexecuted'>        uint pre = __weth__.totalSupply();</span>
 15 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 100}();</span>
 16 |     | <span class='unexecuted'>        uint post = __weth__.totalSupply();</span>
 17 |     | <span class='neutral'>        uint delta = post - pre;</span>
 18 |     | <span class='neutral'>        assertEq(post, 100, &quot;ts&quot;);</span>
 19 |     | <span class='neutral'>        assertEq(delta, 100, &quot;del&quot;);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function testDepositCallersBalanceReturnsMsgValue() public {</span>
 23 |     | <span class='unexecuted'>        uint pre = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));</span>
 24 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 100}();</span>
 25 |     | <span class='unexecuted'>        uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));</span>
 26 |     | <span class='neutral'>        uint delta = post - pre;</span>
 27 |     | <span class='neutral'>        assertEq(post, 100, &quot;ts&quot;);</span>
 28 |     | <span class='neutral'>        assertEq(delta, 100, &quot;del&quot;);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function testDepositEtherBalanceReturnsZero() public {</span>
 32 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 100}();</span>
 33 |     | <span class='unexecuted'>        uint actual = address(__hyperTestingContract__).balance;</span>
 34 |     | <span class='unexecuted'>        assertEq(actual, 0, &quot;balance&quot;);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function testDepositWethReservesReturnsMsgValue() public {</span>
 38 |     | <span class='unexecuted'>        uint pre = getReserve(address(__hyperTestingContract__), address(__weth__));</span>
 39 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 100}();</span>
 40 |     | <span class='unexecuted'>        uint post = getReserve(address(__hyperTestingContract__), address(__weth__));</span>
 41 |     | <span class='unexecuted'>        uint delta = post - pre;</span>
 42 |     | <span class='unexecuted'>        assertEq(post, 100, &quot;ts&quot;);</span>
 43 |     | <span class='unexecuted'>        assertEq(delta, 100, &quot;del&quot;);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function testDepositBalanceOfWethReturnsMsgValue() public {</span>
 47 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 100}();</span>
 48 |     | <span class='unexecuted'>        uint actual = __weth__.balanceOf(address(__hyperTestingContract__));</span>
 49 |     | <span class='unexecuted'>        assertEq(actual, 100, &quot;balance&quot;);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>    function testDepositWrapsEther() public postTestInvariantChecks {</span>
 53 |     | <span class='unexecuted'>        uint prevWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));</span>
 54 |     | <span class='unexecuted'>        uint prevBalance = address(this).balance;</span>
 55 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 4000}();</span>
 56 |     | <span class='unexecuted'>        uint nextBalance = address(this).balance;</span>
 57 |     | <span class='unexecuted'>        uint nextWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        assertTrue(nextBalance &lt; prevBalance);</span>
 60 |     | <span class='unexecuted'>        assertTrue(nextWethBalance &gt; prevWethBalance);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function testDepositIncreasesUserBalance() public postTestInvariantChecks {</span>
 64 |     | <span class='unexecuted'>        uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));</span>
 65 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 4000}();</span>
 66 |     | <span class='unexecuted'>        uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        assertTrue(nextBalance &gt; prevBalance, &quot;balance-not-increased&quot;);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    event Deposit(address indexed account, uint amount);</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function testDepositWrapsEther_emit_Deposit() public {</span>
 74 |     | <span class='unexecuted'>        vm.expectEmit(true, true, false, true, address(__hyperTestingContract__));</span>
 75 |     | <span class='unexecuted'>        emit Deposit(address(this), 4000);</span>
 76 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 4000}();</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>    function testDepositWrapsEther_emit_IncreaseUserBalance() public {</span>
 82 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(__hyperTestingContract__));</span>
 83 |     | <span class='unexecuted'>        emit IncreaseUserBalance(address(this), address(__weth__), 4000);</span>
 84 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 4000}();</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperDraw.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestHyperDraw is TestHyperSetup {</span>
  7 |     | <span class='unexecuted'>    function testDrawReducesBalance() public postTestInvariantChecks {</span>
  8 |     | <span class='neutral'>        // Fund the account</span>
  9 |     | <span class='unexecuted'>        __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>        // Draw</span>
 12 |     | <span class='unexecuted'>        uint prevReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
 13 |     | <span class='unexecuted'>        uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
 14 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(address(defaultScenario.asset), 4000, address(this));</span>
 15 |     | <span class='unexecuted'>        uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
 16 |     | <span class='unexecuted'>        uint nextReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>        assertTrue(nextBalance == 0);</span>
 19 |     | <span class='unexecuted'>        assertTrue(nextBalance &lt; prevBalance);</span>
 20 |     | <span class='unexecuted'>        assertTrue(nextReserve &lt; prevReserve);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function testDrawRevertsWithDrawBalance() public {</span>
 24 |     | <span class='unexecuted'>        vm.expectRevert(DrawBalance.selector);</span>
 25 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(address(defaultScenario.asset), 1e18, address(this));</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function testDrawFromWethTransfersEther() public postTestInvariantChecks {</span>
 29 |     | <span class='neutral'>        // First fund the account</span>
 30 |     | <span class='unexecuted'>        __hyperTestingContract__.deposit{value: 4000}();</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>        // Draw</span>
 33 |     | <span class='unexecuted'>        uint prevBalance = address(this).balance;</span>
 34 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(address(__weth__), 4000, address(this));</span>
 35 |     | <span class='unexecuted'>        uint nextBalance = address(this).balance;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>        assertTrue(nextBalance &gt; prevBalance);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperFund.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestHyperFund is TestHyperSetup {</span>
  7 |     | <span class='unexecuted'>    function testFundIncreasesBalance() public postTestInvariantChecks {</span>
  8 |     | <span class='unexecuted'>        uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
  9 |     | <span class='unexecuted'>        __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);</span>
 10 |     | <span class='unexecuted'>        uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>        assertTrue(nextBalance &gt; prevBalance, &quot;increase-internal-bal&quot;);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function testFuzzFundDrawSuccessful(uint128 amount) public {</span>
 16 |     | <span class='unexecuted'>        vm.assume(amount &gt; 0);</span>
 17 |     | <span class='unexecuted'>        _assertFundDraw(amount);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function _assertFundDraw(uint amount) internal {</span>
 21 |     | <span class='neutral'>        // Preconditions</span>
 22 |     | <span class='unexecuted'>        defaultScenario.asset.approve(address(__hyperTestingContract__), amount);</span>
 23 |     | <span class='unexecuted'>        deal(address(defaultScenario.asset), address(this), amount);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>        // Execution</span>
 26 |     | <span class='unexecuted'>        uint preBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
 27 |     | <span class='unexecuted'>        HyperState memory prev = getState();</span>
 28 |     | <span class='unexecuted'>        __hyperTestingContract__.fund(address(defaultScenario.asset), amount);</span>
 29 |     | <span class='unexecuted'>        HyperState memory post = getState();</span>
 30 |     | <span class='unexecuted'>        uint postBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>        // Post conditions</span>
 33 |     | <span class='unexecuted'>        assertTrue(postBal &gt; preBal, &quot;bal-increase&quot;);</span>
 34 |     | <span class='unexecuted'>        assertEq(postBal, preBal + amount, &quot;bal-increase-exact&quot;);</span>
 35 |     | <span class='unexecuted'>        assertEq(post.reserveAsset, prev.reserveAsset + amount, &quot;reserve-increase&quot;);</span>
 36 |     | <span class='unexecuted'>        assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + amount, &quot;physical-increase&quot;);</span>
 37 |     | <span class='unexecuted'>        assertEq(post.totalBalanceAsset, prev.totalBalanceAsset + amount, &quot;total-bal-increase&quot;);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(address(defaultScenario.asset), amount, address(this));</span>
 40 |     | <span class='unexecuted'>        HyperState memory end = getState();</span>
 41 |     | <span class='unexecuted'>        uint endBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        assertEq(endBal, preBal, &quot;reverse-exact-bal&quot;);</span>
 44 |     | <span class='unexecuted'>        assertEq(end.reserveAsset, prev.reserveAsset, &quot;reverse-exact-reserve&quot;);</span>
 45 |     | <span class='unexecuted'>        assertEq(end.physicalBalanceAsset, prev.physicalBalanceAsset, &quot;reverse-exact-physical&quot;);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperProcessing.t.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
    2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot; as HyperTypes;</span>
    5 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
    6 |     | <span class='unexecuted'></span>
    7 |     | <span class='neutral'>contract TestHyperProcessing is TestHyperSetup {</span>
    8 |     | <span class='neutral'>    using SafeCastLib for uint;</span>
    9 |     | <span class='neutral'></span>
   10 |     | <span class='unexecuted'>    function afterSetUp() public override {</span>
   11 |     | <span class='unexecuted'>        assertTrue(</span>
   12 |     | <span class='unexecuted'>            getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp != 0,</span>
   13 |     | <span class='neutral'>            &quot;Pool not created&quot;</span>
   14 |     | <span class='neutral'>        );</span>
   15 |     | <span class='unexecuted'>        assertTrue(</span>
   16 |     | <span class='unexecuted'>            getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick != 0,</span>
   17 |     | <span class='neutral'>            &quot;Pool not initialized with price&quot;</span>
   18 |     | <span class='neutral'>        );</span>
   19 |     | <span class='unexecuted'>        assertTrue(</span>
   20 |     | <span class='unexecuted'>            getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity == 0,</span>
   21 |     | <span class='neutral'>            &quot;Pool initialized with liquidity&quot;</span>
   22 |     | <span class='neutral'>        );</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    // ===== Getters ===== //</span>
   26 |     | <span class='neutral'></span>
   27 |     | <span class='unexecuted'>    function testGetAmounts() public {</span>
   28 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
   29 |     | <span class='unexecuted'>        HyperCurve memory curve = pool.params;</span>
   30 |     | <span class='unexecuted'>        (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getAmounts(defaultScenario.poolId);</span>
   31 |     | <span class='unexecuted'>        uint maxDelta = 0.001 ether; // 1ether = 100%, 0.001 ether = 0.10%</span>
   32 |     | <span class='unexecuted'>        assertApproxEqRel(</span>
   33 |     | <span class='unexecuted'>            deltaAsset,</span>
   34 |     | <span class='unexecuted'>            Assembly.scaleFromWadDown(DEFAULT_ASSET_RESERVE, pool.pair.decimalsAsset),</span>
   35 |     | <span class='unexecuted'>            maxDelta,</span>
   36 |     | <span class='neutral'>            &quot;asset-reserve&quot;</span>
   37 |     | <span class='neutral'>        ); // todo: fix default amounts</span>
   38 |     | <span class='unexecuted'>        assertApproxEqRel(</span>
   39 |     | <span class='unexecuted'>            deltaQuote,</span>
   40 |     | <span class='unexecuted'>            Assembly.scaleFromWadDown(DEFAULT_QUOTE_RESERVE, pool.pair.decimalsQuote),</span>
   41 |     | <span class='unexecuted'>            maxDelta,</span>
   42 |     | <span class='neutral'>            &quot;quote-reserve&quot;</span>
   43 |     | <span class='neutral'>        );</span>
   44 |     | <span class='neutral'>    }</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='unexecuted'>    function testGetLiquidityMinted() public {</span>
   47 |     | <span class='unexecuted'>        uint deltaLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, 1, 1e19);</span>
   48 |     | <span class='neutral'>    }</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    // ===== Enigma ===== //</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='unexecuted'>    function testJumpProcessCreatesPair() public {</span>
   53 |     | <span class='unexecuted'>        bytes[] memory instructions = new bytes[](1);</span>
   54 |     | <span class='unexecuted'>        instructions[0] = (Enigma.encodeCreatePair(address(__token_8__), address(defaultScenario.quote)));</span>
   55 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeJumpInstruction(instructions);</span>
   56 |     | <span class='unexecuted'>        bool success = __revertCatcher__.jumpProcess(data);</span>
   57 |     | <span class='unexecuted'>        assertTrue(success);</span>
   58 |     | <span class='neutral'></span>
   59 |     | <span class='unexecuted'>        uint24 pairId = uint16(__hyperTestingContract__.getPairNonce());</span>
   60 |     | <span class='unexecuted'>        HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);</span>
   61 |     | <span class='unexecuted'>        assertTrue(pair.tokenAsset != address(0));</span>
   62 |     | <span class='unexecuted'>        assertTrue(pair.tokenQuote != address(0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='unexecuted'>    function testProcessRevertsWithInvalidInstructionZeroOpcode() public {</span>
   66 |     | <span class='unexecuted'>        vm.expectRevert(InvalidInstruction.selector);</span>
   67 |     | <span class='unexecuted'>        __revertCatcher__.process(hex&quot;00&quot;);</span>
   68 |     | <span class='neutral'>    }</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='unexecuted'>    function testProcessRevertsWithInvalidInstruction() public {</span>
   71 |     | <span class='unexecuted'>        vm.expectRevert(InvalidInstruction.selector);</span>
   72 |     | <span class='unexecuted'>        __revertCatcher__.process(hex&quot;44&quot;);</span>
   73 |     | <span class='neutral'>    }</span>
   74 |     | <span class='neutral'></span>
   75 |     | <span class='neutral'>    // ===== Effects ===== //</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    // --- Swap --- //</span>
   78 |     | <span class='neutral'></span>
   79 |     | <span class='unexecuted'>    function testSwapExactInNonExistentPoolIdReverts() public {</span>
   80 |     | <span class='unexecuted'>        uint64 failureArg = uint64(0x01);</span>
   81 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeSwap(0, failureArg, 0x01, 0x01, 0x01, 0x01, 0);</span>
   82 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));</span>
   83 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
   84 |     | <span class='neutral'>        assertTrue(!success);</span>
   85 |     | <span class='neutral'>    }</span>
   86 |     | <span class='neutral'></span>
   87 |     | <span class='unexecuted'>    function testSwapExactInZeroSwapAmountReverts() public {</span>
   88 |     | <span class='unexecuted'>        uint128 failureArg = 0;</span>
   89 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, failureArg, 0x01, 0x01, 0);</span>
   90 |     | <span class='unexecuted'>        vm.expectRevert(ZeroInput.selector);</span>
   91 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
   92 |     | <span class='neutral'>        assertTrue(!success);</span>
   93 |     | <span class='neutral'>    }</span>
   94 |     | <span class='neutral'></span>
   95 |     | <span class='unexecuted'>    function testSwapExactInPoolPriceUpdated() public postTestInvariantChecks {</span>
   96 |     | <span class='neutral'>        // Add liquidity first</span>
   97 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
   98 |     | <span class='neutral'>            0,</span>
   99 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  100 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  101 |     | <span class='neutral'>            0x01</span>
  102 |     | <span class='neutral'>        );</span>
  103 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  104 |     | <span class='unexecuted'>        assertTrue(success);</span>
  105 |     | <span class='neutral'>        // move some time</span>
  106 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='unexecuted'>        uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  111 |     | <span class='neutral'>        uint8 direction = 0;</span>
  112 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  113 |     | <span class='neutral'>        // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2</span>
  114 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);</span>
  115 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  116 |     | <span class='unexecuted'>        assertTrue(success);</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='unexecuted'>        uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;</span>
  119 |     | <span class='unexecuted'>        assertTrue(next != prev);</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    /* function testSwapExactInPoolSlotIndexUpdated() public {</span>
  123 |     | <span class='neutral'>        // Add liquidity first</span>
  124 |     | <span class='neutral'>        bytes memory data = Enigma.encodeAllocate(</span>
  125 |     | <span class='neutral'>            0,</span>
  126 |     | <span class='neutral'>            defaultScenario.poolId,</span>
  127 |     | <span class='neutral'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  128 |     | <span class='neutral'>            0x01</span>
  129 |     | <span class='neutral'>        );</span>
  130 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  131 |     | <span class='neutral'>        assertTrue(success);</span>
  132 |     | <span class='neutral'>        // move some time</span>
  133 |     | <span class='neutral'>        customWarp(block.timestamp + 1);</span>
  134 |     | <span class='neutral'></span>
  135 |     | <span class='neutral'>        int256 prev = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>        // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2</span>
  138 |     | <span class='neutral'>        data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x12, 0x02, 0x1f, 0x01, 0);</span>
  139 |     | <span class='neutral'>        success = __revertCatcher__.process(data);</span>
  140 |     | <span class='neutral'>        assertTrue(success);</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>        int256 next = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;</span>
  143 |     | <span class='neutral'>        assertTrue(next != prev);</span>
  144 |     | <span class='neutral'>    } */</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='unexecuted'>    function testSwapUseMax() public postTestInvariantChecks {</span>
  147 |     | <span class='unexecuted'>        uint amount = type(uint256).max;</span>
  148 |     | <span class='neutral'>        uint limit = amount;</span>
  149 |     | <span class='neutral'>        // Add liquidity first</span>
  150 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  151 |     | <span class='neutral'>            0,</span>
  152 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  153 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  154 |     | <span class='neutral'>            0x01</span>
  155 |     | <span class='neutral'>        );</span>
  156 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  157 |     | <span class='unexecuted'>        assertTrue(success);</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>        // move some time</span>
  160 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  161 |     | <span class='unexecuted'>        uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;</span>
  162 |     | <span class='unexecuted'>        bool direction = true;</span>
  163 |     | <span class='unexecuted'>        __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='unexecuted'>        uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;</span>
  166 |     | <span class='unexecuted'>        assertTrue(next == prev);</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='unexecuted'>    function testSwapInQuote() public postTestInvariantChecks {</span>
  170 |     | <span class='unexecuted'>        uint limit = type(uint256).max;</span>
  171 |     | <span class='unexecuted'>        uint amount = 2222;</span>
  172 |     | <span class='neutral'>        // Add liquidity first</span>
  173 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  174 |     | <span class='neutral'>            0,</span>
  175 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  176 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  177 |     | <span class='neutral'>            0x01</span>
  178 |     | <span class='neutral'>        );</span>
  179 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  180 |     | <span class='unexecuted'>        assertTrue(success);</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>        // move some time</span>
  183 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  184 |     | <span class='unexecuted'>        uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;</span>
  185 |     | <span class='unexecuted'>        bool direction = false;</span>
  186 |     | <span class='unexecuted'>        __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>        uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;</span>
  189 |     | <span class='neutral'>        assertTrue(next == prev);</span>
  190 |     | <span class='neutral'>    }</span>
  191 |     | <span class='neutral'></span>
  192 |     | <span class='unexecuted'>    function testSwapReverse() public {</span>
  193 |     | <span class='unexecuted'>        bool direction = true;</span>
  194 |     | <span class='unexecuted'>        uint limit = type(uint256).max;</span>
  195 |     | <span class='unexecuted'>        uint amount = 17e16;</span>
  196 |     | <span class='neutral'>        // Add liquidity first</span>
  197 |     | <span class='neutral'>        /* bytes memory data = Enigma.encodeAllocate(</span>
  198 |     | <span class='neutral'>            0,</span>
  199 |     | <span class='neutral'>            defaultScenario.poolId,</span>
  200 |     | <span class='neutral'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  201 |     | <span class='neutral'>            0x01</span>
  202 |     | <span class='neutral'>        );</span>
  203 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  204 |     | <span class='neutral'>        assertTrue(success); */</span>
  205 |     | <span class='unexecuted'>        allocatePool(address(__hyperTestingContract__), defaultScenario.poolId, 10e19);</span>
  206 |     | <span class='neutral'></span>
  207 |     | <span class='neutral'>        // deposit first</span>
  208 |     | <span class='unexecuted'>        __hyperTestingContract__.fund(address(defaultScenario.asset), amount);</span>
  209 |     | <span class='unexecuted'>        uint256 prev = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
  210 |     | <span class='neutral'></span>
  211 |     | <span class='unexecuted'>        (uint output, ) = __hyperTestingContract__.swap(</span>
  212 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  213 |     | <span class='unexecuted'>            direction,</span>
  214 |     | <span class='unexecuted'>            amount,</span>
  215 |     | <span class='unexecuted'>            getMaxSwapLimit(direction)</span>
  216 |     | <span class='neutral'>        );</span>
  217 |     | <span class='unexecuted'>        direction = false;</span>
  218 |     | <span class='unexecuted'>        (uint input, ) = __hyperTestingContract__.swap(</span>
  219 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  220 |     | <span class='neutral'>            direction,</span>
  221 |     | <span class='neutral'>            output,</span>
  222 |     | <span class='unexecuted'>            getMaxSwapLimit(direction)</span>
  223 |     | <span class='neutral'>        );</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='unexecuted'>        uint256 next = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));</span>
  226 |     | <span class='unexecuted'>        assertTrue(next &lt;= prev, &quot;invalid-user-gained-balance&quot;);</span>
  227 |     | <span class='unexecuted'>        assertTrue(input &lt; amount, &quot;invalid-invariant-got-more-out&quot;);</span>
  228 |     | <span class='neutral'>    }</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='unexecuted'>    function testSwapExpiredPoolReverts() public {</span>
  231 |     | <span class='unexecuted'>        uint limit = type(uint256).max;</span>
  232 |     | <span class='unexecuted'>        uint amount = 2222;</span>
  233 |     | <span class='neutral'>        // Add liquidity first</span>
  234 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  235 |     | <span class='neutral'>            0,</span>
  236 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  237 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  238 |     | <span class='neutral'>            0x01</span>
  239 |     | <span class='neutral'>        );</span>
  240 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  241 |     | <span class='unexecuted'>        assertTrue(success);</span>
  242 |     | <span class='neutral'></span>
  243 |     | <span class='neutral'>        // move some time beyond maturity</span>
  244 |     | <span class='unexecuted'>        customWarp(</span>
  245 |     | <span class='unexecuted'>            block.timestamp +</span>
  246 |     | <span class='unexecuted'>                getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(</span>
  247 |     | <span class='unexecuted'>                    __hyperTestingContract__.timestamp()</span>
  248 |     | <span class='neutral'>                ) +</span>
  249 |     | <span class='unexecuted'>                1</span>
  250 |     | <span class='neutral'>        );</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='unexecuted'>        vm.expectRevert(PoolExpired.selector);</span>
  253 |     | <span class='unexecuted'>        __hyperTestingContract__.swap(defaultScenario.poolId, false, amount, limit);</span>
  254 |     | <span class='neutral'>    }</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='unexecuted'>    function testSwapExactInPoolLiquidityUnchanged() public postTestInvariantChecks {</span>
  257 |     | <span class='neutral'>        // Add liquidity first</span>
  258 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  259 |     | <span class='neutral'>            0,</span>
  260 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  261 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  262 |     | <span class='neutral'>            0x01</span>
  263 |     | <span class='neutral'>        );</span>
  264 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  265 |     | <span class='unexecuted'>        assertTrue(success);</span>
  266 |     | <span class='neutral'>        // move some time</span>
  267 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  268 |     | <span class='unexecuted'>        uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  271 |     | <span class='neutral'>        uint8 direction = 0;</span>
  272 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  273 |     | <span class='neutral'>        // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2</span>
  274 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);</span>
  275 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  276 |     | <span class='unexecuted'>        assertTrue(success);</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='unexecuted'>        uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;</span>
  279 |     | <span class='unexecuted'>        assertTrue(next == prev);</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='unexecuted'>    function testSwapExactInPoolTimestampUpdated() public postTestInvariantChecks {</span>
  283 |     | <span class='neutral'>        // Add liquidity first</span>
  284 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  285 |     | <span class='neutral'>            0,</span>
  286 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  287 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity, note: 0x0a amount breaks test? todo: handle case where insufficient liquidity</span>
  288 |     | <span class='neutral'>            0x01</span>
  289 |     | <span class='neutral'>        );</span>
  290 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  291 |     | <span class='unexecuted'>        assertTrue(success);</span>
  292 |     | <span class='neutral'>        // move some time</span>
  293 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  294 |     | <span class='neutral'></span>
  295 |     | <span class='unexecuted'>        uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;</span>
  296 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  297 |     | <span class='neutral'>        uint8 direction = 0;</span>
  298 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  299 |     | <span class='neutral'></span>
  300 |     | <span class='neutral'>        // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2</span>
  301 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);</span>
  302 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  303 |     | <span class='unexecuted'>        assertTrue(success);</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='unexecuted'>        uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;</span>
  306 |     | <span class='unexecuted'>        assertTrue(next != prev);</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='unexecuted'>    function testSwapExactInGlobalAssetBalanceIncreases() public postTestInvariantChecks {</span>
  310 |     | <span class='neutral'>        // Add liquidity first</span>
  311 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  312 |     | <span class='neutral'>            0,</span>
  313 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  314 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  315 |     | <span class='neutral'>            0x01</span>
  316 |     | <span class='neutral'>        );</span>
  317 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  318 |     | <span class='unexecuted'>        assertTrue(success);</span>
  319 |     | <span class='neutral'>        // move some time</span>
  320 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='unexecuted'>        uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  323 |     | <span class='neutral'></span>
  324 |     | <span class='neutral'>        // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2</span>
  325 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  326 |     | <span class='neutral'>        uint8 direction = 0;</span>
  327 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  328 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);</span>
  329 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  330 |     | <span class='unexecuted'>        assertTrue(success);</span>
  331 |     | <span class='neutral'></span>
  332 |     | <span class='unexecuted'>        uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  333 |     | <span class='unexecuted'>        assertTrue(next &gt; prev);</span>
  334 |     | <span class='neutral'>    }</span>
  335 |     | <span class='neutral'></span>
  336 |     | <span class='unexecuted'>    function testSwapExactInGlobalQuoteBalanceDecreases() public postTestInvariantChecks {</span>
  337 |     | <span class='neutral'>        // Add liquidity first</span>
  338 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(</span>
  339 |     | <span class='neutral'>            0,</span>
  340 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
  341 |     | <span class='unexecuted'>            0x13, // 19 zeroes, so 10e19 liquidity</span>
  342 |     | <span class='neutral'>            0x01</span>
  343 |     | <span class='neutral'>        );</span>
  344 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  345 |     | <span class='unexecuted'>        assertTrue(success);</span>
  346 |     | <span class='neutral'>        // move some time</span>
  347 |     | <span class='unexecuted'>        customWarp(block.timestamp + 1);</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='unexecuted'>        uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  350 |     | <span class='neutral'></span>
  351 |     | <span class='neutral'>        // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2</span>
  352 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  353 |     | <span class='neutral'>        uint8 direction = 0;</span>
  354 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  355 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, limit, direction);</span>
  356 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  357 |     | <span class='unexecuted'>        assertTrue(success, &quot;swap failed&quot;);</span>
  358 |     | <span class='neutral'></span>
  359 |     | <span class='unexecuted'>        uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  360 |     | <span class='unexecuted'>        assertTrue(next == prev, &quot;reserves-changed&quot;);</span>
  361 |     | <span class='neutral'>    }</span>
  362 |     | <span class='neutral'></span>
  363 |     | <span class='neutral'>    // --- Allocate --- //</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='unexecuted'>    function testAllocateNonExistentPoolIdReverts() public {</span>
  366 |     | <span class='unexecuted'>        uint64 failureArg = uint64(48);</span>
  367 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, failureArg, 0x01, 0x01);</span>
  368 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));</span>
  369 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  370 |     | <span class='unexecuted'>        assertTrue(!success, &quot;forwarder call failed&quot;);</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='unexecuted'>    function testAllocateZeroLiquidityReverts() public {</span>
  374 |     | <span class='unexecuted'>        uint8 failureArg = 0;</span>
  375 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, 0x00, failureArg);</span>
  376 |     | <span class='unexecuted'>        vm.expectRevert(ZeroLiquidity.selector);</span>
  377 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  378 |     | <span class='neutral'>        assertTrue(!success, &quot;forwarder call failed&quot;);</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='unexecuted'>    function testProcessAllocateFull() public postTestInvariantChecks {</span>
  382 |     | <span class='unexecuted'>        uint256 price = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;</span>
  383 |     | <span class='unexecuted'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), (defaultScenario.poolId));</span>
  384 |     | <span class='unexecuted'>        uint tau = getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(</span>
  385 |     | <span class='unexecuted'>            __hyperTestingContract__.timestamp()</span>
  386 |     | <span class='neutral'>        );</span>
  387 |     | <span class='unexecuted'>        uint strike = Price.computePriceWithTick(curve.maxTick);</span>
  388 |     | <span class='unexecuted'>        console.log(tau, strike, curve.volatility);</span>
  389 |     | <span class='unexecuted'>        uint256 theoreticalR2 = Price.getXWithPrice(price, strike, curve.volatility, tau);</span>
  390 |     | <span class='neutral'></span>
  391 |     | <span class='unexecuted'>        uint8 power = uint8(0x06); // 6 zeroes</span>
  392 |     | <span class='unexecuted'>        uint8 amount = uint8(0x04); // 4 with 6 zeroes = 4_000_000 wei</span>
  393 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  394 |     | <span class='neutral'></span>
  395 |     | <span class='unexecuted'>        __revertCatcher__.process(data);</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='unexecuted'>        uint delLiquidity = 4_000_000;</span>
  398 |     | <span class='unexecuted'>        uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  399 |     | <span class='unexecuted'>        uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  400 |     | <span class='unexecuted'>        assertTrue(globalR1 &gt; 0);</span>
  401 |     | <span class='unexecuted'>        assertTrue(globalR2 &gt; 0);</span>
  402 |     | <span class='unexecuted'>        uint expected = (theoreticalR2 * delLiquidity) / 1e18;</span>
  403 |     | <span class='unexecuted'>        console.log(&quot;expected&quot;, expected);</span>
  404 |     | <span class='unexecuted'>        console.log(&quot;globalR2&quot;, globalR2);</span>
  405 |     | <span class='neutral'>        // todo: fix this test</span>
  406 |     | <span class='unexecuted'>        assertApproxEqAbs(globalR2, expected, 1e2, &quot;asset-reserve-theoretic&quot;); // todo: fix, should it be this far?</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='unexecuted'>    function testAllocatePositionTimestampUpdated() public postTestInvariantChecks {</span>
  410 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  411 |     | <span class='neutral'></span>
  412 |     | <span class='unexecuted'>        uint256 prevPositionTimestamp = getPosition(</span>
  413 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  414 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  415 |     | <span class='neutral'>            positionId</span>
  416 |     | <span class='neutral'>        ).lastTimestamp;</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  419 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  420 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  421 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  422 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  423 |     | <span class='neutral'></span>
  424 |     | <span class='unexecuted'>        uint256 nextPositionTimestamp = getPosition(</span>
  425 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  426 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  427 |     | <span class='unexecuted'>            positionId</span>
  428 |     | <span class='neutral'>        ).lastTimestamp;</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='unexecuted'>        assertTrue(prevPositionTimestamp == 0);</span>
  431 |     | <span class='unexecuted'>        assertTrue(nextPositionTimestamp &gt; prevPositionTimestamp &amp;&amp; nextPositionTimestamp == block.timestamp);</span>
  432 |     | <span class='neutral'>    }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='unexecuted'>    function testAllocatePositionfreeLiquidityIncreases() public postTestInvariantChecks {</span>
  435 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='unexecuted'>        uint256 prevPositionfreeLiquidity = getPosition(</span>
  438 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  439 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  440 |     | <span class='neutral'>            positionId</span>
  441 |     | <span class='neutral'>        ).freeLiquidity;</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  444 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  445 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  446 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  447 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='unexecuted'>        uint256 nextPositionfreeLiquidity = getPosition(</span>
  450 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  451 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  452 |     | <span class='unexecuted'>            positionId</span>
  453 |     | <span class='neutral'>        ).freeLiquidity;</span>
  454 |     | <span class='neutral'></span>
  455 |     | <span class='unexecuted'>        assertTrue(prevPositionfreeLiquidity == 0);</span>
  456 |     | <span class='unexecuted'>        assertTrue(nextPositionfreeLiquidity &gt; prevPositionfreeLiquidity);</span>
  457 |     | <span class='neutral'>    }</span>
  458 |     | <span class='neutral'></span>
  459 |     | <span class='unexecuted'>    function testAllocateGlobalAssetIncreases() public postTestInvariantChecks {</span>
  460 |     | <span class='unexecuted'>        uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  463 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  464 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  465 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  466 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='unexecuted'>        uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  469 |     | <span class='neutral'>        assertTrue(nextGlobal != 0, &quot;next globalReserves is zero&quot;);</span>
  470 |     | <span class='neutral'>        assertTrue(nextGlobal &gt; prevGlobal, &quot;globalReserves did not change&quot;);</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='unexecuted'>    function testAllocateGlobalQuoteIncreases() public postTestInvariantChecks {</span>
  474 |     | <span class='unexecuted'>        uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  475 |     | <span class='neutral'></span>
  476 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  477 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  478 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  479 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  480 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='unexecuted'>        uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  483 |     | <span class='unexecuted'>        assertTrue(nextGlobal != 0, &quot;next globalReserves is zero&quot;);</span>
  484 |     | <span class='unexecuted'>        assertTrue(nextGlobal &gt; prevGlobal, &quot;globalReserves did not change&quot;);</span>
  485 |     | <span class='neutral'>    }</span>
  486 |     | <span class='neutral'></span>
  487 |     | <span class='neutral'>    // --- Remove Liquidity --- //</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='unexecuted'>    function testUnallocateZeroLiquidityReverts() public {</span>
  490 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeUnallocate(0, defaultScenario.poolId, 0x00, 0x00);</span>
  491 |     | <span class='unexecuted'>        vm.expectRevert(ZeroLiquidity.selector);</span>
  492 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  493 |     | <span class='unexecuted'>        assertTrue(!success);</span>
  494 |     | <span class='neutral'>    }</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='unexecuted'>    function testUnallocateNonExistentPoolReverts() public {</span>
  497 |     | <span class='unexecuted'>        uint64 failureArg = 42;</span>
  498 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeUnallocate(0, 42, 0x01, 0x01);</span>
  499 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));</span>
  500 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  501 |     | <span class='unexecuted'>        assertTrue(!success);</span>
  502 |     | <span class='neutral'>    }</span>
  503 |     | <span class='neutral'></span>
  504 |     | <span class='neutral'>    // needs a mutable pool, or a pool with a non-zero jit policy</span>
  505 |     | <span class='unexecuted'>    function testUnallocatePositionJitPolicyReverts() public postTestInvariantChecks {</span>
  506 |     | <span class='unexecuted'>        uint16 jit = 99;</span>
  507 |     | <span class='unexecuted'>        bytes memory createData = Enigma.encodeCreatePool(</span>
  508 |     | <span class='unexecuted'>            uint24(1), // pairId</span>
  509 |     | <span class='unexecuted'>            address(this), // controller</span>
  510 |     | <span class='neutral'>            DEFAULT_FEE,</span>
  511 |     | <span class='neutral'>            DEFAULT_FEE,</span>
  512 |     | <span class='neutral'>            uint16(DEFAULT_SIGMA),</span>
  513 |     | <span class='neutral'>            DEFAULT_DURATION_DAYS,</span>
  514 |     | <span class='neutral'>            jit,</span>
  515 |     | <span class='neutral'>            DEFAULT_TICK,</span>
  516 |     | <span class='neutral'>            DEFAULT_PRICE</span>
  517 |     | <span class='neutral'>        );</span>
  518 |     | <span class='neutral'></span>
  519 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(createData);</span>
  520 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='unexecuted'>        uint64 poolId = Enigma.encodePoolId(uint24(0x01), true, uint32(__hyperTestingContract__.getPoolNonce()));</span>
  523 |     | <span class='neutral'></span>
  524 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  525 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  526 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, poolId, power, amount);</span>
  527 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  528 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>        // Set the distance for the position by warping in time.</span>
  531 |     | <span class='unexecuted'>        uint256 distance = 22;</span>
  532 |     | <span class='unexecuted'>        uint256 warpTimestamp = block.timestamp + distance;</span>
  533 |     | <span class='unexecuted'>        customWarp(warpTimestamp);</span>
  534 |     | <span class='neutral'></span>
  535 |     | <span class='unexecuted'>        data = Enigma.encodeUnallocate(0, poolId, power, amount);</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(JitLiquidity.selector, distance));</span>
  538 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  539 |     | <span class='unexecuted'>        assertTrue(!success, &quot;Should not suceed in testUnllocatePositionJit&quot;);</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='unexecuted'>    function testUnallocatePositionTimestampUpdated() public postTestInvariantChecks {</span>
  543 |     | <span class='unexecuted'>        int24 hiTick = DEFAULT_TICK;</span>
  544 |     | <span class='unexecuted'>        int24 loTick = DEFAULT_TICK - 256;</span>
  545 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  546 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  547 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  548 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  549 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  550 |     | <span class='neutral'></span>
  551 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  552 |     | <span class='unexecuted'>        uint256 prevPositionTimestamp = getPosition(</span>
  553 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  554 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  555 |     | <span class='neutral'>            positionId</span>
  556 |     | <span class='neutral'>        ).lastTimestamp;</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='unexecuted'>        uint256 warpTimestamp = block.timestamp + 1;</span>
  559 |     | <span class='unexecuted'>        customWarp(warpTimestamp);</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='unexecuted'>        data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);</span>
  562 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='unexecuted'>        uint256 nextPositionTimestamp = getPosition(</span>
  565 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  566 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  567 |     | <span class='unexecuted'>            positionId</span>
  568 |     | <span class='neutral'>        ).lastTimestamp;</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='unexecuted'>        assertTrue(nextPositionTimestamp &gt; prevPositionTimestamp &amp;&amp; nextPositionTimestamp == warpTimestamp);</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='unexecuted'>    function testUnallocatePositionfreeLiquidityDecreases() public postTestInvariantChecks {</span>
  574 |     | <span class='unexecuted'>        int24 hiTick = DEFAULT_TICK;</span>
  575 |     | <span class='unexecuted'>        int24 loTick = DEFAULT_TICK - 256;</span>
  576 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  577 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  578 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  579 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  580 |     | <span class='unexecuted'>        assertTrue(success, &quot;forwarder call failed&quot;);</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  583 |     | <span class='unexecuted'>        uint256 prevPositionLiquidity = getPosition(</span>
  584 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  585 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  586 |     | <span class='neutral'>            positionId</span>
  587 |     | <span class='neutral'>        ).freeLiquidity;</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='unexecuted'>        data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);</span>
  590 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='unexecuted'>        uint256 nextPositionLiquidity = getPosition(</span>
  593 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  594 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  595 |     | <span class='unexecuted'>            positionId</span>
  596 |     | <span class='neutral'>        ).freeLiquidity;</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='unexecuted'>        assertTrue(nextPositionLiquidity &lt; prevPositionLiquidity);</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='unexecuted'>    function testUnallocateGlobalAssetDecreases() public postTestInvariantChecks {</span>
  602 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  603 |     | <span class='unexecuted'>        uint8 power = 0x05; // if this is low enough, it will revert because token amounts rounded down to zero.</span>
  604 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  605 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  606 |     | <span class='unexecuted'>        assertTrue(success);</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='unexecuted'>        uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='unexecuted'>        data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);</span>
  611 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='unexecuted'>        uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));</span>
  614 |     | <span class='neutral'>        assertTrue(next == prev, &quot;reserves-changed&quot;); // unallocated amounts are credited to user</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    /// @dev IMPORTANT TEST. For low token decimals, be very aware of the amount of liquidity involved in each tx.</span>
  618 |     | <span class='unexecuted'>    function testUnallocateGlobalQuoteDecreases() public postTestInvariantChecks {</span>
  619 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  620 |     | <span class='unexecuted'>        uint8 power = 0x0c; // 1e12 liquidity</span>
  621 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  622 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  623 |     | <span class='unexecuted'>        assertTrue(success);</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='unexecuted'>        uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  626 |     | <span class='neutral'></span>
  627 |     | <span class='unexecuted'>        data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);</span>
  628 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='unexecuted'>        uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));</span>
  631 |     | <span class='unexecuted'>        assertTrue(next == prev, &quot;reserves-changed&quot;); // unallocated amounts are credited to user</span>
  632 |     | <span class='neutral'>    }</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    // --- Stake Position --- //</span>
  635 |     | <span class='neutral'></span>
  636 |     | <span class='unexecuted'>    function testStakeExternalEpochIncrements() public {</span>
  637 |     | <span class='unexecuted'>        uint8 amount = 0x05;</span>
  638 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, amount);</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='unexecuted'>        uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)</span>
  641 |     | <span class='neutral'>            .stakeTimestamp;</span>
  642 |     | <span class='unexecuted'>        __hyperTestingContract__.stake(defaultScenario.poolId, amount);</span>
  643 |     | <span class='unexecuted'>        uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)</span>
  644 |     | <span class='neutral'>            .stakeTimestamp;</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='unexecuted'>        assertTrue(nextId != prevId);</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='unexecuted'>    function testStakePositionStakedUpdated() public postTestInvariantChecks {</span>
  650 |     | <span class='unexecuted'>        int24 lo = DEFAULT_TICK - 256;</span>
  651 |     | <span class='unexecuted'>        int24 hi = DEFAULT_TICK;</span>
  652 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  653 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  654 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  655 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  656 |     | <span class='unexecuted'>        assertTrue(success);</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  659 |     | <span class='neutral'></span>
  660 |     | <span class='unexecuted'>        bool prevPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)</span>
  661 |     | <span class='neutral'>            .stakeTimestamp != 0;</span>
  662 |     | <span class='neutral'></span>
  663 |     | <span class='unexecuted'>        data = Enigma.encodeStakePosition(positionId, amount);</span>
  664 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='unexecuted'>        bool nextPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)</span>
  667 |     | <span class='unexecuted'>            .stakeTimestamp != 0;</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='unexecuted'>        assertTrue(nextPositionStaked != prevPositionStaked, &quot;Position staked did not update.&quot;);</span>
  670 |     | <span class='unexecuted'>        assertTrue(nextPositionStaked, &quot;Position staked is not true.&quot;);</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='unexecuted'>    function testStakePoolStakedLiquidityUpdated() public postTestInvariantChecks {</span>
  674 |     | <span class='unexecuted'>        int24 lo = DEFAULT_TICK - 256;</span>
  675 |     | <span class='unexecuted'>        int24 hi = DEFAULT_TICK;</span>
  676 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  677 |     | <span class='neutral'>        uint8 power = 0x01;</span>
  678 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  679 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  680 |     | <span class='unexecuted'>        assertTrue(success);</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='unexecuted'>        uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)</span>
  683 |     | <span class='neutral'>            .stakedLiquidity;</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  686 |     | <span class='unexecuted'>        data = Enigma.encodeStakePosition(positionId, amount);</span>
  687 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='unexecuted'>        uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)</span>
  690 |     | <span class='neutral'>            .stakedLiquidity;</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='unexecuted'>        if (</span>
  693 |     | <span class='unexecuted'>            lo &lt;= getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick &amp;&amp;</span>
  694 |     | <span class='unexecuted'>            hi &gt; getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick</span>
  695 |     | <span class='neutral'>        ) {</span>
  696 |     | <span class='unexecuted'>            assertTrue(nextPoolStakedLiquidity &gt; prevPoolStakedLiquidity, &quot;Pool staked liquidity did not increase.&quot;);</span>
  697 |     | <span class='unexecuted'>            assertTrue(</span>
  698 |     | <span class='unexecuted'>                nextPoolStakedLiquidity ==</span>
  699 |     | <span class='unexecuted'>                    getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)</span>
  700 |     | <span class='neutral'>                        .freeLiquidity,</span>
  701 |     | <span class='neutral'>                &quot;Pool staked liquidity not equal to liquidity of staked position.&quot;</span>
  702 |     | <span class='neutral'>            );</span>
  703 |     | <span class='neutral'>        } else {</span>
  704 |     | <span class='unexecuted'>            assertTrue(</span>
  705 |     | <span class='unexecuted'>                nextPoolStakedLiquidity == prevPoolStakedLiquidity,</span>
  706 |     | <span class='neutral'>                &quot;Pool staked liquidity changed even though position staked out of range.&quot;</span>
  707 |     | <span class='neutral'>            );</span>
  708 |     | <span class='neutral'>        }</span>
  709 |     | <span class='neutral'>    }</span>
  710 |     | <span class='neutral'></span>
  711 |     | <span class='unexecuted'>    function testStakeNonExistentPoolIdReverts() public {</span>
  712 |     | <span class='unexecuted'>        uint64 failureArg = uint64(3214);</span>
  713 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));</span>
  714 |     | <span class='unexecuted'>        __hyperTestingContract__.stake(failureArg, 100);</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='unexecuted'>    function testStakeZeroLiquidityRevertsWithInsufficientPosition() public {</span>
  718 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InsufficientPosition.selector, defaultScenario.poolId));</span>
  719 |     | <span class='unexecuted'>        __hyperTestingContract__.stake(defaultScenario.poolId, 100);</span>
  720 |     | <span class='neutral'>    }</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='neutral'>    // --- Unstake Position --- //</span>
  723 |     | <span class='neutral'></span>
  724 |     | <span class='unexecuted'>    function testUnstakeExternalEpochIncrements() public {</span>
  725 |     | <span class='unexecuted'>        uint8 amount = 0x05;</span>
  726 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, amount);</span>
  727 |     | <span class='unexecuted'>        __hyperTestingContract__.stake(defaultScenario.poolId, amount);</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='unexecuted'>        uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)</span>
  730 |     | <span class='neutral'>            .unstakeTimestamp;</span>
  731 |     | <span class='neutral'></span>
  732 |     | <span class='unexecuted'>        customWarp(prevId + 1);</span>
  733 |     | <span class='unexecuted'>        __hyperTestingContract__.unstake(defaultScenario.poolId, amount);</span>
  734 |     | <span class='unexecuted'>        uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)</span>
  735 |     | <span class='neutral'>            .unstakeTimestamp;</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>        // todo: add better tests</span>
  738 |     | <span class='neutral'>        //assertTrue(nextId != prevId);</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='unexecuted'>    function testUnstakePositionStakedUpdated() public postTestInvariantChecks {</span>
  742 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  743 |     | <span class='unexecuted'>        uint8 power = 0x0f;</span>
  744 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  745 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  746 |     | <span class='unexecuted'>        assertTrue(success);</span>
  747 |     | <span class='neutral'></span>
  748 |     | <span class='unexecuted'>        uint128 stakeAmount = uint128(amount * 10 ** power);</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  751 |     | <span class='unexecuted'>        data = Enigma.encodeStakePosition(positionId, stakeAmount);</span>
  752 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='unexecuted'>        HyperPosition memory pos = getPosition(</span>
  755 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  756 |     | <span class='unexecuted'>            address(this),</span>
  757 |     | <span class='unexecuted'>            defaultScenario.poolId</span>
  758 |     | <span class='neutral'>        );</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='neutral'>        // touch pool to update it so we know how much staked liquidity the position has</span>
  761 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  762 |     | <span class='neutral'>        uint8 direction = 0;</span>
  763 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  764 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x09, 0x01, 0x0, limit, direction);</span>
  765 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  766 |     | <span class='neutral'></span>
  767 |     | <span class='unexecuted'>        HyperPosition memory revertCatcherPos = defaultRevertCatcherPosition();</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='unexecuted'>        uint256 prevPositionStaked = getPosition(</span>
  770 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  771 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  772 |     | <span class='unexecuted'>            positionId</span>
  773 |     | <span class='neutral'>        ).unstakeTimestamp;</span>
  774 |     | <span class='neutral'></span>
  775 |     | <span class='unexecuted'>        uint prevStaked = revertCatcherPos.stakedLiquidity;</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='unexecuted'>        data = Enigma.encodeUnstakePosition(positionId, stakeAmount);</span>
  778 |     | <span class='unexecuted'>        customWarp(prevPositionStaked + 1);</span>
  779 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  780 |     | <span class='unexecuted'>        revertCatcherPos = defaultRevertCatcherPosition();</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='unexecuted'>        uint256 nextPositionStaked = getPosition(</span>
  783 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
  784 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
  785 |     | <span class='unexecuted'>            positionId</span>
  786 |     | <span class='neutral'>        ).unstakeTimestamp;</span>
  787 |     | <span class='neutral'></span>
  788 |     | <span class='unexecuted'>        uint postStaked = revertCatcherPos.stakedLiquidity;</span>
  789 |     | <span class='unexecuted'>        assertEq(postStaked, prevStaked - stakeAmount, &quot;stake-liquidity-decreases&quot;);</span>
  790 |     | <span class='unexecuted'>        assertTrue(postStaked &lt; prevStaked, &quot;stake-did-not-decrease&quot;);</span>
  791 |     | <span class='neutral'>        //assertTrue(nextPositionStaked != prevPositionStaked, &quot;Position staked did not update.&quot;);</span>
  792 |     | <span class='neutral'>        //assertTrue(nextPositionStaked != 0, &quot;Position staked is true.&quot;);</span>
  793 |     | <span class='neutral'>    }</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>    // note: some unintended side effects most likely from update/sync pool messing with price</span>
  796 |     | <span class='neutral'>    // it creates a discrepency in the contract where the contract holds more tokens than the sum</span>
  797 |     | <span class='neutral'>    // of all claims is entitled to.</span>
  798 |     | <span class='unexecuted'>    function testUnstakePoolStakedLiquidityUpdated() public postTestInvariantChecks {</span>
  799 |     | <span class='unexecuted'>        uint8 amount = 0x01;</span>
  800 |     | <span class='unexecuted'>        uint8 power = 0x0f;</span>
  801 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);</span>
  802 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  803 |     | <span class='unexecuted'>        assertTrue(success);</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='unexecuted'>        uint64 positionId = defaultScenario.poolId;</span>
  806 |     | <span class='unexecuted'>        data = Enigma.encodeStakePosition(positionId, amount);</span>
  807 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>        // touch pool to update it so we know how much staked liquidity the position has</span>
  810 |     | <span class='unexecuted'>        uint8 useMax = 0;</span>
  811 |     | <span class='neutral'>        uint8 direction = 0;</span>
  812 |     | <span class='unexecuted'>        uint128 limit = getMaxSwapLimit(direction == 0).safeCastTo128();</span>
  813 |     | <span class='unexecuted'>        data = Enigma.encodeSwap(useMax, positionId, 0x09, 0x01, 0x0, limit, direction);</span>
  814 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  815 |     | <span class='neutral'></span>
  816 |     | <span class='unexecuted'>        uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), positionId).stakedLiquidity;</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='unexecuted'>        HyperPosition memory pos = defaultRevertCatcherPosition();</span>
  819 |     | <span class='unexecuted'>        customWarp(pos.unstakeTimestamp + 1);</span>
  820 |     | <span class='unexecuted'>        data = Enigma.encodeUnstakePosition(positionId, amount);</span>
  821 |     | <span class='unexecuted'>        success = __revertCatcher__.process(data);</span>
  822 |     | <span class='neutral'></span>
  823 |     | <span class='unexecuted'>        pos = defaultRevertCatcherPosition();</span>
  824 |     | <span class='unexecuted'>        customWarp((pos.unstakeTimestamp + 1) * 2);</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>        // TODO: FIX FAILING TEST</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='neutral'>        // touch pool to update it so we know how much staked liquidity the position has</span>
  829 |     | <span class='neutral'>        // data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, 0x01, 0x15, 0x01, 0);</span>
  830 |     | <span class='neutral'>        // success = __revertCatcher__.process(data);</span>
  831 |     | <span class='neutral'>        //</span>
  832 |     | <span class='neutral'>        // // todo: currently fails because unstaking does not change staked liquidity.</span>
  833 |     | <span class='neutral'>        // uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__),defaultScenario.poolId).stakedLiquidity;</span>
  834 |     | <span class='neutral'>        //</span>
  835 |     | <span class='neutral'>        // if (lo &lt;= getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick &amp;&amp; hi &gt; getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick) {</span>
  836 |     | <span class='neutral'>        //     assertTrue(nextPoolStakedLiquidity &lt; prevPoolStakedLiquidity, &quot;Pool staked liquidity did not increase.&quot;);</span>
  837 |     | <span class='neutral'>        //     assertTrue(nextPoolStakedLiquidity == 0, &quot;Pool staked liquidity does not equal 0 after unstake.&quot;);</span>
  838 |     | <span class='neutral'>        // } else {</span>
  839 |     | <span class='neutral'>        //     assertTrue(</span>
  840 |     | <span class='neutral'>        //         nextPoolStakedLiquidity == prevPoolStakedLiquidity,</span>
  841 |     | <span class='neutral'>        //         &quot;Pool staked liquidity changed even though position staked out of range.&quot;</span>
  842 |     | <span class='neutral'>        //     );</span>
  843 |     | <span class='neutral'>        // }</span>
  844 |     | <span class='neutral'>    }</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='unexecuted'>    function testUnstakeNonExistentPoolIdReverts() public {</span>
  847 |     | <span class='unexecuted'>        uint64 failureArg = 1224;</span>
  848 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));</span>
  849 |     | <span class='unexecuted'>        __hyperTestingContract__.unstake(failureArg, 555);</span>
  850 |     | <span class='neutral'>    }</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='unexecuted'>    function testUnstakeNotStakedReverts() public {</span>
  853 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(PositionNotStaked.selector, defaultScenario.poolId));</span>
  854 |     | <span class='unexecuted'>        __hyperTestingContract__.unstake(defaultScenario.poolId, 555);</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    // --- Create HyperPair --- //</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='unexecuted'>    function testCreatePairSameTokensReverts() public {</span>
  860 |     | <span class='unexecuted'>        address token = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  861 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(token, token);</span>
  862 |     | <span class='unexecuted'>        vm.expectRevert(SameTokenError.selector);</span>
  863 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  864 |     | <span class='neutral'>        assertTrue(!success, &quot;forwarder call failed&quot;);</span>
  865 |     | <span class='neutral'>    }</span>
  866 |     | <span class='neutral'></span>
  867 |     | <span class='unexecuted'>    function testCreatePairPairExistsReverts() public {</span>
  868 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.asset), address(defaultScenario.quote));</span>
  869 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(PairExists.selector, 1));</span>
  870 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='unexecuted'>    function testCreatePairLowerDecimalBoundsAssetReverts() public {</span>
  874 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 5));</span>
  875 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  876 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  877 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));</span>
  878 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='unexecuted'>    function testCreatePairLowerDecimalBoundsQuoteReverts() public {</span>
  882 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  883 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 5));</span>
  884 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  885 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));</span>
  886 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='unexecuted'>    function testCreatePairUpperDecimalBoundsAssetReverts() public {</span>
  890 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 24));</span>
  891 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  892 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  893 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));</span>
  894 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='unexecuted'>    function testCreatePairUpperDecimalBoundsQuoteReverts() public {</span>
  898 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  899 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 24));</span>
  900 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  901 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));</span>
  902 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='unexecuted'>    function testCreatePairPairNonceIncrementedReturnsOneAdded() public {</span>
  906 |     | <span class='unexecuted'>        uint256 prevNonce = __hyperTestingContract__.getPairNonce();</span>
  907 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  908 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  909 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  910 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  911 |     | <span class='unexecuted'>        uint256 nonce = __hyperTestingContract__.getPairNonce();</span>
  912 |     | <span class='unexecuted'>        assertEq(nonce, prevNonce + 1);</span>
  913 |     | <span class='neutral'>    }</span>
  914 |     | <span class='neutral'></span>
  915 |     | <span class='unexecuted'>    function testCreatePairFetchesPairIdReturnsNonZero() public {</span>
  916 |     | <span class='unexecuted'>        uint256 prevNonce = __hyperTestingContract__.getPairNonce();</span>
  917 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  918 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  919 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  920 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  921 |     | <span class='unexecuted'>        uint256 pairId = __hyperTestingContract__.getPairId(token0, token1);</span>
  922 |     | <span class='unexecuted'>        assertTrue(pairId != 0);</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='unexecuted'>    function testCreatePairFetchesPairDataReturnsAddresses() public {</span>
  926 |     | <span class='unexecuted'>        uint256 prevNonce = __hyperTestingContract__.getPairNonce();</span>
  927 |     | <span class='unexecuted'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  928 |     | <span class='unexecuted'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
  929 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
  930 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
  931 |     | <span class='unexecuted'>        uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);</span>
  932 |     | <span class='unexecuted'>        HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);</span>
  933 |     | <span class='unexecuted'>        assertEq(pair.tokenAsset, token0);</span>
  934 |     | <span class='unexecuted'>        assertEq(pair.tokenQuote, token1);</span>
  935 |     | <span class='unexecuted'>        assertEq(pair.decimalsAsset, 18);</span>
  936 |     | <span class='unexecuted'>        assertEq(pair.decimalsQuote, 18);</span>
  937 |     | <span class='neutral'>    }</span>
  938 |     | <span class='neutral'></span>
  939 |     | <span class='neutral'>    /* // --- Create Curve --- //</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function testCreateCurveCurveExistsReverts() public {</span>
  942 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
  943 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
  944 |     | <span class='neutral'>            curve.sigma,</span>
  945 |     | <span class='neutral'>            curve.maturity,</span>
  946 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
  947 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
  948 |     | <span class='neutral'>            curve.strike</span>
  949 |     | <span class='neutral'>        );</span>
  950 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(CurveExists.selector, 1));</span>
  951 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  952 |     | <span class='neutral'>    }</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    function testCreateCurveFeeParameterOutsideBoundsReverts() public {</span>
  955 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
  956 |     | <span class='neutral'>        uint16 failureArg = 5e4;</span>
  957 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
  958 |     | <span class='neutral'>            curve.sigma,</span>
  959 |     | <span class='neutral'>            curve.maturity,</span>
  960 |     | <span class='neutral'>            failureArg,</span>
  961 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
  962 |     | <span class='neutral'>            curve.strike</span>
  963 |     | <span class='neutral'>        );</span>
  964 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));</span>
  965 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  966 |     | <span class='neutral'>    }</span>
  967 |     | <span class='neutral'></span>
  968 |     | <span class='neutral'>    function testCreateCurvePriorityFeeParameterOutsideBoundsReverts() public {</span>
  969 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
  970 |     | <span class='neutral'>        uint16 failureArg = 5e4;</span>
  971 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
  972 |     | <span class='neutral'>            curve.sigma,</span>
  973 |     | <span class='neutral'>            curve.maturity,</span>
  974 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
  975 |     | <span class='neutral'>            failureArg,</span>
  976 |     | <span class='neutral'>            curve.strike</span>
  977 |     | <span class='neutral'>        );</span>
  978 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));</span>
  979 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    function testCreateCurveRMMPoolZeroSigmaReverts() public {</span>
  983 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
  984 |     | <span class='neutral'>        uint24 failureArg = 0;</span>
  985 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
  986 |     | <span class='neutral'>            failureArg,</span>
  987 |     | <span class='neutral'>            curve.maturity,</span>
  988 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
  989 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
  990 |     | <span class='neutral'>            curve.strike</span>
  991 |     | <span class='neutral'>        );</span>
  992 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));</span>
  993 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
  994 |     | <span class='neutral'>    }</span>
  995 |     | <span class='neutral'></span>
  996 |     | <span class='neutral'>    function testCreateCurveRMMPoolZeroStrikeReverts() public {</span>
  997 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
  998 |     | <span class='neutral'>        uint128 failureArg = 0;</span>
  999 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
 1000 |     | <span class='neutral'>            curve.sigma,</span>
 1001 |     | <span class='neutral'>            curve.maturity,</span>
 1002 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
 1003 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
 1004 |     | <span class='neutral'>            failureArg</span>
 1005 |     | <span class='neutral'>        );</span>
 1006 |     | <span class='neutral'>        vm.expectRevert(abi.encodeWithSelector(InvalidStrike.selector, failureArg));</span>
 1007 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    function testCreateCurveCurveNonceIncrementReturnsOne() public {</span>
 1011 |     | <span class='neutral'>        uint256 prevNonce = __hyperTestingContract__.getCurveNonce();</span>
 1012 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
 1013 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
 1014 |     | <span class='neutral'>            curve.sigma + 1,</span>
 1015 |     | <span class='neutral'>            curve.maturity,</span>
 1016 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
 1017 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
 1018 |     | <span class='neutral'>            curve.strike</span>
 1019 |     | <span class='neutral'>        );</span>
 1020 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1021 |     | <span class='neutral'>        uint256 nextNonce = __hyperTestingContract__.getCurveNonce();</span>
 1022 |     | <span class='neutral'>        assertEq(prevNonce, nextNonce - 1);</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function testCreateCurveFetchesCurveIdReturnsNonZero() public {</span>
 1026 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
 1027 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
 1028 |     | <span class='neutral'>            curve.sigma + 1,</span>
 1029 |     | <span class='neutral'>            curve.maturity,</span>
 1030 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
 1031 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
 1032 |     | <span class='neutral'>            curve.strike</span>
 1033 |     | <span class='neutral'>        );</span>
 1034 |     | <span class='neutral'>        bytes32 rawCurveId = Enigma.toBytes32(</span>
 1035 |     | <span class='neutral'>            abi.encodePacked(</span>
 1036 |     | <span class='neutral'>                curve.sigma + 1,</span>
 1037 |     | <span class='neutral'>                curve.maturity,</span>
 1038 |     | <span class='neutral'>                uint16(1e4 - curve.gamma),</span>
 1039 |     | <span class='neutral'>                uint16(1e4 - curve.priorityGamma),</span>
 1040 |     | <span class='neutral'>                curve.strike</span>
 1041 |     | <span class='neutral'>            )</span>
 1042 |     | <span class='neutral'>        );</span>
 1043 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1044 |     | <span class='neutral'>        uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);</span>
 1045 |     | <span class='neutral'>        assertTrue(curveId != 0);</span>
 1046 |     | <span class='neutral'>    }</span>
 1047 |     | <span class='neutral'></span>
 1048 |     | <span class='neutral'>    function testCreateCurveFetchesCurveDataReturnsParametersSet() public {</span>
 1049 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
 1050 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(</span>
 1051 |     | <span class='neutral'>            curve.sigma + 1,</span>
 1052 |     | <span class='neutral'>            curve.maturity,</span>
 1053 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
 1054 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
 1055 |     | <span class='neutral'>            curve.strike</span>
 1056 |     | <span class='neutral'>        );</span>
 1057 |     | <span class='neutral'>        bytes32 rawCurveId = Enigma.toBytes32(</span>
 1058 |     | <span class='neutral'>            abi.encodePacked(</span>
 1059 |     | <span class='neutral'>                curve.sigma + 1,</span>
 1060 |     | <span class='neutral'>                curve.maturity,</span>
 1061 |     | <span class='neutral'>                uint16(1e4 - curve.gamma),</span>
 1062 |     | <span class='neutral'>                uint16(1e4 - curve.priorityGamma),</span>
 1063 |     | <span class='neutral'>                curve.strike</span>
 1064 |     | <span class='neutral'>            )</span>
 1065 |     | <span class='neutral'>        );</span>
 1066 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1067 |     | <span class='neutral'>        uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);</span>
 1068 |     | <span class='neutral'>        HyperCurve memory newCurve = getCurve(address(__hyperTestingContract__), curveId);</span>
 1069 |     | <span class='neutral'>        assertEq(newCurve.sigma, curve.sigma + 1);</span>
 1070 |     | <span class='neutral'>        assertEq(newCurve.maturity, curve.maturity);</span>
 1071 |     | <span class='neutral'>        assertEq(newCurve.gamma, curve.gamma);</span>
 1072 |     | <span class='neutral'>        assertEq(newCurve.priorityGamma, curve.priorityGamma);</span>
 1073 |     | <span class='neutral'>        assertEq(newCurve.strike, curve.strike);</span>
 1074 |     | <span class='neutral'>    } */</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>    // --- Create Pool --- //</span>
 1077 |     | <span class='neutral'>    // todo: fix</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>    /* function testCreatePoolZeroPriceParameterReverts() public {</span>
 1080 |     | <span class='neutral'>        uint128 failureArg = 0;</span>
 1081 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePool(1, failureArg);</span>
 1082 |     | <span class='neutral'>        vm.expectRevert(ZeroPrice.selector);</span>
 1083 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1084 |     | <span class='neutral'>    } */</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    // todo: fix</span>
 1087 |     | <span class='neutral'>    /* function testCreatePoolExistentPoolReverts() public {</span>
 1088 |     | <span class='neutral'>        uint64 failureArg = defaultScenario.poolId;</span>
 1089 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePool(failureArg, 1);</span>
 1090 |     | <span class='neutral'>        vm.expectRevert(PoolExists.selector);</span>
 1091 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1092 |     | <span class='neutral'>    } */</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    // todo: fix</span>
 1095 |     | <span class='neutral'>    /* function testCreatePoolMagicPairId() public {</span>
 1096 |     | <span class='neutral'>        // Create a new curve to increment the nonce to 2</span>
 1097 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreateCurve(4, type(uint32).max - 1, 4, 4, 4);</span>
 1098 |     | <span class='neutral'>        __revertCatcher__.process(data);</span>
 1099 |     | <span class='neutral'></span>
 1100 |     | <span class='neutral'>        uint64 magicVariable = 0x000000000002;</span>
 1101 |     | <span class='neutral'>        data = Enigma.encodeCreatePool(magicVariable, 1);</span>
 1102 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1103 |     | <span class='neutral'>        assertTrue(success);</span>
 1104 |     | <span class='neutral'>    } */</span>
 1105 |     | <span class='neutral'>    /* </span>
 1106 |     | <span class='neutral'>    function testCreatePoolMagicCurveId() public {</span>
 1107 |     | <span class='neutral'>        // Create a new pair to increment the nonce to 2</span>
 1108 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.quote), address(__weth__));</span>
 1109 |     | <span class='neutral'>        __revertCatcher__.process(data);</span>
 1110 |     | <span class='neutral'></span>
 1111 |     | <span class='neutral'>        uint64 magicVariable = 0x000200000000;</span>
 1112 |     | <span class='neutral'>        data = Enigma.encodeCreatePool(magicVariable, 1);</span>
 1113 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1114 |     | <span class='neutral'>        assertTrue(success);</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function testCreatePoolRMMPoolExpiredReverts() public {</span>
 1118 |     | <span class='neutral'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
 1119 |     | <span class='neutral'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
 1120 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
 1121 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1122 |     | <span class='neutral'>        uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
 1125 |     | <span class='neutral'>        data = Enigma.encodeCreateCurve(</span>
 1126 |     | <span class='neutral'>            curve.sigma + 1,</span>
 1127 |     | <span class='neutral'>            uint32(0),</span>
 1128 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
 1129 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
 1130 |     | <span class='neutral'>            curve.strike</span>
 1131 |     | <span class='neutral'>        );</span>
 1132 |     | <span class='neutral'>        bytes32 rawCurveId = Enigma.toBytes32(</span>
 1133 |     | <span class='neutral'>            abi.encodePacked(curve.sigma + 1, uint32(0), uint16(1e4 - curve.gamma), curve.strike)</span>
 1134 |     | <span class='neutral'>        );</span>
 1135 |     | <span class='neutral'>        success = __revertCatcher__.process(data);</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>        uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);</span>
 1138 |     | <span class='neutral'>        uint64 id = Enigma.encodePoolId(pairId, curveId);</span>
 1139 |     | <span class='neutral'>        data = Enigma.encodeCreatePool(id, 1_000);</span>
 1140 |     | <span class='neutral'>        vm.expectRevert(PoolExpired.selector);</span>
 1141 |     | <span class='neutral'>        success = __revertCatcher__.process(data);</span>
 1142 |     | <span class='neutral'>    }</span>
 1143 |     | <span class='neutral'></span>
 1144 |     | <span class='neutral'>    function testCreatePoolFetchesPoolDataReturnsNonZeroBlockTimestamp() public {</span>
 1145 |     | <span class='neutral'>        address token0 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
 1146 |     | <span class='neutral'>        address token1 = address(new TestERC20(&quot;t&quot;, &quot;t&quot;, 18));</span>
 1147 |     | <span class='neutral'>        bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));</span>
 1148 |     | <span class='neutral'>        bool success = __revertCatcher__.process(data);</span>
 1149 |     | <span class='neutral'>        uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);</span>
 1150 |     | <span class='neutral'></span>
 1151 |     | <span class='neutral'>        HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup</span>
 1152 |     | <span class='neutral'>        data = Enigma.encodeCreateCurve(</span>
 1153 |     | <span class='neutral'>            curve.sigma + 1,</span>
 1154 |     | <span class='neutral'>            curve.maturity,</span>
 1155 |     | <span class='neutral'>            uint16(1e4 - curve.gamma),</span>
 1156 |     | <span class='neutral'>            uint16(1e4 - curve.priorityGamma),</span>
 1157 |     | <span class='neutral'>            curve.strike</span>
 1158 |     | <span class='neutral'>        );</span>
 1159 |     | <span class='neutral'>        bytes32 rawCurveId = Enigma.toBytes32(</span>
 1160 |     | <span class='neutral'>            abi.encodePacked(</span>
 1161 |     | <span class='neutral'>                curve.sigma + 1,</span>
 1162 |     | <span class='neutral'>                curve.maturity,</span>
 1163 |     | <span class='neutral'>                uint16(1e4 - curve.gamma),</span>
 1164 |     | <span class='neutral'>                uint16(1e4 - curve.priorityGamma),</span>
 1165 |     | <span class='neutral'>                curve.strike</span>
 1166 |     | <span class='neutral'>            )</span>
 1167 |     | <span class='neutral'>        );</span>
 1168 |     | <span class='neutral'>        success = __revertCatcher__.process(data);</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>        uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);</span>
 1171 |     | <span class='neutral'>        uint64 id = Enigma.encodePoolId(pairId, curveId);</span>
 1172 |     | <span class='neutral'>        data = Enigma.encodeCreatePool(id, 1_000);</span>
 1173 |     | <span class='neutral'>        success = __revertCatcher__.process(data);</span>
 1174 |     | <span class='neutral'></span>
 1175 |     | <span class='neutral'>        uint256 time = getPool(address(__hyperTestingContract__), id).lastTimestamp;</span>
 1176 |     | <span class='neutral'>        assertTrue(time != 0);</span>
 1177 |     | <span class='neutral'>    } */</span>
 1178 |     | <span class='neutral'>}</span>
 1179 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperSwap.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot; as HyperTypes;</span>
  5 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperProfiles.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract TestHyperSwap is TestHyperSetup {</span>
  9 |     | <span class='neutral'>    modifier allocateFirst() {</span>
 10 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, 10 ether);</span>
 11 |     | <span class='neutral'>        _;</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    function testSwap_should_succeed() public allocateFirst {</span>
 15 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        uint input = DEFAULT_SWAP_INPUT;</span>
 18 |     | <span class='neutral'>        uint expected = DEFAULT_SWAP_OUTPUT; // 6 decimals</span>
 19 |     | <span class='unexecuted'>        (uint out, ) = pool.getAmountOut(</span>
 20 |     | <span class='unexecuted'>            getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId &gt;&gt; 40)),</span>
 21 |     | <span class='unexecuted'>            true,</span>
 22 |     | <span class='unexecuted'>            input,</span>
 23 |     | <span class='unexecuted'>            0</span>
 24 |     | <span class='neutral'>        );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        (uint output, uint remainder) = __hyperTestingContract__.swap(</span>
 27 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 28 |     | <span class='neutral'>            true,</span>
 29 |     | <span class='neutral'>            input,</span>
 30 |     | <span class='neutral'>            0 // limit</span>
 31 |     | <span class='neutral'>        );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>        assertEq(output, expected, &quot;expected-output&quot;);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        (uint amount0, uint amount1) = pool.getAmounts();</span>
 36 |     | <span class='unexecuted'>        console.log(&quot;amounts&quot;, amount0, amount1);</span>
 37 |     | <span class='unexecuted'>        console.log(&quot;outputs, actual, expected&quot;, output, out);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function testSwap_back_and_forth_outputs_less() public allocateFirst {</span>
 41 |     | <span class='unexecuted'>        uint256 start = 10000;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>        bool direction = false;</span>
 44 |     | <span class='unexecuted'>        (uint output, ) = __hyperTestingContract__.swap(</span>
 45 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 46 |     | <span class='neutral'>            direction,</span>
 47 |     | <span class='neutral'>            start,</span>
 48 |     | <span class='neutral'>            direction ? 0 : type(uint128).max</span>
 49 |     | <span class='neutral'>        );</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        direction = true;</span>
 52 |     | <span class='unexecuted'>        (uint finalOutput, ) = __hyperTestingContract__.swap(</span>
 53 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 54 |     | <span class='neutral'>            direction,</span>
 55 |     | <span class='neutral'>            output,</span>
 56 |     | <span class='unexecuted'>            direction ? 0 : type(uint128).max</span>
 57 |     | <span class='neutral'>        );</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        assertGt(start, finalOutput);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>    function testSwap_revert_PoolExpired() public allocateFirst {</span>
 63 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 64 |     | <span class='unexecuted'>        uint end = pool.params.createdAt + Assembly.convertDaysToSeconds(pool.params.duration);</span>
 65 |     | <span class='unexecuted'>        customWarp(end + 1);</span>
 66 |     | <span class='unexecuted'>        vm.expectRevert(PoolExpired.selector);</span>
 67 |     | <span class='unexecuted'>        __hyperTestingContract__.swap(defaultScenario.poolId, false, 10000, type(uint128).max);</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='unexecuted'>    function testSwap_revert_ZeroInput() public {</span>
 71 |     | <span class='unexecuted'>        vm.expectRevert(ZeroInput.selector);</span>
 72 |     | <span class='unexecuted'>        __hyperTestingContract__.swap(defaultScenario.poolId, true, 0, 0);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    /*</span>
 76 |     | <span class='neutral'>    function testSwap_revert_NonExistentPool() public {</span>
 77 |     | <span class='neutral'>        vm.expectRevert(NonExistentPool.selector);</span>
 78 |     | <span class='neutral'>        __hyperTestingContract__.swap(</span>
 79 |     | <span class='neutral'>            42,</span>
 80 |     | <span class='neutral'>            true,</span>
 81 |     | <span class='neutral'>            1,</span>
 82 |     | <span class='neutral'>            0</span>
 83 |     | <span class='neutral'>        );</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'>    */</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestHyperUnallocate.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestHyperSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestHyperUnallocate is TestHyperSetup {</span>
  7 |     | <span class='unexecuted'>    function testUnallocateUseMax() public postTestInvariantChecks {</span>
  8 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>        uint maxLiquidity = getPosition(address(__hyperTestingContract__), msg.sender, defaultScenario.poolId)</span>
 11 |     | <span class='neutral'>            .freeLiquidity;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>        __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint256).max);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>        assertEq(0, getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestPriceComputePrice.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestPriceSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestPriceComputePrice is TestPriceSetup {</span>
  7 |     | <span class='neutral'>    using Price for Price.RMM;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function testComputedPriceWithDefaultAssetReserve() public {</span>
 10 |     | <span class='unexecuted'>        uint actual = cases[0].getPriceWithX(DEFAULT_ASSET_RESERVE);</span>
 11 |     | <span class='unexecuted'>        uint err = 1e4; // TODO: Fix for error...</span>
 12 |     | <span class='unexecuted'>        assertTrue(actual &lt;= DEFAULT_PRICE + err &amp;&amp; actual &gt;= DEFAULT_PRICE - err);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // ===== Raw ===== //</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function testComputePriceWithZeroChangeInTauReturnsPrice() public {</span>
 18 |     | <span class='unexecuted'>        uint price = DEFAULT_PRICE;</span>
 19 |     | <span class='unexecuted'>        uint actual = cases[0].computePriceWithChangeInTau(price, 0);</span>
 20 |     | <span class='neutral'>        assertEq(actual, price);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function testComputePriceWithEpsilonEqualsTauReturnsStrike() public {</span>
 24 |     | <span class='unexecuted'>        Price.RMM memory info = cases[0];</span>
 25 |     | <span class='neutral'>        uint price = DEFAULT_PRICE;</span>
 26 |     | <span class='neutral'>        uint epsilon = info.tau;</span>
 27 |     | <span class='unexecuted'>        uint actual = info.computePriceWithChangeInTau(price, epsilon);</span>
 28 |     | <span class='unexecuted'>        assertEq(actual, info.strike);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function testFuzzComputePriceWithChangeInTau(uint32 epsilon) public {</span>
 32 |     | <span class='unexecuted'>        Price.RMM memory info = cases[0];</span>
 33 |     | <span class='neutral'>        // Fuzzing Filters</span>
 34 |     | <span class='unexecuted'>        vm.assume(epsilon &gt; 0); // Fuzzing non-zero test cases only.</span>
 35 |     | <span class='unexecuted'>        vm.assume(epsilon &lt; info.tau); // Epsilon &gt; tau is the same as epsilon == tau.</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>        // Behavior: as epsilon gets larger, tau gets smaller, price increases, reaches inflection, price tends to strike after inflection point.</span>
 38 |     | <span class='unexecuted'>        uint price = DEFAULT_PRICE;</span>
 39 |     | <span class='unexecuted'>        uint actual = info.computePriceWithChangeInTau(price, epsilon);</span>
 40 |     | <span class='unexecuted'>        uint actualDiff = actual - info.strike;</span>
 41 |     | <span class='unexecuted'>        uint expectedDiff = price - info.strike;</span>
 42 |     | <span class='unexecuted'>        assertTrue(actualDiff &gt; expectedDiff); // maybe? As tau gets smaller, price should increase until epsilon &gt;= tau.</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function testComputePriceWithEpsilonChangeEqualToTauReturnsPrice() public {</span>
 46 |     | <span class='unexecuted'>        uint price = DEFAULT_PRICE;</span>
 47 |     | <span class='unexecuted'>        uint actual = cases[0].computePriceWithChangeInTau(price, cases[0].tau);</span>
 48 |     | <span class='unexecuted'>        assertEq(actual, price);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestPriceComputeReserves.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestPriceSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestPriceComputeReserves is TestPriceSetup {</span>
  7 |     | <span class='neutral'>    using Price for Price.RMM;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function testComputedAssetReserveWithDefaultPrice() public {</span>
 10 |     | <span class='unexecuted'>        uint actual = cases[0].getXWithPrice(DEFAULT_PRICE);</span>
 11 |     | <span class='unexecuted'>        assertEq(actual, DEFAULT_ASSET_RESERVE);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    function testComputedQuoteReserveWithDefaultAssetReserve() public {</span>
 15 |     | <span class='unexecuted'>        uint actual = cases[0].getYWithX(DEFAULT_ASSET_RESERVE);</span>
 16 |     | <span class='unexecuted'>        assertEq(actual, DEFAULT_QUOTE_RESERVE);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function testComputedAssetReserveWithDefaultQuoteReserve() public {</span>
 20 |     | <span class='unexecuted'>        uint actual = cases[0].getXWithY(DEFAULT_QUOTE_RESERVE);</span>
 21 |     | <span class='neutral'>        assertEq(actual, DEFAULT_ASSET_RESERVE);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function testComputedReservesWithDefaultPrice() public {</span>
 25 |     | <span class='unexecuted'>        (uint actualQuoteReserve, uint actualAssetReserve) = cases[0].computeReserves(DEFAULT_PRICE);</span>
 26 |     | <span class='unexecuted'>        assertEq(actualQuoteReserve, DEFAULT_QUOTE_RESERVE);</span>
 27 |     | <span class='unexecuted'>        assertEq(actualAssetReserve, DEFAULT_ASSET_RESERVE);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestPriceInvariant.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestPriceSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestPriceInvariant is TestPriceSetup {</span>
  7 |     | <span class='neutral'>    using Price for Price.RMM;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function testInvariantReturnsZeroWithDefaultPool() public {</span>
 10 |     | <span class='unexecuted'>        int actual = cases[0].invariantOf(DEFAULT_QUOTE_RESERVE, DEFAULT_ASSET_RESERVE);</span>
 11 |     | <span class='unexecuted'>        assertEq(actual, 0);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/TestPriceUtils.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./setup/TestPriceSetup.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract TestPriceUtils is TestPriceSetup {</span>
  7 |     | <span class='neutral'>    // ===== Utils ===== //</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function testConvertPercentageReturnsOne() public {</span>
 10 |     | <span class='unexecuted'>        uint percentage = Price.PERCENTAGE;</span>
 11 |     | <span class='neutral'>        uint expected = Price.WAD;</span>
 12 |     | <span class='unexecuted'>        uint converted = Price.convertPercentageToWad(percentage);</span>
 13 |     | <span class='neutral'>        assertEq(converted, expected);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function testFuzzConvertPercentageReturnsComputedValue(uint percentage) public {</span>
 17 |     | <span class='unexecuted'>        vm.assume(percentage &lt; type(uint64).max);</span>
 18 |     | <span class='unexecuted'>        uint expected = (percentage * Price.WAD) / Price.PERCENTAGE;</span>
 19 |     | <span class='unexecuted'>        uint converted = Price.convertPercentageToWad(percentage);</span>
 20 |     | <span class='unexecuted'>        assertEq(converted, expected);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/setup/TestHyperSetup.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;solmate/tokens/WETH.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;solmate/utils/SafeCastLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;contracts/libraries/Price.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  10 |     | <span class='neutral'>import {TestERC20, Hyper, HyperTimeOverride, HyperCatchReverts, RevertCatcher, FixedPointMathLib} from &quot;test/helpers/HyperTestOverrides.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperActions.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperInvariants.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperProfiles.sol&quot;;</span>
  15 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperView.sol&quot;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>uint constant STARTING_BALANCE = 4000e18;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>struct TestScenario {</span>
  20 |     | <span class='neutral'>    TestERC20 asset;</span>
  21 |     | <span class='neutral'>    TestERC20 quote;</span>
  22 |     | <span class='neutral'>    uint64 poolId;</span>
  23 |     | <span class='neutral'>    string label;</span>
  24 |     | <span class='neutral'>}</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>/** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */</span>
  27 |     | <span class='neutral'>contract TestHyperSetup is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView, Test {</span>
  28 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  29 |     | <span class='neutral'>    using FixedPointMathLib for int256;</span>
  30 |     | <span class='neutral'>    using SafeCastLib for uint;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    WETH public __weth__;</span>
  33 |     | <span class='unexecuted'>    Hyper public __hyper__; // Actual contract</span>
  34 |     | <span class='unexecuted'>    HyperTimeOverride public __hyperTimeOverride__; // Inherits Hyper, adds block.timestamp and jit policy overrides</span>
  35 |     | <span class='unexecuted'>    HyperCatchReverts public __hyperTestingContract__; // Inherits HyperTimeOverrides, adds endpoints to process functions.</span>
  36 |     | <span class='unexecuted'>    RevertCatcher public __revertCatcher__;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    TestERC20 public __usdc__;</span>
  39 |     | <span class='unexecuted'>    TestERC20 public __token_8__;</span>
  40 |     | <span class='unexecuted'>    TestERC20 public __token_18__;</span>
  41 |     | <span class='unexecuted'>    TestERC20 public __badToken__;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    address[] public __contracts__;</span>
  44 |     | <span class='unexecuted'>    address[] public __users__;</span>
  45 |     | <span class='unexecuted'>    address[] public __tokens__;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    TestScenario public defaultScenario;</span>
  48 |     | <span class='unexecuted'>    TestScenario[] public scenarios;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    modifier postTestInvariantChecks() virtual {</span>
  51 |     | <span class='neutral'>        _;</span>
  52 |     | <span class='unexecuted'>        assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.asset), __users__);</span>
  53 |     | <span class='unexecuted'>        assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.quote), __users__);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function setUp() public {</span>
  57 |     | <span class='unexecuted'>        initContracts();</span>
  58 |     | <span class='unexecuted'>        initUsers();</span>
  59 |     | <span class='unexecuted'>        initScenarios();</span>
  60 |     | <span class='unexecuted'>        initPrerequisites();</span>
  61 |     | <span class='unexecuted'>        afterSetUp();</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function getState() public view returns (HyperState memory) {</span>
  65 |     | <span class='unexecuted'>        return getState(address(__hyperTestingContract__), defaultScenario.poolId, address(this), __users__);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /** Hook to override receive. Defaults to just accepting ether sent to this test contract. */</span>
  69 |     | <span class='neutral'>    receive() external payable {</span>
  70 |     | <span class='unexecuted'>        receiveOverride();</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /** @dev Hook to run after test setup. */</span>
  74 |     | <span class='unexecuted'>    function afterSetUp() public virtual {}</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function receiveOverride() public virtual {}</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function initContracts() internal {</span>
  79 |     | <span class='unexecuted'>        __weth__ = new WETH();</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // --- Hyper Contracts --- //</span>
  82 |     | <span class='unexecuted'>        __hyper__ = new Hyper(address(__weth__));</span>
  83 |     | <span class='unexecuted'>        __hyperTimeOverride__ = new HyperTimeOverride(address(__weth__));</span>
  84 |     | <span class='unexecuted'>        __hyperTestingContract__ = new HyperCatchReverts(address(__weth__));</span>
  85 |     | <span class='unexecuted'>        __revertCatcher__ = new RevertCatcher(address(__hyperTestingContract__));</span>
  86 |     | <span class='unexecuted'>        __contracts__.push(address(__hyper__));</span>
  87 |     | <span class='unexecuted'>        __contracts__.push(address(__hyperTimeOverride__));</span>
  88 |     | <span class='unexecuted'>        __contracts__.push(address(__hyperTestingContract__));</span>
  89 |     | <span class='unexecuted'>        __contracts__.push(address(__revertCatcher__));</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        __usdc__ = new TestERC20(&quot;USD Coin&quot;, &quot;USDC&quot;, 6);</span>
  92 |     | <span class='unexecuted'>        __token_8__ = new TestERC20(&quot;8 Decimals&quot;, &quot;8DEC&quot;, 8);</span>
  93 |     | <span class='unexecuted'>        __token_18__ = new TestERC20(&quot;18 Decimals&quot;, &quot;18DEC&quot;, 18);</span>
  94 |     | <span class='unexecuted'>        __badToken__ = new TestERC20(&quot;Non-standard ERC20&quot;, &quot;BAD&quot;, 18); // TODO: Add proper bad token.</span>
  95 |     | <span class='unexecuted'>        __tokens__.push(address(__usdc__));</span>
  96 |     | <span class='unexecuted'>        __tokens__.push(address(__token_8__));</span>
  97 |     | <span class='unexecuted'>        __tokens__.push(address(__token_18__));</span>
  98 |     | <span class='unexecuted'>        __tokens__.push(address(__badToken__));</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        setLabels();</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function initUsers() internal {</span>
 104 |     | <span class='unexecuted'>        address self = address(this);</span>
 105 |     | <span class='unexecuted'>        address alicent = address(0x0001);</span>
 106 |     | <span class='unexecuted'>        address boba = address(0x0002);</span>
 107 |     | <span class='unexecuted'>        address revertCatcher = address(__revertCatcher__);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        vm.label(self, &quot;Self&quot;);</span>
 110 |     | <span class='unexecuted'>        vm.label(alicent, &quot;Alicent&quot;);</span>
 111 |     | <span class='unexecuted'>        vm.label(boba, &quot;Boba&quot;);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        __users__.push(self);</span>
 114 |     | <span class='unexecuted'>        __users__.push(alicent);</span>
 115 |     | <span class='unexecuted'>        __users__.push(boba);</span>
 116 |     | <span class='unexecuted'>        __users__.push(revertCatcher);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function initScenarios() internal {</span>
 120 |     | <span class='unexecuted'>        __hyperTestingContract__.setTimestamp(uint128(block.timestamp)); // Important</span>
 121 |     | <span class='neutral'>        // Create default pool</span>
 122 |     | <span class='unexecuted'>        bytes memory data = createPool(</span>
 123 |     | <span class='unexecuted'>            address(__token_18__),</span>
 124 |     | <span class='unexecuted'>            address(__usdc__),</span>
 125 |     | <span class='neutral'>            address(0),</span>
 126 |     | <span class='unexecuted'>            uint16(1e4 - DEFAULT_PRIORITY_GAMMA),</span>
 127 |     | <span class='unexecuted'>            uint16(1e4 - DEFAULT_GAMMA),</span>
 128 |     | <span class='neutral'>            uint16(DEFAULT_SIGMA),</span>
 129 |     | <span class='neutral'>            uint16(DEFAULT_DURATION_DAYS),</span>
 130 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 131 |     | <span class='neutral'>            DEFAULT_TICK,</span>
 132 |     | <span class='neutral'>            DEFAULT_PRICE</span>
 133 |     | <span class='neutral'>        );</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        bool success = __revertCatcher__.jumpProcess(data);</span>
 136 |     | <span class='unexecuted'>        assertTrue(success, &quot;__revertCatcher__ call failed&quot;);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // Create default scenario and add to all scenarios.</span>
 139 |     | <span class='unexecuted'>        defaultScenario = TestScenario(__token_18__, __usdc__, FIRST_POOL, &quot;Default&quot;);</span>
 140 |     | <span class='unexecuted'>        scenarios.push(defaultScenario);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>    uint64 public constant FIRST_POOL = 0x0000010000000001;</span>
 144 |     | <span class='unexecuted'>    uint64 public constant SECOND_POOL_FIRST_PAIR = 0x0000010000000002;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /** @dev Requires tokens to be spent and spenders to be approved. */</span>
 147 |     | <span class='unexecuted'>    function initPrerequisites() internal {</span>
 148 |     | <span class='unexecuted'>        fundUsers();</span>
 149 |     | <span class='unexecuted'>        approveTokens();</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /** @dev Does not include weth. */</span>
 153 |     | <span class='unexecuted'>    function approveTokens() internal {</span>
 154 |     | <span class='unexecuted'>        for (uint x; x != __tokens__.length; ++x) {</span>
 155 |     | <span class='unexecuted'>            for (uint y; y != __contracts__.length; ++y) {</span>
 156 |     | <span class='unexecuted'>                for (uint z; z != __users__.length; ++z) {</span>
 157 |     | <span class='unexecuted'>                    vm.prank(__users__[z]); // Sets caller</span>
 158 |     | <span class='unexecuted'>                    TestERC20(__tokens__[x]).approve(__contracts__[y], type(uint256).max); // Approves test contracts to spend tokens.</span>
 159 |     | <span class='neutral'>                }</span>
 160 |     | <span class='neutral'>            }</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /** @dev Does not include weth. */</span>
 165 |     | <span class='unexecuted'>    function fundUsers() internal {</span>
 166 |     | <span class='unexecuted'>        for (uint i; i != __users__.length; ++i) {</span>
 167 |     | <span class='unexecuted'>            for (uint j; j != __tokens__.length; ++j) {</span>
 168 |     | <span class='unexecuted'>                deal(__tokens__[j], __users__[i], STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>    function setLabels() internal {</span>
 174 |     | <span class='unexecuted'>        vm.label(address(this), &quot;Self&quot;);</span>
 175 |     | <span class='unexecuted'>        vm.label(address(__weth__), &quot;Weth&quot;);</span>
 176 |     | <span class='unexecuted'>        vm.label(address(__revertCatcher__), &quot;RevertCatcher&quot;);</span>
 177 |     | <span class='unexecuted'>        vm.label(address(__hyper__), &quot;DefaultHyper&quot;);</span>
 178 |     | <span class='unexecuted'>        vm.label(address(__hyperTimeOverride__), &quot;HyperTimeOverride&quot;);</span>
 179 |     | <span class='unexecuted'>        vm.label(address(__hyperTestingContract__), &quot;HyperCatchReverts&quot;);</span>
 180 |     | <span class='unexecuted'>        vm.label(address(__usdc__), &quot;USDC&quot;);</span>
 181 |     | <span class='unexecuted'>        vm.label(address(__token_8__), &quot;Token8Decimals&quot;);</span>
 182 |     | <span class='unexecuted'>        vm.label(address(__token_18__), &quot;Token18Decimals&quot;);</span>
 183 |     | <span class='unexecuted'>        vm.label(address(__badToken__), &quot;BadToken&quot;);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>    function customWarp(uint time) internal {</span>
 187 |     | <span class='unexecuted'>        vm.warp(time);</span>
 188 |     | <span class='unexecuted'>        __hyperTestingContract__.setTimestamp(uint128(time));</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function createControlledPool() internal {</span>
 192 |     | <span class='unexecuted'>        bytes memory data = Enigma.encodeCreatePool(</span>
 193 |     | <span class='unexecuted'>            uint24(1), // first pair, is it good in this test?</span>
 194 |     | <span class='unexecuted'>            address(this),</span>
 195 |     | <span class='unexecuted'>            100,</span>
 196 |     | <span class='neutral'>            DEFAULT_FEE,</span>
 197 |     | <span class='neutral'>            DEFAULT_VOLATILITY,</span>
 198 |     | <span class='neutral'>            DEFAULT_DURATION,</span>
 199 |     | <span class='neutral'>            DEFAULT_JIT,</span>
 200 |     | <span class='neutral'>            DEFAULT_MAX_TICK,</span>
 201 |     | <span class='neutral'>            DEFAULT_PRICE</span>
 202 |     | <span class='neutral'>        );</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        bool success = __revertCatcher__.process(data);</span>
 205 |     | <span class='unexecuted'>        assertTrue(success, &quot;controlled pool not created&quot;);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        // assumes second pool has not been created...</span>
 208 |     | <span class='neutral'>        // can be fixed by getting pool nonce and encoding pool id.</span>
 209 |     | <span class='unexecuted'>        uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(__hyperTestingContract__.getPoolNonce()));</span>
 210 |     | <span class='unexecuted'>        scenarios.push(TestScenario(__token_18__, __usdc__, poolId, &quot;Controlled&quot;));</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>    function basicSwap() internal {</span>
 214 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 215 |     | <span class='unexecuted'>        (uint output, ) = __hyperTestingContract__.swap(</span>
 216 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 217 |     | <span class='neutral'>            true,</span>
 218 |     | <span class='unexecuted'>            (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether,</span>
 219 |     | <span class='unexecuted'>            1</span>
 220 |     | <span class='neutral'>        );</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>        assertTrue(output &gt; 0, &quot;no swap happened!&quot;);</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>    function _swap(uint64 id) internal {</span>
 226 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), id);</span>
 227 |     | <span class='unexecuted'>        (uint output, ) = __hyperTestingContract__.swap(id, true, (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether, 1);</span>
 228 |     | <span class='unexecuted'>        assertTrue(output &gt; 0, &quot;no swap happened!&quot;);</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function basicSwapQuoteIn() internal {</span>
 232 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 233 |     | <span class='unexecuted'>        (uint output, ) = __hyperTestingContract__.swap(</span>
 234 |     | <span class='unexecuted'>            defaultScenario.poolId,</span>
 235 |     | <span class='neutral'>            false,</span>
 236 |     | <span class='unexecuted'>            (pool.getMaxSwapQuoteInWad() * 1 ether) / 2 ether,</span>
 237 |     | <span class='neutral'>            type(uint256).max</span>
 238 |     | <span class='neutral'>        );</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>        assertTrue(output &gt; 0, &quot;no swap happened!&quot;);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>    function basicAllocate() internal {</span>
 244 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>    function _alloc(uint64 id) internal {</span>
 248 |     | <span class='unexecuted'>        __hyperTestingContract__.allocate(id, 1 ether);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function basicUnallocate() internal {</span>
 252 |     | <span class='unexecuted'>        __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint).max); // max</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>    function maxDraw() internal {</span>
 256 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(</span>
 257 |     | <span class='unexecuted'>            address(defaultScenario.asset),</span>
 258 |     | <span class='unexecuted'>            __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),</span>
 259 |     | <span class='unexecuted'>            address(this)</span>
 260 |     | <span class='neutral'>        );</span>
 261 |     | <span class='unexecuted'>        __hyperTestingContract__.draw(</span>
 262 |     | <span class='unexecuted'>            address(defaultScenario.quote),</span>
 263 |     | <span class='unexecuted'>            __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),</span>
 264 |     | <span class='unexecuted'>            address(this)</span>
 265 |     | <span class='neutral'>        );</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>    function defaultPool() internal view returns (HyperPool memory) {</span>
 269 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);</span>
 270 |     | <span class='neutral'>        return pool;</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>    function defaultRevertCatcherPosition() internal view returns (HyperPosition memory) {</span>
 274 |     | <span class='unexecuted'>        HyperPosition memory pos = getPosition(</span>
 275 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
 276 |     | <span class='unexecuted'>            address(__revertCatcher__),</span>
 277 |     | <span class='unexecuted'>            defaultScenario.poolId</span>
 278 |     | <span class='neutral'>        );</span>
 279 |     | <span class='neutral'>        return pos;</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>    function defaultPosition() internal view returns (HyperPosition memory) {</span>
 283 |     | <span class='unexecuted'>        HyperPosition memory pos = getPosition(</span>
 284 |     | <span class='unexecuted'>            address(__hyperTestingContract__),</span>
 285 |     | <span class='unexecuted'>            address(this),</span>
 286 |     | <span class='unexecuted'>            defaultScenario.poolId</span>
 287 |     | <span class='neutral'>        );</span>
 288 |     | <span class='neutral'>        return pos;</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    /** @dev Casted to returns structs as memory */</span>
 292 |     | <span class='unexecuted'>    function hs() internal view returns (IHyperStruct) {</span>
 293 |     | <span class='unexecuted'>        return IHyperStruct(address(__hyperTestingContract__));</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='unexecuted'>    function hx() internal view returns (HyperLike) {</span>
 297 |     | <span class='unexecuted'>        return HyperLike(address(__hyperTestingContract__));</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>}</span>
 300 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/foundry/setup/TestPriceSetup.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;contracts/libraries/Price.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;test/helpers/HelperHyperProfiles.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract TestPriceSetup is HelperHyperProfiles, Test {</span>
  9 |     | <span class='neutral'>    Price.RMM[] cases;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function setUp() public {</span>
 12 |     | <span class='unexecuted'>        addTestCase(DEFAULT_STRIKE, DEFAULT_SIGMA, DEFAULT_MATURITY);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function addTestCase(uint strike, uint sigma, uint tau) internal returns (Price.RMM memory) {</span>
 16 |     | <span class='unexecuted'>        Price.RMM memory info = Price.RMM(strike, sigma, tau);</span>
 17 |     | <span class='unexecuted'>        cases.push(info);</span>
 18 |     | <span class='neutral'>        return info;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/helpers/HelperHyperActions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;contracts/Enigma.sol&quot; as ProcessingLib;</span>
  5 |     | <span class='neutral'>import &quot;./HelperHyperProfiles.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract HelperHyperActions {</span>
  8 |     | <span class='neutral'>    /** @dev Encodes jump process for creating a pair + curve + pool in one tx. */</span>
  9 |     | <span class='unexecuted'>    function createPool(</span>
 10 |     | <span class='neutral'>        address token0,</span>
 11 |     | <span class='neutral'>        address token1,</span>
 12 |     | <span class='neutral'>        address controller,</span>
 13 |     | <span class='neutral'>        uint16 priorityFee,</span>
 14 |     | <span class='neutral'>        uint16 fee,</span>
 15 |     | <span class='neutral'>        uint16 volatility,</span>
 16 |     | <span class='neutral'>        uint16 duration,</span>
 17 |     | <span class='neutral'>        uint16 jit,</span>
 18 |     | <span class='neutral'>        int24 maxTick,</span>
 19 |     | <span class='neutral'>        uint128 price</span>
 20 |     | <span class='unexecuted'>    ) internal pure returns (bytes memory data) {</span>
 21 |     | <span class='unexecuted'>        bytes[] memory instructions = new bytes[](2);</span>
 22 |     | <span class='unexecuted'>        uint24 magicPoolId = 0x000000;</span>
 23 |     | <span class='unexecuted'>        instructions[0] = (ProcessingLib.encodeCreatePair(token0, token1));</span>
 24 |     | <span class='unexecuted'>        instructions[1] = (</span>
 25 |     | <span class='unexecuted'>            ProcessingLib.encodeCreatePool(</span>
 26 |     | <span class='unexecuted'>                magicPoolId, // magic variable</span>
 27 |     | <span class='unexecuted'>                controller,</span>
 28 |     | <span class='unexecuted'>                priorityFee,</span>
 29 |     | <span class='unexecuted'>                fee,</span>
 30 |     | <span class='unexecuted'>                volatility,</span>
 31 |     | <span class='unexecuted'>                duration,</span>
 32 |     | <span class='unexecuted'>                jit,</span>
 33 |     | <span class='unexecuted'>                maxTick,</span>
 34 |     | <span class='unexecuted'>                price</span>
 35 |     | <span class='neutral'>            )</span>
 36 |     | <span class='neutral'>        );</span>
 37 |     | <span class='unexecuted'>        data = ProcessingLib.encodeJumpInstruction(instructions);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function allocatePool(address hyper, uint64 poolId, uint amount) internal {</span>
 41 |     | <span class='unexecuted'>        bytes memory data = ProcessingLib.encodeAllocate(</span>
 42 |     | <span class='unexecuted'>            0, // useMax = false</span>
 43 |     | <span class='unexecuted'>            poolId,</span>
 44 |     | <span class='unexecuted'>            0x0, // amount multiplier = 10^0 = 1</span>
 45 |     | <span class='unexecuted'>            uint128(amount)</span>
 46 |     | <span class='neutral'>        );</span>
 47 |     | <span class='unexecuted'>        (bool success, ) = hyper.call{value: 0}(data);</span>
 48 |     | <span class='unexecuted'>        require(success, &quot;failed to allocate&quot;);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/helpers/HelperHyperInvariants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {HyperLike} from &quot;./HelperHyperView.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ERC20Like {</span>
  7 |     | <span class='neutral'>    function balanceOf(address) external view returns (uint);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='unexecuted'></span>
 10 |     | <span class='neutral'>contract HelperHyperInvariants {</span>
 11 |     | <span class='neutral'>    error SettlementInvariantInvalid(uint, uint);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function assertSettlementInvariant(</span>
 14 |     | <span class='neutral'>        address hyper,</span>
 15 |     | <span class='neutral'>        address token,</span>
 16 |     | <span class='neutral'>        address[] memory accounts</span>
 17 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 18 |     | <span class='unexecuted'>        uint reserve = HyperLike(hyper).getReserve(token);</span>
 19 |     | <span class='unexecuted'>        uint physical = ERC20Like(token).balanceOf(hyper);</span>
 20 |     | <span class='unexecuted'>        if (reserve &gt; physical) revert SettlementInvariantInvalid(physical, reserve);</span>
 21 |     | <span class='unexecuted'>        return true;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/helpers/HelperHyperProfiles.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>uint128 constant DEFAULT_STRIKE = 10e18;</span>
  5 |     | <span class='unexecuted'>uint24 constant DEFAULT_SIGMA = 1e4;</span>
  6 |     | <span class='unexecuted'>uint32 constant DEFAULT_MATURITY = 31556953; // adds 1</span>
  7 |     | <span class='unexecuted'>uint16 constant DEFAULT_FEE = 100; // 100 bps = 1%</span>
  8 |     | <span class='unexecuted'>uint32 constant DEFAULT_GAMMA = 9900;</span>
  9 |     | <span class='unexecuted'>uint32 constant DEFAULT_PRIORITY_GAMMA = 9950;</span>
 10 |     | <span class='unexecuted'>uint16 constant DEFAULT_DURATION_DAYS = 365;</span>
 11 |     | <span class='unexecuted'>uint128 constant DEFAULT_QUOTE_RESERVE = 3085375116376210650;</span>
 12 |     | <span class='unexecuted'>uint128 constant DEFAULT_ASSET_RESERVE = 308537516918601823; // 308596235182</span>
 13 |     | <span class='unexecuted'>uint128 constant DEFAULT_LIQUIDITY = 1e18;</span>
 14 |     | <span class='unexecuted'>uint128 constant DEFAULT_PRICE = 10e18;</span>
 15 |     | <span class='unexecuted'>int24 constant DEFAULT_TICK = int24(23027); // 10e18, rounded up! pay attention</span>
 16 |     | <span class='unexecuted'>uint constant DEFAULT_SWAP_INPUT = 0.1 ether;</span>
 17 |     | <span class='unexecuted'>uint constant DEFAULT_SWAP_OUTPUT = 97_627 wei;</span>
 18 |     | <span class='unexecuted'>uint16 constant DEFAULT_JIT = 4;</span>
 19 |     | <span class='unexecuted'>uint16 constant DEFAULT_VOLATILITY = 10_000;</span>
 20 |     | <span class='unexecuted'>uint16 constant DEFAULT_DURATION = 365;</span>
 21 |     | <span class='unexecuted'>int24 constant DEFAULT_MAX_TICK = int24(23027);</span>
 22 |     | <span class='unexecuted'></span>
 23 |     | <span class='neutral'>contract HelperHyperProfiles {}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/helpers/HelperHyperView.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;contracts/Enigma.sol&quot; as Processor;</span>
   5 |     | <span class='neutral'>import &quot;contracts/OS.sol&quot; as Operating;</span>
   6 |     | <span class='neutral'>import {HyperPair, HyperCurve, HyperPool, HyperPosition} from &quot;contracts/HyperLib.sol&quot;;</span>
   7 |     | <span class='neutral'>import {TestERC20} from &quot;contracts/test/TestERC20.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>interface IHyperStruct {</span>
  10 |     | <span class='neutral'>    function pairs(uint24 pairId) external view returns (HyperPair memory);</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    function positions(address owner, uint64 positionId) external view returns (HyperPosition memory);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    function pools(uint64 poolId) external view returns (HyperPool memory);</span>
  15 |     | <span class='neutral'>}</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>interface HyperLike {</span>
  18 |     | <span class='neutral'>    function getReserve(address) external view returns (uint);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function getBalance(address, address) external view returns (uint);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function getPairNonce() external view returns (uint16);</span>
  23 |     | <span class='neutral'>}</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>struct HyperState {</span>
  26 |     | <span class='neutral'>    uint reserveAsset; // getReserve</span>
  27 |     | <span class='neutral'>    uint reserveQuote; // getReserve</span>
  28 |     | <span class='neutral'>    uint physicalBalanceAsset; // balanceOf</span>
  29 |     | <span class='neutral'>    uint physicalBalanceQuote; // balanceOf</span>
  30 |     | <span class='neutral'>    uint totalBalanceAsset; // sum of all balances from getBalance</span>
  31 |     | <span class='neutral'>    uint totalBalanceQuote; // sum of all balances from getBalance</span>
  32 |     | <span class='neutral'>    uint totalPositionLiquidity; // sum of all position liquidity</span>
  33 |     | <span class='neutral'>    uint callerPositionLiquidity; // position.freeLiquidity</span>
  34 |     | <span class='neutral'>    uint totalPoolLiquidity; // pool.liquidity</span>
  35 |     | <span class='neutral'>    uint feeGrowthAssetPool; // getPool</span>
  36 |     | <span class='neutral'>    uint feeGrowthQuotePool; // getPool</span>
  37 |     | <span class='neutral'>    uint feeGrowthAssetPosition; // getPosition</span>
  38 |     | <span class='neutral'>    uint feeGrowthQuotePosition; // getPosition</span>
  39 |     | <span class='neutral'>}</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>interface TokenLike {</span>
  42 |     | <span class='neutral'>    function balanceOf(address) external view returns (uint);</span>
  43 |     | <span class='neutral'>}</span>
  44 |     | <span class='unexecuted'></span>
  45 |     | <span class='neutral'>contract HelperHyperView {</span>
  46 | *r  | <span class='executed'>    function getPool(address hyper, uint64 poolId) internal view returns (HyperPool memory) {</span>
  47 | *r  | <span class='executed'>        return IHyperStruct(hyper).pools(poolId);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    function getCurve(address hyper, uint64 poolId) internal view returns (HyperCurve memory) {</span>
  51 |     | <span class='unexecuted'>        HyperPool memory pool = getPool(hyper, poolId);</span>
  52 |     | <span class='unexecuted'>        return pool.params;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 | *r  | <span class='executed'>    function getPair(address hyper, uint24 pairId) internal view returns (HyperPair memory) {</span>
  56 | *r  | <span class='executed'>        return IHyperStruct(hyper).pairs(pairId);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 | r   | <span class='reverted'>    function getPosition(address hyper, address owner, uint64 positionId) internal view returns (HyperPosition memory) {</span>
  60 | r   | <span class='reverted'>        return IHyperStruct(hyper).positions(owner, positionId);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 | *r  | <span class='executed'>    function getReserve(address hyper, address token) internal view returns (uint) {</span>
  64 | *r  | <span class='executed'>        return HyperLike(hyper).getReserve(token);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 | *r  | <span class='executed'>    function getBalance(address hyper, address owner, address token) internal view returns (uint) {</span>
  68 | *r  | <span class='executed'>        return HyperLike(hyper).getBalance(owner, token);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>    function _getPool(IHyperStruct hyper, uint64 poolId) internal view returns (HyperPool memory) {</span>
  72 |     | <span class='unexecuted'>        return (hyper).pools(poolId);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function _getPosition(</span>
  76 |     | <span class='neutral'>        IHyperStruct hyper,</span>
  77 |     | <span class='neutral'>        address owner,</span>
  78 |     | <span class='neutral'>        uint64 positionId</span>
  79 |     | <span class='unexecuted'>    ) internal view returns (HyperPosition memory) {</span>
  80 |     | <span class='unexecuted'>        return hyper.positions(owner, positionId);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function _getReserve(HyperLike hyper, TestERC20 token) internal view returns (uint) {</span>
  84 |     | <span class='unexecuted'>        return hyper.getReserve(address(token));</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function _getBalance(HyperLike hyper, address owner, TestERC20 token) internal view returns (uint) {</span>
  88 |     | <span class='unexecuted'>        return hyper.getBalance(owner, address(token));</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /** @dev Fetches pool state and account state for a single pool&#39;s tokens. */</span>
  92 | *r  | <span class='executed'>    function getState(</span>
  93 |     | <span class='neutral'>        address hyper,</span>
  94 |     | <span class='neutral'>        uint64 poolId,</span>
  95 |     | <span class='neutral'>        address caller,</span>
  96 |     | <span class='neutral'>        address[] memory owners</span>
  97 | r   | <span class='reverted'>    ) internal view returns (HyperState memory) {</span>
  98 | r   | <span class='reverted'>        HyperPair memory pair = getPair(hyper, Processor.decodePairIdFromPoolId(poolId));</span>
  99 | r   | <span class='reverted'>        address asset = pair.tokenAsset;</span>
 100 | r   | <span class='reverted'>        address quote = pair.tokenQuote;</span>
 101 |     | <span class='neutral'></span>
 102 | r   | <span class='reverted'>        HyperPool memory pool = getPool(hyper, poolId);</span>
 103 | r   | <span class='reverted'>        HyperPosition memory position = getPosition(hyper, caller, poolId);</span>
 104 |     | <span class='neutral'></span>
 105 | r   | <span class='reverted'>        HyperState memory state = HyperState(</span>
 106 | r   | <span class='reverted'>            getReserve(hyper, asset),</span>
 107 | r   | <span class='reverted'>            getReserve(hyper, quote),</span>
 108 | r   | <span class='reverted'>            getPhysicalBalance(hyper, asset),</span>
 109 | r   | <span class='reverted'>            getPhysicalBalance(hyper, quote),</span>
 110 | r   | <span class='reverted'>            getBalanceSum(hyper, asset, owners),</span>
 111 | r   | <span class='reverted'>            getBalanceSum(hyper, quote, owners),</span>
 112 | r   | <span class='reverted'>            getPositionLiquiditySum(hyper, poolId, owners),</span>
 113 | r   | <span class='reverted'>            position.freeLiquidity,</span>
 114 | r   | <span class='reverted'>            pool.liquidity,</span>
 115 | r   | <span class='reverted'>            pool.feeGrowthGlobalAsset,</span>
 116 | r   | <span class='reverted'>            pool.feeGrowthGlobalQuote,</span>
 117 | r   | <span class='reverted'>            position.feeGrowthAssetLast,</span>
 118 | r   | <span class='reverted'>            position.feeGrowthQuoteLast</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 | r   | <span class='reverted'>        return state;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 | r   | <span class='reverted'>    function getPhysicalBalance(address hyper, address token) internal view returns (uint) {</span>
 125 | r   | <span class='reverted'>        return Operating.__balanceOf__(token, hyper);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    function getVirtualBalance(address hyper, address token, address[] memory owners) internal view returns (uint) {</span>
 129 |     | <span class='neutral'>        uint sum = getReserve(hyper, token) + getBalanceSum(hyper, token, owners);</span>
 130 |     | <span class='neutral'>        return sum;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 | r   | <span class='reverted'>    function getBalanceSum(address hyper, address token, address[] memory owners) internal view returns (uint) {</span>
 134 | r   | <span class='reverted'>        uint sum;</span>
 135 | r   | <span class='reverted'>        for (uint x; x != owners.length; ++x) {</span>
 136 | r   | <span class='reverted'>            sum += getBalance(hyper, owners[x], token);</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'></span>
 139 | r   | <span class='reverted'>        return sum;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 | r   | <span class='reverted'>    function getPositionLiquiditySum(address hyper, uint64 poolId, address[] memory owners) internal view returns (uint) {</span>
 143 | r   | <span class='reverted'>        uint sum;</span>
 144 | r   | <span class='reverted'>        for (uint i; i != owners.length; ++i) {</span>
 145 | r   | <span class='reverted'>            sum += getPosition(hyper, owners[i], poolId).freeLiquidity;</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>        return sum;</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>    function getMaxSwapLimit(bool sellAsset) internal pure returns (uint) {</span>
 152 |     | <span class='unexecuted'>        if (sellAsset) {</span>
 153 |     | <span class='neutral'>            // price goes down</span>
 154 |     | <span class='unexecuted'>            return 0;</span>
 155 |     | <span class='neutral'>        } else {</span>
 156 |     | <span class='neutral'>            // price goes up</span>
 157 |     | <span class='unexecuted'>            return type(uint).max;</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'>}</span>
 161 |     | <span class='neutral'></span>

</code>
<br />

<b>/root/code/hyper/test/helpers/HyperTestOverrides.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;contracts/Hyper.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;contracts/HyperLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;contracts/test/TestERC20.sol&quot;;</span>
   7 |     | <span class='unexecuted'></span>
   8 |     | <span class='neutral'>contract HyperTimeOverride is Hyper {</span>
   9 |     | <span class='unexecuted'>    constructor(address weth) Hyper(weth) {}</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    function _blockTimestamp() internal view override returns (uint128) {</span>
  12 |     | <span class='unexecuted'>        return uint128(timestamp);</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function _liquidityPolicy() internal view override returns (uint) {</span>
  16 |     | <span class='unexecuted'>        return jitDelay;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    // ===== Added ==== //</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    uint public timestamp;</span>
  22 |     | <span class='unexecuted'>    uint public jitDelay;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function setJitPolicy(uint delay) public {</span>
  25 |     | <span class='unexecuted'>        jitDelay = delay;</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function setTimestamp(uint128 time) public {</span>
  29 |     | <span class='unexecuted'>        timestamp = time;</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /** @dev Temp jump override for invariant tests. */</span>
  33 |     | <span class='unexecuted'>    function doJumpProcess(bytes calldata data) external payable lock interactions {</span>
  34 |     | <span class='unexecuted'>        Enigma._jumpProcess(data, super._process);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'>}</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>/** @dev To catch reverts, external functions can be called by a contract that has a try-cactch. */</span>
  39 |     | <span class='neutral'>contract HyperCatchReverts is HyperTimeOverride {</span>
  40 |     | <span class='unexecuted'>    constructor(address weth) HyperTimeOverride(weth) {}</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // ===== Added ===== //</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */</span>
  45 |     | <span class='unexecuted'>    function jumpProcess(bytes calldata data) external payable lock interactions {</span>
  46 |     | <span class='unexecuted'>        Enigma._jumpProcess(data, super._process);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */</span>
  50 |     | <span class='unexecuted'>    function process(bytes calldata data) external payable lock interactions {</span>
  51 |     | <span class='unexecuted'>        super._process(data);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /** @dev Solidity does not support error catching with the fallback function, so we use this external function. */</span>
  55 |     | <span class='unexecuted'>    function mockFallback(bytes calldata data) external payable lock interactions {</span>
  56 |     | <span class='unexecuted'>        if (data[0] != Enigma.INSTRUCTION_JUMP) super._process(data);</span>
  57 |     | <span class='unexecuted'>        else Enigma._jumpProcess(data, super._process);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'>}</span>
  60 |     | <span class='unexecuted'></span>
  61 |     | <span class='neutral'>contract RevertCatcher {</span>
  62 |     | <span class='unexecuted'>    HyperCatchReverts public hyper;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    constructor(address hyper_) {</span>
  65 |     | <span class='unexecuted'>        hyper = HyperCatchReverts(payable(hyper_));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    receive() external payable {}</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function approve(address token, address spender) external {</span>
  71 |     | <span class='unexecuted'>        TestERC20(token).approve(spender, type(uint256).max);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function mockFallback(bytes calldata data) external payable returns (bool) {</span>
  75 |     | <span class='unexecuted'>        try hyper.mockFallback{value: msg.value}(data) {} catch (bytes memory reason) {</span>
  76 |     | <span class='neutral'>            assembly {</span>
  77 |     | <span class='neutral'>                revert(add(32, reason), mload(reason))</span>
  78 |     | <span class='neutral'>            }</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='neutral'>        return true;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */</span>
  84 |     | <span class='unexecuted'>    function process(bytes calldata data) external payable returns (bool) {</span>
  85 |     | <span class='unexecuted'>        try hyper.process{value: msg.value}(data) {} catch (bytes memory reason) {</span>
  86 |     | <span class='neutral'>            assembly {</span>
  87 |     | <span class='neutral'>                revert(add(32, reason), mload(reason))</span>
  88 |     | <span class='neutral'>            }</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>        return true;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */</span>
  94 |     | <span class='unexecuted'>    function jumpProcess(bytes calldata data) external payable returns (bool) {</span>
  95 |     | <span class='unexecuted'>        try hyper.jumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {</span>
  96 |     | <span class='neutral'>            assembly {</span>
  97 |     | <span class='unexecuted'>                revert(add(32, reason), mload(reason))</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='unexecuted'>        return true;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'>}</span>
 103 |     | <span class='neutral'></span>

</code>
<br />

