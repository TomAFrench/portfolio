/root/code/hyper/contracts/Assembly.sol
   1 | *r  | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     | 
   8 |     |   Using yul to handle low-level coversions
   9 |     |   can easily be a foot shotgun.
  10 |     | 
  11 |     |   We like the gas reductions.
  12 |     | 
  13 |     |   -------------
  14 |     | 
  15 |     |   Primitive™
  16 |     | 
  17 |     |  */
  18 |     | 
  19 |     | error CastOverflow(uint);
  20 |     | error InvalidLiquidity();
  21 |     | 
  22 |     | uint constant SECONDS_PER_DAY = 86_400 seconds;
  23 | *   | uint8 constant MIN_DECIMALS = 6;
  24 | *r  | uint8 constant MAX_DECIMALS = 18;
  25 | *   | 
  26 | *   | function isBetween(uint256 value, uint256 lower, uint256 upper) pure returns (bool valid) {
  27 | *   |     return __between(int256(value), int256(lower), int256(upper));
  28 |     | }
  29 | *   | 
  30 | *   | function __between(int256 value, int256 lower, int256 upper) pure returns (bool valid) {
  31 |     |     assembly {
  32 |     |         // Is `val` btwn lo and hi, inclusive?
  33 | *   |         function isValid(val, lo, hi) -> btwn {
  34 | *   |             btwn := iszero(sgt(mul(sub(val, lo), sub(val, hi)), 0)) // iszero(x > amount ? 1 : 0) ? true : false, (n - a) * (n - b) <= 0, n = amount, a = lower, b = upper
  35 |     |         }
  36 |     | 
  37 | *   |         valid := isValid(value, lower, upper)
  38 |     |     }
  39 |     | }
  40 |     | 
  41 |     | /**
  42 |     | 
  43 |     |     @dev Reference:
  44 |     | 
  45 |     |     if (delta < 0) {
  46 |     |         output = input - uint128(-delta);
  47 |     |         if (output >= input) revert InvalidLiquidity();
  48 |     |     } else {
  49 |     |         output = input + uint128(delta);
  50 |     |         if (output < input) revert InvalidLiquidity();
  51 |     |     }
  52 | *r  | */
  53 |     | function addSignedDelta(uint128 input, int128 delta) pure returns (uint128 output) {
  54 | *r  |     bytes memory revertData = abi.encodeWithSelector(InvalidLiquidity.selector);
  55 |     |     assembly {
  56 | *r  |         output := add(input, delta)
  57 |     | 
  58 | *r  |         if gt(output, 0xffffffffffffffffffffffffffffffff) {
  59 | r   |             revert(add(32, revertData), mload(revertData)) // 0x1fff9681
  60 |     |         }
  61 |     |     }
  62 |     | }
  63 |     | 
  64 |     | function computeCheckpoint(uint256 present, uint256 delta) pure returns (uint256 checkpoint) {
  65 |     |     checkpoint = present;
  66 |     | 
  67 |     |     if (delta != 0) {
  68 |     |         // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.
  69 |     |         assembly {
  70 |     |             checkpoint := add(present, delta)
  71 |     |         }
  72 |     |     }
  73 |     | }
  74 | *r  | 
  75 |     | function computeCheckpointDistance(uint256 present, uint256 past) pure returns (uint256 distance) {
  76 |     |     // overflow by design, as these are checkpoints, which can measure the distance even if overflowed.
  77 |     |     assembly {
  78 | *r  |         distance := sub(present, past)
  79 |     |     }
  80 |     | }
  81 | *r  | 
  82 |     | function convertDaysToSeconds(uint amountDays) pure returns (uint amountSeconds) {
  83 |     |     assembly {
  84 | *r  |         amountSeconds := mul(amountDays, SECONDS_PER_DAY)
  85 |     |     }
  86 |     | }
  87 |     | 
  88 |     | function toBytes32(bytes memory raw) pure returns (bytes32 data) {
  89 |     |     assembly {
  90 |     |         data := mload(add(raw, 32))
  91 |     |         let shift := mul(sub(32, mload(raw)), 8)
  92 |     |         data := shr(shift, data)
  93 |     |     }
  94 |     | }
  95 | r   | 
  96 |     | function toBytes16(bytes memory raw) pure returns (bytes16 data) {
  97 |     |     assembly {
  98 | r   |         data := mload(add(raw, 32))
  99 | r   |         let shift := mul(sub(16, mload(raw)), 8)
 100 | r   |         data := shr(shift, data)
 101 |     |     }
 102 |     | }
 103 | *r  | 
 104 |     | function separate(bytes1 data) pure returns (bytes1 upper, bytes1 lower) {
 105 | *r  |     upper = data >> 4;
 106 | *r  |     lower = data & 0x0f;
 107 |     | }
 108 |     | 
 109 |     | function pack(bytes1 upper, bytes1 lower) pure returns (bytes1 data) {
 110 |     |     data = (upper << 4) | lower;
 111 |     | }
 112 |     | 
 113 |     | /**
 114 |     |  * @dev             Converts an array of bytes into an uint128, the array must adhere
 115 |     |  *                  to the the following format:
 116 |     |  *                  - First byte: Amount of trailing zeros.
 117 |     |  *                  - Rest of the array: A hexadecimal number.
 118 | *r  |  */
 119 | *r  | function toAmount(bytes calldata raw) pure returns (uint128 amount) {
 120 | r   |     uint8 power = uint8(raw[0]);
 121 | r   |     amount = uint128(toBytes16(raw[1:raw.length]));
 122 | *r  |     if (power != 0) amount = amount * uint128(10 ** power);
 123 |     | }
 124 | *r  | 
 125 | *r  | function computeScalar(uint decimals) pure returns (uint scalar) {
 126 | *r  |     return 10 ** (MAX_DECIMALS - decimals); // can revert on underflow
 127 |     | }
 128 | *r  | 
 129 | *r  | function scaleToWad(uint amountDec, uint decimals) pure returns (uint outputWad) {
 130 | *r  |     uint factor = computeScalar(decimals);
 131 |     |     assembly {
 132 | *r  |         outputWad := mul(amountDec, factor)
 133 |     |     }
 134 |     | }
 135 |     | 
 136 |     | function scaleFromWadUp(uint amountWad, uint decimals) pure returns (uint outputDec) {
 137 |     |     uint factor = computeScalar(decimals);
 138 |     |     assembly {
 139 |     |         outputDec := add(div(amountWad, factor), 1)
 140 |     |     }
 141 |     | }
 142 | *r  | 
 143 | *r  | function scaleFromWadDown(uint amountWad, uint decimals) pure returns (uint outputDec) {
 144 | *r  |     uint factor = computeScalar(decimals);
 145 |     |     assembly {
 146 | *r  |         outputDec := div(amountWad, factor)
 147 |     |     }
 148 |     | }
 149 |     | 
 150 |     | function scaleFromWadUpSigned(int amountWad, uint decimals) pure returns (int outputDec) {
 151 |     |     uint factor = computeScalar(decimals);
 152 |     |     assembly {
 153 |     |         outputDec := add(sdiv(amountWad, factor), 1)
 154 |     |     }
 155 |     | }
 156 |     | 
 157 |     | function scaleFromWadDownSigned(int amountWad, uint decimals) pure returns (int outputDec) {
 158 |     |     uint factor = computeScalar(decimals);
 159 |     |     assembly {
 160 |     |         outputDec := sdiv(amountWad, factor)
 161 |     |     }
 162 |     | }
 163 |     | 

/root/code/hyper/contracts/Enigma.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     |   
   8 |     |   This is called the Enigma, it's an alternative ABI.
   9 |     |   Originally, it was designed to compress calldata and therefore
  10 |     |   save gas on optimistic rollup networks.
  11 |     | 
  12 |     |   There are levels to the optimizations that can be made for it,
  13 |     |   but this one focuses on the alternative multicall: jump process.
  14 |     | 
  15 |     |   Multicalls will pad all calls to a full bytes32.
  16 |     |   This means two calls are at least 64 bytes.
  17 |     |   This alternative multicall can process over 10 calls in the same 64 bytes.
  18 |     |   The smallest bytes provided by a call is for allocate and unallocate, at 11 bytes.
  19 |     | 
  20 |     |   Multicalls also process transactions sequentially.
  21 |     |   State cannot be carried over transiently between transactions.
  22 |     |   With Enigma, we can transiently set state (only specific state),
  23 |     |   and use it across "instructions".
  24 |     | 
  25 |     |   Without jump instruction, this alternative encoding is overkill.
  26 |     | 
  27 |     |   Be aware of function selector hash collisions.
  28 |     |   Data is delivered via the `fallback` function.
  29 |     | 
  30 |     |   -------------
  31 |     | 
  32 |     |   Primitive™
  33 |     | 
  34 |     |  */
  35 |     | 
  36 |     | import "./Assembly.sol" as Assembly;
  37 |     | 
  38 |     | uint8 constant JUMP_PROCESS_START_POINTER = 2;
  39 |     | bytes1 constant UNKNOWN = 0x00;
  40 |     | bytes1 constant ALLOCATE = 0x01;
  41 |     | bytes1 constant UNSET00 = 0x02;
  42 |     | bytes1 constant UNALLOCATE = 0x03;
  43 |     | bytes1 constant UNSET01 = 0x04;
  44 |     | bytes1 constant SWAP = 0x05;
  45 |     | bytes1 constant STAKE_POSITION = 0x06;
  46 |     | bytes1 constant UNSTAKE_POSITION = 0x07;
  47 |     | bytes1 constant UNSET02 = 0x08;
  48 |     | bytes1 constant UNSET03 = 0x09;
  49 |     | bytes1 constant CREATE_POOL = 0x0B;
  50 |     | bytes1 constant CREATE_PAIR = 0x0C;
  51 |     | bytes1 constant UNSET04 = 0x0D;
  52 |     | bytes1 constant INSTRUCTION_JUMP = 0xAA;
  53 |     | 
  54 |     | error InvalidJump(uint256 pointer); // 0x80f63bd1
  55 |     | error InvalidBytesLength(uint256 expected, uint256 length); // 0xe19dc95e
  56 | *r  | 
  57 |     | function __startProcess__(function(bytes calldata) _process) {
  58 | *r  |     if (msg.data[0] != INSTRUCTION_JUMP) _process(msg.data);
  59 |     |     else _jumpProcess(msg.data, _process);
  60 |     | }
  61 |     | 
  62 |     | /** @dev  [jump instruction, instructions.length, pointer, ...instruction, pointer, ...etc] */
  63 |     | function _jumpProcess(bytes calldata data, function(bytes calldata) _process) {
  64 |     |     uint8 length = uint8(data[1]);
  65 |     |     uint8 pointer = JUMP_PROCESS_START_POINTER;
  66 |     |     uint256 start;
  67 |     |     // For each instruction set...
  68 |     |     for (uint256 i; i != length; ++i) {
  69 |     |         // Start at the index of the first byte of the next instruction.
  70 |     |         start = pointer;
  71 |     |         // Set the new pointer to the next instruction, located at the pointer.
  72 |     |         pointer = uint8(data[pointer]);
  73 |     |         // The `start:` includes the pointer byte, while the `:end` `pointer` is excluded.
  74 |     |         if (pointer > data.length) revert InvalidJump(pointer);
  75 |     |         bytes calldata instruction = data[start:pointer];
  76 |     |         // Process the instruction.
  77 |     |         _process(instruction[1:]); // note: Removes the pointer to the next instruction.
  78 |     |     }
  79 |     | }
  80 |     | 
  81 |     | function encodeJumpInstruction(bytes[] memory instructions) pure returns (bytes memory) {
  82 |     |     uint8 nextPointer;
  83 |     |     uint8 len = uint8(instructions.length);
  84 |     |     bytes memory payload = bytes.concat(INSTRUCTION_JUMP, bytes1(len));
  85 |     | 
  86 |     |     // for each instruction set...
  87 |     |     for (uint i; i != len; ++i) {
  88 |     |         bytes memory instruction = instructions[i];
  89 |     |         uint8 size = uint8(instruction.length);
  90 |     | 
  91 |     |         // Using instruction and index of instruction in list, we create a new array with a pointer to the next instruction in front of the instruction payload.
  92 |     |         if (i == 0) {
  93 |     |             nextPointer = size + 3; // [added0, instruction, added1, nextPointer]
  94 |     |         } else {
  95 |     |             nextPointer = nextPointer + size + 1; // [currentPointer, instruction, nextPointer]
  96 |     |         }
  97 |     | 
  98 |     |         bytes memory edited = bytes.concat(bytes1(nextPointer), instruction);
  99 |     |         payload = bytes.concat(payload, edited);
 100 |     |     }
 101 |     | 
 102 |     |     return payload;
 103 |     | }
 104 |     | 
 105 |     | function decodePairIdFromPoolId(uint64 poolId) pure returns (uint24) {
 106 | *r  |     return uint24(poolId >> 40);
 107 |     | }
 108 | *   | 
 109 | *   | function encodePoolId(uint24 pairId, bool isMutable, uint32 poolNonce) pure returns (uint64) {
 110 | *   |     return uint64(bytes8(abi.encodePacked(pairId, isMutable ? uint8(1) : uint8(0), poolNonce)));
 111 |     | }
 112 |     | 
 113 |     | function decodePoolId(
 114 |     |     bytes calldata data
 115 |     | ) pure returns (uint64 poolId, uint24 pairId, uint8 isMutable, uint32 poolNonce) {
 116 |     |     if (data.length != 8) revert InvalidBytesLength(8, data.length);
 117 |     |     poolId = uint64(bytes8(data));
 118 |     |     pairId = uint16(bytes2(data[:3]));
 119 |     |     isMutable = uint8(bytes1(data[3:4]));
 120 |     |     poolNonce = uint32(bytes4(data[4:]));
 121 |     | }
 122 | *   | 
 123 | *   | function encodeCreatePair(address token0, address token1) pure returns (bytes memory data) {
 124 | *   |     data = abi.encodePacked(CREATE_PAIR, token0, token1);
 125 |     | }
 126 | *   | 
 127 | *   | function decodeCreatePair(bytes calldata data) pure returns (address tokenAsset, address tokenQuote) {
 128 | *   |     if (data.length != 41) revert InvalidBytesLength(41, data.length);
 129 | *   |     tokenAsset = address(bytes20(data[1:21]));
 130 | *   |     tokenQuote = address(bytes20(data[21:]));
 131 |     | }
 132 | *   | 
 133 |     | function encodeCreatePool(
 134 |     |     uint24 pairId,
 135 |     |     address controller,
 136 |     |     uint16 priorityFee,
 137 |     |     uint16 fee,
 138 |     |     uint16 vol,
 139 |     |     uint16 dur,
 140 |     |     uint16 jit,
 141 |     |     int24 max,
 142 |     |     uint128 price
 143 | *   | ) pure returns (bytes memory data) {
 144 | *   |     data = abi.encodePacked(CREATE_POOL, pairId, controller, priorityFee, fee, vol, dur, jit, max, price);
 145 |     | }
 146 | *   | 
 147 |     | function decodeCreatePool(
 148 |     |     bytes calldata data
 149 |     | )
 150 |     |     pure
 151 |     |     returns (
 152 | *   |         uint24 pairId,
 153 |     |         address controller,
 154 |     |         uint16 priorityFee,
 155 |     |         uint16 fee,
 156 |     |         uint16 vol,
 157 |     |         uint16 dur,
 158 |     |         uint16 jit,
 159 |     |         int24 max,
 160 |     |         uint128 price
 161 |     |     )
 162 |     | {
 163 | *   |     if (data.length != 53) revert InvalidBytesLength(53, data.length);
 164 | *   |     pairId = uint24(bytes3(data[1:4]));
 165 | *   |     controller = address(bytes20(data[4:24]));
 166 | *   |     priorityFee = uint16(bytes2(data[24:26]));
 167 | *   |     fee = uint16(bytes2(data[26:28]));
 168 | *   |     vol = uint16(bytes2(data[28:30]));
 169 | *   |     dur = uint16(bytes2(data[30:32]));
 170 | *   |     jit = uint16(bytes2(data[32:34]));
 171 | *   |     max = int24(uint24(bytes3(data[34:37])));
 172 | *   |     price = uint128(bytes16(data[37:]));
 173 |     | }
 174 |     | 
 175 |     | function encodeAllocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {
 176 |     |     data = abi.encodePacked(Assembly.pack(bytes1(useMax), ALLOCATE), poolId, power, amount);
 177 |     | }
 178 | r   | 
 179 | r   | function decodeAllocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {
 180 | r   |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 181 |     |     (bytes1 maxFlag, ) = Assembly.separate(data[0]);
 182 |     |     useMax = uint8(maxFlag);
 183 |     |     poolId = uint64(bytes8(data[1:9]));
 184 | r   |     deltaLiquidity = Assembly.toAmount(data[9:]);
 185 |     | }
 186 |     | 
 187 |     | function encodeUnallocate(uint8 useMax, uint64 poolId, uint8 power, uint128 amount) pure returns (bytes memory data) {
 188 |     |     data = abi.encodePacked(Assembly.pack(bytes1(useMax), UNALLOCATE), poolId, power, amount);
 189 |     | }
 190 | *r  | 
 191 | r   | function decodeUnallocate(bytes calldata data) pure returns (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) {
 192 | r   |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 193 | r   |     useMax = uint8(data[0] >> 4);
 194 | r   |     poolId = uint64(bytes8(data[1:9]));
 195 | *r  |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
 196 |     | }
 197 |     | 
 198 |     | function encodeSwap(
 199 |     |     uint8 useMax,
 200 |     |     uint64 poolId,
 201 |     |     uint8 power0,
 202 |     |     uint128 amount0,
 203 |     |     uint8 power1,
 204 |     |     uint128 amount1,
 205 |     |     uint8 direction
 206 |     | ) pure returns (bytes memory data) {
 207 |     |     //    pointerToAmount1 = instruction, poolId, pointer, power0, amount0, power1 {pointer}->
 208 |     |     uint8 pointerToAmount1 = 0x01 + 0x08 + 0x01 + 0x10 + 0x01;
 209 |     |     data = abi.encodePacked(
 210 |     |         Assembly.pack(bytes1(useMax), SWAP),
 211 |     |         poolId,
 212 |     |         pointerToAmount1,
 213 |     |         power0,
 214 |     |         amount0,
 215 |     |         power1,
 216 |     |         amount1,
 217 |     |         direction
 218 |     |     );
 219 |     | }
 220 | r   | 
 221 |     | function decodeSwap(
 222 |     |     bytes calldata data
 223 | r   | ) pure returns (uint8 useMax, uint64 poolId, uint128 input, uint128 output, uint8 direction) {
 224 | r   |     useMax = uint8(data[0] >> 4);
 225 | r   |     poolId = uint64(bytes8(data[1:9]));
 226 |     |     uint8 pointer = uint8(data[9]);
 227 |     |     input = uint128(Assembly.toAmount(data[10:pointer]));
 228 |     |     output = uint128(Assembly.toAmount(data[pointer:data.length - 1]));
 229 |     |     direction = uint8(data[data.length - 1]);
 230 |     | }
 231 |     | 
 232 |     | function encodeStakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {
 233 |     |     data = abi.encodePacked(STAKE_POSITION, poolId, deltaLiquidity);
 234 |     | }
 235 | *r  | 
 236 | r   | function decodeStakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {
 237 | r   |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 238 |     |     poolId = uint64(bytes8(data[1:9]));
 239 | *r  |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
 240 |     | }
 241 |     | 
 242 |     | function encodeUnstakePosition(uint64 poolId, uint128 deltaLiquidity) pure returns (bytes memory data) {
 243 |     |     data = abi.encodePacked(UNSTAKE_POSITION, poolId, deltaLiquidity);
 244 |     | }
 245 |     | 
 246 |     | function decodeUnstakePosition(bytes calldata data) pure returns (uint64 poolId, uint128 deltaLiquidity) {
 247 |     |     if (data.length < 9) revert InvalidBytesLength(9, data.length);
 248 |     |     poolId = uint64(bytes8(data[1:9]));
 249 |     |     deltaLiquidity = uint128(Assembly.toAmount(data[9:]));
 250 |     | }
 251 |     | 

/root/code/hyper/contracts/Hyper.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   ------------------------------------
   7 |     | 
   8 |     |   Hyper is a replicating market maker.
   9 |     | 
  10 |     |   ------------------------------------
  11 |     | 
  12 |     |   Primitive™
  13 |     | 
  14 |     |  */
  15 |     | 
  16 |     | import "./HyperLib.sol";
  17 |     | import "./interfaces/IWETH.sol";
  18 |     | import "./interfaces/IHyper.sol";
  19 |     | import "./interfaces/IERC20.sol";
  20 | *r  | 
  21 |     | contract Hyper is IHyper {
  22 |     |     using Price for Price.RMM;
  23 |     |     using SafeCastLib for uint;
  24 |     |     using FixedPointMathLib for int256;
  25 |     |     using FixedPointMathLib for uint256;
  26 |     |     using {Assembly.isBetween} for uint8;
  27 |     |     using {Assembly.scaleFromWadDownSigned} for int;
  28 |     |     using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;
  29 |     | 
  30 | *r  |     function VERSION() public pure returns (string memory) {
  31 |     |         assembly {
  32 |     |             // Load 0x20 (32) in memory at slot 0x00, this corresponds to the
  33 |     |             // offset location of the next data.
  34 | *   |             mstore(0x00, 0x20)
  35 |     | 
  36 |     |             // Then we load both the length of our string (11 bytes, 0x0b in hex) and its
  37 |     |             // actual hex value (0x626574612d76302e312e30) using the offset 0x2b. Using this
  38 |     |             // particular offset value will right pad the length at the end of the slot
  39 |     |             // and left pad the string at the beginning of the next slot, assuring the
  40 |     |             // right ABI format to return a string.
  41 | *   |             mstore(0x2b, 0x0b626574612d76302e312e30) // "beta-v0.1.0"
  42 |     | 
  43 |     |             // Return all the 96 bytes (0x60) of data that was loaded into the memory.
  44 | *   |             return(0x00, 0x60)
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 | *r  |     OS.AccountSystem public __account__;
  49 |     | 
  50 | *r  |     address public immutable WETH;
  51 | *r  |     uint24 public getPairNonce;
  52 | *r  |     uint32 public getPoolNonce;
  53 |     | 
  54 | *r  |     mapping(uint24 => HyperPair) public pairs;
  55 | *r  |     mapping(uint64 => HyperPool) public pools;
  56 | *r  |     mapping(address => mapping(address => uint24)) public getPairId;
  57 | *r  |     mapping(address => mapping(uint64 => HyperPosition)) public positions;
  58 |     | 
  59 | *r  |     uint256 public locked = 1;
  60 |     |     Payment[] private _payments;
  61 |     |     SwapState private _state;
  62 |     | 
  63 |     |     modifier lock() {
  64 | *r  |         if (locked != 1) revert InvalidReentrancy();
  65 |     | 
  66 | *r  |         locked = 2;
  67 |     |         _;
  68 | *r  |         locked = 1;
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev
  73 |     |      * Used on external functions to handle settlement of outstanding token balances.
  74 |     |      *
  75 |     |      * @notice
  76 |     |      * Tokens sent to this contract are lost.
  77 |     |      *
  78 |     |      * @custom:guide
  79 |     |      * Step 1. Enter `locked` re-entrancy guard.
  80 |     |      * Step 2. Validate Hyper's account system has not already been entered.
  81 |     |      * Step 3. Wrap the entire ether balance of this contract and credit the wrapped ether to the msg.sender account.
  82 |     |      * Step 4. Enter the re-entrancy guard of Hyper's account system.
  83 |     |      * Step 5. Execute the function logic.
  84 |     |      * Step 6. Exit the re-entrancy guard of Hyper's account system.
  85 |     |      * Step 7. Enter the settlement function, requesting token payments or sending them out to msg.sender.
  86 |     |      * Step 8. Validate Hyper's account system was settled.
  87 |     |      * Step 9. Exit interactions modifier.
  88 |     |      * Step 10. Exit `locked` re-entrancy guard.
  89 |     |      */
  90 |     |     modifier interactions() {
  91 | *r  |         if (__account__.prepared) revert InvalidReentrancy();
  92 | *r  |         __account__.__wrapEther__(WETH); // Deposits msg.value ether, this contract receives WETH.
  93 | *r  |         __account__.prepared = false;
  94 |     |         _;
  95 | *r  |         __account__.prepared = true;
  96 |     | 
  97 | *r  |         _settlement();
  98 |     | 
  99 | *r  |         if (!__account__.settled) revert InvalidSettlement();
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev
 104 |     |      * Failing to pass a valid WETH contract that implements the `deposit()` function,
 105 |     |      * will cause all transactions with Hyper to fail once address(this).balance > 0.
 106 |     |      *
 107 |     |      * @notice
 108 |     |      * Tokens sent to this contract are lost.
 109 |     |      */
 110 |     |     constructor(address weth) {
 111 |     |         WETH = weth;
 112 |     |         __account__.settled = true;
 113 |     |     }
 114 |     | 
 115 |     |     receive() external payable {
 116 | *r  |         if (msg.sender != WETH) revert();
 117 |     |     }
 118 |     | 
 119 |     |     /**  @dev Alternative entrypoint to process operations using encoded calldata transferred directly as `msg.data`. */
 120 |     |     fallback() external payable lock interactions {
 121 | *r  |         Enigma.__startProcess__(_process);
 122 |     |     }
 123 |     | 
 124 |     |     /** @dev balanceOf(token) - getReserve(token). If negative, you win. */
 125 | *r  |     function getNetBalance(address token) public view returns (int256) {
 126 | *r  |         return __account__.getNetBalance(token, address(this));
 127 |     |     }
 128 |     | 
 129 |     |     /** @dev Virtual balance of `token`. */
 130 | *r  |     function getReserve(address token) public view returns (uint) {
 131 | *r  |         return __account__.reserves[token];
 132 |     |     }
 133 |     | 
 134 |     |     /** @dev Internal balance of `owner` of `token`. */
 135 | *r  |     function getBalance(address owner, address token) public view returns (uint) {
 136 | *r  |         return __account__.balances[owner][token];
 137 |     |     }
 138 |     | 
 139 |     |     /** @dev Transient stored tokens */
 140 | *r  |     function getWarm() public view returns (address[] memory warm) {
 141 | *   |         return __account__.warm;
 142 |     |     }
 143 |     | 
 144 |     |     // ===== Actions ===== //
 145 |     | 
 146 |     |     /// @inheritdoc IHyperActions
 147 | *r  |     function allocate(
 148 |     |         uint64 poolId,
 149 |     |         uint amount
 150 | *r  |     ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {
 151 | *r  |         bool useMax = amount == type(uint).max;
 152 | *r  |         (deltaAsset, deltaQuote) = _allocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());
 153 |     |     }
 154 |     | 
 155 |     |     /// @inheritdoc IHyperActions
 156 | r   |     function unallocate(
 157 |     |         uint64 poolId,
 158 |     |         uint amount
 159 | r   |     ) external lock interactions returns (uint deltaAsset, uint deltaQuote) {
 160 | r   |         bool useMax = amount == type(uint).max;
 161 | r   |         (deltaAsset, deltaQuote) = _unallocate(useMax, poolId, (useMax ? 1 : amount).safeCastTo128());
 162 |     |     }
 163 |     | 
 164 |     |     /// @inheritdoc IHyperActions
 165 | *r  |     function stake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {
 166 | *r  |         _stake(poolId, deltaLiquidity);
 167 |     |     }
 168 |     | 
 169 |     |     /// @inheritdoc IHyperActions
 170 | r   |     function unstake(uint64 poolId, uint128 deltaLiquidity) external lock interactions {
 171 | r   |         _unstake(poolId, deltaLiquidity);
 172 |     |     }
 173 |     | 
 174 |     |     /// @inheritdoc IHyperActions
 175 | *r  |     function swap(
 176 |     |         uint64 poolId,
 177 |     |         bool sellAsset,
 178 |     |         uint amount,
 179 |     |         uint limit
 180 | *r  |     ) external lock interactions returns (uint output, uint remainder) {
 181 | *r  |         if (limit == type(uint256).max) limit = type(uint128).max;
 182 | *r  |         bool useMax = amount == type(uint256).max; // magic variable.
 183 | *r  |         uint128 input = useMax ? type(uint128).max : amount.safeCastTo128();
 184 | *r  |         (, remainder, , output) = _swapExactIn(
 185 | *r  |             Order({
 186 | *r  |                 useMax: useMax ? 1 : 0,
 187 | *r  |                 poolId: poolId,
 188 | *r  |                 input: input,
 189 | *r  |                 output: limit.safeCastTo128(),
 190 | *r  |                 direction: sellAsset ? 0 : 1
 191 |     |             })
 192 |     |         );
 193 |     |     }
 194 |     | 
 195 |     |     /// @inheritdoc IHyperActions
 196 | *r  |     function draw(address token, uint256 amount, address to) external lock interactions {
 197 | *r  |         if (to == address(this)) revert InvalidTransfer(); // todo: Investigate attack vectors if this was not here.
 198 | *r  |         if (amount > getBalance(msg.sender, token)) revert DrawBalance();
 199 |     | 
 200 | *r  |         _applyDebit(token, amount);
 201 | *r  |         _decreaseReserves(token, amount);
 202 |     | 
 203 | *r  |         if (token == WETH) OS.__dangerousUnwrapEther__(WETH, to, amount);
 204 | *r  |         else OS.SafeTransferLib.safeTransfer(OS.ERC20(token), to, amount);
 205 |     |     }
 206 |     | 
 207 |     |     /// @inheritdoc IHyperActions
 208 | *r  |     function fund(address token, uint256 amount) external override lock interactions {
 209 | *r  |         __account__.dangerousFund(token, address(this), amount); // transferFrom(msg.sender)
 210 |     |     }
 211 |     | 
 212 |     |     /// @inheritdoc IHyperActions
 213 | *r  |     function deposit() external payable override lock interactions {
 214 | *r  |         if (msg.value == 0) revert ZeroValue();
 215 | *   |         emit Deposit(msg.sender, msg.value);
 216 |     |         // interactions modifier does the work.
 217 |     |     }
 218 |     | 
 219 | *r  |     function claim(uint64 poolId, uint deltaAsset, uint deltaQuote) external lock interactions {
 220 | r   |         HyperPool memory pool = pools[poolId];
 221 | r   |         HyperPosition storage pos = positions[msg.sender][poolId];
 222 | *r  |         if (pos.lastTimestamp == 0) revert NonExistentPosition(msg.sender, poolId);
 223 |     | 
 224 |     |         uint256 positionLiquidity = pos.freeLiquidity + pos.stakedLiquidity;
 225 |     |         pos.syncPositionFees(positionLiquidity, pool.feeGrowthGlobalAsset, pool.feeGrowthGlobalQuote);
 226 |     | 
 227 |     |         // 2^256 is a magic variable to claim the maximum amount of owed tokens after it has been synced.
 228 |     |         uint256 claimedAssets = deltaAsset == type(uint256).max ? pos.tokensOwedAsset : deltaAsset;
 229 |     |         uint256 claimedQuotes = deltaQuote == type(uint256).max ? pos.tokensOwedQuote : deltaQuote;
 230 |     | 
 231 |     |         pos.tokensOwedAsset -= claimedAssets.safeCastTo128();
 232 |     |         pos.tokensOwedQuote -= claimedQuotes.safeCastTo128();
 233 |     | 
 234 |     |         if (claimedAssets > 0) _applyCredit(pool.pair.tokenAsset, claimedAssets);
 235 |     |         if (claimedQuotes > 0) _applyCredit(pool.pair.tokenQuote, claimedQuotes);
 236 |     | 
 237 |     |         pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward);
 238 |     |         uint128 deltaReward = pos.tokensOwedReward;
 239 |     |         pos.tokensOwedReward -= deltaReward;
 240 |     | 
 241 |     |         // todo: a hack that utilizes Hyper contract as a fee bucket for priority swaps.
 242 |     |         // Currently uses WETH as the reward token. However, these priority fees
 243 |     |         // are paid based on liquidity.
 244 |     |         // If 1 WAD of liquidity is worth a small amount, the priority fee cost
 245 |     |         // a lot relative to the liquidity's value.
 246 |     |         // A better change is making this reward token configurable.
 247 |     |         if (deltaReward > 0) {
 248 |     |             _applyCredit(WETH, deltaReward); // gift to `msg.sender`.
 249 |     |             if (getBalance(address(this), WETH) < deltaReward) revert InvalidReward();
 250 |     |             __account__.debit(address(this), WETH, deltaReward); // only place hyper's balance is used
 251 |     |         }
 252 |     | 
 253 |     |         emit Collect(
 254 |     |             poolId,
 255 |     |             msg.sender,
 256 |     |             claimedAssets,
 257 |     |             pool.pair.tokenAsset,
 258 |     |             claimedQuotes,
 259 |     |             pool.pair.tokenQuote,
 260 |     |             deltaReward,
 261 |     |             WETH
 262 |     |         );
 263 |     |     }
 264 |     | 
 265 |     |     // ===== Effects ===== //
 266 |     | 
 267 |     |     /** @dev Increases virtal reserves and liquidity. Debits `msg.sender`. */
 268 | *r  |     function _allocate(
 269 |     |         bool useMax,
 270 |     |         uint64 poolId,
 271 |     |         uint128 deltaLiquidity
 272 | *r  |     ) internal returns (uint256 deltaAsset, uint256 deltaQuote) {
 273 | *r  |         HyperPool memory pool = pools[poolId];
 274 | *r  |         if (!pool.exists()) revert NonExistentPool(poolId);
 275 |     | 
 276 | *r  |         if (useMax) {
 277 |     |             deltaLiquidity = pool.getMaxLiquidity({
 278 |     |                 deltaAsset: getBalance(msg.sender, pool.pair.tokenAsset),
 279 |     |                 deltaQuote: getBalance(msg.sender, pool.pair.tokenQuote)
 280 |     |             });
 281 |     |         }
 282 |     | 
 283 | *r  |         if (deltaLiquidity == 0) revert ZeroLiquidity();
 284 | *r  |         (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(toInt128(deltaLiquidity)); // note: rounds up.
 285 |     | 
 286 | *r  |         ChangeLiquidityParams memory args = ChangeLiquidityParams({
 287 | *r  |             owner: msg.sender,
 288 |     |             poolId: poolId,
 289 |     |             timestamp: _blockTimestamp(),
 290 | *r  |             deltaAsset: deltaAsset,
 291 | *r  |             deltaQuote: deltaQuote,
 292 | *r  |             tokenAsset: pool.pair.tokenAsset,
 293 | *r  |             tokenQuote: pool.pair.tokenQuote,
 294 | *r  |             deltaLiquidity: toInt128(deltaLiquidity)
 295 |     |         });
 296 |     | 
 297 | *r  |         _changeLiquidity(args);
 298 | *r  |         emit Allocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);
 299 |     |     }
 300 |     | 
 301 |     |     /** @dev Reduces virtual reserves and liquidity. Credits `msg.sender`. */
 302 | r   |     function _unallocate(
 303 |     |         bool useMax,
 304 |     |         uint64 poolId,
 305 |     |         uint128 deltaLiquidity
 306 | r   |     ) internal returns (uint deltaAsset, uint deltaQuote) {
 307 | r   |         if (useMax) deltaLiquidity = positions[msg.sender][poolId].freeLiquidity;
 308 | r   |         if (deltaLiquidity == 0) revert ZeroLiquidity();
 309 |     | 
 310 | r   |         HyperPool memory pool = pools[poolId];
 311 | r   |         if (!pool.exists()) revert NonExistentPool(poolId);
 312 |     | 
 313 | r   |         (deltaAsset, deltaQuote) = pool.getLiquidityDeltas(-toInt128(deltaLiquidity)); // rounds down
 314 |     | 
 315 | r   |         ChangeLiquidityParams memory args = ChangeLiquidityParams({
 316 | r   |             owner: msg.sender,
 317 |     |             poolId: poolId,
 318 |     |             timestamp: _blockTimestamp(),
 319 | r   |             deltaAsset: deltaAsset,
 320 | r   |             deltaQuote: deltaQuote,
 321 | r   |             tokenAsset: pool.pair.tokenAsset,
 322 | r   |             tokenQuote: pool.pair.tokenQuote,
 323 | r   |             deltaLiquidity: -toInt128(deltaLiquidity)
 324 |     |         });
 325 |     | 
 326 | r   |         _changeLiquidity(args);
 327 |     |         emit Unallocate(poolId, pool.pair.tokenAsset, pool.pair.tokenQuote, deltaAsset, deltaQuote, deltaLiquidity);
 328 |     |     }
 329 |     | 
 330 | *r  |     function _changeLiquidity(ChangeLiquidityParams memory args) internal returns (uint feeAsset, uint feeQuote) {
 331 | *r  |         (HyperPool storage pool, HyperPosition storage pos) = (pools[args.poolId], positions[args.owner][args.poolId]);
 332 |     | 
 333 |     |         // Positions are broken up into "free" and "staked" liquidity buckets.
 334 |     |         // The pool accrues fees to the sum of these buckets, so the same fees are earned
 335 |     |         // for a position with 2 free and 0 staked as a position with 1 free and 1 staked.
 336 |     |         // The purpose for staking is to access a new fee bucket, the "reward", in addition
 337 |     |         // to the standard bucket.
 338 | *r  |         uint256 positionLiquidity = pos.freeLiquidity + pos.stakedLiquidity;
 339 | *r  |         (feeAsset, feeQuote) = pos.syncPositionFees(
 340 | *r  |             positionLiquidity,
 341 | *r  |             pool.feeGrowthGlobalAsset,
 342 | *r  |             pool.feeGrowthGlobalQuote
 343 |     |         );
 344 |     | 
 345 | *r  |         _changePosition(args);
 346 |     |     }
 347 |     | 
 348 |     |     /** @dev Changes position liquidity and timestamp. */
 349 | *r  |     function _changePosition(ChangeLiquidityParams memory args) internal {
 350 | *r  |         HyperPosition storage position = positions[args.owner][args.poolId];
 351 |     | 
 352 | *r  |         if (args.deltaLiquidity < 0) {
 353 | r   |             uint distance = position.getTimeSinceChanged(_blockTimestamp());
 354 | r   |             if (pools[args.poolId].params.jit > distance) revert JitLiquidity(distance);
 355 |     |         }
 356 |     | 
 357 | *r  |         position.changePositionLiquidity(args.timestamp, args.deltaLiquidity);
 358 |     | 
 359 | *r  |         _changePool(args);
 360 |     |     }
 361 |     | 
 362 |     |     /** @dev Changes virtual reserves and pool liquidity. Does not update timestamp of pool. */
 363 | *r  |     function _changePool(ChangeLiquidityParams memory args) internal {
 364 | *r  |         (address asset, address quote) = (args.tokenAsset, args.tokenQuote);
 365 |     | 
 366 | *r  |         pools[args.poolId].changePoolLiquidity(args.deltaLiquidity);
 367 |     | 
 368 | *r  |         if (args.deltaLiquidity < 0) {
 369 |     |             _decreaseReserves(asset, args.deltaAsset);
 370 |     |             _decreaseReserves(quote, args.deltaQuote);
 371 |     |         } else {
 372 |     |             // note: Reserves are used at the end of instruction processing to interactions transactions.
 373 | *r  |             _increaseReserves(asset, args.deltaAsset);
 374 | *r  |             _increaseReserves(quote, args.deltaQuote);
 375 |     |         }
 376 |     |     }
 377 |     | 
 378 | r   |     function _stake(uint64 poolId, uint128 deltaLiquidity) internal {
 379 | r   |         HyperPool storage pool = pools[poolId];
 380 | r   |         if (!pool.exists()) revert NonExistentPool(poolId);
 381 |     | 
 382 |     |         HyperPosition memory pos = positions[msg.sender][poolId];
 383 |     |         if (deltaLiquidity == 0) revert ZeroLiquidity();
 384 |     |         if (pos.freeLiquidity < deltaLiquidity) revert InsufficientPosition(poolId);
 385 |     | 
 386 |     |         uint feeEarned = _changeStake(poolId, toInt128(deltaLiquidity));
 387 |     |         pool.stakedLiquidityDelta += toInt128(deltaLiquidity);
 388 |     |         emit Stake(poolId, msg.sender, deltaLiquidity);
 389 |     |     }
 390 |     | 
 391 | r   |     function _unstake(uint64 poolId, uint128 deltaLiquidity) internal returns (uint feeEarned) {
 392 | r   |         HyperPool storage pool = pools[poolId];
 393 | r   |         if (!pool.exists()) revert NonExistentPool(poolId);
 394 |     | 
 395 | r   |         uint timestamp = _blockTimestamp();
 396 | r   |         HyperPosition memory pos = positions[msg.sender][poolId];
 397 | r   |         if (pos.stakeTimestamp == 0) revert PositionNotStaked(poolId);
 398 |     |         if (pos.unstakeTimestamp > timestamp) revert StakeNotMature(poolId); // todo: Investigate if its okay to unstake whenever.
 399 |     | 
 400 |     |         feeEarned = _changeStake(poolId, -toInt128(deltaLiquidity));
 401 |     |         pool.stakedLiquidityDelta -= toInt128(deltaLiquidity);
 402 |     |         emit Unstake(poolId, msg.sender, deltaLiquidity);
 403 |     |     }
 404 |     | 
 405 |     |     function _changeStake(uint64 poolId, int128 deltaLiquidity) internal returns (uint feeEarned) {
 406 |     |         uint timestamp = _blockTimestamp();
 407 |     |         HyperPool memory pool = pools[poolId];
 408 |     |         HyperPosition storage pos = positions[msg.sender][poolId];
 409 |     |         if (pos.stakeTimestamp == 0) pos.stakeTimestamp = timestamp.safeCastTo32();
 410 |     |         if (pos.unstakeTimestamp == 0) pos.unstakeTimestamp = pool.params.maturity();
 411 |     | 
 412 |     |         feeEarned = pos.syncPositionStakedFees(pool.stakedLiquidity, pool.feeGrowthGlobalReward); // must apply before liquidity changes.
 413 |     |         pos.changePositionLiquidity(timestamp, -deltaLiquidity);
 414 |     |         pos.stakedLiquidity = Assembly.addSignedDelta(pos.stakedLiquidity, deltaLiquidity);
 415 |     |     }
 416 |     | 
 417 |     |     // ===== Swaps ===== //
 418 |     | 
 419 | *r  |     function _swapExactIn(
 420 |     |         Order memory args
 421 | *r  |     ) internal returns (uint64 poolId, uint256 remainder, uint256 input, uint256 output) {
 422 | *r  |         if (args.input == 0) revert ZeroInput();
 423 |     | 
 424 | *r  |         uint limitPrice = args.output;
 425 | *r  |         bool sellAsset = args.direction == 0;
 426 |     | 
 427 | *r  |         HyperPool memory pool = pools[args.poolId];
 428 | *r  |         if (args.useMax == 0) {
 429 | *r  |             input = args.input;
 430 | r   |         } else {
 431 | r   |             address tokenInput = sellAsset ? pool.pair.tokenAsset : pool.pair.tokenQuote;
 432 | r   |             input = getBalance(msg.sender, tokenInput);
 433 |     |         }
 434 |     | 
 435 | *r  |         uint256 passed = getTimePassed(args.poolId);
 436 | *r  |         (output, ) = pool.getAmountOut(sellAsset, input, passed);
 437 |     | 
 438 |     |         args.input = input.safeCastTo128();
 439 |     |         args.output = output.safeCastTo128();
 440 |     | 
 441 |     |         (poolId, remainder, input, output) = _swap(args);
 442 |     | 
 443 |     |         uint nextPrice = pools[args.poolId].lastPrice;
 444 |     |         if (!sellAsset && nextPrice > limitPrice) revert SwapLimitReached();
 445 |     |         if (sellAsset && limitPrice > nextPrice) revert SwapLimitReached();
 446 |     |     }
 447 |     | 
 448 |     |     /** @dev Swaps in direction (0 or 1) input of tokens (0 = asset, 1 = quote) for output of tokens (0 = quote, 1 = asset). */
 449 |     |     function _swap(
 450 |     |         Order memory args
 451 |     |     ) internal returns (uint64 poolId, uint256 remainder, uint256 input, uint256 output) {
 452 |     |         if (args.input == 0) revert ZeroInput();
 453 |     | 
 454 |     |         HyperPool storage pool = pools[args.poolId];
 455 |     |         if (!pool.exists()) revert NonExistentPool(args.poolId);
 456 |     | 
 457 |     |         _state.sell = args.direction == 0; // 0: asset -> quote, 1: quote -> asset
 458 |     |         _state.fee = msg.sender == pool.controller ? pool.params.priorityFee : uint(pool.params.fee);
 459 |     |         _state.feeGrowthGlobal = _state.sell ? pool.feeGrowthGlobalAsset : pool.feeGrowthGlobalQuote;
 460 |     |         _state.tokenInput = _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote;
 461 |     |         _state.tokenOutput = _state.sell ? pool.pair.tokenQuote : pool.pair.tokenAsset;
 462 |     | 
 463 |     |         Price.RMM memory rmm = Price.RMM({strike: pool.params.strike(), sigma: pool.params.volatility, tau: 0});
 464 |     |         Iteration memory _swap;
 465 |     |         {
 466 |     |             (uint256 price, int24 tick, uint updatedTau) = _computeSyncedPrice(args.poolId);
 467 |     |             rmm.tau = updatedTau;
 468 |     | 
 469 |     |             uint internalBalance = getBalance(msg.sender, _state.sell ? pool.pair.tokenAsset : pool.pair.tokenQuote);
 470 |     |             remainder = args.useMax == 1 ? internalBalance : args.input;
 471 |     |             remainder = remainder.scaleToWad(_state.sell ? pool.pair.decimalsAsset : pool.pair.decimalsQuote);
 472 |     |             output = args.output;
 473 |     |             output = output.scaleToWad(_state.sell ? pool.pair.decimalsQuote : pool.pair.decimalsAsset);
 474 |     | 
 475 |     |             // Keeps WAD values
 476 |     |             _swap = Iteration({
 477 |     |                 price: price,
 478 |     |                 tick: tick,
 479 |     |                 feeAmount: 0,
 480 |     |                 remainder: remainder,
 481 |     |                 liquidity: pool.liquidity,
 482 |     |                 input: 0,
 483 |     |                 output: output
 484 |     |             });
 485 |     |         }
 486 |     | 
 487 |     |         if (rmm.tau == 0) revert PoolExpired();
 488 |     |         if (_swap.output == 0) revert ZeroOutput();
 489 |     |         if (_swap.remainder == 0) revert ZeroInput();
 490 |     |         if (_swap.liquidity == 0) revert ZeroLiquidity();
 491 |     | 
 492 |     |         // =---= Effects =---= //
 493 |     | 
 494 |     |         // These are WAD values.
 495 |     |         uint256 liveIndependent;
 496 |     |         uint256 nextIndependent;
 497 |     |         uint256 liveDependent;
 498 |     |         uint256 nextDependent;
 499 |     |         uint256 priorityFeeAmount;
 500 |     | 
 501 |     |         {
 502 |     |             uint256 maxInput;
 503 |     |             uint256 deltaInput;
 504 |     |             uint256 deltaInputLessFee;
 505 |     |             uint256 deltaOutput = _swap.output;
 506 |     | 
 507 |     |             // Virtual reserves
 508 |     |             if (_state.sell) {
 509 |     |                 (liveDependent, liveIndependent) = rmm.computeReserves(_swap.price);
 510 | *r  |                 maxInput = (FixedPointMathLib.WAD - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.
 511 |     |             } else {
 512 |     |                 (liveIndependent, liveDependent) = rmm.computeReserves(_swap.price);
 513 |     |                 maxInput = (rmm.strike - liveIndependent).mulWadDown(_swap.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.
 514 |     |             }
 515 |     | 
 516 |     |             priorityFeeAmount = msg.sender == pool.controller ? (pool.liquidity * _state.fee) / 10_000 : 0;
 517 |     |             _swap.feeAmount = priorityFeeAmount != 0
 518 |     |                 ? 0
 519 |     |                 : ((_swap.remainder > maxInput ? maxInput : _swap.remainder) * _state.fee) / 10_000;
 520 |     |             _state.feeGrowthGlobal = FixedPointMathLib.divWadDown(_swap.feeAmount, _swap.liquidity);
 521 |     |             if (priorityFeeAmount != 0) _state.priorityFeeGrowthGlobal = priorityFeeAmount.divWadDown(_swap.liquidity); // todo: change to staked liquidity
 522 |     | 
 523 |     |             deltaInput = _swap.remainder > maxInput ? maxInput : _swap.remainder; // swaps up to the maximum input
 524 |     |             deltaInputLessFee = deltaInput - _swap.feeAmount;
 525 |     | 
 526 |     |             nextIndependent = liveIndependent + deltaInputLessFee.divWadDown(_swap.liquidity);
 527 |     |             nextDependent = liveDependent - deltaOutput.divWadDown(_swap.liquidity);
 528 |     | 
 529 |     |             _swap.remainder -= deltaInput;
 530 |     |             _swap.input += deltaInput;
 531 |     |         }
 532 |     | 
 533 |     |         {
 534 |     |             uint256 nextPrice;
 535 |     |             int256 liveInvariantWad;
 536 |     |             int256 nextInvariantWad;
 537 |     | 
 538 |     |             if (_state.sell) {
 539 |     |                 liveInvariantWad = rmm.invariantOf(liveDependent, liveIndependent);
 540 |     |                 nextInvariantWad = rmm.invariantOf(nextDependent, nextIndependent);
 541 |     |                 nextPrice = rmm.getPriceWithX(nextIndependent);
 542 |     |             } else {
 543 |     |                 liveInvariantWad = rmm.invariantOf(liveIndependent, liveDependent);
 544 |     |                 nextInvariantWad = rmm.invariantOf(nextIndependent, nextDependent);
 545 |     |                 nextPrice = rmm.getPriceWithX(nextDependent);
 546 |     |             }
 547 |     | 
 548 |     |             liveInvariantWad = liveInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote); // invariant is denominated in quote token.
 549 |     |             nextInvariantWad = nextInvariantWad.scaleFromWadDownSigned(pool.pair.decimalsQuote);
 550 |     |             if (nextInvariantWad < liveInvariantWad) revert InvalidInvariant(liveInvariantWad, nextInvariantWad);
 551 |     | 
 552 |     |             _swap.price = (nextPrice * (0.001 ether + 1)) / 0.001 ether;
 553 |     |         }
 554 |     | 
 555 |     |         {
 556 |     |             uint inputDec;
 557 |     |             uint outputDec;
 558 |     |             if (_state.sell) {
 559 |     |                 inputDec = pool.pair.decimalsAsset;
 560 |     |                 outputDec = pool.pair.decimalsQuote;
 561 |     |             } else {
 562 |     |                 inputDec = pool.pair.decimalsQuote;
 563 |     |                 outputDec = pool.pair.decimalsAsset;
 564 |     |             }
 565 |     | 
 566 |     |             _swap.input = _swap.input.scaleFromWadDown(inputDec);
 567 |     |             _swap.output = _swap.output.scaleFromWadDown(outputDec);
 568 |     |         }
 569 |     | 
 570 |     |         // Apply pool effects.
 571 |     |         _syncPool(
 572 |     |             args.poolId,
 573 |     |             Price.computeTickWithPrice(_swap.price),
 574 |     |             _swap.price,
 575 |     |             _swap.liquidity,
 576 |     |             _state.sell ? _state.feeGrowthGlobal : 0,
 577 |     |             _state.sell ? 0 : _state.feeGrowthGlobal,
 578 |     |             _state.priorityFeeGrowthGlobal
 579 |     |         );
 580 |     | 
 581 |     |         _increaseReserves(_state.tokenInput, _swap.input);
 582 |     |         _decreaseReserves(_state.tokenOutput, _swap.output);
 583 |     | 
 584 |     |         // Apply reserve effects.
 585 |     |         if (priorityFeeAmount != 0) {
 586 |     |             // Uses hyper's internal balance as a fee bucket for priority swaps.
 587 |     |             // todo: investigate two different pools accruing priority rewards in the same bucket,
 588 |     |             // and if it's possible to "steal" another pool's accrued priority rewards.
 589 |     |             _increaseReserves(WETH, priorityFeeAmount);
 590 |     |             emit IncreaseUserBalance(address(this), WETH, priorityFeeAmount);
 591 |     |             __account__.credit(address(this), WETH, priorityFeeAmount);
 592 |     |         }
 593 |     | 
 594 |     |         emit Swap(args.poolId, _swap.price, _state.tokenInput, _swap.input, _state.tokenOutput, _swap.output);
 595 |     | 
 596 |     |         delete _state;
 597 |     |         return (args.poolId, _swap.remainder, _swap.input, _swap.output);
 598 |     |     }
 599 |     | 
 600 |     |     /**
 601 |     |      * @dev Computes the price of the pool, which changes over time.
 602 |     |      *
 603 |     |      * @custom:reverts Underflows if the reserve of the input token is lower than the next one, after the next price movement.
 604 |     |      * @custom:reverts Underflows if current reserves of output token is less then next reserves.
 605 |     |      */
 606 | *r  |     function _computeSyncedPrice(uint64 poolId) internal view returns (uint256 price, int24 tick, uint updatedTau) {
 607 | *r  |         HyperPool memory pool = pools[poolId];
 608 | *r  |         if (!pool.exists()) revert NonExistentPool(poolId);
 609 |     | 
 610 | *   |         (price, tick, updatedTau) = (pool.lastPrice, pool.lastTick, pool.tau(_blockTimestamp()));
 611 |     | 
 612 | *   |         uint passed = getTimePassed(poolId);
 613 | *   |         if (passed > 0) {
 614 | *   |             uint256 lastTau = pool.lastTau(); // pool.params.maturity() - pool.lastTimestamp.
 615 | *   |             (price, tick) = pool.computePriceChangeWithTime(lastTau, passed);
 616 |     |         }
 617 |     |     }
 618 |     | 
 619 |     |     /**
 620 |     |      * @dev Effects on a Pool after a successful swap order condition has been met.
 621 |     |      */
 622 |     |     function _syncPool(
 623 |     |         uint64 poolId,
 624 |     |         int24 tick,
 625 |     |         uint256 price,
 626 |     |         uint256 liquidity,
 627 |     |         uint256 feeGrowthGlobalAsset,
 628 |     |         uint256 feeGrowthGlobalQuote,
 629 |     |         uint256 feeGrowthGlobalReward
 630 |     |     ) internal returns (uint256 timeDelta) {
 631 |     |         HyperPool storage pool = pools[poolId];
 632 |     | 
 633 |     |         uint256 timestamp = _blockTimestamp();
 634 |     |         timeDelta = getTimePassed(poolId);
 635 |     | 
 636 |     |         // todo: better configuration of this value?
 637 |     |         uint requiredTimePassedForStake = 1;
 638 |     |         if (timeDelta >= requiredTimePassedForStake) {
 639 |     |             pool.stakedLiquidity = Assembly.addSignedDelta(pool.stakedLiquidity, pool.stakedLiquidityDelta);
 640 |     |             pool.stakedLiquidityDelta = 0;
 641 |     |         }
 642 |     | 
 643 |     |         if (pool.lastTick != tick) pool.lastTick = tick;
 644 |     |         if (pool.lastPrice != price) pool.lastPrice = price.safeCastTo128();
 645 |     |         if (pool.liquidity != liquidity) pool.liquidity = liquidity.safeCastTo128();
 646 |     |         if (pool.lastTimestamp != timestamp) pool.syncPoolTimestamp(timestamp);
 647 |     | 
 648 |     |         pool.feeGrowthGlobalAsset = Assembly.computeCheckpoint(pool.feeGrowthGlobalAsset, feeGrowthGlobalAsset);
 649 |     |         pool.feeGrowthGlobalQuote = Assembly.computeCheckpoint(pool.feeGrowthGlobalQuote, feeGrowthGlobalQuote);
 650 |     |         pool.feeGrowthGlobalReward = Assembly.computeCheckpoint(pool.feeGrowthGlobalReward, feeGrowthGlobalReward);
 651 |     |     }
 652 |     | 
 653 |     |     // ===== Initializing Pools ===== //
 654 |     | 
 655 | *   |     function _createPair(address asset, address quote) internal returns (uint24 pairId) {
 656 | *   |         if (asset == quote) revert SameTokenError();
 657 |     | 
 658 | *   |         pairId = getPairId[asset][quote];
 659 | *   |         if (pairId != 0) revert PairExists(pairId);
 660 |     | 
 661 | *   |         (uint8 decimalsAsset, uint8 decimalsQuote) = (IERC20(asset).decimals(), IERC20(quote).decimals());
 662 | *   |         if (!decimalsAsset.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))
 663 | *   |             revert InvalidDecimals(decimalsAsset);
 664 | *   |         if (!decimalsQuote.isBetween(Assembly.MIN_DECIMALS, Assembly.MAX_DECIMALS))
 665 |     |             revert InvalidDecimals(decimalsQuote);
 666 |     | 
 667 | *   |         pairId = ++getPairNonce;
 668 |     | 
 669 | *   |         getPairId[asset][quote] = pairId; // note: order of tokens matters!
 670 | *   |         pairs[pairId] = HyperPair({
 671 |     |             tokenAsset: asset,
 672 |     |             decimalsAsset: decimalsAsset,
 673 |     |             tokenQuote: quote,
 674 |     |             decimalsQuote: decimalsQuote
 675 |     |         });
 676 |     | 
 677 | *   |         emit CreatePair(pairId, asset, quote, decimalsAsset, decimalsQuote);
 678 |     |     }
 679 |     | 
 680 |     |     /** @dev If pairId == 0, its a magic variable that uses current pair nonce. */
 681 | *   |     function _createPool(
 682 |     |         uint24 pairId,
 683 |     |         address controller,
 684 |     |         uint16 priorityFee,
 685 |     |         uint16 fee,
 686 |     |         uint16 vol,
 687 |     |         uint16 dur,
 688 |     |         uint16 jit,
 689 |     |         int24 max,
 690 |     |         uint128 price
 691 | *   |     ) internal returns (uint64 poolId) {
 692 | *   |         if (price == 0) revert ZeroPrice();
 693 |     | 
 694 | *   |         uint32 timestamp = uint(_blockTimestamp()).safeCastTo32();
 695 | *   |         HyperPool memory pool;
 696 | *   |         pool.controller = controller;
 697 | *   |         pool.lastTimestamp = timestamp;
 698 | *   |         pool.lastPrice = price;
 699 | *   |         pool.lastTick = Price.computeTickWithPrice(pool.lastPrice);
 700 | *   |         bool hasController = pool.controller != address(0);
 701 | *   |         if (hasController && priorityFee == 0) revert InvalidFee(priorityFee); // Cannot set priority to 0.
 702 |     | 
 703 | *   |         uint24 pairNonce = pairId == 0 ? getPairNonce : pairId; // magic variable todo: fix, possible to set 0 pairId if getPairNonce is 0
 704 | *   |         pool.pair = pairs[pairNonce];
 705 |     | 
 706 | *   |         HyperCurve memory params = HyperCurve({
 707 |     |             maxTick: max,
 708 | *   |             jit: hasController ? jit : uint8(_liquidityPolicy()),
 709 | *   |             fee: fee,
 710 | *   |             duration: dur,
 711 | *   |             volatility: vol,
 712 | *   |             priorityFee: hasController ? priorityFee : 0, // min fee
 713 | *   |             createdAt: timestamp
 714 |     |         });
 715 | *   |         params.validateParameters();
 716 | *   |         pool.params = params;
 717 |     | 
 718 | *   |         uint32 poolNonce = ++getPoolNonce;
 719 |     | 
 720 | *   |         poolId = Enigma.encodePoolId(pairNonce, hasController, poolNonce);
 721 | *   |         if (pools[poolId].exists()) revert PoolExists(); // todo: poolNonce always increments, so this never gets hit, remove
 722 |     | 
 723 | *   |         pools[poolId] = pool; // effect
 724 |     | 
 725 | *   |         emit CreatePool(poolId, hasController, pool.pair.tokenAsset, pool.pair.tokenQuote, price);
 726 |     |     }
 727 |     | 
 728 | r   |     function changeParameters(
 729 |     |         uint64 poolId,
 730 |     |         uint16 priorityFee,
 731 |     |         uint16 fee,
 732 |     |         uint16 volatility,
 733 |     |         uint16 duration,
 734 |     |         uint16 jit,
 735 |     |         int24 maxTick
 736 |     |     ) external lock interactions {
 737 | r   |         HyperPool storage pool = pools[poolId];
 738 | r   |         if (pool.controller != msg.sender) revert NotController();
 739 |     | 
 740 |     |         HyperCurve memory modified = pool.params;
 741 |     |         if (jit != 0) modified.jit = jit;
 742 |     |         if (maxTick != 0) modified.maxTick = maxTick;
 743 |     |         if (fee != 0) modified.fee = fee;
 744 |     |         if (volatility != 0) modified.volatility = volatility;
 745 |     |         if (duration != 0) modified.duration = duration;
 746 |     |         if (priorityFee != 0) modified.priorityFee = priorityFee;
 747 |     | 
 748 |     |         pool.changePoolParameters(modified);
 749 |     | 
 750 |     |         emit ChangeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
 751 |     |     }
 752 |     | 
 753 |     |     /** @dev Overridable in tests.  */
 754 | r   |     function _blockTimestamp() internal view virtual returns (uint128) {
 755 | *r  |         return uint128(block.timestamp);
 756 |     |     }
 757 |     | 
 758 |     |     /** @dev Overridable in tests.  */
 759 |     |     function _liquidityPolicy() internal view virtual returns (uint256) {
 760 |     |         return JUST_IN_TIME_LIQUIDITY_POLICY;
 761 |     |     }
 762 |     | 
 763 |     |     // ===== Accounting System ===== //
 764 |     |     /**
 765 |     |      * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.
 766 |     |      *
 767 |     |      * @custom:security Directly manipulates reserves.
 768 |     |      */
 769 | *r  |     function _increaseReserves(address token, uint256 amount) internal {
 770 | *r  |         __account__.increase(token, amount);
 771 | *r  |         emit IncreaseReserveBalance(token, amount);
 772 |     |     }
 773 |     | 
 774 |     |     /**
 775 |     |      * @dev Reserves are an internally tracked amount of tokens that should match the return value of `balanceOf`.
 776 |     |      *
 777 |     |      * @custom:security Directly manipulates reserves.
 778 |     |      * @custom:reverts With `InsufficientReserve` if current reserve balance for `token` iss less than `amount`.
 779 |     |      */
 780 | *r  |     function _decreaseReserves(address token, uint256 amount) internal {
 781 | *r  |         __account__.decrease(token, amount);
 782 | *r  |         emit DecreaseReserveBalance(token, amount);
 783 |     |     }
 784 |     | 
 785 |     |     /**
 786 |     |      * @dev A positive credit is a receivable paid to the `msg.sender` internal balance.
 787 |     |      *      Positive credits are only applied to the internal balance of the account.
 788 |     |      *      Therefore, it does not require a state change for the global reserves.
 789 |     |      *
 790 |     |      * @custom:security Directly manipulates intrernal balances.
 791 |     |      */
 792 | *r  |     function _applyCredit(address token, uint256 amount) internal {
 793 |     |         __account__.credit(msg.sender, token, amount);
 794 | *r  |         emit IncreaseUserBalance(msg.sender, token, amount);
 795 |     |     }
 796 |     | 
 797 |     |     /**
 798 |     |      * @dev A positive debit is a cost that must be paid for a transaction to be processed.
 799 |     |      *      If a balance exists for the token for the internal balance of `msg.sender`,
 800 |     |      *      it will be used to pay the debit. Else, the contract expects tokens to be transferred in.
 801 |     |      *
 802 |     |      * @custom:security Directly manipulates intrernal balances.
 803 |     |      */
 804 | *r  |     function _applyDebit(address token, uint256 amount) internal {
 805 | *r  |         __account__.debit(msg.sender, token, amount);
 806 | *r  |         emit DecreaseUserBalance(msg.sender, token, amount);
 807 |     |     }
 808 |     | 
 809 |     |     /**
 810 |     |      * @dev Alternative entrypoint to execute functions.
 811 |     |      * @param data Encoded Enigma data. First byte must be an Enigma instruction.
 812 |     |      */
 813 | *r  |     function _process(bytes calldata data) internal {
 814 | *r  |         (, bytes1 instruction) = Assembly.separate(data[0]); // Upper byte is useMax, lower byte is instruction.
 815 |     | 
 816 | *r  |         if (instruction == Enigma.ALLOCATE) {
 817 | r   |             (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeAllocate(data);
 818 |     |             _allocate(useMax == 1, poolId, deltaLiquidity);
 819 | *r  |         } else if (instruction == Enigma.UNALLOCATE) {
 820 | r   |             (uint8 useMax, uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnallocate(data);
 821 | r   |             _unallocate(useMax == 1, poolId, deltaLiquidity);
 822 | *r  |         } else if (instruction == Enigma.SWAP) {
 823 |     |             Order memory args;
 824 | r   |             (args.useMax, args.poolId, args.input, args.output, args.direction) = Enigma.decodeSwap(data);
 825 |     |             _swap(args);
 826 | *r  |         } else if (instruction == Enigma.STAKE_POSITION) {
 827 | r   |             (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeStakePosition(data);
 828 | *r  |             _stake(poolId, deltaLiquidity);
 829 | *r  |         } else if (instruction == Enigma.UNSTAKE_POSITION) {
 830 |     |             (uint64 poolId, uint128 deltaLiquidity) = Enigma.decodeUnstakePosition(data);
 831 | *r  |             _unstake(poolId, deltaLiquidity);
 832 | *r  |         } else if (instruction == Enigma.CREATE_POOL) {
 833 | *   |             (
 834 | *   |                 uint24 pairId,
 835 | *   |                 address controller,
 836 | *   |                 uint16 priorityFee,
 837 | *   |                 uint16 fee,
 838 | *   |                 uint16 vol,
 839 | *   |                 uint16 dur,
 840 | *   |                 uint16 jit,
 841 | *   |                 int24 max,
 842 | *   |                 uint128 price
 843 | *   |             ) = Enigma.decodeCreatePool(data);
 844 | *   |             _createPool(pairId, controller, priorityFee, fee, vol, dur, jit, max, price);
 845 | *r  |         } else if (instruction == Enigma.CREATE_PAIR) {
 846 | *   |             (address asset, address quote) = Enigma.decodeCreatePair(data);
 847 | *   |             _createPair(asset, quote);
 848 |     |         } else {
 849 | r   |             revert InvalidInstruction();
 850 |     |         }
 851 |     |     }
 852 |     | 
 853 |     |     /**
 854 |     | 
 855 |     |         Be aware of these settlement invariants:
 856 |     | 
 857 |     |         Invariant 1. Every token that is interacted with is cached and exists.
 858 |     |         Invariant 2. Tokens are removed from cache, and cache is empty by end of settlement.
 859 |     |         Invariant 3. Cached tokens cannot be carried over from previous transactions.
 860 |     |         Invariant 4. Execution does not exit during the loops prematurely.
 861 |     |         Invariant 5. Account `settled` bool is set to true at end of `settlement`.
 862 |     |         Invariant 6. Debits reduce `reserves` of `token`.
 863 |     | 
 864 |     |      */
 865 | *r  |     function _settlement() internal {
 866 | *r  |         if (!__account__.prepared) revert OS.NotPreparedToSettle();
 867 |     | 
 868 | *r  |         address[] memory tokens = __account__.warm;
 869 | *r  |         uint256 loops = tokens.length;
 870 | *r  |         if (loops == 0) return __account__.reset(); // exit early.
 871 |     | 
 872 | *r  |         uint x;
 873 | *r  |         uint i = loops;
 874 | *r  |         do {
 875 |     |             // Loop backwards to pop tokens off.
 876 | *r  |             address token = tokens[i - 1];
 877 |     |             // Apply credits or debits to net balance.
 878 | *r  |             (uint credited, uint debited, uint remainder) = __account__.settle(token, address(this));
 879 |     |             // Reserves were increased, we paid a debit, therefore need to decrease reserves by `debited` amount.
 880 | *r  |             if (debited > 0) {
 881 |     |                 emit DecreaseUserBalance(msg.sender, token, debited);
 882 |     |                 emit DecreaseReserveBalance(token, debited);
 883 |     |             }
 884 |     |             // Reserves were not tracking some tokens, increase the reserves to account for them.
 885 | *r  |             if (credited > 0) {
 886 | *   |                 emit IncreaseUserBalance(msg.sender, token, credited);
 887 | *   |                 emit IncreaseReserveBalance(token, credited);
 888 |     |             }
 889 |     |             // Outstanding amount must be transferred in.
 890 | *r  |             if (remainder > 0) _payments.push(Payment({token: token, amount: remainder}));
 891 |     |             // Token accounted for.
 892 | *r  |             __account__.warm.pop();
 893 |     |             unchecked {
 894 | *r  |                 --i;
 895 | *r  |                 ++x;
 896 |     |             }
 897 | *r  |         } while (i != 0);
 898 |     | 
 899 | *r  |         Payment[] memory payments = _payments;
 900 |     | 
 901 | *r  |         uint px = payments.length;
 902 | *r  |         while (px != 0) {
 903 | *r  |             uint index = px - 1;
 904 | *r  |             OS.__dangerousTransferFrom__(payments[index].token, address(this), payments[index].amount);
 905 |     |             unchecked {
 906 | *r  |                 --px;
 907 |     |             }
 908 |     |         }
 909 |     | 
 910 | *r  |         __account__.reset();
 911 | *r  |         delete _payments;
 912 |     |     }
 913 |     | 
 914 |     |     // ===== View ===== //
 915 |     | 
 916 |     |     /** @dev Can be manipulated. */
 917 | *r  |     function getLatestPrice(uint64 poolId) public view returns (uint price) {
 918 | *r  |         (price, , ) = _computeSyncedPrice(poolId);
 919 |     |     }
 920 |     | 
 921 | *r  |     function getTimePassed(uint64 poolId) public view returns (uint) {
 922 | *r  |         return _blockTimestamp() - pools[poolId].lastTimestamp;
 923 |     |     }
 924 |     | 
 925 | *r  |     function getVirtualReserves(uint64 poolId) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {
 926 | *   |         return pools[poolId].getVirtualReserves();
 927 |     |     }
 928 |     | 
 929 | *r  |     function getMaxLiquidity(
 930 |     |         uint64 poolId,
 931 |     |         uint deltaAsset,
 932 |     |         uint deltaQuote
 933 | *r  |     ) public view override returns (uint128 deltaLiquidity) {
 934 | *r  |         return pools[poolId].getMaxLiquidity(deltaAsset, deltaQuote);
 935 |     |     }
 936 |     | 
 937 | *r  |     function getLiquidityDeltas(
 938 |     |         uint64 poolId,
 939 |     |         int128 deltaLiquidity
 940 | *r  |     ) public view override returns (uint128 deltaAsset, uint128 deltaQuote) {
 941 | *r  |         return pools[poolId].getLiquidityDeltas(deltaLiquidity);
 942 |     |     }
 943 |     | 
 944 | *r  |     function getAmounts(uint64 poolId) public view override returns (uint256 deltaAsset, uint256 deltaQuote) {
 945 | *r  |         return pools[poolId].getAmounts();
 946 |     |     }
 947 |     | 
 948 | r   |     function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) public view returns (uint output) {
 949 | r   |         HyperPool memory pool = pools[poolId];
 950 | r   |         (output, ) = pool.getAmountOut({
 951 | r   |             sellAsset: sellAsset,
 952 | r   |             amountIn: amountIn,
 953 | r   |             timeSinceUpdate: _blockTimestamp() - pool.lastTimestamp // invariant: should not underflow.
 954 |     |         });
 955 |     |     }
 956 |     | }
 957 |     | 

/root/code/hyper/contracts/HyperLib.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     | 
   8 |     |   Comprehensive library with all structs, errors,
   9 |     |   constants, and utils for Hyper.
  10 |     | 
  11 |     |   -------------
  12 |     | 
  13 |     |   Primitive™
  14 |     | 
  15 |     |  */
  16 |     | 
  17 |     | import "solmate/utils/SafeCastLib.sol";
  18 |     | import "./libraries/Price.sol";
  19 |     | import "./Assembly.sol" as Assembly;
  20 |     | import "./Enigma.sol" as Enigma;
  21 |     | import "./OS.sol" as OS;
  22 |     | 
  23 |     | using Price for Price.RMM;
  24 |     | using SafeCastLib for uint;
  25 |     | using FixedPointMathLib for uint;
  26 |     | using {Assembly.scaleFromWadDown, Assembly.scaleFromWadUp, Assembly.scaleToWad} for uint;
  27 |     | using {checkParameters, maturity, strike, validateParameters} for HyperCurve global;
  28 |     | using {changePositionLiquidity, syncPositionFees, getTimeSinceChanged, syncPositionStakedFees} for HyperPosition global;
  29 |     | using {
  30 |     |     changePoolLiquidity,
  31 |     |     changePoolParameters,
  32 |     |     computePriceChangeWithTime,
  33 |     |     exists,
  34 |     |     getAmounts,
  35 |     |     getAmountOut,
  36 |     |     getAmountsWad,
  37 |     |     getLiquidityDeltas,
  38 |     |     getMaxLiquidity,
  39 |     |     getMaxSwapAssetInWad,
  40 |     |     getMaxSwapQuoteInWad,
  41 |     |     getRMM,
  42 |     |     getVirtualReserves,
  43 |     |     isMutable,
  44 |     |     syncPoolTimestamp,
  45 |     |     lastTau,
  46 |     |     tau
  47 |     | } for HyperPool global;
  48 |     | 
  49 | *   | int24 constant MAX_TICK = 887272;
  50 |     | uint256 constant BUFFER = 300 seconds;
  51 | *   | uint256 constant MIN_FEE = 1; // 0.01%
  52 | *   | uint256 constant MAX_FEE = 1000; // 10%
  53 | *   | uint256 constant MIN_VOLATILITY = 100; // 1%
  54 | *   | uint256 constant MAX_VOLATILITY = 25_000; // 250%
  55 | *   | uint256 constant MIN_DURATION = 1; // days, but without units
  56 | *   | uint256 constant MAX_DURATION = 500; // days, but without units
  57 | *   | uint256 constant JUST_IN_TIME_MAX = 600 seconds;
  58 | *   | uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;
  59 |     | 
  60 |     | // todo: add selectors for debugging?
  61 |     | error DrawBalance();
  62 |     | error InsufficientPosition(uint64 poolId);
  63 |     | error InvalidDecimals(uint8 decimals);
  64 |     | error InvalidDuration(uint16);
  65 |     | error InvalidFee(uint16 fee);
  66 |     | error InvalidInstruction();
  67 |     | error InvalidInvariant(int256 prev, int256 next);
  68 |     | error InvalidJit(uint16);
  69 |     | error InvalidReentrancy();
  70 |     | error InvalidReward();
  71 |     | error InvalidSettlement();
  72 |     | error InvalidStrike(uint128 strike);
  73 |     | error InvalidTick(int24);
  74 |     | error InvalidTransfer();
  75 |     | error InvalidVolatility(uint24 sigma); // todo: fix, use uint16 type.
  76 |     | error JitLiquidity(uint256 distance);
  77 |     | error MaxFee(uint16 fee);
  78 |     | error NotController();
  79 |     | error NonExistentPool(uint64 poolId);
  80 |     | error NonExistentPosition(address owner, uint64 poolId);
  81 |     | error PairExists(uint24 pairId);
  82 |     | error PerLiquidityError(uint256 deltaAsset);
  83 |     | error PoolExists();
  84 |     | error PoolExpired();
  85 |     | error PositionStaked(uint96 positionId);
  86 |     | error PositionZeroLiquidity(uint96 positionId);
  87 |     | error PositionNotStaked(uint96 positionId);
  88 |     | error SameTokenError();
  89 |     | error StakeNotMature(uint64 poolId);
  90 |     | error SwapLimitReached();
  91 |     | error ZeroInput();
  92 |     | error ZeroLiquidity();
  93 |     | error ZeroOutput();
  94 |     | error ZeroPrice();
  95 |     | error ZeroValue();
  96 |     | 
  97 |     | struct HyperPair {
  98 |     |     address tokenAsset;
  99 |     |     uint8 decimalsAsset;
 100 |     |     address tokenQuote;
 101 |     |     uint8 decimalsQuote;
 102 |     | }
 103 |     | 
 104 |     | struct HyperCurve {
 105 |     |     // single slot
 106 |     |     int24 maxTick;
 107 |     |     uint16 jit;
 108 |     |     uint16 fee;
 109 |     |     uint16 duration;
 110 |     |     uint16 volatility;
 111 |     |     uint16 priorityFee;
 112 |     |     uint32 createdAt;
 113 |     | }
 114 |     | 
 115 |     | struct HyperPool {
 116 |     |     int24 lastTick;
 117 |     |     uint32 lastTimestamp; // updated on swaps.
 118 |     |     address controller;
 119 |     |     uint256 feeGrowthGlobalReward;
 120 |     |     uint256 feeGrowthGlobalAsset;
 121 |     |     uint256 feeGrowthGlobalQuote;
 122 |     |     uint128 lastPrice;
 123 |     |     uint128 liquidity; // available liquidity to remove
 124 |     |     uint128 stakedLiquidity; // locked liquidity
 125 |     |     int128 stakedLiquidityDelta; // liquidity to be added or removed
 126 |     |     HyperCurve params;
 127 |     |     HyperPair pair;
 128 |     | }
 129 |     | 
 130 |     | // todo: optimize slot
 131 |     | struct HyperPosition {
 132 |     |     uint128 freeLiquidity;
 133 |     |     uint128 stakedLiquidity;
 134 |     |     uint256 lastTimestamp;
 135 |     |     uint256 stakeTimestamp;
 136 |     |     uint256 unstakeTimestamp;
 137 |     |     uint256 feeGrowthRewardLast;
 138 |     |     uint256 feeGrowthAssetLast;
 139 |     |     uint256 feeGrowthQuoteLast;
 140 |     |     uint128 tokensOwedAsset;
 141 |     |     uint128 tokensOwedQuote;
 142 |     |     uint128 tokensOwedReward;
 143 |     | }
 144 |     | 
 145 |     | struct ChangeLiquidityParams {
 146 |     |     address owner;
 147 |     |     uint64 poolId;
 148 |     |     uint256 timestamp;
 149 |     |     uint256 deltaAsset;
 150 |     |     uint256 deltaQuote;
 151 |     |     address tokenAsset;
 152 |     |     address tokenQuote;
 153 |     |     int128 deltaLiquidity;
 154 |     | }
 155 |     | 
 156 |     | struct Order {
 157 |     |     uint8 useMax;
 158 |     |     uint64 poolId;
 159 |     |     uint128 input;
 160 |     |     // For swapExactIn or swapExactOut, output is the limit price.
 161 |     |     uint128 output;
 162 |     |     uint8 direction;
 163 |     | }
 164 |     | 
 165 |     | struct Iteration {
 166 |     |     int24 tick;
 167 |     |     uint256 price;
 168 |     |     uint256 remainder;
 169 |     |     uint256 feeAmount;
 170 |     |     uint256 liquidity;
 171 |     |     uint256 input;
 172 |     |     uint256 output;
 173 |     | }
 174 |     | 
 175 |     | struct SwapState {
 176 |     |     bool sell;
 177 |     |     address tokenInput;
 178 |     |     address tokenOutput;
 179 |     |     uint256 fee;
 180 |     |     uint256 feeGrowthGlobal;
 181 |     |     uint256 priorityFeeGrowthGlobal;
 182 |     | }
 183 |     | 
 184 |     | struct Payment {
 185 |     |     address token;
 186 |     |     uint amount;
 187 |     | }
 188 | *r  | 
 189 |     | function changePoolLiquidity(HyperPool storage self, int128 liquidityDelta) {
 190 | *r  |     self.liquidity = Assembly.addSignedDelta(self.liquidity, liquidityDelta);
 191 |     | }
 192 |     | 
 193 |     | function syncPoolTimestamp(HyperPool storage self, uint timestamp) {
 194 |     |     self.lastTimestamp = SafeCastLib.safeCastTo32(timestamp);
 195 |     | }
 196 |     | 
 197 |     | function changePoolParameters(HyperPool storage self, HyperCurve memory updated) {
 198 |     |     (bool success, ) = updated.validateParameters();
 199 |     |     self.params = updated;
 200 |     |     assert(success);
 201 |     | }
 202 | *r  | 
 203 |     | function changePositionLiquidity(HyperPosition storage self, uint256 timestamp, int128 liquidityDelta) {
 204 | *r  |     self.lastTimestamp = timestamp;
 205 | *r  |     self.freeLiquidity = Assembly.addSignedDelta(self.freeLiquidity, liquidityDelta);
 206 |     | }
 207 |     | 
 208 | *r  | /** @dev Liquidity must be altered after syncing positions and not before. */
 209 |     | function syncPositionFees(
 210 |     |     HyperPosition storage self,
 211 |     |     uint positionLiquidity,
 212 |     |     uint feeGrowthAsset,
 213 |     |     uint feeGrowthQuote
 214 | *r  | ) returns (uint feeAssetEarned, uint feeQuoteEarned) {
 215 |     |     // fee growth current - position fee growth last
 216 | *r  |     uint differenceAsset = Assembly.computeCheckpointDistance(feeGrowthAsset, self.feeGrowthAssetLast);
 217 | *r  |     uint differenceQuote = Assembly.computeCheckpointDistance(feeGrowthQuote, self.feeGrowthQuoteLast);
 218 |     |     
 219 |     |     // fee growth per liquidity * position liquidity
 220 | *r  |     feeAssetEarned = FixedPointMathLib.mulWadDown(differenceAsset, positionLiquidity); 
 221 | *r  |     feeQuoteEarned = FixedPointMathLib.mulWadDown(differenceQuote, positionLiquidity);
 222 |     | 
 223 | *r  |     self.feeGrowthAssetLast = feeGrowthAsset;
 224 | *r  |     self.feeGrowthQuoteLast = feeGrowthQuote;
 225 |     | 
 226 | *r  |     self.tokensOwedAsset += SafeCastLib.safeCastTo128(feeAssetEarned);
 227 | *r  |     self.tokensOwedQuote += SafeCastLib.safeCastTo128(feeQuoteEarned);
 228 |     | }
 229 |     | 
 230 |     | function syncPositionStakedFees(HyperPosition storage self, uint liquidity, uint feeGrowth) returns (uint feeEarned) {
 231 |     |     uint checkpoint = Assembly.computeCheckpointDistance(feeGrowth, self.feeGrowthRewardLast);
 232 |     |     feeEarned = FixedPointMathLib.mulWadDown(checkpoint, liquidity);
 233 |     |     self.feeGrowthRewardLast = feeEarned;
 234 |     |     self.tokensOwedReward += SafeCastLib.safeCastTo128(feeEarned);
 235 |     | }
 236 |     | 
 237 |     | // ===== View ===== //
 238 | *   | 
 239 | *   | function getVirtualReserves(HyperPool memory self) view returns (uint128 reserveAsset, uint128 reserveQuote) {
 240 | *   |     return self.getLiquidityDeltas(-int128(self.liquidity)); // rounds down
 241 |     | }
 242 | *r  | 
 243 |     | function getMaxLiquidity(
 244 |     |     HyperPool memory self,
 245 |     |     uint deltaAsset,
 246 |     |     uint deltaQuote
 247 | *r  | ) view returns (uint128 deltaLiquidity) {
 248 | *r  |     (uint amountAsset, uint amountQuote) = self.getAmounts();
 249 | *r  |     uint liquidity0 = deltaAsset.divWadDown(amountAsset);
 250 | *   |     uint liquidity1 = deltaQuote.divWadDown(amountQuote);
 251 | *   |     deltaLiquidity = (liquidity0 < liquidity1 ? liquidity0 : liquidity1).safeCastTo128();
 252 |     | }
 253 |     | 
 254 | *r  | /** @dev Rounds positive deltas up. Rounds negative deltas down. */
 255 |     | function getLiquidityDeltas(
 256 |     |     HyperPool memory self,
 257 |     |     int128 deltaLiquidity
 258 | *r  | ) view returns (uint128 deltaAsset, uint128 deltaQuote) {
 259 | *r  |     if (deltaLiquidity == 0) return (deltaAsset, deltaQuote);
 260 | *r  |     (uint amountAsset, uint amountQuote) = self.getAmounts();
 261 |     | 
 262 | *r  |     uint delta;
 263 | *r  |     if (deltaLiquidity > 0) {
 264 | *r  |         delta = uint128(deltaLiquidity);
 265 | *r  |         deltaAsset = amountAsset.mulWadUp(delta).safeCastTo128();
 266 | *r  |         deltaQuote = amountQuote.mulWadUp(delta).safeCastTo128();
 267 |     |     } else {
 268 | *r  |         delta = uint128(-deltaLiquidity);
 269 | *r  |         deltaAsset = amountAsset.mulWadDown(delta).safeCastTo128();
 270 | *r  |         deltaQuote = amountQuote.mulWadDown(delta).safeCastTo128();
 271 |     |     }
 272 |     | }
 273 |     | 
 274 | *r  | /** @dev Decimal amounts per WAD of liquidity, rounded down... */
 275 | *r  | function getAmounts(HyperPool memory self) view returns (uint amountAssetDec, uint amountQuoteDec) {
 276 | *r  |     (uint amountAssetWad, uint amountQuoteWad) = self.getAmountsWad();
 277 | *r  |     amountAssetDec = amountAssetWad.scaleFromWadDown(self.pair.decimalsAsset);
 278 | *r  |     amountQuoteDec = amountQuoteWad.scaleFromWadDown(self.pair.decimalsQuote);
 279 |     | }
 280 |     | 
 281 | *r  | /** @dev WAD Amounts per WAD of liquidity. */
 282 | *r  | function getAmountsWad(HyperPool memory self) view returns (uint amountAssetWad, uint amountQuoteWad) {
 283 | *r  |     Price.RMM memory rmm = self.getRMM();
 284 | *r  |     amountAssetWad = rmm.getXWithPrice(self.lastPrice);
 285 | *r  |     amountQuoteWad = rmm.getYWithX(amountAssetWad);
 286 |     | }
 287 |     | 
 288 |     | // ===== Derived ===== //
 289 | *r  | 
 290 |     | function computePriceChangeWithTime(
 291 |     |     HyperPool memory self,
 292 |     |     uint timeRemaining,
 293 |     |     uint epsilon
 294 | *r  | ) pure returns (uint price, int24 tick) {
 295 | *r  |     uint maxPrice = Price.computePriceWithTick(self.params.maxTick);
 296 | *r  |     price = Price.computePriceWithChangeInTau(maxPrice, self.params.volatility, self.lastPrice, timeRemaining, epsilon);
 297 | *r  |     tick = Price.computeTickWithPrice(price);
 298 |     | }
 299 | r   | 
 300 | r   | function getTimeSinceChanged(HyperPosition memory self, uint timestamp) view returns (uint distance) {
 301 | r   |     return timestamp - self.lastTimestamp;
 302 |     | }
 303 | *r  | 
 304 |     | function exists(HyperPool memory self) view returns (bool) {
 305 | *r  |     return self.lastTimestamp != 0;
 306 |     | }
 307 | *   | 
 308 |     | function isMutable(HyperPool memory self) view returns (bool) {
 309 | *r  |     return self.controller != address(0);
 310 |     | }
 311 | *r  | 
 312 | *r  | function getRMM(HyperPool memory self) view returns (Price.RMM memory) {
 313 | *r  |     return Price.RMM({strike: self.params.strike(), sigma: self.params.volatility, tau: self.lastTau()});
 314 |     | }
 315 | *r  | 
 316 | *r  | function lastTau(HyperPool memory self) view returns (uint) {
 317 | *r  |     return self.tau(self.lastTimestamp);
 318 |     | }
 319 | *r  | 
 320 | *r  | function tau(HyperPool memory self, uint timestamp) view returns (uint) {
 321 | *r  |     uint end = self.params.maturity();
 322 | *r  |     if (timestamp > end) return 0;
 323 | *r  |     return end - timestamp;
 324 |     | }
 325 | *r  | 
 326 | *r  | function strike(HyperCurve memory self) view returns (uint) {
 327 | *r  |     return Price.computePriceWithTick(self.maxTick);
 328 |     | }
 329 | *r  | 
 330 | *r  | function maturity(HyperCurve memory self) view returns (uint32 endTimestamp) {
 331 | *r  |     return (Assembly.convertDaysToSeconds(self.duration) + self.createdAt).safeCastTo32();
 332 |     | }
 333 | *   | 
 334 | *   | function validateParameters(HyperCurve memory self) view returns (bool, bytes memory) {
 335 | *   |     (bool success, bytes memory reason) = self.checkParameters();
 336 | *   |     if (!success) {
 337 |     |         assembly {
 338 |     |             revert(add(32, reason), mload(reason))
 339 |     |         }
 340 |     |     }
 341 |     | 
 342 | *   |     return (success, reason);
 343 |     | }
 344 |     | 
 345 | *   | /** @dev Invalid parameters should revert. */
 346 | *   | function checkParameters(HyperCurve memory self) view returns (bool, bytes memory) {
 347 | *   |     if (!Assembly.isBetween(self.volatility, MIN_VOLATILITY, MAX_VOLATILITY))
 348 |     |         return (false, abi.encodeWithSelector(InvalidVolatility.selector, self.volatility));
 349 | *   |     if (!Assembly.isBetween(self.duration, MIN_DURATION, MAX_DURATION))
 350 |     |         return (false, abi.encodeWithSelector(InvalidDuration.selector, self.duration));
 351 | *   |     if (self.maxTick >= MAX_TICK) return (false, abi.encodeWithSelector(InvalidTick.selector, self.maxTick)); //  todo: fix, min tick check?
 352 | *   |     if (self.jit > JUST_IN_TIME_MAX) return (false, abi.encodeWithSelector(InvalidJit.selector, self.jit));
 353 | *   |     if (!Assembly.isBetween(self.fee, MIN_FEE, MAX_FEE))
 354 |     |         return (false, abi.encodeWithSelector(InvalidFee.selector, self.fee));
 355 |     |     // 0 priority fee == no controller, impossible to set to zero unless default from non controlled pools.
 356 | *   |     if (!Assembly.isBetween(self.priorityFee, 0, self.fee))
 357 |     |         return (false, abi.encodeWithSelector(InvalidFee.selector, self.priorityFee));
 358 |     | 
 359 | *   |     return (true, "");
 360 |     | }
 361 |     | 
 362 |     | // ===== Swaps ===== //
 363 |     | 
 364 |     | function getMaxSwapAssetInWad(HyperPool memory self) view returns (uint) {
 365 |     |     Price.RMM memory rmm = self.getRMM();
 366 |     |     (, uint res1) = rmm.computeReserves(self.lastPrice);
 367 |     |     uint maxInput = FixedPointMathLib.WAD - res1;
 368 |     |     maxInput = maxInput.mulWadDown(self.liquidity);
 369 |     |     return maxInput.scaleFromWadDown(self.pair.decimalsAsset);
 370 |     | }
 371 |     | 
 372 |     | function getMaxSwapQuoteInWad(HyperPool memory self) view returns (uint) {
 373 |     |     Price.RMM memory rmm = self.getRMM();
 374 |     |     (uint res0, ) = rmm.computeReserves(self.lastPrice);
 375 |     |     uint maxInput = rmm.strike - res0;
 376 |     |     maxInput = maxInput.mulWadDown(self.liquidity);
 377 |     |     return maxInput.scaleFromWadDown(self.pair.decimalsQuote);
 378 |     | }
 379 | *r  | 
 380 |     | function getAmountOut(
 381 |     |     HyperPool memory self,
 382 |     |     bool sellAsset,
 383 |     |     uint amountIn,
 384 |     |     uint timeSinceUpdate
 385 | *r  | ) view returns (uint, uint) {
 386 | *r  |     Iteration memory data;
 387 | *r  |     Price.RMM memory rmm = self.getRMM();
 388 | *r  |     (data.price, data.tick) = self.computePriceChangeWithTime(self.lastTau(), timeSinceUpdate);
 389 | *r  |     data.remainder = amountIn.scaleToWad(sellAsset ? self.pair.decimalsAsset : self.pair.decimalsQuote);
 390 | *r  |     data.liquidity = self.liquidity;
 391 |     | 
 392 |     |     uint prioFee;
 393 |     |     uint prevInd;
 394 |     |     uint prevDep;
 395 |     |     uint nextInd;
 396 |     |     uint nextDep;
 397 |     | 
 398 |     |     {
 399 |     |         uint maxInput;
 400 |     |         uint delInput;
 401 |     | 
 402 | *r  |         if (sellAsset) {
 403 | *r  |             (prevDep, prevInd) = rmm.computeReserves(data.price);
 404 | *r  |             maxInput = (FixedPointMathLib.WAD - prevInd).mulWadDown(data.liquidity); // There can be maximum 1:1 ratio between assets and liqudiity.
 405 |     |         } else {
 406 | r   |             (prevInd, prevDep) = rmm.computeReserves(data.price);
 407 | r   |             maxInput = (rmm.strike - prevInd).mulWadDown(data.liquidity); // There can be maximum strike:1 liquidity ratio between quote and liquidity.
 408 |     |         }
 409 |     | 
 410 | *r  |         prioFee = msg.sender == self.controller ? (data.liquidity * self.params.fee) / 10_000 : 0;
 411 | *r  |         data.feeAmount = prioFee != 0
 412 |     |             ? 0
 413 | *r  |             : ((data.remainder > maxInput ? maxInput : data.remainder) * self.params.fee) / 10_000;
 414 |     | 
 415 | *r  |         delInput = data.remainder > maxInput ? maxInput : data.remainder;
 416 | *r  |         nextInd = prevInd + (delInput - data.feeAmount).divWadDown(data.liquidity);
 417 |     | 
 418 |     |         // Compute the output of the swap by computing the difference between the dependent reserves.
 419 |     |         if (sellAsset) nextDep = rmm.getYWithX(nextInd);
 420 |     |         else nextDep = rmm.getXWithY(nextInd);
 421 |     | 
 422 |     |         data.remainder -= delInput;
 423 |     |         data.input += delInput;
 424 |     |         data.output += (prevDep - nextDep).mulWadDown(data.liquidity);
 425 |     |     }
 426 |     | 
 427 |     |     {
 428 |     |         // Scale down amounts from WAD.
 429 |     |         uint inputDec;
 430 |     |         uint outputDec;
 431 |     |         if (sellAsset) {
 432 |     |             inputDec = self.pair.decimalsAsset;
 433 |     |             outputDec = self.pair.decimalsQuote;
 434 |     |         } else {
 435 |     |             inputDec = self.pair.decimalsQuote;
 436 |     |             outputDec = self.pair.decimalsAsset;
 437 |     |         }
 438 |     | 
 439 |     |         data.input = data.input.scaleFromWadUp(inputDec);
 440 |     |         data.output = data.output.scaleFromWadDown(outputDec);
 441 |     |     }
 442 |     | 
 443 |     |     return (data.output, data.remainder);
 444 |     | }
 445 | *r  | 
 446 | *r  | function toInt128(uint128 a) pure returns (int128 b) {
 447 |     |     assembly {
 448 | *r  |         if gt(a, 0x7fffffffffffffffffffffffffffffff) {
 449 |     |             revert(0, 0)
 450 |     |         }
 451 |     | 
 452 |     |         b := a
 453 |     |     }
 454 |     | }
 455 |     | 

/root/code/hyper/contracts/OS.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     | 
   6 |     |   -------------
   7 |     |   
   8 |     |   This is a custom account system to support Enigma's
   9 |     |   jump processing. Without jump processing, the benefits 
  10 |     |   are marginal at best. Combining the two reduces the 
  11 |     |   marginal cost of aditional operations to only ~20% of a single operation. 
  12 |     |   This is by design, in order to support a system that interacts with a lot
  13 |     |   of different parameters, tokens, actors, and pools.
  14 |     | 
  15 |     |   -------------
  16 |     | 
  17 |     |   Glossary:
  18 |     | 
  19 |     |   Virtual Reserves  - Expected balance of tokens.
  20 |     |   Physical Reserves - Actual balance of tokens.
  21 |     |   Net Balance       - Difference of physical reserve and virtual reserve.
  22 |     |   Credit            - Increase (+) spendable tokens.
  23 |     |   Debit             - Decrease (-) spendable tokens.
  24 |     |   Settle            - Apply net balance (+/-) as credit (+) or debit (-) to user.
  25 |     | 
  26 |     |   -------------
  27 |     | 
  28 |     |   Primitive™
  29 |     | 
  30 |     |  */
  31 |     | 
  32 |     | import "solmate/utils/SafeTransferLib.sol";
  33 |     | import "./interfaces/IWETH.sol";
  34 |     | import "./interfaces/IERC20.sol";
  35 |     | import "./Assembly.sol" as Assembly;
  36 |     | 
  37 |     | using {
  38 |     |     __wrapEther__,
  39 |     |     dangerousFund,
  40 |     |     cache,
  41 |     |     credit,
  42 |     |     debit,
  43 |     |     decrease,
  44 |     |     increase,
  45 |     |     reset,
  46 |     |     settle,
  47 |     |     touch,
  48 |     |     getNetBalance
  49 |     | } for AccountSystem global;
  50 |     | 
  51 |     | error EtherTransferFail(); // 0x75f42683
  52 |     | error InsufficientReserve(uint amount, uint delta); // 0x315276c9
  53 |     | error InvalidBalance(); // 0xc52e3eff
  54 |     | error NotPreparedToSettle(); // 0xf7cede50
  55 |     | 
  56 |     | struct AccountSystem {
  57 |     |     // user -> token -> internal balance.
  58 |     |     mapping(address => mapping(address => uint)) balances;
  59 |     |     // token -> virtual reserve.
  60 |     |     mapping(address => uint) reserves;
  61 |     |     // token -> cached status. todo: make this a bitmap
  62 |     |     mapping(address => bool) cached;
  63 |     |     // Transiently stored cached tokens, must be length zero outside of execution.
  64 |     |     address[] warm;
  65 |     |     // Must be `false` outside of execution.
  66 |     |     bool prepared;
  67 |     |     // Must be `true` outside of execution.
  68 |     |     bool settled;
  69 |     | }
  70 |     | 
  71 | *r  | /** @dev Gas optimized. */
  72 | *r  | function __balanceOf__(address token, address account) view returns (uint256) {
  73 | *r  |     (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, account));
  74 | *r  |     if (!success || data.length != 32) revert InvalidBalance();
  75 | *r  |     return abi.decode(data, (uint256));
  76 |     | }
  77 |     | 
  78 | *r  | /** @dev Must validate `weth` is real weth. */
  79 |     | function __wrapEther__(AccountSystem storage self, address weth) {
  80 | *r  |     if (msg.value > 0) {
  81 | *r  |         self.touch(weth);
  82 | *r  |         IWETH(weth).deposit{value: msg.value}();
  83 |     |     }
  84 |     | }
  85 |     | 
  86 | *r  | /** @dev Dangerously sends ether to `to` in a low-level call. */
  87 |     | function __dangerousUnwrapEther__(address weth, address to, uint256 amount) {
  88 | *r  |     IWETH(weth).withdraw(amount);
  89 | *r  |     __dangerousTransferEther__(to, amount);
  90 |     | }
  91 |     | 
  92 | *r  | /** @dev Dangerously sends ether to `to` in a low-level call. */
  93 |     | function __dangerousTransferEther__(address to, uint256 value) {
  94 | *r  |     (bool success, ) = to.call{value: value}(new bytes(0));
  95 | *r  |     if (!success) revert EtherTransferFail();
  96 |     | }
  97 |     | 
  98 | *r  | /** @dev External call to the `to` address is dangerous. */
  99 |     | function __dangerousTransferFrom__(address token, address to, uint amount) {
 100 | *r  |     SafeTransferLib.safeTransferFrom(ERC20(token), msg.sender, to, amount);
 101 |     | }
 102 |     | 
 103 | *r  | /** @dev External call to the `to` address is dangerous. */
 104 |     | function dangerousFund(AccountSystem storage self, address token, address to, uint amount) {
 105 | *r  |     self.touch(token);
 106 | *r  |     __dangerousTransferFrom__(token, to, amount); // Settlement gifts tokens to msg.sender.
 107 |     | }
 108 |     | 
 109 | *r  | /** @dev Increases an `owner`'s spendable balance. */
 110 |     | function credit(AccountSystem storage self, address owner, address token, uint amount) {
 111 | *   |     self.touch(token);
 112 | *r  |     self.balances[owner][token] += amount;
 113 |     | }
 114 |     | 
 115 | *r  | /** @dev Decreases an `owner`'s spendable balance. */
 116 |     | function debit(
 117 |     |     AccountSystem storage self,
 118 |     |     address owner,
 119 |     |     address token,
 120 |     |     uint256 owed
 121 | *r  | ) returns (uint paid, uint remainder) {
 122 | *r  |     self.touch(token);
 123 | *r  |     uint balance = self.balances[owner][token];
 124 | *r  |     if (balance >= owed) {
 125 | *r  |         paid = owed;
 126 | *r  |         self.balances[owner][token] -= paid;
 127 | *r  |         remainder = 0;
 128 |     |     } else {
 129 | *r  |         paid = balance;
 130 | *r  |         self.balances[owner][token] -= paid;
 131 | *r  |         remainder = owed - paid;
 132 |     |     }
 133 |     | }
 134 |     | 
 135 | *r  | /** @dev Actives a token and increases the reserves. Settlement will pick up this activated token. */
 136 |     | function increase(AccountSystem storage self, address token, uint amount) {
 137 | *r  |     self.touch(token);
 138 | *r  |     self.reserves[token] += amount;
 139 |     | }
 140 |     | 
 141 | *r  | /** @dev Actives a token and decreases the reserves. Settlement will pick up this activated token. */
 142 |     | function decrease(AccountSystem storage self, address token, uint amount) {
 143 | *r  |     uint balance = self.reserves[token];
 144 | *r  |     if (amount > balance) revert InsufficientReserve(balance, amount);
 145 |     | 
 146 | *r  |     self.touch(token);
 147 | *r  |     self.reserves[token] -= amount;
 148 |     | }
 149 |     | 
 150 | *r  | /** @notice Settles the difference in balance between virtual tokens and physically held tokens. */
 151 |     | function settle(
 152 |     |     AccountSystem storage self,
 153 |     |     address token,
 154 |     |     address account
 155 | *r  | ) returns (uint credited, uint debited, uint remainder) {
 156 | *r  |     int net = self.getNetBalance(token, account);
 157 | *r  |     if (net > 0) {
 158 | *   |         credited = uint(net);
 159 |     |         // unaccounted for tokens, e.g. transferred directly into Hyper.
 160 | *   |         self.credit(msg.sender, token, uint(net)); // gift to `msg.sender`.
 161 | *   |         self.reserves[token] += uint(net); // add the difference back to reserves, so net is zero.
 162 | *r  |     } else if (net < 0) {
 163 |     |         // missing tokens that must be paid for or transferred in.
 164 | *r  |         remainder = uint(-net);
 165 | *r  |         (debited, remainder) = self.debit(msg.sender, token, remainder);
 166 | *r  |         if (debited > 0) self.reserves[token] -= debited; // using a balance means tokens are in contract already.
 167 |     |     }
 168 |     | 
 169 | *r  |     delete self.cached[token]; // Note: Assumes this token is completely paid for by the end of the transaction.
 170 |     | }
 171 |     | 
 172 | *r  | /** @dev Interacting with a token will activate it, adding it to an array of interacted tokens for settlement to loop through. */
 173 |     | function touch(AccountSystem storage self, address token) {
 174 | *r  |     if (self.settled) self.settled = false; // If tokens are warm, they are not settled.
 175 | *r  |     if (!self.cached[token]) {
 176 | *r  |         self.warm.push(token);
 177 |     |         self.cache(token, true);
 178 |     |     }
 179 |     |     // do nothing if already cached.
 180 |     | }
 181 |     | 
 182 | *r  | /** @dev Account system is reset after settlement is successful. */
 183 |     | function reset(AccountSystem storage self) {
 184 | *r  |     assert(self.warm.length == 0); // todo: this is a valid assertion, but should we use assert?
 185 | *r  |     self.settled = true;
 186 | *r  |     delete self.warm;
 187 | *r  |     delete self.prepared;
 188 |     | }
 189 |     | 
 190 |     | /** @dev Used to check if a token was already activated after being interacted with again. */
 191 |     | function cache(AccountSystem storage self, address token, bool status) {
 192 | *r  |     self.cached[token] = status;
 193 |     | }
 194 |     | 
 195 | *r  | /** @dev Computes surplus (positive) or deficit (negative) in actual tokens compared to tracked amounts. */
 196 | *r  | function getNetBalance(AccountSystem storage self, address token, address account) view returns (int256 net) {
 197 | *r  |     uint256 internalBalance = self.reserves[token];
 198 | *r  |     uint256 physicalBalance = __balanceOf__(token, account);
 199 | *r  |     net = int256(physicalBalance) - int256(internalBalance);
 200 |     | }
 201 |     | 

/root/code/hyper/contracts/echidna/EchidnaE2E.sol
    1 |     | pragma solidity ^0.8.0;
    2 |     | 
    3 |     | import "./Helper.sol";
    4 |     | import "solmate/tokens/WETH.sol";
    5 |     | import "../test/EchidnaERC20.sol";
    6 |     | import "../Hyper.sol";
    7 |     | import "../Enigma.sol" as ProcessingLib;
    8 |     | import "../../test/helpers/HelperHyperProfiles.sol" as DefaultValues;
    9 |     | import "../../test/helpers/HelperHyperView.sol";
   10 |     | import "./EchidnaStateHandling.sol";
   11 | *r  | 
   12 |     | contract EchidnaE2E is HelperHyperView, Helper, EchidnaStateHandling {
   13 |     |     WETH _weth;
   14 |     |     Hyper _hyper;
   15 |     | 
   16 |     |     constructor() public {
   17 |     |         _weth = new WETH();
   18 |     |         _hyper = new Hyper(address(_weth));
   19 |     |         EchidnaERC20 _asset = create_token("Asset Token", "ADEC6", 6);
   20 |     |         EchidnaERC20 _quote = create_token("Quote Token", "QDEC18", 18);
   21 |     |         add_created_hyper_token(_asset);
   22 |     |         add_created_hyper_token(_quote);
   23 |     |         create_pair_with_safe_preconditions(1, 2);
   24 |     |     }
   25 |     | 
   26 |     |     OS.AccountSystem hyperAccount;
   27 |     | 
   28 |     |     // ******************** Check Proper System Deployment ********************
   29 | *   |     function check_proper_deployment() public {
   30 | *   |         assert(address(_weth) != address(0));
   31 | *   |         assert(address(_hyper) != address(0));
   32 |     | 
   33 |     |         // Note: This invariant may break with tokens on hooks.
   34 | *   |         assert(_hyper.locked() == 1);
   35 |     | 
   36 |     |         // Retrieve the OS.__account__
   37 | *   |         (bool prepared, bool settled) = _hyper.__account__();
   38 | *   |         assert(!prepared);
   39 | *   |         assert(settled);
   40 |     | 
   41 | *   |         address[] memory warmTokens = _hyper.getWarm();
   42 | *   |         assert(warmTokens.length == 0);
   43 |     |     }
   44 |     | 
   45 |     |     // ******************** System wide Invariants ********************
   46 |     |     // The token balance of Hyper should be greater or equal to the reserve for all tokens
   47 |     |     // Note: assumption that pairs are created through create_pair invariant test
   48 |     |     // which will add the token to the hyperTokens list
   49 |     |     // this function is built so that extending the creation of new pairs should not require code changes here
   50 | *   |     function global_token_balance_greater_or_equal_reserves() public {
   51 | *   |         uint256 reserveBalance = 0;
   52 | *   |         uint256 tokenBalance = 0;
   53 | *   |         for (uint8 i = 0; i < EchidnaStateHandling.hyperTokens.length; i++) {
   54 | *   |             EchidnaERC20 token = EchidnaStateHandling.get_token_at_index(i);
   55 |     | 
   56 |     |             // retrieve reserves of the token and add to tracked reserve balance
   57 | *   |             reserveBalance = getReserve(address(_hyper), address(token));
   58 |     | 
   59 |     |             // get token balance and add to tracked token balance
   60 | *   |             tokenBalance = token.balanceOf(address(_hyper));
   61 |     | 
   62 | *   |             assert(tokenBalance >= reserveBalance);
   63 |     |         }
   64 |     |     }
   65 |     | 
   66 |     |     // ---------- HyperPair Properties -------
   67 | *r  |     function pair_asset_never_equal_to_quote(uint256 id) public {
   68 | *   |         uint24 pairId = retrieve_created_pair(id);
   69 |     | 
   70 | *   |         HyperPair memory pair = getPair(address(_hyper), pairId);
   71 | *   |         assert(pair.tokenAsset != pair.tokenQuote);
   72 |     |     }
   73 |     | 
   74 | *r  |     function pair_decimals_never_exceed_bounds(uint256 id) public {
   75 | *r  |         uint24 pairId = retrieve_created_pair(id);
   76 |     | 
   77 | *r  |         HyperPair memory pair = getPair(address(_hyper), pairId);
   78 | *r  |         assert(pair.decimalsAsset == EchidnaERC20(pair.tokenAsset).decimals());
   79 | *r  |         assert(pair.decimalsAsset >= 6);
   80 | *r  |         assert(pair.decimalsAsset <= 18);
   81 |     | 
   82 | *r  |         assert(pair.decimalsQuote == EchidnaERC20(pair.tokenQuote).decimals());
   83 | *   |         assert(pair.decimalsQuote >= 6);
   84 | *r  |         assert(pair.decimalsQuote <= 18);
   85 |     |     }
   86 |     | 
   87 |     |     // ---------- Pool Properties -------
   88 | *   |     function pool_fee_growth_greater_than_position_fee_growth() public {
   89 | *   |         for (uint8 i = 0; i < poolIds.length; i++) {
   90 | *   |             uint64 poolId = poolIds[i];
   91 | *   |             HyperPool memory pool = getPool(address(_hyper), poolId);
   92 |     |         }
   93 |     |     }
   94 |     | 
   95 | *r  |     function pool_non_zero_priority_fee_if_controlled(uint64 id) public {
   96 | *r  |         (HyperPool memory pool, , , ) = retrieve_random_pool_and_tokens(id);
   97 |     |         // if the pool has a controller, the priority fee should never be zero
   98 | *   |         emit LogBool("is mutable", pool.isMutable());
   99 | *   |         if (pool.controller != address(0)) {
  100 | *   |             if (pool.params.priorityFee == 0) {
  101 |     |                 emit LogUint256("priority feel value", pool.params.priorityFee);
  102 |     |                 emit AssertionFailed("BUG: Mutable pool has a non zero priority fee.");
  103 |     |             }
  104 |     |         }
  105 |     |     }
  106 |     | 
  107 | *r  |     function pool_last_price_not_greater_than_strike() public {
  108 | *r  |         for (uint8 i = 0; i < poolIds.length; i++) {
  109 | *r  |             uint64 poolId = poolIds[i];
  110 | *r  |             HyperPool memory pool = getPool(address(_hyper), poolId);
  111 | *r  |             HyperCurve memory curve = pool.params;
  112 |     | 
  113 | *r  |             emit LogUint256("pool's last price", pool.lastPrice);
  114 | *r  |             emit LogUint256("strike price", curve.strike());
  115 |     | 
  116 | *r  |             assert(pool.lastPrice <= curve.strike());
  117 |     |         }
  118 |     |     }
  119 |     | 
  120 |     |     // Strike price for a pool should never be zero.
  121 |     |     // If it is, it suggests the mispricing and/or incorrect rounding of assets.
  122 | *r  |     function pool_strike_price_non_zero() public {
  123 | *   |         for (uint8 i = 0; i < poolIds.length; i++) {
  124 | *   |             uint64 poolId = poolIds[i];
  125 | *   |             HyperPool memory pool = getPool(address(_hyper), poolId);
  126 | *   |             HyperCurve memory curve = pool.params;
  127 |     | 
  128 | *   |             emit LogUint256("pool's last price", pool.lastPrice);
  129 | *   |             emit LogUint256("strike price", curve.strike());
  130 |     | 
  131 | *   |             if (curve.strike() == 0) {
  132 |     |                 emit AssertionFailed("BUG: Strike price should never be 0.");
  133 |     |             }
  134 |     |         }
  135 |     |     }
  136 |     | 
  137 | *   |     function pool_maturity_never_less_last_timestamp() public {
  138 | *   |         for (uint8 i = 0; i < poolIds.length; i++) {
  139 | *   |             uint64 poolId = poolIds[i];
  140 | *   |             HyperPool memory pool = getPool(address(_hyper), poolId);
  141 | *   |             HyperCurve memory curve = pool.params;
  142 |     | 
  143 | *   |             emit LogUint256("hyper pool last timestamp: ", pool.lastTimestamp);
  144 | *   |             emit LogUint256("maturity", curve.maturity());
  145 |     | 
  146 | *   |             if (curve.maturity() < pool.lastTimestamp) {
  147 |     |                 emit AssertionFailed("BUG: curve maturity is less than last timestamp");
  148 |     |             }
  149 |     |         }
  150 |     |     }
  151 |     | 
  152 | *   |     function pool_non_zero_last_price_never_zero_liquidity() public {
  153 | *   |         for (uint8 i = 0; i < poolIds.length; i++) {
  154 | *   |             uint64 poolId = poolIds[i];
  155 |     | 
  156 | *   |             HyperPool memory pool = getPool(address(_hyper), poolId);
  157 | *   |             emit LogUint256("last timestamp", uint256(pool.lastTimestamp));
  158 |     | 
  159 | *   |             if (pool.lastPrice != 0) {
  160 | *   |                 emit LogUint256("pool's last price", pool.lastPrice);
  161 | *   |                 if (pool.liquidity == 0) {
  162 | *   |                     emit AssertionFailed("BUG: non zero last price should have a non zero liquidity");
  163 |     |                 }
  164 |     |             }
  165 |     |             //TODO: if pool.lastPrice == 0; pool.liquidity == 0?
  166 |     |         }
  167 |     |     }
  168 |     | 
  169 |     |     // TODO: remove if it's a false invariant
  170 |     |     // TODO: Add to iterate over all created-pools
  171 |     | 
  172 | *r  |     function pool_liquidity_delta_never_returns_zeroes(uint256 id, int128 deltaLiquidity) public {
  173 | *r  |         require(deltaLiquidity != 0);
  174 | *r  |         (
  175 | *r  |             HyperPool memory pool,
  176 | *r  |             uint64 poolId,
  177 | *r  |             EchidnaERC20 quote,
  178 | *r  |             EchidnaERC20 asset
  179 | *r  |         ) = retrieve_random_pool_and_tokens(id);
  180 |     | 
  181 | *r  |         emit LogInt128("deltaLiquidity", deltaLiquidity);
  182 |     | 
  183 | *r  |         (uint128 deltaAsset, uint128 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidity);
  184 | *   |         emit LogUint256("deltaAsset", deltaAsset);
  185 | *   |         if (deltaAsset == 0) {
  186 | *   |             emit AssertionFailed("BUG: getLiquidityDeltas returned 0 for deltaAsset");
  187 |     |         }
  188 | *   |         emit LogUint256("deltaQuote", deltaQuote);
  189 | *   |         if (deltaQuote == 0) {
  190 |     |             emit AssertionFailed("BUG: getLiquidityDeltas returned 0 for deltaQuote");
  191 |     |         }
  192 |     |     }
  193 |     | 
  194 |     |     // TODO: Find a better name here with `pool_` at the beginning
  195 |     | 
  196 | *   |     function check_hyper_curve_assumptions() public {
  197 | *   |         for (uint8 i = 0; i < poolIds.length; i++) {
  198 | *   |             uint64 poolId = poolIds[i];
  199 | *   |             HyperPool memory pool = getPool(address(_hyper), poolId);
  200 | *   |             HyperCurve memory curve = pool.params;
  201 |     | 
  202 | *   |             assert(curve.fee != 0);
  203 | *   |             assert(curve.priorityFee <= curve.fee);
  204 | *   |             assert(curve.duration != 0);
  205 | *   |             assert(curve.volatility >= MIN_VOLATILITY);
  206 | *   |             assert(curve.createdAt != 0);
  207 |     |         }
  208 |     |     }
  209 |     | 
  210 |     |     // TODO: Find a better name here with `pool_` at the beginning
  211 | *r  |     function check_hyper_pool_assumptions() public {
  212 | *   |         for (uint8 i = 0; i < poolIds.length; i++) {
  213 | *   |             uint64 poolId = poolIds[i];
  214 | *   |             HyperPool memory pool = getPool(address(_hyper), poolId);
  215 | *   |             HyperPair memory pair = pool.pair;
  216 |     | 
  217 |     |             // The `getVirtualReserves` method always returns values less than Hyper’s respective `getReserve` function for each token of the pool’s pair.
  218 |     | 
  219 |     |             // `getVirtualReserves method`
  220 | *   |             (uint128 deltaAsset, uint128 deltaQuote) = _hyper.getVirtualReserves(poolId);
  221 |     | 
  222 |     |             // Hyper's `getReserve` function for each of the pool's pair
  223 | *   |             uint256 assetReserves = _hyper.getReserve(pair.tokenAsset);
  224 | *   |             uint256 quoteReserves = _hyper.getReserve(pair.tokenQuote);
  225 |     | 
  226 | *   |             if (deltaAsset > assetReserves) {
  227 |     |                 emit LogUint256("deltaAsset", deltaAsset);
  228 |     |                 emit LogUint256("assetReserves", assetReserves);
  229 |     |                 emit AssertionFailed("BUG (`asset`): virtualReserves returned more than getReserve function");
  230 |     |             }
  231 | *   |             if (deltaQuote > quoteReserves) {
  232 |     |                 emit LogUint256("deltaQuote", deltaQuote);
  233 |     |                 emit LogUint256("quoteReserves", quoteReserves);
  234 |     |                 emit AssertionFailed("BUG (`asset`): virtualReserves returned more than getReserve function");
  235 |     |             }
  236 |     |         }
  237 |     |     }
  238 |     | 
  239 | *r  |     function pool_get_amounts_wad_returns_safe_bounds() public {
  240 |     |         // The `getAmountsWad` method always returns less than `1e18` for `amountAssetWad` and `pool.params.strike()` for `amountQuoteWad`.
  241 |     | 
  242 | *r  |         for (uint8 i = 0; i < poolIds.length; i++) {
  243 | *r  |             uint64 poolId = poolIds[i];
  244 | *r  |             HyperPool memory pool = getPool(address(_hyper), poolId);
  245 | *r  |             HyperCurve memory curve = pool.params;
  246 |     | 
  247 | *r  |             (uint256 amountAssetWad, uint256 amountQuoteWad) = pool.getAmountsWad();
  248 |     | 
  249 | *r  |             if (amountAssetWad > 1e18) {
  250 |     |                 emit LogUint256("amountAssetWad", amountAssetWad);
  251 |     |                 emit AssertionFailed("BUG amountAssetWad is greater than 1e18");
  252 |     |             }
  253 |     |             // Inclusive of strike price?
  254 | *r  |             if (amountQuoteWad > curve.strike()) {
  255 |     |                 emit LogUint256("amountQuoteWad", amountQuoteWad);
  256 |     |                 emit AssertionFailed("BUG amountQuoteWad is greater than strike");
  257 |     |             }
  258 |     |         }
  259 |     |     }
  260 |     | 
  261 | *r  |     function pool_get_amounts_returns_less_than_get_amounts_wad() public {
  262 |     |         // The `getAmounts` method always returns values less than or equal to `getAmountsWad`.
  263 |     | 
  264 | *r  |         for (uint8 i = 0; i < poolIds.length; i++) {
  265 | *r  |             uint64 poolId = poolIds[i];
  266 | *r  |             HyperPool memory pool = getPool(address(_hyper), poolId);
  267 | *r  |             HyperCurve memory curve = pool.params;
  268 |     | 
  269 | *r  |             (uint256 amountAssetDec, uint256 amountQuoteDec) = pool.getAmounts();
  270 |     | 
  271 | *r  |             (uint256 amountAssetWad, uint256 amountQuoteWad) = pool.getAmountsWad();
  272 |     | 
  273 |     |             // Assumes inclusivity of bounds (i.e: equivalence is okay)
  274 | *r  |             if (amountAssetDec > amountAssetWad) {
  275 |     |                 emit LogUint256("amountAssetDec", amountAssetDec);
  276 |     |                 emit LogUint256("amountAssetWad", amountAssetWad);
  277 |     |                 emit AssertionFailed("BUG (asset): getAmounts returned more than getAmountsWad");
  278 |     |             }
  279 |     |             // Assumes inclusivity of bounds (i.e: equivalence is okay)
  280 | *r  |             if (amountQuoteDec > amountQuoteWad) {
  281 |     |                 emit LogUint256("amountQuoteDec", amountQuoteDec);
  282 |     |                 emit LogUint256("amountQuoteWad", amountQuoteWad);
  283 |     |                 emit AssertionFailed("BUG (quote): getAmounts returned more than getAmountsWad");
  284 |     |             }
  285 |     |         }
  286 |     |     }
  287 |     | 
  288 |     |     // ******************** Create Pairs ********************
  289 |     |     /**
  290 |     |      * Future Invariant: This assumes that there is a single pair of _asset and _quote token
  291 |     |      *      - In the future, can be extended to deploy tokens from here and save the address in a list
  292 |     |      * 			which allows echidna to test against different pairs.
  293 |     |      * 			- Assumption: 1 pair for now.
  294 |     |      */
  295 | *   |     function create_token(
  296 |     |         string memory tokenName,
  297 |     |         string memory shortform,
  298 |     |         uint8 decimals
  299 | *   |     ) public returns (EchidnaERC20 token) {
  300 | *   |         token = new EchidnaERC20(tokenName, shortform, decimals, address(_hyper));
  301 | *   |         assert(token.decimals() == decimals);
  302 | *   |         if (decimals >= 6 && decimals <= 18) {
  303 | *   |             add_created_hyper_token(token);
  304 |     |         }
  305 |     |         return token;
  306 |     |     }
  307 |     | 
  308 |     |     /* Future Invariant: This could be extended to create arbitrary pairs. 
  309 |     |     For now for complexity, I am leaving as is. 
  310 |     |     Test overlapping token pairs
  311 |     |     */
  312 | *r  |     function create_pair_with_safe_preconditions(uint256 id1, uint256 id2) public {
  313 |     |         // retrieve an existing rpair of tokens that wee created with 6-18 decimals
  314 | *r  |         (EchidnaERC20 asset, EchidnaERC20 quote) = get_hyper_tokens(id1, id2);
  315 | *r  |         emit LogUint256("decimals asset", asset.decimals());
  316 | *r  |         emit LogUint256("decimals quote", quote.decimals());
  317 | *r  |         emit LogUint256("pair ID", uint256(_hyper.getPairId(address(asset), address(quote))));
  318 |     | 
  319 | *r  |         require(asset.decimals() >= 6 && asset.decimals() <= 18);
  320 | *r  |         require(quote.decimals() >= 6 && quote.decimals() <= 18);
  321 | *r  |         require(asset != quote);
  322 |     |         // require that this pair ID does not exist yet
  323 | *   |         if (_hyper.getPairId(address(asset), address(quote)) != 0) {
  324 | *   |             return;
  325 |     |         }
  326 |     |         // without this, Echidna may decide to call the EchidnaERC20.setDecimals
  327 | *   |         uint256 preCreationNonce = _hyper.getPairNonce();
  328 |     | 
  329 |     |         // encode createPair arguments and call hyper contract
  330 | *   |         bytes memory createPairData = ProcessingLib.encodeCreatePair(address(asset), address(quote));
  331 | *   |         (bool success, bytes memory err) = address(_hyper).call(createPairData);
  332 | *   |         if (!success) {
  333 |     |             emit LogBytes("error", err);
  334 |     |             emit AssertionFailed("FAILED");
  335 |     |         }
  336 |     | 
  337 | *   |         pair_id_saved_properly(address(asset), address(quote));
  338 |     | 
  339 | *   |         uint256 pairNonce = _hyper.getPairNonce();
  340 | *   |         assert(pairNonce == preCreationNonce + 1);
  341 |     |     }
  342 |     | 
  343 |     |     /**
  344 |     |      * Future Invariant: This can likely be extended to ensure that pairID's must always match backwards to the tokens saved
  345 |     |      */
  346 | *   |     function pair_id_saved_properly(address asset, address quote) private {
  347 |     |         // retrieve recently created pair ID
  348 | *   |         uint24 pairId = _hyper.getPairId(address(asset), address(quote));
  349 | *   |         if (pairId == 0) {
  350 |     |             emit LogUint256("PairId Exists", uint256(pairId));
  351 | *   |             assert(false);
  352 |     |         }
  353 |     | 
  354 |     |         // retrieve pair information and ensure pair was saved
  355 | *   |         HyperPair memory pair = getPair(address(_hyper), pairId);
  356 | *   |         assert(pair.tokenAsset == address(asset));
  357 | *   |         assert(pair.decimalsAsset == EchidnaERC20(asset).decimals());
  358 | *   |         assert(pair.tokenQuote == address(quote));
  359 | *   |         assert(pair.decimalsQuote == EchidnaERC20(quote).decimals());
  360 |     | 
  361 |     |         // save internal Echidna state to test against
  362 | *   |         save_pair_id(pairId);
  363 |     |     }
  364 |     | 
  365 | *r  |     function create_same_pair_should_fail() public {
  366 | *   |         EchidnaERC20 quote = create_token("Create same pair asset fail", "CSPF", 18);
  367 | *   |         bytes memory createPairData = ProcessingLib.encodeCreatePair(address(quote), address(quote));
  368 | *   |         (bool success, ) = address(_hyper).call(createPairData);
  369 | *   |         assert(!success);
  370 |     |     }
  371 |     | 
  372 | *r  |     function create_pair_with_less_than_min_decimals_should_fail(uint256 decimals) public {
  373 | *   |         decimals = uint8(between(decimals, 0, 5));
  374 | *   |         EchidnaERC20 testToken = create_token("create less min decimals asset fail", "CLMDF", uint8(decimals));
  375 | *   |         EchidnaERC20 quote = create_token("create less min decimals quote", "CLMDQ", 18);
  376 |     |         bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(quote));
  377 |     |         (bool success, ) = address(_hyper).call(createPairData);
  378 |     |         assert(!success);
  379 |     |     }
  380 |     | 
  381 | *   |     function create_pair_with_more_than_max_decimals_should_fail(uint256 decimals) public {
  382 | *   |         decimals = uint8(between(decimals, 19, type(uint8).max));
  383 | *   |         EchidnaERC20 testToken = create_token("Create more than max decimals fail", "CMTMF", uint8(decimals));
  384 | *   |         EchidnaERC20 quote = create_token("Create more than max decimals fail quote", "CMTMF2", 18);
  385 | *   |         bytes memory createPairData = ProcessingLib.encodeCreatePair(address(testToken), address(quote));
  386 | *   |         (bool success, ) = address(_hyper).call(createPairData);
  387 | *   |         assert(!success);
  388 |     |     }
  389 |     | 
  390 |     |     // ******************** Create Pool ********************
  391 |     |     // Create a non controlled pool (controller address is 0) with default pair
  392 |     |     // Note: This function can be extended to choose from any created pair and create a pool on top of it
  393 | *r  |     function create_non_controlled_pool(
  394 |     |         uint256 id,
  395 |     |         uint16 fee,
  396 |     |         int24 maxTick,
  397 |     |         uint16 volatility,
  398 |     |         uint16 duration,
  399 |     |         uint128 price
  400 | *r  |     ) public {
  401 | *r  |         uint24 pairId = retrieve_created_pair(uint256(id));
  402 |     |         {
  403 | *r  |             (, fee, maxTick, volatility, duration, , price) = clam_safe_create_bounds(
  404 | *r  |                 0,
  405 | *r  |                 fee,
  406 | *r  |                 maxTick,
  407 | *r  |                 volatility,
  408 | *r  |                 duration,
  409 | *r  |                 0,
  410 | *r  |                 price
  411 |     |             );
  412 |     |         }
  413 | *   |         bytes memory createPoolData = ProcessingLib.encodeCreatePool(
  414 | *   |             pairId,
  415 |     |             address(0), // no controller
  416 |     |             0, // no priority fee
  417 |     |             fee,
  418 |     |             volatility,
  419 |     |             duration,
  420 |     |             0, // no jit
  421 |     |             maxTick,
  422 |     |             price
  423 |     |         );
  424 | *r  |         {
  425 | *   |             (HyperPool memory pool, uint64 poolId) = execute_create_pool(pairId, createPoolData, false);
  426 | *   |             assert(!pool.isMutable());
  427 | *   |             HyperCurve memory curve = pool.params;
  428 | *   |             assert(pool.lastTimestamp == block.timestamp);
  429 | *   |             assert(pool.lastPrice == price);
  430 | *   |             assert(curve.createdAt == block.timestamp);
  431 | *   |             assert(pool.controller == address(0));
  432 | *   |             assert(curve.priorityFee == 0);
  433 | *   |             assert(curve.fee == fee);
  434 | *   |             assert(curve.volatility == volatility);
  435 | *   |             assert(curve.duration == duration);
  436 | *   |             assert(curve.jit == JUST_IN_TIME_LIQUIDITY_POLICY);
  437 | *r  |             assert(curve.maxTick == maxTick);
  438 |     |         }
  439 |     |     }
  440 |     | 
  441 |     |     function create_controlled_pool(
  442 |     |         uint256 id,
  443 |     |         uint16 priorityFee,
  444 |     |         uint16 fee,
  445 |     |         int24 maxTick,
  446 |     |         uint16 volatility,
  447 |     |         uint16 duration,
  448 |     |         uint16 jit,
  449 |     |         uint128 price
  450 |     |     ) public {
  451 |     |         uint24 pairId = retrieve_created_pair(id);
  452 |     |         {
  453 |     |             (priorityFee, fee, maxTick, volatility, duration, jit, price) = clam_safe_create_bounds(
  454 |     |                 priorityFee,
  455 |     |                 fee,
  456 |     |                 maxTick,
  457 |     |                 volatility,
  458 |     |                 duration,
  459 |     |                 jit,
  460 |     |                 price
  461 |     |             );
  462 |     |         }
  463 |     |         bytes memory createPoolData = ProcessingLib.encodeCreatePool(
  464 |     |             pairId,
  465 |     |             address(this), //controller
  466 |     |             priorityFee, // no priority fee
  467 |     |             fee,
  468 |     |             volatility,
  469 |     |             duration,
  470 |     |             jit, // no jit
  471 |     |             maxTick,
  472 |     |             price
  473 |     |         );
  474 |     |         {
  475 |     |             (HyperPool memory pool, uint64 poolId) = execute_create_pool(pairId, createPoolData, true);
  476 |     |             assert(pool.isMutable());
  477 |     |             HyperCurve memory curve = pool.params;
  478 |     |             assert(pool.lastTimestamp == block.timestamp);
  479 |     |             assert(curve.createdAt == block.timestamp);
  480 |     |             assert(pool.controller == address(this));
  481 |     |             assert(curve.priorityFee == priorityFee);
  482 |     |             assert(curve.fee == fee);
  483 |     |             assert(curve.volatility == volatility);
  484 |     |             assert(curve.duration == duration);
  485 |     |             assert(curve.jit == jit);
  486 |     |             assert(curve.maxTick == maxTick);
  487 |     |         }
  488 |     |     }
  489 |     | 
  490 | *r  |     function create_controlled_pool_with_zero_priority_fee_should_fail(
  491 |     |         uint256 id,
  492 |     |         uint16 fee,
  493 |     |         int24 maxTick,
  494 |     |         uint16 volatility,
  495 |     |         uint16 duration,
  496 |     |         uint16 jit,
  497 |     |         uint128 price
  498 |     |     ) public {
  499 | *r  |         uint24 pairId = retrieve_created_pair(id);
  500 | *r  |         uint16 priorityFee = 0;
  501 |     |         {
  502 | *r  |             (, fee, maxTick, volatility, duration, jit, price) = clam_safe_create_bounds(
  503 | *r  |                 priorityFee,
  504 | *r  |                 fee,
  505 | *r  |                 maxTick,
  506 | *r  |                 volatility,
  507 | *r  |                 duration,
  508 | *r  |                 jit,
  509 | *r  |                 price
  510 |     |             );
  511 |     |         }
  512 | *   |         bytes memory createPoolData = ProcessingLib.encodeCreatePool(
  513 | *   |             pairId,
  514 | *   |             address(this), //controller
  515 | *   |             priorityFee, // no priority fee
  516 |     |             fee,
  517 |     |             volatility,
  518 |     |             duration,
  519 |     |             jit, // no jit
  520 |     |             maxTick,
  521 |     |             price
  522 |     |         );
  523 | *   |         (bool success, ) = address(_hyper).call(createPoolData);
  524 | *   |         assert(!success);
  525 |     |     }
  526 |     | 
  527 | *r  |     function create_pool_with_negative_max_tick_as_bounds(
  528 |     |         uint256 id,
  529 |     |         uint16 priorityFee,
  530 |     |         uint16 fee,
  531 |     |         int24 maxTick,
  532 |     |         uint16 volatility,
  533 |     |         uint16 duration,
  534 |     |         uint16 jit,
  535 |     |         uint128 price
  536 | *   |     ) public {
  537 | *r  |         uint24 pairId = retrieve_created_pair(id);
  538 |     |         {
  539 | *r  |             (priorityFee, fee, maxTick, volatility, duration, jit, price) = clam_safe_create_bounds(
  540 | *r  |                 priorityFee,
  541 | *r  |                 fee,
  542 | *r  |                 maxTick,
  543 | *r  |                 volatility,
  544 | *r  |                 duration,
  545 | *r  |                 jit,
  546 | *r  |                 price
  547 |     |             );
  548 |     |         }
  549 | *   |         bytes memory createPoolData = ProcessingLib.encodeCreatePool(
  550 | *   |             pairId,
  551 | *   |             address(this), //controller
  552 |     |             priorityFee, // no priority fee
  553 |     |             fee,
  554 |     |             volatility,
  555 |     |             duration,
  556 |     |             jit, // no jit
  557 |     |             maxTick,
  558 |     |             price
  559 |     |         );
  560 | *   |         {
  561 | *   |             (HyperPool memory pool, uint64 poolId) = execute_create_pool(pairId, createPoolData, true);
  562 | *   |             assert(pool.isMutable());
  563 | *   |             HyperCurve memory curve = pool.params;
  564 | *   |             assert(pool.lastTimestamp == block.timestamp);
  565 | *   |             assert(curve.createdAt == block.timestamp);
  566 | *   |             assert(pool.controller == address(this));
  567 | *   |             assert(curve.priorityFee == priorityFee);
  568 | *   |             assert(curve.fee == fee);
  569 | *   |             assert(curve.volatility == volatility);
  570 | *   |             assert(curve.duration == duration);
  571 | *   |             assert(curve.jit == jit);
  572 | *   |             assert(curve.maxTick == maxTick);
  573 |     |         }
  574 |     |     }
  575 |     | 
  576 | *   |     function execute_create_pool(
  577 |     |         uint24 pairId,
  578 |     |         bytes memory createPoolData,
  579 |     |         bool hasController
  580 | *   |     ) private returns (HyperPool memory pool, uint64 poolId) {
  581 | *   |         uint256 preCreationPoolNonce = _hyper.getPoolNonce();
  582 | *   |         (bool success, ) = address(_hyper).call(createPoolData);
  583 |     | 
  584 |     |         // pool nonce should increase by 1 each time a pool is created
  585 | *   |         uint256 poolNonce = _hyper.getPoolNonce();
  586 | *   |         assert(poolNonce == preCreationPoolNonce + 1);
  587 |     | 
  588 |     |         // pool should be created and exist
  589 | *   |         poolId = ProcessingLib.encodePoolId(pairId, hasController, uint32(poolNonce));
  590 | *   |         pool = getPool(address(_hyper), poolId);
  591 | *   |         if (!pool.exists()) {
  592 |     |             emit AssertionFailed("BUG: Pool should return true on exists after being created.");
  593 |     |         }
  594 |     | 
  595 |     |         // save pools in Echidna
  596 |     |         save_pool_id(poolId);
  597 |     |     }
  598 |     | 
  599 |     |     // function check_decoding_pool_id(uint64 _poolId, uint24 _pairId, uint8 _isMutable, uint32 _poolNonce) private {
  600 |     | 
  601 |     |     //     (uint64 poolId, uint24 pairId, uint8 isMutable, uint32 poolNonce) = ProcessingLib.decodePoolId([_poolId,_pairId,_isMutable,_poolNonce]);
  602 |     | 
  603 |     |     // }
  604 |     | 
  605 |     |     // ******************** Change Pool Parameters ********************
  606 | r   |     function change_parameters(
  607 |     |         uint256 id,
  608 |     |         uint16 priorityFee,
  609 |     |         uint16 fee,
  610 |     |         int24 maxTick,
  611 |     |         uint16 volatility,
  612 |     |         uint16 duration,
  613 |     |         uint16 jit,
  614 |     |         uint128 price
  615 |     |     ) public {
  616 | r   |         (HyperPool memory preChangeState, uint64 poolId, , ) = retrieve_random_pool_and_tokens(id);
  617 | r   |         emit LogUint256("created pools", poolIds.length);
  618 | r   |         emit LogUint256("pool ID", uint256(poolId));
  619 | r   |         require(preChangeState.isMutable());
  620 |     |         require(preChangeState.controller == address(this));
  621 |     |         {
  622 |     |             // scaling remaining pool creation values
  623 |     |             fee = uint16(between(fee, MIN_FEE, MAX_FEE));
  624 |     |             priorityFee = uint16(between(priorityFee, 1, fee));
  625 |     |             volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
  626 |     |             duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
  627 |     |             maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
  628 |     |             jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
  629 |     |             price = uint128(between(price, 1, type(uint128).max)); // price is between 1-uint256.max
  630 |     |         }
  631 |     | 
  632 |     |         _hyper.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
  633 |     |         {
  634 |     |             (HyperPool memory postChangeState, , , ) = retrieve_random_pool_and_tokens(id);
  635 |     |             HyperCurve memory preChangeCurve = preChangeState.params;
  636 |     |             HyperCurve memory postChangeCurve = postChangeState.params;
  637 |     |             assert(postChangeState.lastTimestamp == preChangeState.lastTimestamp);
  638 |     |             assert(postChangeState.controller == address(this));
  639 |     |             assert(postChangeCurve.createdAt == preChangeCurve.createdAt);
  640 |     |             assert(postChangeCurve.priorityFee == priorityFee);
  641 |     |             assert(postChangeCurve.fee == fee);
  642 |     |             assert(postChangeCurve.volatility == volatility);
  643 |     |             assert(postChangeCurve.duration == duration);
  644 |     |             assert(postChangeCurve.jit == jit);
  645 |     |             assert(postChangeCurve.maxTick == maxTick);
  646 |     |         }
  647 |     |     }
  648 |     | 
  649 |     |     // Invariant: Attempting to change parameters of a nonmutable pool should fail
  650 | r   |     function change_parameters_to_non_mutable_pool_should_fail(
  651 |     |         uint256 id,
  652 |     |         uint16 priorityFee,
  653 |     |         uint16 fee,
  654 |     |         int24 maxTick,
  655 |     |         uint16 volatility,
  656 |     |         uint16 duration,
  657 |     |         uint16 jit,
  658 |     |         uint128 price
  659 |     |     ) public {
  660 | r   |         (HyperPool memory preChangeState, uint64 poolId, , ) = retrieve_random_pool_and_tokens(id);
  661 | r   |         emit LogUint256("created pools", poolIds.length);
  662 | r   |         emit LogUint256("pool ID", uint256(poolId));
  663 | r   |         require(!preChangeState.isMutable());
  664 | r   |         require(preChangeState.controller == address(this));
  665 |     |         {
  666 |     |             // scaling remaining pool creation values
  667 |     |             fee = uint16(between(fee, MIN_FEE, MAX_FEE));
  668 |     |             priorityFee = uint16(between(priorityFee, 1, fee));
  669 |     |             volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
  670 |     |             duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
  671 |     |             maxTick = (-MAX_TICK) + (maxTick % (MAX_TICK - (-MAX_TICK))); // [-MAX_TICK,MAX_TICK]
  672 |     |             jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
  673 |     |             price = uint128(between(price, 1, type(uint128).max)); // price is between 1-uint256.max
  674 |     |         }
  675 |     | 
  676 |     |         try _hyper.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick) {
  677 |     |             emit AssertionFailed("BUG: Changing pool parameters of a nonmutable pool should not be possible");
  678 |     |         } catch {}
  679 |     |     }
  680 |     | 
  681 |     |     // Invariant: Attempting to change parameters by a non-controller should fail
  682 |     |     // ******************** Funding ********************
  683 |     | 
  684 | *r  |     function fund_with_correct_preconditions_should_succeed(uint256 assetAmount, uint256 quoteAmount) public {
  685 |     |         // asset and quote amount > 1
  686 | *r  |         assetAmount = between(assetAmount, 1, type(uint64).max);
  687 | *r  |         quoteAmount = between(quoteAmount, 1, type(uint64).max);
  688 |     | 
  689 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);
  690 |     | 
  691 | *r  |         emit LogUint256("assetAmount", assetAmount);
  692 | *r  |         emit LogUint256("quoteAmount", quoteAmount);
  693 | *r  |         mint_and_approve(_asset, assetAmount);
  694 | *r  |         mint_and_approve(_quote, quoteAmount);
  695 |     | 
  696 | *   |         if (_asset.balanceOf(address(this)) < assetAmount) {
  697 |     |             emit LogUint256("asset balance", _asset.balanceOf(address(this)));
  698 |     |         }
  699 | *   |         if (_quote.balanceOf(address(this)) < quoteAmount) {
  700 |     |             emit LogUint256("quote balance", _quote.balanceOf(address(this)));
  701 |     |         }
  702 |     | 
  703 | *   |         fund_token(address(_asset), assetAmount);
  704 | *   |         fund_token(address(_quote), quoteAmount);
  705 |     |     }
  706 |     | 
  707 | *r  |     function fund_with_insufficient_funds_should_fail(uint256 assetAmount, uint256 quoteAmount) public {
  708 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);
  709 |     | 
  710 | *   |         assetAmount = between(assetAmount, 1, type(uint256).max);
  711 | *   |         quoteAmount = between(quoteAmount, 1, type(uint256).max);
  712 |     | 
  713 | *   |         try _hyper.fund(address(_asset), assetAmount) {
  714 | *   |             emit AssertionFailed("BUG: Funding with insufficient asset should fail");
  715 |     |         } catch {}
  716 |     | 
  717 | *   |         try _hyper.fund(address(_quote), quoteAmount) {
  718 |     |             emit AssertionFailed("Funding with insufficient quote should fail");
  719 |     |         } catch {}
  720 |     |     }
  721 |     | 
  722 | *r  |     function fund_with_insufficient_allowance_should_fail(uint256 id, uint256 fundAmount) public {
  723 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(id, fundAmount);
  724 |     | 
  725 | *r  |         uint256 smallAssetAllowance = between(fundAmount, 1, fundAmount - 1);
  726 |     | 
  727 |     |         // mint the asset to address(this) and approve some amount < fund
  728 | *r  |         _asset.mint(address(this), fundAmount);
  729 | *r  |         _asset.approve(address(_hyper), smallAssetAllowance);
  730 | *r  |         try _hyper.fund(address(_asset), fundAmount) {
  731 |     |             emit LogUint256("small asset allowance", smallAssetAllowance);
  732 |     |             emit AssertionFailed("BUG: insufficient allowance on asset should fail.");
  733 |     |         } catch {}
  734 |     | 
  735 |     |         // mint the quote token to address(this), approve some amount < fund
  736 | *r  |         _quote.mint(address(this), fundAmount);
  737 | *   |         _quote.approve(address(_hyper), smallAssetAllowance);
  738 | *   |         try _hyper.fund(address(_quote), fundAmount) {
  739 |     |             emit LogUint256("small quote allowance", smallAssetAllowance);
  740 |     |             emit AssertionFailed("BUG: insufficient allowance on quote should fail.");
  741 |     |         } catch {}
  742 |     |     }
  743 |     | 
  744 | *r  |     function fund_with_zero(uint256 id1, uint256 id2) public {
  745 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(id1, id2);
  746 |     | 
  747 | *   |         mint_and_approve(_asset, 0);
  748 | *   |         mint_and_approve(_quote, 0);
  749 | *   |         _hyper.fund(address(_asset), 0);
  750 | *   |         _hyper.fund(address(_quote), 0);
  751 |     |     }
  752 |     | 
  753 | *   |     function fund_token(address token, uint256 amount) private returns (bool) {
  754 |     |         // TODO Refactor: reuse the HelperHyperView.getState() keeps this cleaner
  755 | *   |         uint256 senderBalancePreFund = EchidnaERC20(token).balanceOf(address(this));
  756 | *   |         uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(token));
  757 | *   |         uint256 reservePreFund = getReserve(address(_hyper), address(token));
  758 | *   |         uint256 hyperBalancePreFund = EchidnaERC20(token).balanceOf(address(_hyper));
  759 |     | 
  760 | *   |         try _hyper.fund(address(token), amount) {} catch (bytes memory error) {
  761 |     |             emit LogBytes("error", error);
  762 |     |             assert(false);
  763 |     |         }
  764 |     | 
  765 |     |         // sender's token balance should decrease
  766 |     |         // usdc sender pre token balance = 100 ; usdc sender post token = 100 - 1
  767 | *   |         uint256 senderBalancePostFund = EchidnaERC20(token).balanceOf(address(this));
  768 | *   |         if (senderBalancePostFund != senderBalancePreFund - amount) {
  769 |     |             emit LogUint256("postTransfer sender balance", senderBalancePostFund);
  770 |     |             emit LogUint256("preTransfer:", senderBalancePreFund);
  771 |     |             emit AssertionFailed("BUG: Sender balance of token did not decrease by amount after funding");
  772 |     |         }
  773 |     |         // hyper balance of the sender should increase
  774 |     |         // pre hyper balance = a; post hyperbalance + 100
  775 | *   |         uint256 virtualBalancePostFund = getBalance(address(_hyper), address(this), address(token));
  776 | *   |         if (virtualBalancePostFund != virtualBalancePreFund + amount) {
  777 |     |             emit LogUint256("tracked balance after funding", virtualBalancePostFund);
  778 |     |             emit LogUint256("tracked balance before funding:", virtualBalancePreFund);
  779 |     |             emit AssertionFailed("BUG: Tracked balance of sender did not increase after funding");
  780 |     |         }
  781 |     |         // hyper reserves for token should increase
  782 |     |         // reserve balance = b; post reserves + 100
  783 | *   |         uint256 reservePostFund = getReserve(address(_hyper), address(token));
  784 | *   |         if (reservePostFund != reservePreFund + amount) {
  785 |     |             emit LogUint256("reserve after funding", reservePostFund);
  786 |     |             emit LogUint256("reserve balance before funding:", reservePreFund);
  787 |     |             emit AssertionFailed("BUG: Reserve of hyper did not increase after funding");
  788 |     |         }
  789 |     |         // hyper's token balance should increase
  790 |     |         // pre balance of usdc = y; post balance = y + 100
  791 | *   |         uint256 hyperBalancePostFund = EchidnaERC20(token).balanceOf(address(_hyper));
  792 | *   |         if (hyperBalancePostFund != hyperBalancePreFund + amount) {
  793 |     |             emit LogUint256("hyper token balance after funding", hyperBalancePostFund);
  794 |     |             emit LogUint256("hyper balance before funding:", hyperBalancePreFund);
  795 |     |             emit AssertionFailed("BUG: Hyper token balance did not increase after funding");
  796 |     |         }
  797 | *   |         return true;
  798 |     |     }
  799 |     | 
  800 | *r  |     function mint_and_approve(EchidnaERC20 token, uint256 amount) private {
  801 | *r  |         token.mint(address(this), amount);
  802 | *r  |         token.approve(address(_hyper), type(uint256).max);
  803 |     |     }
  804 |     | 
  805 |     |     // ******************** Draw ********************
  806 | *r  |     function draw_should_succeed(uint256 assetAmount, uint256 quoteAmount, address recipient) public {
  807 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);
  808 |     | 
  809 | *r  |         assetAmount = between(assetAmount, 1, type(uint64).max);
  810 | *r  |         quoteAmount = between(quoteAmount, 1, type(uint64).max);
  811 | *r  |         emit LogUint256("asset amount: ", assetAmount);
  812 | *r  |         emit LogUint256("quote amount:", quoteAmount);
  813 |     | 
  814 | *r  |         require(recipient != address(_hyper));
  815 | *r  |         require(recipient != address(0));
  816 |     | 
  817 | *r  |         draw_token(address(_asset), assetAmount, recipient);
  818 | *r  |         draw_token(address(_quote), quoteAmount, recipient);
  819 |     |     }
  820 |     | 
  821 | *r  |     function draw_token(address token, uint256 amount, address recipient) private {
  822 |     |         // make sure a user has funded already
  823 | *r  |         uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(token));
  824 | *r  |         require(virtualBalancePreFund > 0);
  825 | *r  |         amount = between(amount, 1, virtualBalancePreFund);
  826 |     | 
  827 | *r  |         uint256 recipientBalancePreFund = EchidnaERC20(token).balanceOf(address(recipient));
  828 | *r  |         uint256 reservePreFund = getReserve(address(_hyper), address(token));
  829 | *r  |         uint256 hyperBalancePreFund = EchidnaERC20(token).balanceOf(address(_hyper));
  830 |     | 
  831 | *r  |         _hyper.draw(token, amount, recipient);
  832 |     | 
  833 |     |         //-- Postconditions
  834 |     |         // caller balance should decrease
  835 |     |         // pre caller balance = a; post caller balance = a - 100
  836 | *r  |         uint256 virtualBalancePostFund = getBalance(address(_hyper), address(this), address(token));
  837 | *r  |         if (virtualBalancePostFund != virtualBalancePreFund - amount) {
  838 |     |             emit LogUint256("virtual balance post draw", virtualBalancePostFund);
  839 |     |             emit LogUint256("virtual balance pre draw", virtualBalancePreFund);
  840 |     |             emit AssertionFailed("BUG: virtual balance should decrease after drawing tokens");
  841 |     |         }
  842 |     |         // reserves should decrease
  843 | *r  |         uint256 reservePostFund = getReserve(address(_hyper), address(token));
  844 | *r  |         if (reservePostFund != reservePreFund - amount) {
  845 |     |             emit LogUint256("reserve post draw", reservePostFund);
  846 |     |             emit LogUint256("reserve pre draw", reservePreFund);
  847 |     |             emit AssertionFailed("BUG: reserve balance should decrease after drawing tokens");
  848 |     |         }
  849 |     |         // to address should increase
  850 |     |         // pre-token balance = a; post-token = a + 100
  851 | *r  |         uint256 recipientBalancePostFund = EchidnaERC20(token).balanceOf(address(recipient));
  852 | *r  |         if (recipientBalancePostFund != recipientBalancePreFund + amount) {
  853 |     |             emit LogUint256("recipient balance post draw", recipientBalancePostFund);
  854 |     |             emit LogUint256("recipient balance pre draw", recipientBalancePreFund);
  855 |     |             emit AssertionFailed("BUG: recipient balance should increase after drawing tokens");
  856 |     |         }
  857 |     |         // hyper token's balance should decrease
  858 | *r  |         uint256 tokenPostFund = EchidnaERC20(token).balanceOf(address(_hyper));
  859 | *r  |         if (tokenPostFund != hyperBalancePreFund - amount) {
  860 |     |             emit LogUint256("token post draw", tokenPostFund);
  861 |     |             emit LogUint256("token pre draw", hyperBalancePreFund);
  862 |     |             emit AssertionFailed("BUG: hyper token balance should increase after drawing tokens");
  863 |     |         }
  864 |     |     }
  865 |     | 
  866 | *r  |     function draw_to_zero_should_fail(uint256 assetAmount, uint256 quoteAmount) public {
  867 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(assetAmount, quoteAmount);
  868 |     | 
  869 |     |         // make sure a user has funded already
  870 | *r  |         uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(_asset));
  871 | *r  |         emit LogUint256("virtual balance pre fund", virtualBalancePreFund);
  872 |     |         require(virtualBalancePreFund >= 0);
  873 | *r  |         assetAmount = between(assetAmount, 1, virtualBalancePreFund);
  874 |     | 
  875 | *   |         try _hyper.draw(address(_asset), assetAmount, address(0)) {
  876 |     |             emit AssertionFailed("BUG: draw should fail attempting to transfer to zero");
  877 |     |         } catch {}
  878 |     |     }
  879 |     | 
  880 | *r  |     function fund_then_draw(uint256 whichToken, uint256 amount) public {
  881 | *r  |         (EchidnaERC20 _asset, EchidnaERC20 _quote) = get_hyper_tokens(amount, whichToken);
  882 |     | 
  883 |     |         // this can be extended to use the token list in `hyperTokens`
  884 | *r  |         address token;
  885 | *r  |         if (whichToken % 2 == 0) token = address(_asset);
  886 | *r  |         else token = address(_quote);
  887 |     | 
  888 | *r  |         mint_and_approve(_asset, amount);
  889 | *r  |         mint_and_approve(_quote, amount);
  890 |     | 
  891 | *r  |         uint256 hyperBalancePreFund = EchidnaERC20(token).balanceOf(address(_hyper));
  892 | *r  |         require(hyperBalancePreFund == 0);
  893 |     | 
  894 | *r  |         uint256 virtualBalancePreFund = getBalance(address(_hyper), address(this), address(token));
  895 | *r  |         uint256 recipientBalancePreFund = EchidnaERC20(token).balanceOf(address(this));
  896 | *r  |         uint256 reservePreFund = getReserve(address(_hyper), address(token));
  897 |     | 
  898 |     |         // Call fund and draw
  899 | *r  |         _hyper.fund(token, amount);
  900 | *   |         _hyper.draw(token, amount, address(this));
  901 |     | 
  902 |     |         //-- Postconditions
  903 |     |         // caller balance should be equal
  904 |     | 
  905 |     |         //TODO Refactor: use HelperHyperView.getState() here
  906 | *   |         uint256 virtualBalancePostFund = getBalance(address(_hyper), address(this), address(token));
  907 | *   |         if (virtualBalancePostFund != virtualBalancePreFund) {
  908 |     |             emit LogUint256("virtual balance post fund-draw", virtualBalancePostFund);
  909 |     |             emit LogUint256("virtual balance pre fund-draw", virtualBalancePreFund);
  910 |     |             emit AssertionFailed("BUG: virtual balance should be equal after fund-draw");
  911 |     |         }
  912 |     |         // reserves should be equal
  913 | *   |         uint256 reservePostFund = getReserve(address(_hyper), address(token));
  914 | *   |         if (reservePostFund != reservePreFund) {
  915 |     |             emit LogUint256("reserve post fund-draw", reservePostFund);
  916 |     |             emit LogUint256("reserve pre fund-draw", reservePreFund);
  917 |     |             emit AssertionFailed("BUG: reserve balance should be equal after fund-draw");
  918 |     |         }
  919 |     |         // recipient = sender balance should be equal
  920 | *   |         uint256 recipientBalancePostFund = EchidnaERC20(token).balanceOf(address(this));
  921 | *   |         if (recipientBalancePostFund != recipientBalancePreFund) {
  922 |     |             emit LogUint256("recipient balance post fund-draw", recipientBalancePostFund);
  923 |     |             emit LogUint256("recipient balance pre fund-draw", recipientBalancePreFund);
  924 |     |             emit AssertionFailed("BUG: recipient balance should be equal after fund-draw");
  925 |     |         }
  926 |     |         // hyper token's balance should be equal
  927 | *   |         uint256 tokenPostFund = EchidnaERC20(token).balanceOf(address(_hyper));
  928 | *   |         if (tokenPostFund != hyperBalancePreFund) {
  929 |     |             emit LogUint256("token post fund-draw", tokenPostFund);
  930 |     |             emit LogUint256("token pre fund-draw", hyperBalancePreFund);
  931 |     |             emit AssertionFailed("BUG: hyper token balance should be equal after fund-draw");
  932 |     |         }
  933 |     |     }
  934 |     | 
  935 |     |     // ******************** Deposits ********************
  936 |     | 
  937 | *r  |     function deposit_with_correct_postconditions_should_succeed() public payable {
  938 | *r  |         require(msg.value > 0);
  939 | *   |         emit LogUint256("msg.value", msg.value);
  940 |     | 
  941 | *   |         uint256 thisEthBalancePre = address(this).balance;
  942 | *   |         uint256 reserveBalancePre = getReserve(address(_hyper), address(_weth));
  943 | *   |         uint256 wethBalancePre = _weth.balanceOf(address(_hyper));
  944 |     | 
  945 | *   |         try _hyper.deposit{value: msg.value}() {
  946 | *   |             uint256 thisEthBalancePost = address(this).balance;
  947 | *   |             uint256 reserveBalancePost = getReserve(address(_hyper), address(_weth));
  948 | *   |             uint256 wethBalancePost = _weth.balanceOf(address(_hyper));
  949 |     |             // Eth balance of this contract should decrease by the deposited amount
  950 | *   |             if (thisEthBalancePost != thisEthBalancePre - msg.value) {
  951 |     |                 emit LogUint256("eth balance post transfer (sender)", thisEthBalancePost);
  952 |     |                 emit LogUint256("eth balance pre transfer (sender)", thisEthBalancePre);
  953 |     |                 emit AssertionFailed("sender's eth balance should not change.");
  954 |     |             }
  955 |     |             // Hyper reserve of WETH should increase by msg.value
  956 | *   |             if (reserveBalancePost != reserveBalancePre + msg.value) {
  957 |     |                 emit LogUint256("weth reserve post transfer (hyper)", reserveBalancePost);
  958 |     |                 emit LogUint256("weth reserve pre transfer (hyper)", reserveBalancePre);
  959 |     |                 emit AssertionFailed("hyper's weth reserve should increase by added amount.");
  960 |     |             }
  961 |     |             // Hyper balance of WETH should increase by msg.value
  962 | *   |             if (wethBalancePost != wethBalancePre + msg.value) {
  963 |     |                 emit LogUint256("weth balance post transfer (hyper)", wethBalancePost);
  964 |     |                 emit LogUint256("weth balance pre transfer (hyper)", wethBalancePre);
  965 |     |                 emit AssertionFailed("hypers's weth balance should increase by added amount.");
  966 |     |             }
  967 |     |         } catch (bytes memory err) {
  968 |     |             emit LogBytes("error", err);
  969 |     |             emit AssertionFailed("BUG: deposit should not have failed.");
  970 |     |         }
  971 |     |     }
  972 |     | 
  973 |     |     using SafeCastLib for uint256;
  974 |     | 
  975 |     |     // ******************** Claim ********************
  976 | *r  |     function claim_should_succeed_with_correct_preconditions(
  977 |     |         uint256 id,
  978 |     |         uint256 deltaAsset,
  979 |     |         uint256 deltaQuote
  980 | *   |     ) public {
  981 | r   |         (
  982 | r   |             HyperPool memory pool,
  983 | r   |             uint64 poolId,
  984 | r   |             EchidnaERC20 _asset,
  985 | r   |             EchidnaERC20 _quote
  986 | r   |         ) = retrieve_random_pool_and_tokens(id);
  987 | r   |         emit LogUint256("pool id:", uint256(poolId));
  988 |     | 
  989 | r   |         HyperPosition memory preClaimPosition = getPosition(address(_hyper), address(this), poolId);
  990 | r   |         require(preClaimPosition.lastTimestamp != 0);
  991 |     | 
  992 | *   |         try _hyper.claim(poolId, deltaAsset, deltaQuote) {
  993 |     |             // if tokens were owned, decrement from position
  994 |     |             // if tokens were owed, getBalance of tokens increased for the caller
  995 |     |         } catch {
  996 |     |             emit AssertionFailed("BUG: claim function should have succeeded");
  997 |     |         }
  998 |     |     }
  999 |     | 
 1000 |     |     // Future invariant: Funding with WETH and then depositing with ETH should have the same impact on the pool
 1001 |     |     // ******************** Allocate ********************
 1002 | *r  |     function allocate_should_succeed_with_correct_preconditions(uint256 id, uint256 deltaLiquidity) public {
 1003 | *r  |         (
 1004 | *r  |             HyperPool memory pool,
 1005 | *r  |             uint64 poolId,
 1006 | *r  |             EchidnaERC20 _asset,
 1007 | *r  |             EchidnaERC20 _quote
 1008 | *r  |         ) = retrieve_random_pool_and_tokens(id);
 1009 | *r  |         emit LogUint256("pool id:", uint256(poolId));
 1010 |     | 
 1011 | *r  |         require(pool.lastPrice != 0);
 1012 | *r  |         require(pool.lastTimestamp != 0);
 1013 |     | 
 1014 |     |         // ensures deltaLiquidity is never zero
 1015 | *r  |         deltaLiquidity = between(deltaLiquidity, 1, type(uint256).max);
 1016 | *r  |         if (deltaLiquidity == type(uint256).max) {
 1017 |     |             deltaLiquidity = 1;
 1018 |     |         } else {
 1019 | *r  |             deltaLiquidity = uint128(deltaLiquidity);
 1020 |     |         }
 1021 |     | 
 1022 | *r  |         int128 deltaLiquidityInt = convertToInt128(uint128(deltaLiquidity));
 1023 | *r  |         (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidityInt);
 1024 |     | 
 1025 | *   |         emit LogUint256("delta asset:", deltaAsset);
 1026 | *   |         emit LogUint256("delta quote:", deltaQuote);
 1027 | *   |         emit LogUint256("deltaLiquidity", deltaLiquidity);
 1028 |     | 
 1029 | *   |         execute_allocate_call(poolId, _asset, _quote, deltaAsset, deltaQuote, deltaLiquidity);
 1030 |     |     }
 1031 |     | 
 1032 | *r  |     function execute_allocate_call(
 1033 |     |         uint64 poolId,
 1034 |     |         EchidnaERC20 _asset,
 1035 |     |         EchidnaERC20 _quote,
 1036 |     |         uint256 deltaAsset,
 1037 |     |         uint256 deltaQuote,
 1038 |     |         uint256 deltaLiquidity
 1039 |     |     ) internal {
 1040 |     |         // Caller must have a balance and have approved hyper
 1041 | *r  |         mint_and_approve(_asset, deltaAsset);
 1042 | *r  |         mint_and_approve(_quote, deltaQuote);
 1043 |     | 
 1044 | *r  |         address[] memory owners = new address[](1);
 1045 |     | 
 1046 |     |         // Save pre allocation state
 1047 | *r  |         HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);
 1048 |     | 
 1049 | *r  |         (uint256 allocateAsset, uint256 allocateQuote) = _hyper.allocate(poolId, deltaLiquidity);
 1050 | *r  |         emit LogUint256("allocate asset return", allocateAsset);
 1051 | *r  |         emit LogUint256("allocate quote return", allocateQuote);
 1052 |     | 
 1053 | *r  |         HyperState memory postState = getState(address(_hyper), poolId, address(this), owners);
 1054 |     |         {
 1055 |     |             // Reserves in both tokens should increase
 1056 | *r  |             if (preState.reserveAsset + deltaAsset != postState.reserveAsset) {
 1057 |     |                 emit LogUint256("pre allocate reserve asset", preState.reserveAsset);
 1058 |     |                 emit LogUint256("post allocate reserve asset", postState.reserveAsset);
 1059 |     |                 emit AssertionFailed("BUG: Reserve asset did not increase by deltaAsset");
 1060 |     |             }
 1061 | *r  |             if (preState.reserveQuote + deltaQuote != postState.reserveQuote) {
 1062 |     |                 emit LogUint256("pre allocate reserve quote", preState.reserveQuote);
 1063 |     |                 emit LogUint256("post allocate reserve quote", postState.reserveQuote);
 1064 |     |                 emit AssertionFailed("BUG: Reserve quote did not increase by deltaQuote");
 1065 |     |             }
 1066 |     |             // Total pool liquidity should increase by deltaLiquidity
 1067 | *r  |             if (preState.totalPoolLiquidity + deltaLiquidity != postState.totalPoolLiquidity) {
 1068 |     |                 emit LogUint256("pre allocate total pool liqudity", preState.totalPoolLiquidity);
 1069 |     |                 emit LogUint256("post allocate total pool liquidity", postState.totalPoolLiquidity);
 1070 |     |                 emit AssertionFailed("BUG: Total liquidity did not increase by deltaLiquidity");
 1071 |     |             }
 1072 |     |             // Physical asset balance of both tokens should increase
 1073 | *r  |             assert(preState.physicalBalanceAsset + deltaAsset == postState.physicalBalanceAsset);
 1074 | *r  |             assert(preState.physicalBalanceQuote + deltaQuote == postState.physicalBalanceQuote);
 1075 | *r  |             assert(preState.callerPositionLiquidity + deltaLiquidity == postState.callerPositionLiquidity);
 1076 |     |         }
 1077 |     |         {
 1078 | *r  |             if (preState.feeGrowthAssetPool != postState.feeGrowthAssetPool) {
 1079 | *r  |                 assert(postState.feeGrowthAssetPosition != 0);
 1080 |     |             }
 1081 | *r  |             if (preState.feeGrowthQuotePool != postState.feeGrowthQuotePool) {
 1082 |     |                 assert(postState.feeGrowthQuotePosition != 0);
 1083 |     |             }
 1084 |     |         }
 1085 |     |     }
 1086 |     | 
 1087 | r   |     function allocate_with_non_existent_pool_should_fail(uint256 id, uint256 deltaLiquidity) public {
 1088 | r   |         (
 1089 | r   |             HyperPool memory pool,
 1090 | r   |             uint64 poolId,
 1091 | r   |             EchidnaERC20 _asset,
 1092 | r   |             EchidnaERC20 _quote
 1093 | r   |         ) = retrieve_random_pool_and_tokens(id);
 1094 |     | 
 1095 | r   |         address[] memory owners = new address[](1);
 1096 | r   |         require(!is_created_pool(poolId)); // require pool does not exist
 1097 |     |         emit LogUint256("pool id:", uint256(poolId));
 1098 |     | 
 1099 |     |         deltaLiquidity = between(deltaLiquidity, 1, type(uint256).max);
 1100 |     |         if (deltaLiquidity == type(uint256).max) {
 1101 |     |             deltaLiquidity = 1;
 1102 |     |         } else {
 1103 |     |             deltaLiquidity = uint128(deltaLiquidity);
 1104 |     |         }
 1105 |     | 
 1106 |     |         int128 deltaLiquidityInt = convertToInt128(uint128(deltaLiquidity));
 1107 |     |         (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidityInt);
 1108 |     | 
 1109 |     |         emit LogUint256("delta asset:", deltaAsset);
 1110 |     |         emit LogUint256("delta quote:", deltaQuote);
 1111 |     |         emit LogUint256("deltaLiquidity", deltaLiquidity);
 1112 |     | 
 1113 |     |         // Caller must have a balance and have approved hyper
 1114 |     |         mint_and_approve(_asset, deltaAsset);
 1115 |     |         mint_and_approve(_quote, deltaQuote);
 1116 |     | 
 1117 |     |         // Save pre allocation state
 1118 |     |         HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);
 1119 |     | 
 1120 |     |         try _hyper.allocate(poolId, deltaLiquidity) returns (uint256 allocateAset, uint256 allocateQuote) {
 1121 |     |             emit AssertionFailed("BUG: allocate with non existent pool should fail");
 1122 |     |         } catch {}
 1123 |     |     }
 1124 |     | 
 1125 | *r  |     function allocate_with_zero_delta_liquidity_should_fail(uint256 id) public {
 1126 | *r  |         address[] memory owners = new address[](1);
 1127 | *   |         (
 1128 | *r  |             HyperPool memory pool,
 1129 | *r  |             uint64 poolId,
 1130 | *r  |             EchidnaERC20 _asset,
 1131 | *r  |             EchidnaERC20 _quote
 1132 | *r  |         ) = retrieve_random_pool_and_tokens(id);
 1133 | *   |         emit LogUint256("pool id:", uint256(poolId));
 1134 |     | 
 1135 | *   |         require(pool.lastPrice != 0);
 1136 | *   |         require(pool.lastTimestamp != 0);
 1137 |     | 
 1138 | *   |         uint128 deltaLiquidity = 0;
 1139 |     | 
 1140 | *   |         int128 deltaLiquidityInt = convertToInt128(uint128(deltaLiquidity));
 1141 | *   |         (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, deltaLiquidityInt);
 1142 |     | 
 1143 | *   |         emit LogUint256("delta asset:", deltaAsset);
 1144 | *   |         emit LogUint256("delta quote:", deltaQuote);
 1145 | *   |         emit LogUint256("deltaLiquidity", deltaLiquidity);
 1146 |     | 
 1147 |     |         // Caller must have a balance and have approved hyper
 1148 | *   |         mint_and_approve(_asset, deltaAsset);
 1149 | *   |         mint_and_approve(_quote, deltaQuote);
 1150 |     | 
 1151 | *   |         try _hyper.allocate(poolId, deltaLiquidity) returns (uint256 allocateAset, uint256 allocateQuote) {
 1152 |     |             emit AssertionFailed("BUG: allocate with deltaLiquidity=0 should fail");
 1153 |     |         } catch {}
 1154 |     |     }
 1155 |     | 
 1156 |     |     // A user should not be able to allocate more than they own
 1157 |     | 
 1158 |     |     // ******************** Unallocate ********************
 1159 | r   |     function unallocate_with_correct_preconditions_should_work(uint256 id, uint256 amount) public {
 1160 | r   |         address[] memory owners = new address[](1);
 1161 | r   |         (
 1162 | r   |             HyperPool memory pool,
 1163 | r   |             uint64 poolId,
 1164 | r   |             EchidnaERC20 _asset,
 1165 | r   |             EchidnaERC20 _quote
 1166 | r   |         ) = retrieve_random_pool_and_tokens(id);
 1167 |     | 
 1168 |     |         // Save pre unallocation state
 1169 | r   |         HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);
 1170 | r   |         uint256 preUnallocateAssetBalance = _asset.balanceOf(address(this));
 1171 | r   |         uint256 preUnallocateQuoteBalance = _quote.balanceOf(address(this));
 1172 | r   |         require(preState.callerPositionLiquidity > 0);
 1173 |     |         require(pool.lastTimestamp - block.timestamp < JUST_IN_TIME_LIQUIDITY_POLICY);
 1174 |     | 
 1175 |     |         (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getAmounts(poolId);
 1176 |     | 
 1177 |     |         _hyper.unallocate(poolId, amount);
 1178 |     | 
 1179 |     |         // Save post unallocation state
 1180 |     |         HyperState memory postState = getState(address(_hyper), poolId, address(this), owners);
 1181 |     |         {
 1182 |     |             uint256 postUnallocateAssetBalance = _asset.balanceOf(address(this));
 1183 |     |             uint256 postUnallocateQuoteBalance = _quote.balanceOf(address(this));
 1184 |     |             assert(preUnallocateAssetBalance + deltaAsset == postUnallocateAssetBalance);
 1185 |     |             assert(preUnallocateQuoteBalance + deltaQuote == postUnallocateQuoteBalance);
 1186 |     |         }
 1187 |     | 
 1188 |     |         assert(preState.totalPoolLiquidity - amount == postState.totalPoolLiquidity);
 1189 |     |         assert(preState.callerPositionLiquidity - amount == postState.callerPositionLiquidity);
 1190 |     |         assert(preState.reserveAsset == postState.reserveAsset);
 1191 |     |         assert(preState.reserveQuote == postState.reserveQuote);
 1192 |     |         assert(preState.physicalBalanceAsset == postState.physicalBalanceAsset);
 1193 |     |         assert(preState.physicalBalanceQuote == postState.physicalBalanceQuote);
 1194 |     |     }
 1195 |     | 
 1196 |     |     // A user without a position should not be able to unallocate funds
 1197 | r   |     function unallocate_without_position_should_fail(uint256 id, uint256 amount) public {
 1198 | r   |         address[] memory owners = new address[](1);
 1199 | r   |         (
 1200 | r   |             HyperPool memory pool,
 1201 | r   |             uint64 poolId,
 1202 | r   |             EchidnaERC20 _asset,
 1203 | r   |             EchidnaERC20 _quote
 1204 | r   |         ) = retrieve_random_pool_and_tokens(id);
 1205 |     | 
 1206 |     |         // Save pre unallocation state
 1207 | r   |         HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);
 1208 | r   |         uint256 preUnallocateAssetBalance = _asset.balanceOf(address(this));
 1209 | r   |         uint256 preUnallocateQuoteBalance = _quote.balanceOf(address(this));
 1210 | r   |         require(pool.lastTimestamp - block.timestamp < JUST_IN_TIME_LIQUIDITY_POLICY);
 1211 |     | 
 1212 |     |         try _hyper.unallocate(poolId, amount) {
 1213 |     |             emit AssertionFailed("BUG: User was able to unallocate without prior allocation");
 1214 |     |         } catch {}
 1215 |     |     }
 1216 |     | 
 1217 |     |     // A user attempting to unallocate a nonexistent pool should fail
 1218 |     |     // A user attempting to unallocate an expired pool should be successful
 1219 |     |     // Caller position last timestamp <= block.timestamp, with JIT policy
 1220 |     |     // A user should not be able to unallocate more than they own
 1221 |     |     // A user calling allocate then unallocate should succeed
 1222 | r   |     function allocate_then_unallocate_should_succeed(uint256 id, uint256 amount) public {
 1223 | r   |         address[] memory owners = new address[](1);
 1224 | r   |         (
 1225 | r   |             HyperPool memory pool,
 1226 | r   |             uint64 poolId,
 1227 | r   |             EchidnaERC20 _asset,
 1228 | r   |             EchidnaERC20 _quote
 1229 | r   |         ) = retrieve_random_pool_and_tokens(id);
 1230 | r   |         emit LogUint256("pool id:", uint256(poolId));
 1231 |     | 
 1232 | r   |         require(pool.lastPrice != 0);
 1233 | r   |         require(pool.lastTimestamp != 0);
 1234 |     | 
 1235 |     |         // ensures deltaLiquidity is never zero
 1236 | r   |         amount = between(amount, 1, type(uint256).max);
 1237 | r   |         if (amount == type(uint256).max) {
 1238 |     |             amount = 1;
 1239 |     |         } else {
 1240 | r   |             amount = uint128(amount);
 1241 |     |         }
 1242 |     | 
 1243 | r   |         int128 amountInt = convertToInt128(uint128(amount));
 1244 | r   |         (uint256 deltaAsset, uint256 deltaQuote) = _hyper.getLiquidityDeltas(poolId, amountInt);
 1245 |     | 
 1246 | r   |         emit LogUint256("delta asset:", deltaAsset);
 1247 | r   |         emit LogUint256("delta quote:", deltaQuote);
 1248 | r   |         emit LogUint256("amount", amount);
 1249 |     | 
 1250 | r   |         execute_allocate_call(poolId, _asset, _quote, deltaAsset, deltaQuote, amount);
 1251 | r   |         _hyper.unallocate(poolId, amount);
 1252 |     |     }
 1253 |     | 
 1254 |     |     // Swaps
 1255 | *r  |     function swap_should_succeed(uint id, bool sellAsset, uint256 amount, uint256 limit) public {
 1256 | *r  |         address[] memory owners = new address[](1);
 1257 |     |         // Will always return a pool that exists 
 1258 | *   |         (
 1259 | *r  |             HyperPool memory pool,
 1260 | *r  |             uint64 poolId,
 1261 | *r  |             EchidnaERC20 _asset,
 1262 | *r  |             EchidnaERC20 _quote
 1263 | *r  |         ) = retrieve_random_pool_and_tokens(id);
 1264 | *   |         amount = between(amount, 1, type(uint256).max);
 1265 |     | 
 1266 | *   |         mint_and_approve(_asset, amount);
 1267 | *   |         mint_and_approve(_quote, amount);
 1268 | *   |         HyperState memory preState = getState(address(_hyper), poolId, address(this), owners);
 1269 |     | 
 1270 | *   |         try _hyper.swap(poolId, sellAsset, amount, limit) returns (uint256 output, uint256 remainder) {
 1271 |     |             HyperState memory postState = getState(address(_hyper), poolId, address(this), owners);
 1272 |     |         } catch {}
 1273 |     |     }
 1274 | *r  |     function swap_on_expired_pool_should_fail(uint id,uint256 amount) public {
 1275 |     |         // Will always return a pool that exists 
 1276 | *   |         (
 1277 | *r  |             HyperPool memory pool,
 1278 | *r  |             uint64 poolId,
 1279 | *r  |             EchidnaERC20 _asset,
 1280 | *r  |             EchidnaERC20 _quote
 1281 | *r  |         ) = retrieve_random_pool_and_tokens(id);
 1282 | *   |         HyperCurve memory curve = pool.params;
 1283 | *   |         amount = between(amount,1,type(uint256).max);
 1284 | *   |         mint_and_approve(_asset,amount);
 1285 | *   |         if (curve.maturity() <= block.timestamp){
 1286 | *   |             emit LogUint256("Maturity timestamp",curve.maturity());
 1287 | *   |             emit LogUint256("block.timestamp", block.timestamp);            
 1288 | *   |             swap_should_fail(curve, poolId, true, amount, amount, "BUG: Swap on an expired pool should have failed.");
 1289 |     |         }
 1290 |     |     }
 1291 | *   |     function swap_on_non_existent_pool_should_fail(uint64 id) public {
 1292 |     |         // Ensure that the pool id was not one that's already been created 
 1293 | *   |         require(!is_created_pool(id)); 
 1294 | *   |         HyperPool memory pool = getPool(address(_hyper),id);
 1295 |     | 
 1296 | *   |         swap_should_fail(pool.params, id, true, id, id, "BUG: Swap on a nonexistent pool should fail.");
 1297 |     |     }
 1298 | *r  |     function swap_on_zero_amount_should_fail(uint id) public {
 1299 |     |         // Will always return a pool that exists 
 1300 | *   |         (
 1301 | *r  |             HyperPool memory pool,
 1302 | *r  |             uint64 poolId,
 1303 | *r  |             EchidnaERC20 _asset,
 1304 | *r  |             EchidnaERC20 _quote
 1305 | *r  |         ) = retrieve_random_pool_and_tokens(id);
 1306 | *   |         uint256 amount = 0;
 1307 |     |         
 1308 | *   |         swap_should_fail(pool.params, poolId, true, amount, id, "BUG: Swap with zero amount should fail.");
 1309 |     |     }
 1310 | *   |     function swap_should_fail(HyperCurve memory curve, uint64 poolId, bool sellAsset, uint256 amount, uint256 limit, string memory msg) private {
 1311 | *   |         try _hyper.swap(poolId, sellAsset, amount, amount) {
 1312 |     |             emit AssertionFailed(msg);
 1313 |     |         }
 1314 |     |         catch {}
 1315 |     |     }
 1316 |     | 
 1317 | *r  |     function retrieve_random_pool_and_tokens(
 1318 |     |         uint256 id
 1319 | *r  |     ) private view returns (HyperPool memory pool, uint64 poolId, EchidnaERC20 asset, EchidnaERC20 quote) {
 1320 | *r  |         require(poolIds.length > 0);
 1321 | *r  |         uint256 random = between(id, 0, poolIds.length - 1);
 1322 |     | 
 1323 | *r  |         pool = getPool(address(_hyper), poolIds[random]);
 1324 | *r  |         poolId = poolIds[random];
 1325 | *r  |         HyperPair memory pair = pool.pair;
 1326 | *r  |         quote = EchidnaERC20(pair.tokenQuote);
 1327 | *r  |         asset = EchidnaERC20(pair.tokenAsset);
 1328 |     |     }
 1329 |     | }
 1330 |     | 

/root/code/hyper/contracts/echidna/EchidnaStateHandling.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "../test/EchidnaERC20.sol";
  4 |     | import "./Helper.sol";
  5 |     | 
  6 |     | contract EchidnaStateHandling is Helper{
  7 |     |     // Hyper Tokens
  8 | *r  |     EchidnaERC20[] public hyperTokens;
  9 |     | 
 10 | *   |     function add_created_hyper_token(EchidnaERC20 token) internal {
 11 | *   |         hyperTokens.push(token);
 12 |     |     }
 13 | *r  |     function get_hyper_tokens(uint256 id1, uint256 id2) internal view returns (EchidnaERC20 asset, EchidnaERC20 quote) {
 14 |     |         // This assumes that hyperTokens.length is always >2
 15 | *r  |         if (poolIds.length == 2) {
 16 | *r  |             id1 = 0;
 17 | *r  |             id2 = 1;
 18 |     |         } else {
 19 | *r  |             id1 = between(id1, 0, hyperTokens.length - 1);
 20 | *r  |             id2 = between(id2, 0, hyperTokens.length - 1);
 21 |     |         }
 22 | *r  |         require(id1 != id2);
 23 | *r  |         return (hyperTokens[id1], hyperTokens[id2]);
 24 |     |     }    
 25 | *   |     function get_token_at_index(uint256 index) internal view returns (EchidnaERC20 token){
 26 | *   |         return hyperTokens[index];
 27 |     |     }
 28 |     |     // Pairs 
 29 |     |     uint24[] pairIds;
 30 |     | 
 31 | *   |     function save_pair_id(uint24 pairId) internal {
 32 | *   |         pairIds.push(pairId);
 33 |     |     }
 34 |     | 
 35 | *r  |     function retrieve_created_pair(uint256 id) internal view returns (uint24 pairId) {
 36 | *r  |         require(pairIds.length > 0);
 37 | *r  |         id = between(id, 0, pairIds.length);
 38 | *r  |         return pairIds[id];
 39 |     |     }    
 40 |     | 
 41 |     |     // Pools 
 42 |     |     uint64[] poolIds;
 43 |     |     function save_pool_id(uint64 id) internal {
 44 | *   |         poolIds.push(id);
 45 |     |     }
 46 |     | 
 47 | *r  |     function is_created_pool(uint64 id) internal view returns (bool) {
 48 | *r  |         for (uint8 i = 0; i < poolIds.length; i++) {
 49 | *r  |             if (poolIds[i] == id) return true;
 50 |     |         }
 51 | *   |         return false;
 52 |     |     }    
 53 |     | }

/root/code/hyper/contracts/echidna/Helper.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | contract Helper {
  4 |     |     event AssertionFailed(string msg);
  5 |     |     event LogUint256(string msg, uint256 value);
  6 |     |     event LogBytes(string msg, bytes value);
  7 |     |     event LogAddress(string msg, address tkn);
  8 |     |     event LogBool(string msg, bool value);
  9 |     |     event LogInt24(string msg, int24 value);
 10 |     |     event LogInt128(string msg, int128 value);
 11 |     | 
 12 | *   |     int24 constant MAX_TICK = 887272;
 13 |     |     int24 constant MIN_TICK = -414486;
 14 |     |     uint256 constant BUFFER = 300 seconds;
 15 | *r  |     uint256 constant MIN_FEE = 1; // 0.01%
 16 | *r  |     uint256 constant MAX_FEE = 1000; // 10%
 17 | *   |     uint256 constant MIN_VOLATILITY = 100; // 1%
 18 | *   |     uint256 constant MAX_VOLATILITY = 25_000; // 250%
 19 | *   |     uint256 constant MIN_DURATION = 1; // days, but without units
 20 | *   |     uint256 constant MAX_DURATION = 500; // days, but without units
 21 | *   |     uint256 constant JUST_IN_TIME_MAX = 600 seconds;
 22 | *r  |     uint256 constant JUST_IN_TIME_LIQUIDITY_POLICY = 4 seconds;
 23 |     | 
 24 | *r  |     function clam_safe_create_bounds(
 25 |     |         uint16 priorityFee,
 26 |     |         uint16 fee,
 27 |     |         int24 maxTick,
 28 |     |         uint16 volatility,
 29 |     |         uint16 duration,
 30 |     |         uint16 jit,
 31 |     |         uint128 price
 32 | *r  |     ) internal returns (uint16, uint16, int24, uint16, uint16, uint16, uint128) {
 33 |     |         // scaling remaining pool creation values
 34 | *r  |         fee = uint16(between(fee, MIN_FEE, MAX_FEE));
 35 | *r  |         priorityFee = uint16(between(priorityFee, 1, fee));
 36 | *   |         emit LogUint256("priority fee", uint256(priorityFee));
 37 | *   |         volatility = uint16(between(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
 38 | *   |         duration = uint16(between(duration, MIN_DURATION, MAX_DURATION));
 39 | *   |         maxTick = (-MIN_TICK) + (maxTick % (MAX_TICK - (-MIN_TICK))); // [-MIN_TICK,MAX_TICK]
 40 | *   |         if (maxTick == 0) {
 41 |     |             maxTick += 1;
 42 |     |         }
 43 | *   |         emit LogInt24("maxTick", maxTick);
 44 | *   |         jit = uint16(between(jit, 1, JUST_IN_TIME_MAX));
 45 | *   |         price = uint128(between(price, 1, type(uint128).max)); // price is between 1-uint256.max
 46 | *   |         return (priorityFee, fee, maxTick, volatility, duration, jit, price);
 47 |     |     }
 48 |     |     // ******************** Helper ********************
 49 |     | 
 50 | *r  |     function between(uint256 random, uint256 low, uint256 high) public pure returns (uint256) {
 51 | *r  |         return low + (random % (high - low));
 52 |     |     }
 53 |     | 
 54 | *r  |     function convertToInt128(uint128 a) internal pure returns (int128 b) {
 55 |     |         assembly {
 56 | *r  |             if gt(a, 0x7fffffffffffffffffffffffffffffff) { revert(0, 0) }
 57 |     | 
 58 | *r  |             b := a
 59 |     |         }
 60 |     |     }
 61 |     | }
 62 |     | 

/root/code/hyper/contracts/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | interface IERC20 {
  5 |     |     function totalSupply() external view returns (uint256);
  6 |     | 
  7 |     |     function balanceOf(address account) external view returns (uint256);
  8 |     | 
  9 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 10 |     | 
 11 |     |     function allowance(address owner, address spender) external view returns (uint256);
 12 |     | 
 13 |     |     function approve(address spender, uint256 amount) external returns (bool);
 14 |     | 
 15 |     |     function transferFrom(
 16 |     |         address sender,
 17 |     |         address recipient,
 18 |     |         uint256 amount
 19 |     |     ) external returns (bool);
 20 |     | 
 21 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 22 |     | 
 23 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 24 |     | 
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/root/code/hyper/contracts/interfaces/IHyper.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import {HyperCurve, HyperPair} from "../HyperLib.sol";
   5 |     | 
   6 |     | interface IHyperEvents {
   7 |     |     event Deposit(address indexed account, uint amount);
   8 |     |     event DecreaseUserBalance(address indexed account, address indexed token, uint256 amount);
   9 |     |     event DecreaseReserveBalance(address indexed token, uint256 amount);
  10 |     |     event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);
  11 |     |     event IncreaseReserveBalance(address indexed token, uint256 amount);
  12 |     |     event Swap(
  13 |     |         uint64 indexed poolId,
  14 |     |         uint256 price,
  15 |     |         address indexed tokenIn,
  16 |     |         uint256 input,
  17 |     |         address indexed tokenOut,
  18 |     |         uint256 output
  19 |     |     );
  20 |     |     event Stake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);
  21 |     |     event Unstake(uint64 indexed poolId, address indexed owner, uint deltaLiquidity);
  22 |     |     event Allocate(
  23 |     |         uint64 indexed poolId,
  24 |     |         address indexed asset,
  25 |     |         address indexed quote,
  26 |     |         uint256 deltaAsset,
  27 |     |         uint256 deltaQuote,
  28 |     |         uint256 deltaLiquidity
  29 |     |     );
  30 |     |     event Unallocate(
  31 |     |         uint64 indexed poolId,
  32 |     |         address indexed asset,
  33 |     |         address indexed quote,
  34 |     |         uint256 deltaAsset,
  35 |     |         uint256 deltaQuote,
  36 |     |         uint256 deltaLiquidity
  37 |     |     );
  38 |     | 
  39 |     |     event ChangeParameters(
  40 |     |         uint64 indexed poolId,
  41 |     |         uint16 priorityFee,
  42 |     |         uint16 indexed fee,
  43 |     |         uint16 volatility,
  44 |     |         uint16 duration,
  45 |     |         uint16 jit,
  46 |     |         int24 indexed maxTick
  47 |     |     );
  48 |     |     event Collect(
  49 |     |         uint64 poolId,
  50 |     |         address account,
  51 |     |         uint feeAsset,
  52 |     |         address indexed asset,
  53 |     |         uint feeQuote,
  54 |     |         address indexed quote,
  55 |     |         uint feeReward,
  56 |     |         address indexed reward
  57 |     |     );
  58 |     |     event CreatePair(
  59 |     |         uint24 indexed pairId,
  60 |     |         address indexed asset,
  61 |     |         address indexed quote,
  62 |     |         uint8 decimalsAsset,
  63 |     |         uint8 decimalsQuote
  64 |     |     );
  65 |     |     event CreatePool(
  66 |     |         uint64 indexed poolId,
  67 |     |         bool isMutable,
  68 |     |         address indexed asset,
  69 |     |         address indexed quote,
  70 |     |         uint256 price
  71 |     |     );
  72 |     | }
  73 |     | 
  74 |     | interface IHyperGetters {
  75 |     |     function getNetBalance(address token) external view returns (int);
  76 |     | 
  77 |     |     function getReserve(address token) external view returns (uint);
  78 |     | 
  79 |     |     function getBalance(address owner, address token) external view returns (uint);
  80 |     | 
  81 |     |     function pairs(
  82 |     |         uint24 pairId
  83 |     |     ) external view returns (address tokenAsset, uint8 decimalsAsset, address tokenQuote, uint8 decimalsQuote);
  84 |     | 
  85 |     |     function pools(
  86 |     |         uint64 poolId
  87 |     |     )
  88 |     |         external
  89 |     |         view
  90 |     |         returns (
  91 |     |             int24 lastTick,
  92 |     |             uint32 lastTimestamp,
  93 |     |             address controller,
  94 |     |             uint256 feeGrowthGlobalReward,
  95 |     |             uint256 feeGrowthGlobalAsset,
  96 |     |             uint256 feeGrowthGlobalQuote,
  97 |     |             uint128 lastPrice,
  98 |     |             uint128 liquidity,
  99 |     |             uint128 stakedLiquidity,
 100 |     |             int128 stakedLiquidityDelta,
 101 |     |             HyperCurve memory,
 102 |     |             HyperPair memory
 103 |     |         );
 104 |     | 
 105 |     |     function positions(
 106 |     |         address owner,
 107 |     |         uint64 poolId
 108 |     |     )
 109 |     |         external
 110 |     |         view
 111 |     |         returns (
 112 |     |             uint128 freeLiquidity,
 113 |     |             uint128 stakedLiquidity,
 114 |     |             uint256 lastTimestamp,
 115 |     |             uint256 stakeTimestamp,
 116 |     |             uint256 unstakeTimestamp,
 117 |     |             uint256 feeGrowthRewardLast,
 118 |     |             uint256 feeGrowthAssetLast,
 119 |     |             uint256 feeGrowthQuoteLast,
 120 |     |             uint128 tokensOwedAsset,
 121 |     |             uint128 tokensOwedQuote,
 122 |     |             uint128 tokensOwedReward
 123 |     |         );
 124 |     | 
 125 |     |     function getPairNonce() external view returns (uint24);
 126 |     | 
 127 |     |     function getPoolNonce() external view returns (uint32);
 128 |     | 
 129 |     |     function getAmounts(uint64 poolId) external view returns (uint256 deltaAsset, uint256 deltaQuote);
 130 |     | 
 131 |     |     function getAmountOut(uint64 poolId, bool sellAsset, uint amountIn) external view returns (uint);
 132 |     | 
 133 |     |     function getVirtualReserves(uint64 poolId) external view returns (uint128 deltaAsset, uint128 deltaQuote);
 134 |     | 
 135 |     |     function getMaxLiquidity(
 136 |     |         uint64 poolId,
 137 |     |         uint deltaAsset,
 138 |     |         uint deltaQuote
 139 |     |     ) external view returns (uint128 deltaLiquidity);
 140 |     | 
 141 |     |     function getLiquidityDeltas(
 142 |     |         uint64 poolId,
 143 |     |         int128 deltaLiquidity
 144 |     |     ) external view returns (uint128 deltaAsset, uint128 deltaQuote);
 145 |     | 
 146 |     |     function getLatestPrice(uint64 poolId) external view returns (uint price);
 147 |     | }
 148 |     | 
 149 |     | interface IHyperActions {
 150 |     |     function allocate(uint64 poolId, uint deltaLiquidity) external returns (uint deltaAsset, uint deltaQuote);
 151 |     | 
 152 |     |     function unallocate(uint64 poolId, uint amount) external returns (uint deltaAsset, uint deltaQuote);
 153 |     | 
 154 |     |     function stake(uint64 poolId, uint128 deltaLiquidity) external;
 155 |     | 
 156 |     |     function unstake(uint64 poolId, uint128 deltaLiquidity) external;
 157 |     | 
 158 |     |     function swap(
 159 |     |         uint64 poolId,
 160 |     |         bool sellAsset,
 161 |     |         uint amount,
 162 |     |         uint limit
 163 |     |     ) external returns (uint output, uint remainder);
 164 |     | 
 165 |     |     function fund(address token, uint256 amount) external;
 166 |     | 
 167 |     |     function draw(address token, uint256 amount, address to) external;
 168 |     | 
 169 |     |     function deposit() external payable;
 170 |     | 
 171 |     |     function changeParameters(
 172 |     |         uint64 poolId,
 173 |     |         uint16 priorityFee,
 174 |     |         uint16 fee,
 175 |     |         uint16 volatility,
 176 |     |         uint16 duration,
 177 |     |         uint16 jit,
 178 |     |         int24 maxTick
 179 |     |     ) external;
 180 |     | }
 181 |     | 
 182 |     | interface IHyper is IHyperActions, IHyperEvents, IHyperGetters {}
 183 |     | 

/root/code/hyper/contracts/interfaces/IWETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IWETH {
  5 |     |     function deposit() external payable;
  6 |     | 
  7 |     |     function withdraw(uint256 wad) external;
  8 |     | }
  9 |     | 

/root/code/hyper/contracts/libraries/Price.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "solstat/Invariant.sol";
   5 |     | 
   6 |     | using Price for Price.RMM global;
   7 |     | 
   8 |     | /**
   9 |     |  * @dev     Library for RMM to compute reserves, prices, and changes in reserves over time.
  10 |     |  * @notice  Units Glossary:
  11 |     |  *
  12 |     |  *          wad - `1 ether` == 1e18
  13 |     |  *          seconds - `1 seconds` == 1
  14 |     |  *          percentage - 10_000 == 100%
  15 |     |  *
  16 |     |  */
  17 |     | library Price {
  18 |     |     using FixedPointMathLib for uint256;
  19 |     |     using FixedPointMathLib for int256;
  20 |     | 
  21 |     |     struct RMM {
  22 |     |         uint256 strike; // wad
  23 |     |         uint256 sigma; // 10_000 = 100%;
  24 |     |         uint256 tau; // seconds
  25 |     |     }
  26 |     | 
  27 |     |     error OverflowWad(int256 wad);
  28 |     | 
  29 | *r  |     int256 internal constant TICK_BASE = 1_0001e14;
  30 | *r  |     uint256 internal constant DOUBLE_WAD = 2 ether;
  31 |     |     uint256 internal constant PERCENTAGE = 10_000;
  32 | *r  |     uint256 internal constant SQRT_WAD = 1e9;
  33 | *r  |     uint256 internal constant WAD = 1 ether;
  34 |     |     uint256 internal constant YEAR = 31556953 seconds;
  35 |     | 
  36 |     |     // ===== Class Methods ===== //
  37 |     | 
  38 |     |     function invariantOf(RMM memory args, uint R_y, uint R_x) internal pure returns (int256) {
  39 |     |         return Invariant.invariant(R_y, R_x, args.strike, convertPercentageToWad(args.sigma), args.tau);
  40 |     |     }
  41 |     | 
  42 | *r  |     function getXWithPrice(RMM memory args, uint256 prc) internal pure returns (uint256 R_x) {
  43 | *r  |         R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);
  44 |     |     }
  45 |     | 
  46 |     |     function getPriceWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 prc) {
  47 |     |         prc = getPriceWithX(R_x, args.strike, args.sigma, args.tau);
  48 |     |     }
  49 |     | 
  50 | *r  |     function getYWithX(RMM memory args, uint256 R_x) internal pure returns (uint256 R_y) {
  51 | *r  |         R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);
  52 |     |     }
  53 |     | 
  54 |     |     function getXWithY(RMM memory args, uint256 R_y) internal pure returns (uint256 R_x) {
  55 |     |         R_x = getXWithY(R_y, args.strike, args.sigma, args.tau, 0);
  56 |     |     }
  57 |     | 
  58 |     |     function computePriceWithChangeInTau(RMM memory args, uint256 prc, uint256 eps) internal pure returns (uint256) {
  59 |     |         return computePriceWithChangeInTau(args.strike, args.sigma, prc, args.tau, eps);
  60 |     |     }
  61 |     | 
  62 | *r  |     function computeReserves(RMM memory args, uint prc) internal pure returns (uint R_y, uint R_x) {
  63 | *r  |         R_x = getXWithPrice(prc, args.strike, args.sigma, args.tau);
  64 | *r  |         R_y = getYWithX(R_x, args.strike, args.sigma, args.tau, 0);
  65 |     |     }
  66 |     | 
  67 |     |     // ===== Raw Functions ===== //
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Computes change in price given a change in time in seconds.
  71 |     |      * @param stk WAD
  72 |     |      * @param vol percentage
  73 |     |      * @param prc WAD
  74 |     |      * @param tau seconds
  75 |     |      * @param epsilon seconds
  76 |     |      * @custom:math P(τ - ε) = ( ( P(τ) / K ) ^ ( √(1 - ε/τ) )) (K) (e^( (1/2) (o^2) ( √(τ) √(τ- ε) - (τ - ε) ) ))
  77 |     |      */
  78 | *r  |     function computePriceWithChangeInTau(
  79 |     |         uint256 stk,
  80 |     |         uint256 vol,
  81 |     |         uint256 prc,
  82 |     |         uint256 tau,
  83 |     |         uint256 epsilon
  84 | *r  |     ) internal pure returns (uint256) {
  85 | *r  |         if (epsilon == 0) return prc;
  86 | *r  |         if (epsilon > tau) return stk;
  87 |     | 
  88 | *r  |         RMM memory params = RMM(stk, vol, tau);
  89 |     | 
  90 |     |         uint256 tauYears;
  91 |     |         assembly {
  92 | *r  |             tauYears := sdiv(mul(tau, WAD), YEAR) // tau * WAD / year = time in years scaled to WAD
  93 |     |         }
  94 |     | 
  95 |     |         uint256 epsilonYears;
  96 |     |         assembly {
  97 | *r  |             epsilonYears := sdiv(mul(epsilon, WAD), YEAR) // epsilon * WAD / year = epsilon in years scaled to WAD
  98 |     |         }
  99 |     | 
 100 | *r  |         uint256 term_0 = WAD - (epsilonYears.divWadUp(tauYears)); // 1 - ε/τ, WAD - ((epsilon * WAD) / tau rounded down), units are WAD - WAD, time units cancel out
 101 | *r  |         uint256 term_1 = term_0.sqrt(); // √(1 - ε/τ)), this sqrts WAD, so we end up with SQRT_WAD units
 102 |     | 
 103 | *r  |         uint256 term_2 = prc.divWadUp(params.strike); // P(t) / K, both units are already WAD
 104 | *r  |         uint256 term_3 = uint256(int256(term_2).powWad(int256(term_1 * SQRT_WAD))); // ( P(τ) / K ) ^ ( √(1 - ε/τ) ))
 105 |     | 
 106 | *r  |         uint256 term_7;
 107 | *r  |         {
 108 | *r  |             uint256 currentTau = tauYears - epsilonYears; // (τ- ε), WAD - WAD = WAD
 109 | *r  |             uint256 tausSqrt = tauYears.sqrt() * (currentTau).sqrt(); // ( √(τ) √(τ- ε) ), sqrt(1e18) = 1e9, so 1e9 * 1e9 = 1e18
 110 | *r  |             uint256 term_4 = tausSqrt - currentTau; // ( √(τ) √(τ- ε) - (τ - ε) ), WAD - WAD = WAD
 111 |     | 
 112 | *r  |             uint256 sigmaWad = convertPercentageToWad(uint256(params.sigma));
 113 |     | 
 114 | *r  |             uint256 term_5 = (sigmaWad * sigmaWad) / DOUBLE_WAD; // ( 1 / 2 )(o^2), 1e4 * 1e4 * 1e17 / 1e4 = 1e17, which is half WAD
 115 | *r  |             uint256 term_6 = uint256((int256(term_5.mulWadDown(term_4))).expWad()); // (e^( (1/2) (o^2) ( √(τ) √(τ- ε) - (τ - ε) ) )), exp(WAD * WAD / WAD)
 116 | *r  |             term_7 = uint256(params.strike).mulWadDown(term_6); // (K) (e^( (1/2) (o^2) ( √(τ) √(τ- ε) - (τ - ε) ) ), WAD * WAD / WAD
 117 |     |         }
 118 |     | 
 119 | *r  |         uint256 price = term_3.mulWadDown(term_7); // WAD * WAD / WAD = WAD
 120 |     |         return price;
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev R_y = tradingFunction(R_x, ...)
 125 |     |      * @param R_x WAD
 126 |     |      * @param stk WAD
 127 |     |      * @param vol percentage
 128 |     |      * @param tau seconds
 129 |     |      * @param inv WAD
 130 |     |      * @return R_y WAD
 131 |     |      */
 132 | *r  |     function getYWithX(
 133 |     |         uint256 R_x,
 134 |     |         uint256 stk,
 135 |     |         uint256 vol,
 136 |     |         uint256 tau,
 137 |     |         int256 inv
 138 | *r  |     ) internal pure returns (uint256 R_y) {
 139 | *r  |         R_y = Invariant.getY(R_x, stk, convertPercentageToWad(vol), tau, inv);
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev R_x = tradingFunction(R_y, ...)
 144 |     |      * @param R_y WAD
 145 |     |      * @param stk WAD
 146 |     |      * @param vol percentage
 147 |     |      * @param tau seconds
 148 |     |      * @param inv WAD
 149 |     |      * @return R_x WAD
 150 |     |      */
 151 |     |     function getXWithY(
 152 |     |         uint256 R_y,
 153 |     |         uint256 stk,
 154 |     |         uint256 vol,
 155 |     |         uint256 tau,
 156 |     |         int256 inv
 157 |     |     ) internal pure returns (uint256 R_x) {
 158 |     |         R_x = Invariant.getX(R_y, stk, convertPercentageToWad(vol), tau, inv);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Used in `getAmounts` to compute the virtual amount of assets at the pool's price.
 163 |     |      * @param prc WAD
 164 |     |      * @param stk WAD
 165 |     |      * @param vol percentage
 166 |     |      * @param tau seconds
 167 |     |      * @return R_x WAD
 168 |     |      * @custom:math R_x = 1 - Φ(( ln(S/K) + (σ²/2)τ ) / σ√τ)
 169 |     |      */
 170 | *r  |     function getXWithPrice(uint256 prc, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 R_x) {
 171 | *r  |         if (prc != 0) {
 172 | *r  |             int256 ln = FixedPointMathLib.lnWad(int256(FixedPointMathLib.divWadDown(prc, stk)));
 173 | *r  |             uint256 tauYears = convertSecondsToWadYears(tau);
 174 |     | 
 175 |     |             uint256 sigmaWad = convertPercentageToWad(vol);
 176 | *r  |             uint256 doubleSigma = (sigmaWad * sigmaWad) / uint256(Gaussian.TWO);
 177 | *r  |             uint256 halfSigmaTau = doubleSigma * tauYears;
 178 | *r  |             uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(sigmaWad);
 179 |     | 
 180 | *r  |             int256 lnOverVol = (ln * Gaussian.ONE + int256(halfSigmaTau)) / int256(sqrtTauSigma);
 181 | *r  |             int256 cdf = Gaussian.cdf(lnOverVol);
 182 | *r  |             if (cdf > Gaussian.ONE) revert OverflowWad(cdf);
 183 | *r  |             R_x = uint256(Gaussian.ONE - cdf);
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev price(R_x) = Ke^(Φ^-1(1 - R_x)σ√τ - 1/2σ^2τ)
 189 |     |      * @param R_x WAD
 190 |     |      * @param stk WAD
 191 |     |      * @param vol percentage
 192 |     |      * @param tau seconds
 193 |     |      * @return prc WAD
 194 |     |      */
 195 | *r  |     function getPriceWithX(uint256 R_x, uint256 stk, uint256 vol, uint256 tau) internal pure returns (uint256 prc) {
 196 |     |         uint256 tauYears = convertSecondsToWadYears(tau);
 197 |     |         uint256 volWad = convertPercentageToWad(vol);
 198 |     | 
 199 |     |         if (uint256(Gaussian.ONE) < R_x) revert OverflowWad(int256(R_x));
 200 |     |         int256 input = Gaussian.ONE - int256(R_x);
 201 |     |         int256 ppf = Gaussian.ppf(input);
 202 |     |         uint256 sqrtTauSigma = (tauYears.sqrt() * SQRT_WAD).mulWadDown(volWad);
 203 |     |         int256 first = (ppf * int256(sqrtTauSigma)) / Gaussian.ONE; // Φ^-1(1 - R_x)σ√τ
 204 |     |         uint256 doubleSigma = (volWad * volWad) / uint256(Gaussian.TWO);
 205 |     |         int256 halfSigmaTau = int256(doubleSigma * tauYears) / Gaussian.ONE; // 1/2σ^2τ
 206 |     | 
 207 |     |         int256 exponent = first - halfSigmaTau;
 208 |     |         int256 exp = exponent.expWad();
 209 | *r  |         prc = uint256(exp).mulWadDown(stk);
 210 |     |     }
 211 |     | 
 212 |     |     // ===== Tick Math ===== //
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Computes a price value from a tick key.
 216 |     |      *
 217 |     |      * @custom:math price = e^(ln(1.0001) * tick)
 218 |     |      *
 219 |     |      * @param tick Key of a slot in a price/liquidity grid.
 220 |     |      * @return price WAD Value on a key (tick) value pair of a price grid.
 221 |     |      */
 222 | *r  |     function computePriceWithTick(int24 tick) internal pure returns (uint256 price) {
 223 | *r  |         int256 tickWad = int256(tick) * int256(FixedPointMathLib.WAD);
 224 | *r  |         price = uint256(FixedPointMathLib.powWad(TICK_BASE, tickWad));
 225 |     |     }
 226 |     | 
 227 |     |     /**
 228 |     |      * @dev Computes a tick value from the price.
 229 |     |      *
 230 |     |      * @custom:math tick = ln(price) / ln(1.0001)
 231 |     |      *
 232 |     |      * @param price WAD Value on a key (tick) value pair of a price grid.
 233 |     |      * @return tick Key of a slot in a price/liquidity grid.
 234 |     |      */
 235 | *r  |     function computeTickWithPrice(uint256 price) internal pure returns (int24 tick) {
 236 | *r  |         uint256 numerator = uint256(int256(price).lnWad());
 237 | *r  |         uint256 denominator = uint256(TICK_BASE.lnWad());
 238 | *r  |         tick = int24(int256((numerator)) / int256(denominator) + 1);
 239 |     |     }
 240 |     | 
 241 |     |     // ===== Utils ===== //
 242 |     | 
 243 |     |     function convertSecondsToWadYears(uint256 sec) internal pure returns (uint256 yrsWad) {
 244 |     |         assembly {
 245 | *r  |             yrsWad := div(mul(sec, WAD), YEAR)
 246 |     |         }
 247 |     |     }
 248 |     | 
 249 | *r  |     function convertPercentageToWad(uint256 pct) internal pure returns (uint256 pctWad) {
 250 |     |         assembly {
 251 | *r  |             pctWad := div(mul(pct, WAD), PERCENTAGE)
 252 |     |         }
 253 |     |     }
 254 |     | }
 255 |     | 

/root/code/hyper/contracts/recipes/SwapMath.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /**
   5 |     |     @dev Marginal price to trade y (∆) for x (∆′).
   6 |     |     
   7 |     |     Variable | Name         | Value
   8 |     |     ---------|--------------|-----------
   9 |     |     γ        | Gamma        | 1 - fee, Percentage
  10 |     |     K        | Strike       | K > 0, Wad
  11 |     |     k        | Invariant    | 2^128 > k > -2^128, Signed integer
  12 |     |     y        | Quote        | K >= y >= 0, Wad
  13 |     |     x        | Asset        | 1 >= x >= 0, Wad
  14 |     | 
  15 |     |     @custom:source https://primitive.xyz/whitepaper-rmm-01.pdf
  16 |     |  */
  17 |     | 
  18 |     | import "solmate/utils/FixedPointMathLib.sol";
  19 |     | import "../libraries/Price.sol";
  20 |     | 
  21 |     | using FixedPointMathLib for uint;
  22 |     | 
  23 |     | uint constant HALF_SCALAR = 1e9;
  24 |     | uint constant WAD = 1 ether;
  25 |     | 
  26 |     | /**
  27 |     |  @custom:math 1 / φ( Φ^(−1) (x) )
  28 |     |  */
  29 |     | function d_ppf(int256 input) view returns (int256) {
  30 |     |     int256 numerator;
  31 |     |     int256 denominator;
  32 |     |     assembly {
  33 |     |         numerator := mul(WAD, WAD)
  34 |     |     }
  35 |     | 
  36 |     |     denominator = Gaussian.pdf(Gaussian.ppf(input));
  37 |     | 
  38 |     |     int256 output;
  39 |     |     assembly {
  40 |     |         output := sdiv(numerator, denominator)
  41 |     |     }
  42 |     | 
  43 |     |     return output;
  44 |     | }
  45 |     | 
  46 |     | struct Parameters {
  47 |     |     uint stk;
  48 |     |     uint vol;
  49 |     |     uint tau;
  50 |     |     uint fee;
  51 |     |     int inv;
  52 |     | }
  53 |     | 
  54 |     | /**
  55 |     |     todo: currently broken, marginal price goes lower after a swap in, should go higher!
  56 |     |     @dev Marginal price to trade y (∆) for x (∆′).
  57 |     |     @custom:math ( d∆′ / d∆ ) (∆) = (K / γ) φ( Φ^(−1)( ( y + γ∆ − k) / K ) + σ√τ) × (Φ−1)′ ( (y + γ∆ − k) / K )
  58 |     |     @custom:source https://primitive.xyz/whitepaper-rmm-01.pdf
  59 |     |  */
  60 |     | function computeMarginalPriceQuoteIn(
  61 |     |     uint d_y,
  62 |     |     uint R_y,
  63 |     |     uint stk,
  64 |     |     uint vol,
  65 |     |     uint tau,
  66 |     |     uint fee,
  67 |     |     int inv
  68 |     | ) view returns (uint) {
  69 |     |     Parameters memory params = Parameters({stk: stk, vol: vol, tau: tau, fee: fee, inv: inv});
  70 |     |     uint256 volSqrtTau;
  71 |     |     uint256 gamma;
  72 |     |     {
  73 |     |         uint256 tauWadYears = Price.convertSecondsToWadYears(params.tau);
  74 |     |         uint256 volWad = Price.convertPercentageToWad(params.vol);
  75 |     |         uint256 feeWad = Price.convertPercentageToWad(params.fee);
  76 |     |         uint256 sqrtTau = tauWadYears.sqrt();
  77 |     |         gamma = FixedPointMathLib.WAD - feeWad;
  78 |     |         volSqrtTau = (sqrtTau * HALF_SCALAR).mulWadDown(volWad);
  79 |     |     }
  80 |     | 
  81 |     |     uint256 part0 = R_y + d_y.mulWadDown(gamma); // ( y + γ∆)
  82 |     |     assembly {
  83 |     |         part0 := add(part0, inv) // // ( y + γ∆ − k)
  84 |     |     }
  85 |     | 
  86 |     |     uint256 part1 = part0.divWadDown(params.stk); // ( y + γ∆ − k) / K )
  87 |     |     int256 part2 = Gaussian.ppf(int256(part1)); // Φ^(−1)( ( y + γ∆ − k) / K )
  88 |     | 
  89 |     |     int256 part3;
  90 |     |     assembly {
  91 |     |         part3 := add(part2, volSqrtTau) // Φ^(−1)( ( y + γ∆ − k) / K ) + σ√τ
  92 |     |     }
  93 |     | 
  94 |     |     uint256 part4 = (params.stk).divWadDown(gamma); // K / γ
  95 |     |     uint256 part5 = part4.mulWadDown(uint(Gaussian.pdf(int256(part3)))); // (K / γ) φ( Φ^(−1)( ( y + γ∆ − k) / K ) + σ√τ)
  96 |     | 
  97 |     |     int256 part6 = d_ppf(int256(part1)); // (Φ−1)′ ( (y + γ∆ − k) / K )
  98 |     | 
  99 |     |     uint256 d_x; // ( d∆′ / d∆ ) (∆) = part5 * part6
 100 |     |     assembly {
 101 |     |         d_x := mul(part5, part6)
 102 |     |         d_x := sdiv(d_x, WAD)
 103 |     |     }
 104 |     | 
 105 |     |     return d_x;
 106 |     | }
 107 |     | 
 108 |     | /**
 109 |     |     @dev Marginal price to trade x (∆) for y (∆′).
 110 |     |     @custom:math (d∆′ / d∆) (∆) = γKφ(Φ−1(1 − x − γ∆) − σ√τ ) × (Φ−1)′(1 − x − γ∆)
 111 |     |     @custom:source https://primitive.xyz/whitepaper-rmm-01.pdf
 112 |     |  */
 113 |     | function computeMarginalPriceAssetIn(
 114 |     |     uint d_x,
 115 |     |     uint R_x,
 116 |     |     uint stk,
 117 |     |     uint vol,
 118 |     |     uint tau,
 119 |     |     uint fee,
 120 |     |     int inv
 121 |     | ) view returns (uint) {
 122 |     |     Parameters memory params = Parameters({stk: stk, vol: vol, tau: tau, fee: fee, inv: inv});
 123 |     |     uint256 sqrtTau;
 124 |     |     uint256 volSqrtTau;
 125 |     |     uint256 gamma;
 126 |     |     {
 127 |     |         uint256 tauWadYears = Price.convertSecondsToWadYears(params.tau);
 128 |     |         uint256 volWad = Price.convertPercentageToWad(params.vol);
 129 |     |         uint256 feeWad = Price.convertPercentageToWad(params.fee);
 130 |     |         gamma = FixedPointMathLib.WAD - feeWad;
 131 |     |         sqrtTau = tauWadYears.sqrt();
 132 |     |         volSqrtTau = (sqrtTau * HALF_SCALAR).mulWadDown(volWad);
 133 |     |     }
 134 |     | 
 135 |     |     uint256 part0 = WAD - R_x - d_x.mulWadDown(gamma); // 1 wad > x > 0 wad
 136 |     |     int256 part1 = Gaussian.ppf(int256(part0));
 137 |     | 
 138 |     |     uint256 part2;
 139 |     |     assembly {
 140 |     |         part2 := sub(part1, volSqrtTau)
 141 |     |     }
 142 |     | 
 143 |     |     uint256 part3 = gamma.mulWadDown(params.stk);
 144 |     |     int256 part4 = Gaussian.pdf(int256(part2));
 145 |     |     uint256 part5 = part3.mulWadDown(uint256(part4));
 146 |     | 
 147 |     |     int256 part6 = d_ppf(int256(part0)); // todo: fix, need derivative!
 148 |     |     uint256 d_y;
 149 |     |     assembly {
 150 |     |         d_y := mul(part5, part6) // todo: unsigned * signed, dangerous!
 151 |     |         d_y := sdiv(d_y, WAD)
 152 |     |     }
 153 |     | 
 154 |     |     return d_y;
 155 |     | }
 156 |     | 

/root/code/hyper/contracts/test/EchidnaERC20.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "../interfaces/IERC20.sol";
   5 | *r  | 
   6 |     | contract EchidnaERC20 is IERC20 {
   7 |     |     mapping(address => uint256) private _balances;
   8 |     | 
   9 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  10 |     | 
  11 |     |     uint256 private _totalSupply;
  12 |     | 
  13 | *r  |     string public name;
  14 | *   |     string public symbol;
  15 | *r  |     uint8 public override decimals;
  16 | *   |     address public hyper;
  17 |     | 
  18 |     |     constructor(
  19 |     |         string memory name_,
  20 |     |         string memory symbol_,
  21 |     |         uint8 decimals_,
  22 |     |         address _hyper
  23 |     |     ) {
  24 |     |         name = name_;
  25 |     |         symbol = symbol_;
  26 |     |         decimals = decimals_;
  27 |     |         hyper = _hyper;
  28 |     |     }
  29 |     | 
  30 |     |     /// @notice Used for testing pairs with decimals that are not 18
  31 | *   |     function setDecimals(uint8 decimals_) public {
  32 | *   |         decimals = decimals_;
  33 |     |     }
  34 |     | 
  35 | *r  |     function totalSupply() public view virtual override returns (uint256) {
  36 | *   |         return _totalSupply;
  37 |     |     }
  38 |     | 
  39 | *r  |     function balanceOf(address account) public view virtual override returns (uint256) {
  40 | *r  |         return _balances[account];
  41 |     |     }
  42 |     | 
  43 | *r  |     function mint(address to, uint256 wad) public {
  44 | *r  |         if (to == address(hyper)) return;
  45 | *r  |         _mint(to, wad);
  46 |     |     }
  47 |     | 
  48 | *r  |     function burn(address to, uint256 wad) public {
  49 | *r  |         _burn(to, wad);
  50 |     |     }
  51 |     | 
  52 | *r  |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
  53 | *r  |         _transfer(msg.sender, recipient, amount);
  54 |     |         return true;
  55 |     |     }
  56 |     | 
  57 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
  58 | *   |         return _allowances[owner][spender];
  59 |     |     }
  60 |     | 
  61 | *r  |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  62 | *r  |         _approve(msg.sender, spender, amount);
  63 | *r  |         return true;
  64 |     |     }
  65 |     | 
  66 | *r  |     function transferFrom(
  67 |     |         address sender,
  68 |     |         address recipient,
  69 |     |         uint256 amount
  70 | *r  |     ) public virtual override returns (bool) {
  71 | *r  |         _transfer(sender, recipient, amount);
  72 |     | 
  73 | *r  |         uint256 currentAllowance = _allowances[sender][msg.sender];
  74 | *r  |         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
  75 |     |         unchecked {
  76 | *r  |             _approve(sender, msg.sender, currentAllowance - amount);
  77 |     |         }
  78 |     | 
  79 | *r  |         return true;
  80 |     |     }
  81 |     | 
  82 | *r  |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
  83 | *r  |         _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
  84 |     |         return true;
  85 |     |     }
  86 |     | 
  87 | *r  |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
  88 | *r  |         uint256 currentAllowance = _allowances[msg.sender][spender];
  89 | *r  |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
  90 |     |         unchecked {
  91 | *r  |             _approve(msg.sender, spender, currentAllowance - subtractedValue);
  92 |     |         }
  93 |     | 
  94 | *   |         return true;
  95 |     |     }
  96 |     | 
  97 | *r  |     function _transfer(
  98 |     |         address sender,
  99 |     |         address recipient,
 100 |     |         uint256 amount
 101 | *r  |     ) internal virtual {
 102 | *r  |         require(sender != address(0), "ERC20: transfer from the zero address");
 103 | *r  |         require(recipient != address(0), "ERC20: transfer to the zero address");
 104 |     | 
 105 |     |         _beforeTokenTransfer(sender, recipient, amount);
 106 |     | 
 107 | *r  |         uint256 senderBalance = _balances[sender];
 108 | *r  |         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
 109 |     |         unchecked {
 110 | *r  |             _balances[sender] = senderBalance - amount;
 111 |     |         }
 112 | *r  |         _balances[recipient] += amount;
 113 |     | 
 114 | *r  |         emit Transfer(sender, recipient, amount);
 115 |     |     }
 116 |     | 
 117 | *r  |     function _mint(address account, uint256 amount) internal virtual {
 118 | *r  |         require(account != address(0), "ERC20: mint to the zero address");
 119 |     | 
 120 |     |         _beforeTokenTransfer(address(0), account, amount);
 121 |     | 
 122 | *r  |         _totalSupply += amount;
 123 | *r  |         _balances[account] += amount;
 124 | *r  |         emit Transfer(address(0), account, amount);
 125 |     |     }
 126 |     | 
 127 | *r  |     function _burn(address account, uint256 amount) internal virtual {
 128 | *r  |         require(account != address(0), "ERC20: burn from the zero address");
 129 |     | 
 130 |     |         _beforeTokenTransfer(account, address(0), amount);
 131 |     | 
 132 | *r  |         uint256 accountBalance = _balances[account];
 133 | *r  |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 134 |     |         unchecked {
 135 | *   |             _balances[account] = accountBalance - amount;
 136 |     |         }
 137 | *   |         _totalSupply -= amount;
 138 |     | 
 139 | *   |         emit Transfer(account, address(0), amount);
 140 |     |     }
 141 |     | 
 142 | *r  |     function _approve(
 143 |     |         address owner,
 144 |     |         address spender,
 145 |     |         uint256 amount
 146 |     |     ) internal virtual {
 147 | *r  |         require(owner != address(0), "ERC20: approve from the zero address");
 148 | *r  |         require(spender != address(0), "ERC20: approve to the zero address");
 149 |     | 
 150 | *r  |         _allowances[owner][spender] = amount;
 151 | *r  |         emit Approval(owner, spender, amount);
 152 |     |     }
 153 |     | 
 154 |     |     function _beforeTokenTransfer(
 155 |     |         address from,
 156 |     |         address to,
 157 |     |         uint256 amount
 158 |     |     ) internal virtual {}
 159 |     | }
 160 |     | 

/root/code/hyper/contracts/test/HyperForwarderHelper.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IERC20 {
  5 |     |     function approve(address spender, uint256 amount) external;
  6 |     | }
  7 |     | 
  8 |     | contract HyperForwarderHelper {
  9 |     |     Caller public caller;
 10 |     | 
 11 |     |     event Success();
 12 |     |     event Fail(bytes reason);
 13 |     | 
 14 |     |     constructor() {
 15 |     |         caller = new Caller();
 16 |     |     }
 17 |     | 
 18 |     |     function approve(address token, address target) external {
 19 |     |         caller.approve(token, target, type(uint256).max);
 20 |     |     }
 21 |     | 
 22 |     |     // Assumes Hyper calls this, for testing only.
 23 |     |     function pass(address target, bytes calldata data) external payable returns (bool) {
 24 |     |         try caller.forward{value: msg.value}(target, data) {
 25 |     |             emit Success();
 26 |     |             return true;
 27 |     |         } catch (bytes memory reason) {
 28 |     |             emit Fail(reason);
 29 |     |             assembly {
 30 |     |                 revert(add(32, reason), mload(reason))
 31 |     |             }
 32 |     |         }
 33 |     |     }
 34 |     | 
 35 |     |     function getPoolId(uint24 pairId, bool isMutable, uint32 poolNonce) public pure returns (uint64) {
 36 |     |         return uint64(bytes8(abi.encodePacked(pairId, isMutable ? 1 : 0, poolNonce)));
 37 |     |     }
 38 |     | }
 39 |     | 
 40 |     | /// @dev msg.sender in Hyper calls.
 41 |     | contract Caller {
 42 |     |     function approve(address token, address to, uint256 amount) external {
 43 |     |         IERC20(token).approve(to, amount);
 44 |     |     }
 45 |     | 
 46 |     |     function forward(address target, bytes calldata data) external payable returns (bool) {
 47 |     |         (bool success, bytes memory returnData) = target.call{value: msg.value}(data);
 48 |     |         if (!success) {
 49 |     |             assembly {
 50 |     |                 revert(add(32, returnData), mload(returnData))
 51 |     |             }
 52 |     |         }
 53 |     | 
 54 |     |         return success;
 55 |     |     }
 56 |     | }
 57 |     | 

/root/code/hyper/contracts/test/TestERC20.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "../interfaces/IERC20.sol";
   5 |     | 
   6 |     | contract TestERC20 is IERC20 {
   7 |     |     mapping(address => uint256) private _balances;
   8 |     | 
   9 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  10 |     | 
  11 |     |     uint256 private _totalSupply;
  12 |     | 
  13 |     |     string public name;
  14 |     |     string public symbol;
  15 |     |     uint8 public override decimals;
  16 |     | 
  17 |     |     constructor(
  18 |     |         string memory name_,
  19 |     |         string memory symbol_,
  20 |     |         uint8 decimals_
  21 |     |     ) {
  22 |     |         name = name_;
  23 |     |         symbol = symbol_;
  24 |     |         decimals = decimals_;
  25 |     |     }
  26 |     | 
  27 |     |     /// @notice Used for testing pairs with decimals that are not 18
  28 |     |     function setDecimals(uint8 decimals_) public {
  29 |     |         decimals = decimals_;
  30 |     |     }
  31 |     | 
  32 |     |     function totalSupply() public view virtual override returns (uint256) {
  33 |     |         return _totalSupply;
  34 |     |     }
  35 |     | 
  36 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
  37 |     |         return _balances[account];
  38 |     |     }
  39 |     | 
  40 |     |     function mint(address to, uint256 wad) public {
  41 |     |         _mint(to, wad);
  42 |     |     }
  43 |     | 
  44 |     |     function burn(address to, uint256 wad) public {
  45 |     |         _burn(to, wad);
  46 |     |     }
  47 |     | 
  48 |     |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
  49 |     |         _transfer(msg.sender, recipient, amount);
  50 |     |         return true;
  51 |     |     }
  52 |     | 
  53 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
  54 |     |         return _allowances[owner][spender];
  55 |     |     }
  56 |     | 
  57 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  58 |     |         _approve(msg.sender, spender, amount);
  59 |     |         return true;
  60 |     |     }
  61 |     | 
  62 |     |     function transferFrom(
  63 |     |         address sender,
  64 |     |         address recipient,
  65 |     |         uint256 amount
  66 |     |     ) public virtual override returns (bool) {
  67 |     |         _transfer(sender, recipient, amount);
  68 |     | 
  69 |     |         uint256 currentAllowance = _allowances[sender][msg.sender];
  70 |     |         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
  71 |     |         unchecked {
  72 |     |             _approve(sender, msg.sender, currentAllowance - amount);
  73 |     |         }
  74 |     | 
  75 |     |         return true;
  76 |     |     }
  77 |     | 
  78 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
  79 |     |         _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
  80 |     |         return true;
  81 |     |     }
  82 |     | 
  83 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
  84 |     |         uint256 currentAllowance = _allowances[msg.sender][spender];
  85 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
  86 |     |         unchecked {
  87 |     |             _approve(msg.sender, spender, currentAllowance - subtractedValue);
  88 |     |         }
  89 |     | 
  90 |     |         return true;
  91 |     |     }
  92 |     | 
  93 |     |     function _transfer(
  94 |     |         address sender,
  95 |     |         address recipient,
  96 |     |         uint256 amount
  97 |     |     ) internal virtual {
  98 |     |         require(sender != address(0), "ERC20: transfer from the zero address");
  99 |     |         require(recipient != address(0), "ERC20: transfer to the zero address");
 100 |     | 
 101 |     |         _beforeTokenTransfer(sender, recipient, amount);
 102 |     | 
 103 |     |         uint256 senderBalance = _balances[sender];
 104 |     |         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
 105 |     |         unchecked {
 106 |     |             _balances[sender] = senderBalance - amount;
 107 |     |         }
 108 |     |         _balances[recipient] += amount;
 109 |     | 
 110 |     |         emit Transfer(sender, recipient, amount);
 111 |     |     }
 112 |     | 
 113 |     |     function _mint(address account, uint256 amount) internal virtual {
 114 |     |         require(account != address(0), "ERC20: mint to the zero address");
 115 |     | 
 116 |     |         _beforeTokenTransfer(address(0), account, amount);
 117 |     | 
 118 |     |         _totalSupply += amount;
 119 |     |         _balances[account] += amount;
 120 |     |         emit Transfer(address(0), account, amount);
 121 |     |     }
 122 |     | 
 123 |     |     function _burn(address account, uint256 amount) internal virtual {
 124 |     |         require(account != address(0), "ERC20: burn from the zero address");
 125 |     | 
 126 |     |         _beforeTokenTransfer(account, address(0), amount);
 127 |     | 
 128 |     |         uint256 accountBalance = _balances[account];
 129 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 130 |     |         unchecked {
 131 |     |             _balances[account] = accountBalance - amount;
 132 |     |         }
 133 |     |         _totalSupply -= amount;
 134 |     | 
 135 |     |         emit Transfer(account, address(0), amount);
 136 |     |     }
 137 |     | 
 138 |     |     function _approve(
 139 |     |         address owner,
 140 |     |         address spender,
 141 |     |         uint256 amount
 142 |     |     ) internal virtual {
 143 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 144 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 145 |     | 
 146 |     |         _allowances[owner][spender] = amount;
 147 |     |         emit Approval(owner, spender, amount);
 148 |     |     }
 149 |     | 
 150 |     |     function _beforeTokenTransfer(
 151 |     |         address from,
 152 |     |         address to,
 153 |     |         uint256 amount
 154 |     |     ) internal virtual {}
 155 |     | }
 156 |     | 

/root/code/hyper/contracts/test/TestHyperTime.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import "../Hyper.sol";
  5 |     | 
  6 |     | contract TestHyperTime is Hyper {
  7 |     |     uint256 public timestamp;
  8 |     | 
  9 |     |     function set(uint256 x) public {
 10 |     |         timestamp = x;
 11 |     |     }
 12 |     | 
 13 |     |     constructor(address weth) Hyper(weth) {}
 14 |     | 
 15 |     |     function _blockTimestamp() internal view override returns (uint128) {
 16 |     |         return uint128(timestamp);
 17 |     |     }
 18 |     | }
 19 |     | 

/root/code/hyper/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
  9 |     |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
 10 |     |     // console.sol and console2.sol work by executing a staticcall to this address.
 11 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 12 |     |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
 13 |     |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
 14 |     |     // Address of the test contract, deployed by the DEFAULT_SENDER.
 15 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 16 |     | 
 17 |     |     uint256 internal constant UINT256_MAX =
 18 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 19 |     | 
 20 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 21 |     |     StdStorage internal stdstore;
 22 |     | }
 23 |     | 
 24 |     | abstract contract TestBase is CommonBase {}
 25 |     | 
 26 |     | abstract contract ScriptBase is CommonBase {
 27 |     |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
 28 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 29 |     | 
 30 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 31 |     | }
 32 |     | 

/root/code/hyper/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {DSTest} from "ds-test/test.sol";
   5 |     | import {stdMath} from "./StdMath.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions is DSTest {
   8 |     |     event log_array(uint256[] val);
   9 |     |     event log_array(int256[] val);
  10 |     |     event log_array(address[] val);
  11 |     |     event log_named_array(string key, uint256[] val);
  12 |     |     event log_named_array(string key, int256[] val);
  13 |     |     event log_named_array(string key, address[] val);
  14 |     | 
  15 |     |     function fail(string memory err) internal virtual {
  16 |     |         emit log_named_string("Error", err);
  17 |     |         fail();
  18 |     |     }
  19 |     | 
  20 |     |     function assertFalse(bool data) internal virtual {
  21 |     |         assertTrue(!data);
  22 |     |     }
  23 |     | 
  24 |     |     function assertFalse(bool data, string memory err) internal virtual {
  25 |     |         assertTrue(!data, err);
  26 |     |     }
  27 |     | 
  28 |     |     function assertEq(bool a, bool b) internal virtual {
  29 |     |         if (a != b) {
  30 |     |             emit log("Error: a == b not satisfied [bool]");
  31 |     |             emit log_named_string("  Expected", b ? "true" : "false");
  32 |     |             emit log_named_string("    Actual", a ? "true" : "false");
  33 |     |             fail();
  34 |     |         }
  35 |     |     }
  36 |     | 
  37 |     |     function assertEq(bool a, bool b, string memory err) internal virtual {
  38 |     |         if (a != b) {
  39 |     |             emit log_named_string("Error", err);
  40 |     |             assertEq(a, b);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     function assertEq(bytes memory a, bytes memory b) internal virtual {
  45 |     |         assertEq0(a, b);
  46 |     |     }
  47 |     | 
  48 |     |     function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {
  49 |     |         assertEq0(a, b, err);
  50 |     |     }
  51 |     | 
  52 |     |     function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {
  53 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  54 |     |             emit log("Error: a == b not satisfied [uint[]]");
  55 |     |             emit log_named_array("  Expected", b);
  56 |     |             emit log_named_array("    Actual", a);
  57 |     |             fail();
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     function assertEq(int256[] memory a, int256[] memory b) internal virtual {
  62 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  63 |     |             emit log("Error: a == b not satisfied [int[]]");
  64 |     |             emit log_named_array("  Expected", b);
  65 |     |             emit log_named_array("    Actual", a);
  66 |     |             fail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     function assertEq(address[] memory a, address[] memory b) internal virtual {
  71 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  72 |     |             emit log("Error: a == b not satisfied [address[]]");
  73 |     |             emit log_named_array("  Expected", b);
  74 |     |             emit log_named_array("    Actual", a);
  75 |     |             fail();
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {
  80 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  81 |     |             emit log_named_string("Error", err);
  82 |     |             assertEq(a, b);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {
  87 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  88 |     |             emit log_named_string("Error", err);
  89 |     |             assertEq(a, b);
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {
  94 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  95 |     |             emit log_named_string("Error", err);
  96 |     |             assertEq(a, b);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     // Legacy helper
 101 |     |     function assertEqUint(uint256 a, uint256 b) internal virtual {
 102 |     |         assertEq(uint256(a), uint256(b));
 103 |     |     }
 104 |     | 
 105 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {
 106 |     |         uint256 delta = stdMath.delta(a, b);
 107 |     | 
 108 |     |         if (delta > maxDelta) {
 109 |     |             emit log("Error: a ~= b not satisfied [uint]");
 110 |     |             emit log_named_uint("  Expected", b);
 111 |     |             emit log_named_uint("    Actual", a);
 112 |     |             emit log_named_uint(" Max Delta", maxDelta);
 113 |     |             emit log_named_uint("     Delta", delta);
 114 |     |             fail();
 115 |     |         }
 116 |     |     }
 117 |     | 
 118 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {
 119 |     |         uint256 delta = stdMath.delta(a, b);
 120 |     | 
 121 |     |         if (delta > maxDelta) {
 122 |     |             emit log_named_string("Error", err);
 123 |     |             assertApproxEqAbs(a, b, maxDelta);
 124 |     |         }
 125 |     |     }
 126 |     | 
 127 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {
 128 |     |         uint256 delta = stdMath.delta(a, b);
 129 |     | 
 130 |     |         if (delta > maxDelta) {
 131 |     |             emit log("Error: a ~= b not satisfied [int]");
 132 |     |             emit log_named_int("  Expected", b);
 133 |     |             emit log_named_int("    Actual", a);
 134 |     |             emit log_named_uint(" Max Delta", maxDelta);
 135 |     |             emit log_named_uint("     Delta", delta);
 136 |     |             fail();
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {
 141 |     |         uint256 delta = stdMath.delta(a, b);
 142 |     | 
 143 |     |         if (delta > maxDelta) {
 144 |     |             emit log_named_string("Error", err);
 145 |     |             assertApproxEqAbs(a, b, maxDelta);
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     function assertApproxEqRel(
 150 |     |         uint256 a,
 151 |     |         uint256 b,
 152 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 153 |     |     ) internal virtual {
 154 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 155 |     | 
 156 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 157 |     | 
 158 |     |         if (percentDelta > maxPercentDelta) {
 159 |     |             emit log("Error: a ~= b not satisfied [uint]");
 160 |     |             emit log_named_uint("    Expected", b);
 161 |     |             emit log_named_uint("      Actual", a);
 162 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 163 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 164 |     |             fail();
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     function assertApproxEqRel(
 169 |     |         uint256 a,
 170 |     |         uint256 b,
 171 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 172 |     |         string memory err
 173 |     |     ) internal virtual {
 174 |     |         if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.
 175 |     | 
 176 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 177 |     | 
 178 |     |         if (percentDelta > maxPercentDelta) {
 179 |     |             emit log_named_string("Error", err);
 180 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {
 185 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 186 |     | 
 187 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 188 |     | 
 189 |     |         if (percentDelta > maxPercentDelta) {
 190 |     |             emit log("Error: a ~= b not satisfied [int]");
 191 |     |             emit log_named_int("    Expected", b);
 192 |     |             emit log_named_int("      Actual", a);
 193 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 194 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 195 |     |             fail();
 196 |     |         }
 197 |     |     }
 198 |     | 
 199 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {
 200 |     |         if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.
 201 |     | 
 202 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 203 |     | 
 204 |     |         if (percentDelta > maxPercentDelta) {
 205 |     |             emit log_named_string("Error", err);
 206 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 207 |     |         }
 208 |     |     }
 209 |     | }
 210 |     | 

/root/code/hyper/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
  10 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
  11 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  12 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  13 |     |  * alias used in this contract, which can be found as the first argument to the
  14 |     |  * `setChainWithDefaultRpcUrl` call in the `initialize` function.
  15 |     |  *
  16 |     |  * There are two main ways to use this contract:
  17 |     |  *   1. Set a chain with `setChain(string memory chainAlias, Chain memory chain)`
  18 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  19 |     |  *
  20 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  21 |     |  * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  22 |     |  * `defaultRpcUrls`.
  23 |     |  *
  24 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  25 |     |  *
  26 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  27 |     |  * we want to retrieve `mainnet`'s RPC URL:
  28 |     |  *   - If you haven't set any mainnet chain info with `setChain` and you haven't specified that
  29 |     |  *     chain in `foundry.toml`, the default data and RPC URL will be returned.
  30 |     |  *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if
  31 |     |  *     a URL is given or if an environment variable is given and that environment variable exists).
  32 |     |  *     Otherwise, the default data is returned.
  33 |     |  *   - If you specified data with `setChain` it will return that.
  34 |     |  *
  35 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> defaults.
  36 |     |  */
  37 |     | abstract contract StdChains {
  38 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  39 |     | 
  40 |     |     bool private initialized;
  41 |     | 
  42 |     |     struct Chain {
  43 |     |         // The chain name.
  44 |     |         string name;
  45 |     |         // The chain's Chain ID.
  46 |     |         uint256 chainId;
  47 |     |         // A default RPC endpoint for this chain.
  48 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  49 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  50 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  51 |     |         string rpcUrl;
  52 |     |     }
  53 |     | 
  54 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  55 |     |     mapping(string => Chain) private chains;
  56 |     |     // Maps from the chain's alias to it's default RPC URL.
  57 |     |     mapping(string => string) private defaultRpcUrls;
  58 |     |     // Maps from a chain ID to it's alias.
  59 |     |     mapping(uint256 => string) private idToAlias;
  60 |     | 
  61 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  62 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  63 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  64 |     | 
  65 |     |         initialize();
  66 |     |         chain = chains[chainAlias];
  67 |     |         require(
  68 |     |             chain.chainId != 0,
  69 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  70 |     |         );
  71 |     | 
  72 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  73 |     |     }
  74 |     | 
  75 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  76 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  77 |     |         initialize();
  78 |     |         string memory chainAlias = idToAlias[chainId];
  79 |     | 
  80 |     |         chain = chains[chainAlias];
  81 |     | 
  82 |     |         require(
  83 |     |             chain.chainId != 0,
  84 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  85 |     |         );
  86 |     | 
  87 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  88 |     |     }
  89 |     | 
  90 |     |     // set chain info, with priority to argument's rpcUrl field.
  91 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
  92 |     |         require(
  93 |     |             bytes(chainAlias).length != 0, "StdChains setChain(string,Chain): Chain alias cannot be the empty string."
  94 |     |         );
  95 |     | 
  96 |     |         require(chain.chainId != 0, "StdChains setChain(string,Chain): Chain ID cannot be 0.");
  97 |     | 
  98 |     |         initialize();
  99 |     |         string memory foundAlias = idToAlias[chain.chainId];
 100 |     | 
 101 |     |         require(
 102 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 103 |     |             string(
 104 |     |                 abi.encodePacked(
 105 |     |                     "StdChains setChain(string,Chain): Chain ID ",
 106 |     |                     vm.toString(chain.chainId),
 107 |     |                     " already used by \"",
 108 |     |                     foundAlias,
 109 |     |                     "\"."
 110 |     |                 )
 111 |     |             )
 112 |     |         );
 113 |     | 
 114 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 115 |     |         delete idToAlias[oldChainId];
 116 |     | 
 117 |     |         chains[chainAlias] = chain;
 118 |     |         idToAlias[chain.chainId] = chainAlias;
 119 |     |     }
 120 |     | 
 121 |     |     // lookup rpcUrl, in descending order of priority:
 122 |     |     // current -> config (foundry.toml) -> default
 123 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 124 |     |         private
 125 |     |         view
 126 |     |         returns (Chain memory)
 127 |     |     {
 128 |     |         if (bytes(chain.rpcUrl).length == 0) {
 129 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 130 |     |                 chain.rpcUrl = configRpcUrl;
 131 |     |             } catch (bytes memory err) {
 132 |     |                 chain.rpcUrl = defaultRpcUrls[chainAlias];
 133 |     |                 // distinguish 'not found' from 'cannot read'
 134 |     |                 bytes memory notFoundError =
 135 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 136 |     |                 if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {
 137 |     |                     /// @solidity memory-safe-assembly
 138 |     |                     assembly {
 139 |     |                         revert(add(32, err), mload(err))
 140 |     |                     }
 141 |     |                 }
 142 |     |             }
 143 |     |         }
 144 |     |         return chain;
 145 |     |     }
 146 |     | 
 147 |     |     function initialize() private {
 148 |     |         if (initialized) return;
 149 |     | 
 150 |     |         initialized = true;
 151 |     | 
 152 |     |         // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`
 153 |     |         setChainWithDefaultRpcUrl("anvil", Chain("Anvil", 31337, "http://127.0.0.1:8545"));
 154 |     |         setChainWithDefaultRpcUrl(
 155 |     |             "mainnet", Chain("Mainnet", 1, "https://mainnet.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
 156 |     |         );
 157 |     |         setChainWithDefaultRpcUrl(
 158 |     |             "goerli", Chain("Goerli", 5, "https://goerli.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
 159 |     |         );
 160 |     |         setChainWithDefaultRpcUrl(
 161 |     |             "sepolia", Chain("Sepolia", 11155111, "https://sepolia.infura.io/v3/6770454bc6ea42c58aac12978531b93f")
 162 |     |         );
 163 |     |         setChainWithDefaultRpcUrl("optimism", Chain("Optimism", 10, "https://mainnet.optimism.io"));
 164 |     |         setChainWithDefaultRpcUrl("optimism_goerli", Chain("Optimism Goerli", 420, "https://goerli.optimism.io"));
 165 |     |         setChainWithDefaultRpcUrl("arbitrum_one", Chain("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 166 |     |         setChainWithDefaultRpcUrl(
 167 |     |             "arbitrum_one_goerli", Chain("Arbitrum One Goerli", 421613, "https://goerli-rollup.arbitrum.io/rpc")
 168 |     |         );
 169 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", Chain("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 170 |     |         setChainWithDefaultRpcUrl("polygon", Chain("Polygon", 137, "https://polygon-rpc.com"));
 171 |     |         setChainWithDefaultRpcUrl("polygon_mumbai", Chain("Polygon Mumbai", 80001, "https://rpc-mumbai.maticvigil.com"));
 172 |     |         setChainWithDefaultRpcUrl("avalanche", Chain("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 173 |     |         setChainWithDefaultRpcUrl(
 174 |     |             "avalanche_fuji", Chain("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 175 |     |         );
 176 |     |         setChainWithDefaultRpcUrl("bnb_smart_chain", Chain("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org"));
 177 |     |         setChainWithDefaultRpcUrl("bnb_smart_chain_testnet", Chain("BNB Smart Chain Testnet", 97, "https://data-seed-prebsc-1-s1.binance.org:8545"));// forgefmt: disable-line
 178 |     |         setChainWithDefaultRpcUrl("gnosis_chain", Chain("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 179 |     |     }
 180 |     | 
 181 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 182 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, Chain memory chain) private {
 183 |     |         string memory rpcUrl = chain.rpcUrl;
 184 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 185 |     |         chain.rpcUrl = "";
 186 |     |         setChain(chainAlias, chain);
 187 |     |         chain.rpcUrl = rpcUrl; // restore argument
 188 |     |     }
 189 |     | }
 190 |     | 

/root/code/hyper/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {Vm} from "./Vm.sol";
   8 |     | 
   9 |     | abstract contract StdCheatsSafe {
  10 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  11 |     | 
  12 |     |     bool private gasMeteringOff;
  13 |     | 
  14 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  15 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  16 |     |     // and then converted to the one that is used by the user for better UX.
  17 |     | 
  18 |     |     struct RawTx1559 {
  19 |     |         string[] arguments;
  20 |     |         address contractAddress;
  21 |     |         string contractName;
  22 |     |         // json value name = function
  23 |     |         string functionSig;
  24 |     |         bytes32 hash;
  25 |     |         // json value name = tx
  26 |     |         RawTx1559Detail txDetail;
  27 |     |         // json value name = type
  28 |     |         string opcode;
  29 |     |     }
  30 |     | 
  31 |     |     struct RawTx1559Detail {
  32 |     |         AccessList[] accessList;
  33 |     |         bytes data;
  34 |     |         address from;
  35 |     |         bytes gas;
  36 |     |         bytes nonce;
  37 |     |         address to;
  38 |     |         bytes txType;
  39 |     |         bytes value;
  40 |     |     }
  41 |     | 
  42 |     |     struct Tx1559 {
  43 |     |         string[] arguments;
  44 |     |         address contractAddress;
  45 |     |         string contractName;
  46 |     |         string functionSig;
  47 |     |         bytes32 hash;
  48 |     |         Tx1559Detail txDetail;
  49 |     |         string opcode;
  50 |     |     }
  51 |     | 
  52 |     |     struct Tx1559Detail {
  53 |     |         AccessList[] accessList;
  54 |     |         bytes data;
  55 |     |         address from;
  56 |     |         uint256 gas;
  57 |     |         uint256 nonce;
  58 |     |         address to;
  59 |     |         uint256 txType;
  60 |     |         uint256 value;
  61 |     |     }
  62 |     | 
  63 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  64 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  65 |     |     // and then converted to the one that is used by the user for better UX.
  66 |     | 
  67 |     |     struct TxLegacy {
  68 |     |         string[] arguments;
  69 |     |         address contractAddress;
  70 |     |         string contractName;
  71 |     |         string functionSig;
  72 |     |         string hash;
  73 |     |         string opcode;
  74 |     |         TxDetailLegacy transaction;
  75 |     |     }
  76 |     | 
  77 |     |     struct TxDetailLegacy {
  78 |     |         AccessList[] accessList;
  79 |     |         uint256 chainId;
  80 |     |         bytes data;
  81 |     |         address from;
  82 |     |         uint256 gas;
  83 |     |         uint256 gasPrice;
  84 |     |         bytes32 hash;
  85 |     |         uint256 nonce;
  86 |     |         bytes1 opcode;
  87 |     |         bytes32 r;
  88 |     |         bytes32 s;
  89 |     |         uint256 txType;
  90 |     |         address to;
  91 |     |         uint8 v;
  92 |     |         uint256 value;
  93 |     |     }
  94 |     | 
  95 |     |     struct AccessList {
  96 |     |         address accessAddress;
  97 |     |         bytes32[] storageKeys;
  98 |     |     }
  99 |     | 
 100 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 101 |     |     // The Raw structs is what is parsed from the JSON
 102 |     |     // and then converted to the one that is used by the user for better UX.
 103 |     | 
 104 |     |     struct RawReceipt {
 105 |     |         bytes32 blockHash;
 106 |     |         bytes blockNumber;
 107 |     |         address contractAddress;
 108 |     |         bytes cumulativeGasUsed;
 109 |     |         bytes effectiveGasPrice;
 110 |     |         address from;
 111 |     |         bytes gasUsed;
 112 |     |         RawReceiptLog[] logs;
 113 |     |         bytes logsBloom;
 114 |     |         bytes status;
 115 |     |         address to;
 116 |     |         bytes32 transactionHash;
 117 |     |         bytes transactionIndex;
 118 |     |     }
 119 |     | 
 120 |     |     struct Receipt {
 121 |     |         bytes32 blockHash;
 122 |     |         uint256 blockNumber;
 123 |     |         address contractAddress;
 124 |     |         uint256 cumulativeGasUsed;
 125 |     |         uint256 effectiveGasPrice;
 126 |     |         address from;
 127 |     |         uint256 gasUsed;
 128 |     |         ReceiptLog[] logs;
 129 |     |         bytes logsBloom;
 130 |     |         uint256 status;
 131 |     |         address to;
 132 |     |         bytes32 transactionHash;
 133 |     |         uint256 transactionIndex;
 134 |     |     }
 135 |     | 
 136 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 137 |     |     // transactions conform to EIP1559.
 138 |     | 
 139 |     |     struct EIP1559ScriptArtifact {
 140 |     |         string[] libraries;
 141 |     |         string path;
 142 |     |         string[] pending;
 143 |     |         Receipt[] receipts;
 144 |     |         uint256 timestamp;
 145 |     |         Tx1559[] transactions;
 146 |     |         TxReturn[] txReturns;
 147 |     |     }
 148 |     | 
 149 |     |     struct RawEIP1559ScriptArtifact {
 150 |     |         string[] libraries;
 151 |     |         string path;
 152 |     |         string[] pending;
 153 |     |         RawReceipt[] receipts;
 154 |     |         TxReturn[] txReturns;
 155 |     |         uint256 timestamp;
 156 |     |         RawTx1559[] transactions;
 157 |     |     }
 158 |     | 
 159 |     |     struct RawReceiptLog {
 160 |     |         // json value = address
 161 |     |         address logAddress;
 162 |     |         bytes32 blockHash;
 163 |     |         bytes blockNumber;
 164 |     |         bytes data;
 165 |     |         bytes logIndex;
 166 |     |         bool removed;
 167 |     |         bytes32[] topics;
 168 |     |         bytes32 transactionHash;
 169 |     |         bytes transactionIndex;
 170 |     |         bytes transactionLogIndex;
 171 |     |     }
 172 |     | 
 173 |     |     struct ReceiptLog {
 174 |     |         // json value = address
 175 |     |         address logAddress;
 176 |     |         bytes32 blockHash;
 177 |     |         uint256 blockNumber;
 178 |     |         bytes data;
 179 |     |         uint256 logIndex;
 180 |     |         bytes32[] topics;
 181 |     |         uint256 transactionIndex;
 182 |     |         uint256 transactionLogIndex;
 183 |     |         bool removed;
 184 |     |     }
 185 |     | 
 186 |     |     struct TxReturn {
 187 |     |         string internalType;
 188 |     |         string value;
 189 |     |     }
 190 |     | 
 191 |     |     function assumeNoPrecompiles(address addr) internal virtual {
 192 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 193 |     |         uint256 chainId;
 194 |     |         assembly {
 195 |     |             chainId := chainid()
 196 |     |         }
 197 |     |         assumeNoPrecompiles(addr, chainId);
 198 |     |     }
 199 |     | 
 200 |     |     function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {
 201 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 202 |     |         // address), but the same rationale for excluding them applies so we include those too.
 203 |     | 
 204 |     |         // These should be present on all EVM-compatible chains.
 205 |     |         vm.assume(addr < address(0x1) || addr > address(0x9));
 206 |     | 
 207 |     |         // forgefmt: disable-start
 208 |     |         if (chainId == 10 || chainId == 420) {
 209 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 210 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 211 |     |         } else if (chainId == 42161 || chainId == 421613) {
 212 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 213 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 214 |     |         } else if (chainId == 43114 || chainId == 43113) {
 215 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 216 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 217 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 218 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 219 |     |         }
 220 |     |         // forgefmt: disable-end
 221 |     |     }
 222 |     | 
 223 |     |     function readEIP1559ScriptArtifact(string memory path)
 224 |     |         internal
 225 |     |         view
 226 |     |         virtual
 227 |     |         returns (EIP1559ScriptArtifact memory)
 228 |     |     {
 229 |     |         string memory data = vm.readFile(path);
 230 |     |         bytes memory parsedData = vm.parseJson(data);
 231 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 232 |     |         EIP1559ScriptArtifact memory artifact;
 233 |     |         artifact.libraries = rawArtifact.libraries;
 234 |     |         artifact.path = rawArtifact.path;
 235 |     |         artifact.timestamp = rawArtifact.timestamp;
 236 |     |         artifact.pending = rawArtifact.pending;
 237 |     |         artifact.txReturns = rawArtifact.txReturns;
 238 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 239 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 240 |     |         return artifact;
 241 |     |     }
 242 |     | 
 243 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 244 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 245 |     |         for (uint256 i; i < rawTxs.length; i++) {
 246 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 247 |     |         }
 248 |     |         return txs;
 249 |     |     }
 250 |     | 
 251 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 252 |     |         Tx1559 memory transaction;
 253 |     |         transaction.arguments = rawTx.arguments;
 254 |     |         transaction.contractName = rawTx.contractName;
 255 |     |         transaction.functionSig = rawTx.functionSig;
 256 |     |         transaction.hash = rawTx.hash;
 257 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 258 |     |         transaction.opcode = rawTx.opcode;
 259 |     |         return transaction;
 260 |     |     }
 261 |     | 
 262 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 263 |     |         internal
 264 |     |         pure
 265 |     |         virtual
 266 |     |         returns (Tx1559Detail memory)
 267 |     |     {
 268 |     |         Tx1559Detail memory txDetail;
 269 |     |         txDetail.data = rawDetail.data;
 270 |     |         txDetail.from = rawDetail.from;
 271 |     |         txDetail.to = rawDetail.to;
 272 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 273 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 274 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 275 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 276 |     |         txDetail.accessList = rawDetail.accessList;
 277 |     |         return txDetail;
 278 |     |     }
 279 |     | 
 280 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 281 |     |         string memory deployData = vm.readFile(path);
 282 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 283 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 284 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 285 |     |     }
 286 |     | 
 287 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 288 |     |         string memory deployData = vm.readFile(path);
 289 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 290 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 291 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 292 |     |         return rawToConvertedEIPTx1559(rawTx);
 293 |     |     }
 294 |     | 
 295 |     |     // Analogous to readTransactions, but for receipts.
 296 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 297 |     |         string memory deployData = vm.readFile(path);
 298 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 299 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 300 |     |         return rawToConvertedReceipts(rawReceipts);
 301 |     |     }
 302 |     | 
 303 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 304 |     |         string memory deployData = vm.readFile(path);
 305 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 306 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 307 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 308 |     |         return rawToConvertedReceipt(rawReceipt);
 309 |     |     }
 310 |     | 
 311 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 312 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 313 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 314 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 315 |     |         }
 316 |     |         return receipts;
 317 |     |     }
 318 |     | 
 319 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 320 |     |         Receipt memory receipt;
 321 |     |         receipt.blockHash = rawReceipt.blockHash;
 322 |     |         receipt.to = rawReceipt.to;
 323 |     |         receipt.from = rawReceipt.from;
 324 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 325 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 326 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 327 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 328 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 329 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 330 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 331 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 332 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 333 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 334 |     |         return receipt;
 335 |     |     }
 336 |     | 
 337 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 338 |     |         internal
 339 |     |         pure
 340 |     |         virtual
 341 |     |         returns (ReceiptLog[] memory)
 342 |     |     {
 343 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 344 |     |         for (uint256 i; i < rawLogs.length; i++) {
 345 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 346 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 347 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 348 |     |             logs[i].data = rawLogs[i].data;
 349 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 350 |     |             logs[i].topics = rawLogs[i].topics;
 351 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 352 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 353 |     |             logs[i].removed = rawLogs[i].removed;
 354 |     |         }
 355 |     |         return logs;
 356 |     |     }
 357 |     | 
 358 |     |     // Deploy a contract by fetching the contract bytecode from
 359 |     |     // the artifacts directory
 360 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 361 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 362 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 363 |     |         /// @solidity memory-safe-assembly
 364 |     |         assembly {
 365 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 366 |     |         }
 367 |     | 
 368 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 369 |     |     }
 370 |     | 
 371 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 372 |     |         bytes memory bytecode = vm.getCode(what);
 373 |     |         /// @solidity memory-safe-assembly
 374 |     |         assembly {
 375 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 376 |     |         }
 377 |     | 
 378 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 379 |     |     }
 380 |     | 
 381 |     |     /// @dev deploy contract with value on construction
 382 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 383 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 384 |     |         /// @solidity memory-safe-assembly
 385 |     |         assembly {
 386 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 387 |     |         }
 388 |     | 
 389 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 390 |     |     }
 391 |     | 
 392 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 393 |     |         bytes memory bytecode = vm.getCode(what);
 394 |     |         /// @solidity memory-safe-assembly
 395 |     |         assembly {
 396 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 397 |     |         }
 398 |     | 
 399 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 400 |     |     }
 401 |     | 
 402 |     |     // creates a labeled address and the corresponding private key
 403 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 404 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 405 |     |         addr = vm.addr(privateKey);
 406 |     |         vm.label(addr, name);
 407 |     |     }
 408 |     | 
 409 |     |     // creates a labeled address
 410 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 411 |     |         (addr,) = makeAddrAndKey(name);
 412 |     |     }
 413 |     | 
 414 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 415 |     |         internal
 416 |     |         virtual
 417 |     |         returns (address who, uint256 privateKey)
 418 |     |     {
 419 |     |         privateKey = vm.deriveKey(mnemonic, index);
 420 |     |         who = vm.rememberKey(privateKey);
 421 |     |     }
 422 |     | 
 423 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 424 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 425 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 426 |     |     }
 427 |     | 
 428 |     |     function isFork() internal view virtual returns (bool status) {
 429 |     |         try vm.activeFork() {
 430 |     |             status = true;
 431 |     |         } catch (bytes memory) {}
 432 |     |     }
 433 |     | 
 434 |     |     modifier skipWhenForking() {
 435 |     |         if (!isFork()) {
 436 |     |             _;
 437 |     |         }
 438 |     |     }
 439 |     | 
 440 |     |     modifier skipWhenNotForking() {
 441 |     |         if (isFork()) {
 442 |     |             _;
 443 |     |         }
 444 |     |     }
 445 |     | 
 446 |     |     modifier noGasMetering() {
 447 |     |         vm.pauseGasMetering();
 448 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 449 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 450 |     |         // it back on until we exit the top level function that used the modifier
 451 |     |         //
 452 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 453 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 454 |     |         // so we only turn metering back on at the end of the funcA
 455 |     |         bool gasStartedOff = gasMeteringOff;
 456 |     |         gasMeteringOff = true;
 457 |     | 
 458 |     |         _;
 459 |     | 
 460 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 461 |     |         if (!gasStartedOff) {
 462 |     |             gasMeteringOff = false;
 463 |     |             vm.resumeGasMetering();
 464 |     |         }
 465 |     |     }
 466 |     | }
 467 |     | 
 468 |     | // Wrappers around cheatcodes to avoid footguns
 469 |     | abstract contract StdCheats is StdCheatsSafe {
 470 |     |     using stdStorage for StdStorage;
 471 |     | 
 472 |     |     StdStorage private stdstore;
 473 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 474 |     | 
 475 |     |     // Skip forward or rewind time by the specified number of seconds
 476 |     |     function skip(uint256 time) internal virtual {
 477 |     |         vm.warp(block.timestamp + time);
 478 |     |     }
 479 |     | 
 480 |     |     function rewind(uint256 time) internal virtual {
 481 |     |         vm.warp(block.timestamp - time);
 482 |     |     }
 483 |     | 
 484 |     |     // Setup a prank from an address that has some ether
 485 |     |     function hoax(address who) internal virtual {
 486 |     |         vm.deal(who, 1 << 128);
 487 |     |         vm.prank(who);
 488 |     |     }
 489 |     | 
 490 |     |     function hoax(address who, uint256 give) internal virtual {
 491 |     |         vm.deal(who, give);
 492 |     |         vm.prank(who);
 493 |     |     }
 494 |     | 
 495 |     |     function hoax(address who, address origin) internal virtual {
 496 |     |         vm.deal(who, 1 << 128);
 497 |     |         vm.prank(who, origin);
 498 |     |     }
 499 |     | 
 500 |     |     function hoax(address who, address origin, uint256 give) internal virtual {
 501 |     |         vm.deal(who, give);
 502 |     |         vm.prank(who, origin);
 503 |     |     }
 504 |     | 
 505 |     |     // Start perpetual prank from an address that has some ether
 506 |     |     function startHoax(address who) internal virtual {
 507 |     |         vm.deal(who, 1 << 128);
 508 |     |         vm.startPrank(who);
 509 |     |     }
 510 |     | 
 511 |     |     function startHoax(address who, uint256 give) internal virtual {
 512 |     |         vm.deal(who, give);
 513 |     |         vm.startPrank(who);
 514 |     |     }
 515 |     | 
 516 |     |     // Start perpetual prank from an address that has some ether
 517 |     |     // tx.origin is set to the origin parameter
 518 |     |     function startHoax(address who, address origin) internal virtual {
 519 |     |         vm.deal(who, 1 << 128);
 520 |     |         vm.startPrank(who, origin);
 521 |     |     }
 522 |     | 
 523 |     |     function startHoax(address who, address origin, uint256 give) internal virtual {
 524 |     |         vm.deal(who, give);
 525 |     |         vm.startPrank(who, origin);
 526 |     |     }
 527 |     | 
 528 |     |     function changePrank(address who) internal virtual {
 529 |     |         vm.stopPrank();
 530 |     |         vm.startPrank(who);
 531 |     |     }
 532 |     | 
 533 |     |     // The same as Vm's `deal`
 534 |     |     // Use the alternative signature for ERC20 tokens
 535 |     |     function deal(address to, uint256 give) internal virtual {
 536 |     |         vm.deal(to, give);
 537 |     |     }
 538 |     | 
 539 |     |     // Set the balance of an account for any ERC20 token
 540 |     |     // Use the alternative signature to update `totalSupply`
 541 |     |     function deal(address token, address to, uint256 give) internal virtual {
 542 |     |         deal(token, to, give, false);
 543 |     |     }
 544 |     | 
 545 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 546 |     |         // get current balance
 547 |     |         (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));
 548 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 549 |     | 
 550 |     |         // update balance
 551 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 552 |     | 
 553 |     |         // update total supply
 554 |     |         if (adjust) {
 555 |     |             (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));
 556 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 557 |     |             if (give < prevBal) {
 558 |     |                 totSup -= (prevBal - give);
 559 |     |             } else {
 560 |     |                 totSup += (give - prevBal);
 561 |     |             }
 562 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 563 |     |         }
 564 |     |     }
 565 |     | }
 566 |     | 

/root/code/hyper/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/root/code/hyper/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("some_peth");
  13 |     | // json.parseUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "deploymentArtifact";
  19 |     | // Contract contract = new Contract();
  20 |     | // json.serialize("contractAddress", address(contract));
  21 |     | // json = json.serialize("deploymentTimes", uint(1));
  22 |     | // // store the stringified JSON to the 'json' variable we have been using as a key
  23 |     | // // as we won't need it any longer
  24 |     | // string memory json2 = "finalArtifact";
  25 |     | // string memory final = json2.serialize("depArtifact", json);
  26 |     | // final.write("<some_path>");
  27 |     | // ```
  28 |     | 
  29 |     | library stdJson {
  30 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  37 |     |         return abi.decode(vm.parseJson(json, key), (uint256));
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return abi.decode(vm.parseJson(json, key), (uint256[]));
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  45 |     |         return abi.decode(vm.parseJson(json, key), (int256));
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return abi.decode(vm.parseJson(json, key), (int256[]));
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  53 |     |         return abi.decode(vm.parseJson(json, key), (bytes32));
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return abi.decode(vm.parseJson(json, key), (bytes32[]));
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  61 |     |         return abi.decode(vm.parseJson(json, key), (string));
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  65 |     |         return abi.decode(vm.parseJson(json, key), (string[]));
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  69 |     |         return abi.decode(vm.parseJson(json, key), (address));
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  73 |     |         return abi.decode(vm.parseJson(json, key), (address[]));
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  77 |     |         return abi.decode(vm.parseJson(json, key), (bool));
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return abi.decode(vm.parseJson(json, key), (bool[]));
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  85 |     |         return abi.decode(vm.parseJson(json, key), (bytes));
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return abi.decode(vm.parseJson(json, key), (bytes[]));
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeJson(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeJson(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/root/code/hyper/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/root/code/hyper/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct StdStorage {
   7 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
   8 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
   9 |     |     bytes32[] _keys;
  10 |     |     bytes4 _sig;
  11 |     |     uint256 _depth;
  12 |     |     address _target;
  13 |     |     bytes32 _set;
  14 |     | }
  15 |     | 
  16 |     | library stdStorageSafe {
  17 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  18 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  19 |     | 
  20 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  21 |     | 
  22 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  23 |     |         return bytes4(keccak256(bytes(sigStr)));
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
  27 |     |     // slot complexity:
  28 |     |     //  if flat, will be bytes32(uint256(uint));
  29 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
  30 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
  31 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
  32 |     |     function find(StdStorage storage self) internal returns (uint256) {
  33 |     |         address who = self._target;
  34 |     |         bytes4 fsig = self._sig;
  35 |     |         uint256 field_depth = self._depth;
  36 |     |         bytes32[] memory ins = self._keys;
  37 |     | 
  38 |     |         // calldata to test against
  39 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
  40 |     |             return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
  41 |     |         }
  42 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
  43 |     |         vm.record();
  44 |     |         bytes32 fdat;
  45 |     |         {
  46 |     |             (, bytes memory rdat) = who.staticcall(cald);
  47 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
  48 |     |         }
  49 |     | 
  50 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
  51 |     |         if (reads.length == 1) {
  52 |     |             bytes32 curr = vm.load(who, reads[0]);
  53 |     |             if (curr == bytes32(0)) {
  54 |     |                 emit WARNING_UninitedSlot(who, uint256(reads[0]));
  55 |     |             }
  56 |     |             if (fdat != curr) {
  57 |     |                 require(
  58 |     |                     false,
  59 |     |                     "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
  60 |     |                 );
  61 |     |             }
  62 |     |             emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
  63 |     |             self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
  64 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  65 |     |         } else if (reads.length > 1) {
  66 |     |             for (uint256 i = 0; i < reads.length; i++) {
  67 |     |                 bytes32 prev = vm.load(who, reads[i]);
  68 |     |                 if (prev == bytes32(0)) {
  69 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
  70 |     |                 }
  71 |     |                 // store
  72 |     |                 vm.store(who, reads[i], bytes32(hex"1337"));
  73 |     |                 bool success;
  74 |     |                 bytes memory rdat;
  75 |     |                 {
  76 |     |                     (success, rdat) = who.staticcall(cald);
  77 |     |                     fdat = bytesToBytes32(rdat, 32 * field_depth);
  78 |     |                 }
  79 |     | 
  80 |     |                 if (success && fdat == bytes32(hex"1337")) {
  81 |     |                     // we found which of the slots is the actual one
  82 |     |                     emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
  83 |     |                     self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
  84 |     |                     self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  85 |     |                     vm.store(who, reads[i], prev);
  86 |     |                     break;
  87 |     |                 }
  88 |     |                 vm.store(who, reads[i], prev);
  89 |     |             }
  90 |     |         } else {
  91 |     |             require(false, "stdStorage find(StdStorage): No storage use detected for target.");
  92 |     |         }
  93 |     | 
  94 |     |         require(
  95 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],
  96 |     |             "stdStorage find(StdStorage): Slot(s) not found."
  97 |     |         );
  98 |     | 
  99 |     |         delete self._target;
 100 |     |         delete self._sig;
 101 |     |         delete self._keys;
 102 |     |         delete self._depth;
 103 |     | 
 104 |     |         return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
 105 |     |     }
 106 |     | 
 107 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 108 |     |         self._target = _target;
 109 |     |         return self;
 110 |     |     }
 111 |     | 
 112 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 113 |     |         self._sig = _sig;
 114 |     |         return self;
 115 |     |     }
 116 |     | 
 117 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 118 |     |         self._sig = sigs(_sig);
 119 |     |         return self;
 120 |     |     }
 121 |     | 
 122 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 123 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 124 |     |         return self;
 125 |     |     }
 126 |     | 
 127 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 128 |     |         self._keys.push(bytes32(amt));
 129 |     |         return self;
 130 |     |     }
 131 |     | 
 132 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 133 |     |         self._keys.push(key);
 134 |     |         return self;
 135 |     |     }
 136 |     | 
 137 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 138 |     |         self._depth = _depth;
 139 |     |         return self;
 140 |     |     }
 141 |     | 
 142 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 143 |     |         address t = self._target;
 144 |     |         uint256 s = find(self);
 145 |     |         return abi.encode(vm.load(t, bytes32(s)));
 146 |     |     }
 147 |     | 
 148 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 149 |     |         return abi.decode(read(self), (bytes32));
 150 |     |     }
 151 |     | 
 152 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 153 |     |         int256 v = read_int(self);
 154 |     |         if (v == 0) return false;
 155 |     |         if (v == 1) return true;
 156 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 157 |     |     }
 158 |     | 
 159 |     |     function read_address(StdStorage storage self) internal returns (address) {
 160 |     |         return abi.decode(read(self), (address));
 161 |     |     }
 162 |     | 
 163 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 164 |     |         return abi.decode(read(self), (uint256));
 165 |     |     }
 166 |     | 
 167 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 168 |     |         return abi.decode(read(self), (int256));
 169 |     |     }
 170 |     | 
 171 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 172 |     |         bytes32 out;
 173 |     | 
 174 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 175 |     |         for (uint256 i = 0; i < max; i++) {
 176 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 177 |     |         }
 178 |     |         return out;
 179 |     |     }
 180 |     | 
 181 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 182 |     |         bytes memory result = new bytes(b.length * 32);
 183 |     |         for (uint256 i = 0; i < b.length; i++) {
 184 |     |             bytes32 k = b[i];
 185 |     |             /// @solidity memory-safe-assembly
 186 |     |             assembly {
 187 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 |     |         return result;
 192 |     |     }
 193 |     | }
 194 |     | 
 195 |     | library stdStorage {
 196 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 197 |     | 
 198 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 199 |     |         return stdStorageSafe.sigs(sigStr);
 200 |     |     }
 201 |     | 
 202 |     |     function find(StdStorage storage self) internal returns (uint256) {
 203 |     |         return stdStorageSafe.find(self);
 204 |     |     }
 205 |     | 
 206 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 207 |     |         return stdStorageSafe.target(self, _target);
 208 |     |     }
 209 |     | 
 210 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 211 |     |         return stdStorageSafe.sig(self, _sig);
 212 |     |     }
 213 |     | 
 214 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 215 |     |         return stdStorageSafe.sig(self, _sig);
 216 |     |     }
 217 |     | 
 218 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 219 |     |         return stdStorageSafe.with_key(self, who);
 220 |     |     }
 221 |     | 
 222 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 223 |     |         return stdStorageSafe.with_key(self, amt);
 224 |     |     }
 225 |     | 
 226 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 227 |     |         return stdStorageSafe.with_key(self, key);
 228 |     |     }
 229 |     | 
 230 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 231 |     |         return stdStorageSafe.depth(self, _depth);
 232 |     |     }
 233 |     | 
 234 |     |     function checked_write(StdStorage storage self, address who) internal {
 235 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 236 |     |     }
 237 |     | 
 238 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 239 |     |         checked_write(self, bytes32(amt));
 240 |     |     }
 241 |     | 
 242 |     |     function checked_write(StdStorage storage self, bool write) internal {
 243 |     |         bytes32 t;
 244 |     |         /// @solidity memory-safe-assembly
 245 |     |         assembly {
 246 |     |             t := write
 247 |     |         }
 248 |     |         checked_write(self, t);
 249 |     |     }
 250 |     | 
 251 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 252 |     |         address who = self._target;
 253 |     |         bytes4 fsig = self._sig;
 254 |     |         uint256 field_depth = self._depth;
 255 |     |         bytes32[] memory ins = self._keys;
 256 |     | 
 257 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
 258 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
 259 |     |             find(self);
 260 |     |         }
 261 |     |         bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);
 262 |     | 
 263 |     |         bytes32 fdat;
 264 |     |         {
 265 |     |             (, bytes memory rdat) = who.staticcall(cald);
 266 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
 267 |     |         }
 268 |     |         bytes32 curr = vm.load(who, slot);
 269 |     | 
 270 |     |         if (fdat != curr) {
 271 |     |             require(
 272 |     |                 false,
 273 |     |                 "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
 274 |     |             );
 275 |     |         }
 276 |     |         vm.store(who, slot, set);
 277 |     |         delete self._target;
 278 |     |         delete self._sig;
 279 |     |         delete self._keys;
 280 |     |         delete self._depth;
 281 |     |     }
 282 |     | 
 283 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 284 |     |         return stdStorageSafe.read_bytes32(self);
 285 |     |     }
 286 |     | 
 287 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 288 |     |         return stdStorageSafe.read_bool(self);
 289 |     |     }
 290 |     | 
 291 |     |     function read_address(StdStorage storage self) internal returns (address) {
 292 |     |         return stdStorageSafe.read_address(self);
 293 |     |     }
 294 |     | 
 295 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 296 |     |         return stdStorageSafe.read_uint(self);
 297 |     |     }
 298 |     | 
 299 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 300 |     |         return stdStorageSafe.read_int(self);
 301 |     |     }
 302 |     | 
 303 |     |     // Private function so needs to be copied over
 304 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 305 |     |         bytes32 out;
 306 |     | 
 307 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 308 |     |         for (uint256 i = 0; i < max; i++) {
 309 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 310 |     |         }
 311 |     |         return out;
 312 |     |     }
 313 |     | 
 314 |     |     // Private function so needs to be copied over
 315 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 316 |     |         bytes memory result = new bytes(b.length * 32);
 317 |     |         for (uint256 i = 0; i < b.length; i++) {
 318 |     |             bytes32 k = b[i];
 319 |     |             /// @solidity memory-safe-assembly
 320 |     |             assembly {
 321 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 322 |     |             }
 323 |     |         }
 324 |     | 
 325 |     |         return result;
 326 |     |     }
 327 |     | }
 328 |     | 

/root/code/hyper/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | // TODO Remove import.
   5 |     | import {VmSafe} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdUtils {
   8 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  10 |     | 
  11 |     |     uint256 private constant INT256_MIN_ABS =
  12 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  17 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  18 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  19 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  20 |     |         if (x >= min && x <= max) return x;
  21 |     | 
  22 |     |         uint256 size = max - min + 1;
  23 |     | 
  24 |     |         // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  25 |     |         // This helps ensure coverage of the min/max values.
  26 |     |         if (x <= 3 && size > x) return min + x;
  27 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  28 |     | 
  29 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  30 |     |         if (x > max) {
  31 |     |             uint256 diff = x - max;
  32 |     |             uint256 rem = diff % size;
  33 |     |             if (rem == 0) return max;
  34 |     |             result = min + rem - 1;
  35 |     |         } else if (x < min) {
  36 |     |             uint256 diff = min - x;
  37 |     |             uint256 rem = diff % size;
  38 |     |             if (rem == 0) return min;
  39 |     |             result = max - rem + 1;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {
  44 |     |         result = _bound(x, min, max);
  45 |     |         console2_log("Bound Result", result);
  46 |     |     }
  47 |     | 
  48 |     |     function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {
  49 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  50 |     | 
  51 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  52 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  53 |     |         // uint256:     0     ~ (2**256 - 1)
  54 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  55 |     |         //
  56 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  57 |     |         // So, use `~uint256(x) + 1` instead.
  58 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  59 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  60 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  61 |     | 
  62 |     |         uint256 y = _bound(_x, _min, _max);
  63 |     | 
  64 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  65 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  66 |     |         console2_log("Bound result", vm.toString(result));
  67 |     |     }
  68 |     | 
  69 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
  70 |     |     /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
  71 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
  72 |     |         // forgefmt: disable-start
  73 |     |         // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
  74 |     |         // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
  75 |     |         if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));
  76 |     |         if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));
  77 |     | 
  78 |     |         // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
  79 |     |         if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));
  80 |     |         if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));
  81 |     |         if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));
  82 |     |         // forgefmt: disable-end
  83 |     | 
  84 |     |         // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
  85 |     |         // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
  86 |     |         // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
  87 |     |         // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
  88 |     |         // We assume nobody can have a nonce large enough to require more than 32 bytes.
  89 |     |         return addressFromLast20Bytes(
  90 |     |             keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))
  91 |     |         );
  92 |     |     }
  93 |     | 
  94 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
  95 |     |         internal
  96 |     |         pure
  97 |     |         virtual
  98 |     |         returns (address)
  99 |     |     {
 100 |     |         return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));
 101 |     |     }
 102 |     | 
 103 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
 104 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
 105 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 106 |     |     }
 107 |     | 
 108 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 109 |     |         return address(uint160(uint256(bytesValue)));
 110 |     |     }
 111 |     | 
 112 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 113 |     | 
 114 |     |     function console2_log(string memory p0, uint256 p1) private view {
 115 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 116 |     |         status;
 117 |     |     }
 118 |     | 
 119 |     |     function console2_log(string memory p0, string memory p1) private view {
 120 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,string)", p0, p1));
 121 |     |         status;
 122 |     |     }
 123 |     | }
 124 |     | 

/root/code/hyper/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | // 💬 ABOUT
  5 |     | // Standard Library's default Test
  6 |     | 
  7 |     | // 🧩 MODULES
  8 |     | import {console} from "./console.sol";
  9 |     | import {console2} from "./console2.sol";
 10 |     | import {StdAssertions} from "./StdAssertions.sol";
 11 |     | import {StdChains} from "./StdChains.sol";
 12 |     | import {StdCheats} from "./StdCheats.sol";
 13 |     | import {stdError} from "./StdError.sol";
 14 |     | import {stdJson} from "./StdJson.sol";
 15 |     | import {stdMath} from "./StdMath.sol";
 16 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 17 |     | import {StdUtils} from "./StdUtils.sol";
 18 |     | import {Vm} from "./Vm.sol";
 19 |     | 
 20 |     | // 📦 BOILERPLATE
 21 |     | import {TestBase} from "./Base.sol";
 22 |     | import {DSTest} from "ds-test/test.sol";
 23 |     | 
 24 |     | // ⭐️ TEST
 25 |     | abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdUtils, TestBase {
 26 |     | // Note: IS_TEST() must return true.
 27 |     | // Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.
 28 |     | }
 29 |     | 

/root/code/hyper/lib/forge-std/src/Vm.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | // Cheatcodes are marked as view/pure/none using the following rules:
   7 |     | // 0. A call's observable behaviour includes its return value, logs, reverts and state writes,
   8 |     | // 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),
   9 |     | // 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,
  10 |     | // 3. Otherwise you're `pure`.
  11 |     | 
  12 |     | interface VmSafe {
  13 |     |     struct Log {
  14 |     |         bytes32[] topics;
  15 |     |         bytes data;
  16 |     |         address emitter;
  17 |     |     }
  18 |     | 
  19 |     |     struct Rpc {
  20 |     |         string key;
  21 |     |         string url;
  22 |     |     }
  23 |     | 
  24 |     |     struct FsMetadata {
  25 |     |         bool isDir;
  26 |     |         bool isSymlink;
  27 |     |         uint256 length;
  28 |     |         bool readOnly;
  29 |     |         uint256 modified;
  30 |     |         uint256 accessed;
  31 |     |         uint256 created;
  32 |     |     }
  33 |     | 
  34 |     |     // Loads a storage slot from an address
  35 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  36 |     |     // Signs data
  37 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  38 |     |     // Gets the address for a given private key
  39 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  40 |     |     // Gets the nonce of an account
  41 |     |     function getNonce(address account) external view returns (uint64 nonce);
  42 |     |     // Performs a foreign function call via the terminal
  43 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  44 |     |     // Sets environment variables
  45 |     |     function setEnv(string calldata name, string calldata value) external;
  46 |     |     // Reads environment variables, (name) => (value)
  47 |     |     function envBool(string calldata name) external view returns (bool value);
  48 |     |     function envUint(string calldata name) external view returns (uint256 value);
  49 |     |     function envInt(string calldata name) external view returns (int256 value);
  50 |     |     function envAddress(string calldata name) external view returns (address value);
  51 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  52 |     |     function envString(string calldata name) external view returns (string memory value);
  53 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  54 |     |     // Reads environment variables as arrays
  55 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  56 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  57 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  58 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  59 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  60 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  61 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  62 |     |     // Read environment variables with default value
  63 |     |     function envOr(string calldata name, bool defaultValue) external returns (bool value);
  64 |     |     function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);
  65 |     |     function envOr(string calldata name, int256 defaultValue) external returns (int256 value);
  66 |     |     function envOr(string calldata name, address defaultValue) external returns (address value);
  67 |     |     function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);
  68 |     |     function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);
  69 |     |     function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);
  70 |     |     // Read environment variables as arrays with default value
  71 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  72 |     |         external
  73 |     |         returns (bool[] memory value);
  74 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  75 |     |         external
  76 |     |         returns (uint256[] memory value);
  77 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  78 |     |         external
  79 |     |         returns (int256[] memory value);
  80 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  81 |     |         external
  82 |     |         returns (address[] memory value);
  83 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  84 |     |         external
  85 |     |         returns (bytes32[] memory value);
  86 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  87 |     |         external
  88 |     |         returns (string[] memory value);
  89 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  90 |     |         external
  91 |     |         returns (bytes[] memory value);
  92 |     |     // Records all storage reads and writes
  93 |     |     function record() external;
  94 |     |     // Gets all accessed reads and write slot from a recording session, for a given address
  95 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  96 |     |     // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file
  97 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  98 |     |     // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file
  99 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
 100 |     |     // Labels an address in call traces
 101 |     |     function label(address account, string calldata newLabel) external;
 102 |     |     // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain
 103 |     |     function broadcast() external;
 104 |     |     // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain
 105 |     |     function broadcast(address signer) external;
 106 |     |     // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain
 107 |     |     function broadcast(uint256 privateKey) external;
 108 |     |     // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain
 109 |     |     function startBroadcast() external;
 110 |     |     // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain
 111 |     |     function startBroadcast(address signer) external;
 112 |     |     // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain
 113 |     |     function startBroadcast(uint256 privateKey) external;
 114 |     |     // Stops collecting onchain transactions
 115 |     |     function stopBroadcast() external;
 116 |     |     // Reads the entire content of file to string
 117 |     |     function readFile(string calldata path) external view returns (string memory data);
 118 |     |     // Reads the entire content of file as binary. Path is relative to the project root.
 119 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
 120 |     |     // Get the path of the current project root
 121 |     |     function projectRoot() external view returns (string memory path);
 122 |     |     // Get the metadata for a file/directory
 123 |     |     function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);
 124 |     |     // Reads next line of file to string
 125 |     |     function readLine(string calldata path) external view returns (string memory line);
 126 |     |     // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
 127 |     |     function writeFile(string calldata path, string calldata data) external;
 128 |     |     // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
 129 |     |     // Path is relative to the project root.
 130 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
 131 |     |     // Writes line to file, creating a file if it does not exist.
 132 |     |     function writeLine(string calldata path, string calldata data) external;
 133 |     |     // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
 134 |     |     function closeFile(string calldata path) external;
 135 |     |     // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:
 136 |     |     // - Path points to a directory.
 137 |     |     // - The file doesn't exist.
 138 |     |     // - The user lacks permissions to remove the file.
 139 |     |     function removeFile(string calldata path) external;
 140 |     |     // Convert values to a string
 141 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
 142 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
 143 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
 144 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
 145 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
 146 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
 147 |     |     // Convert values from a string
 148 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
 149 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
 150 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
 151 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
 152 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
 153 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
 154 |     |     // Record all the transaction logs
 155 |     |     function recordLogs() external;
 156 |     |     // Gets all the recorded logs
 157 |     |     function getRecordedLogs() external returns (Log[] memory logs);
 158 |     |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}
 159 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
 160 |     |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}
 161 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
 162 |     |         external
 163 |     |         pure
 164 |     |         returns (uint256 privateKey);
 165 |     |     // Adds a private key to the local forge wallet and returns the address
 166 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
 167 |     |     //
 168 |     |     // parseJson
 169 |     |     //
 170 |     |     // ----
 171 |     |     // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects
 172 |     |     // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in
 173 |     |     // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that
 174 |     |     // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded
 175 |     |     // as tuples, with the attributes in the order in which they are defined.
 176 |     |     // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}
 177 |     |     // a: uint256
 178 |     |     // b: address
 179 |     |     // To decode that json, we need to define a struct or a tuple as follows:
 180 |     |     // struct json = { uint256 a; address b; }
 181 |     |     // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to
 182 |     |     // decode the tuple in that order, and thus fail.
 183 |     |     // ----
 184 |     |     // Given a string of JSON, return it as ABI-encoded
 185 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
 186 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
 187 |     | 
 188 |     |     // Serialize a key and value to a JSON object stored in-memory that can be later written to a file
 189 |     |     // It returns the stringified version of the specific JSON file up to that moment.
 190 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
 191 |     |         external
 192 |     |         returns (string memory json);
 193 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
 194 |     |         external
 195 |     |         returns (string memory json);
 196 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
 197 |     |         external
 198 |     |         returns (string memory json);
 199 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
 200 |     |         external
 201 |     |         returns (string memory json);
 202 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
 203 |     |         external
 204 |     |         returns (string memory json);
 205 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
 206 |     |         external
 207 |     |         returns (string memory json);
 208 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
 209 |     |         external
 210 |     |         returns (string memory json);
 211 |     | 
 212 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
 213 |     |         external
 214 |     |         returns (string memory json);
 215 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
 216 |     |         external
 217 |     |         returns (string memory json);
 218 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
 219 |     |         external
 220 |     |         returns (string memory json);
 221 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
 222 |     |         external
 223 |     |         returns (string memory json);
 224 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
 225 |     |         external
 226 |     |         returns (string memory json);
 227 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
 228 |     |         external
 229 |     |         returns (string memory json);
 230 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
 231 |     |         external
 232 |     |         returns (string memory json);
 233 |     | 
 234 |     |     //
 235 |     |     // writeJson
 236 |     |     //
 237 |     |     // ----
 238 |     |     // Write a serialized JSON object to a file. If the file exists, it will be overwritten.
 239 |     |     // Let's assume we want to write the following JSON to a file:
 240 |     |     //
 241 |     |     // { "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
 242 |     |     //
 243 |     |     // ```
 244 |     |     //  string memory json1 = "some key";
 245 |     |     //  vm.serializeBool(json1, "boolean", true);
 246 |     |     //  vm.serializeBool(json1, "number", uint256(342));
 247 |     |     //  json2 = "some other key";
 248 |     |     //  string memory output = vm.serializeString(json2, "title", "finally json serialization");
 249 |     |     //  string memory finalJson = vm.serialize(json1, "object", output);
 250 |     |     //  vm.writeJson(finalJson, "./output/example.json");
 251 |     |     // ```
 252 |     |     // The critical insight is that every invocation of serialization will return the stringified version of the JSON
 253 |     |     // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version
 254 |     |     // to serialize them as values to another JSON object.
 255 |     |     //
 256 |     |     // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)
 257 |     |     // will find the object in-memory that is keyed by "some key".
 258 |     |     function writeJson(string calldata json, string calldata path) external;
 259 |     |     // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>
 260 |     |     // This is useful to replace a specific value of a JSON file, without having to parse the entire thing
 261 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
 262 |     |     // Returns the RPC url for the given alias
 263 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 264 |     |     // Returns all rpc urls and their aliases `[alias, url][]`
 265 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 266 |     |     // Returns all rpc urls and their aliases as structs.
 267 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 268 |     |     // If the condition is false, discard this run's fuzz inputs and generate new ones.
 269 |     |     function assume(bool condition) external pure;
 270 |     |     // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
 271 |     |     function pauseGasMetering() external;
 272 |     |     // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
 273 |     |     function resumeGasMetering() external;
 274 |     | }
 275 |     | 
 276 |     | interface Vm is VmSafe {
 277 |     |     // Sets block.timestamp
 278 |     |     function warp(uint256 newTimestamp) external;
 279 |     |     // Sets block.height
 280 |     |     function roll(uint256 newHeight) external;
 281 |     |     // Sets block.basefee
 282 |     |     function fee(uint256 newBasefee) external;
 283 |     |     // Sets block.difficulty
 284 |     |     function difficulty(uint256 newDifficulty) external;
 285 |     |     // Sets block.chainid
 286 |     |     function chainId(uint256 newChainId) external;
 287 |     |     // Stores a value to an address' storage slot.
 288 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 289 |     |     // Sets the nonce of an account; must be higher than the current nonce of the account
 290 |     |     function setNonce(address account, uint64 newNonce) external;
 291 |     |     // Sets the *next* call's msg.sender to be the input address
 292 |     |     function prank(address msgSender) external;
 293 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
 294 |     |     function startPrank(address msgSender) external;
 295 |     |     // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
 296 |     |     function prank(address msgSender, address txOrigin) external;
 297 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
 298 |     |     function startPrank(address msgSender, address txOrigin) external;
 299 |     |     // Resets subsequent calls' msg.sender to be `address(this)`
 300 |     |     function stopPrank() external;
 301 |     |     // Sets an address' balance
 302 |     |     function deal(address account, uint256 newBalance) external;
 303 |     |     // Sets an address' code
 304 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 305 |     |     // Expects an error on next call
 306 |     |     function expectRevert(bytes calldata revertData) external;
 307 |     |     function expectRevert(bytes4 revertData) external;
 308 |     |     function expectRevert() external;
 309 |     |     // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
 310 |     |     // Call this function, then emit an event, then call a function. Internally after the call, we check if
 311 |     |     // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
 312 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 313 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 314 |     |         external;
 315 |     |     // Mocks a call to an address, returning specified data.
 316 |     |     // Calldata can either be strict or a partial match, e.g. if you only
 317 |     |     // pass a Solidity selector to the expected calldata, then the entire Solidity
 318 |     |     // function will be mocked.
 319 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 320 |     |     // Mocks a call to an address with a specific msg.value, returning specified data.
 321 |     |     // Calldata match takes precedence over msg.value in case of ambiguity.
 322 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 323 |     |     // Clears all mocked calls
 324 |     |     function clearMockedCalls() external;
 325 |     |     // Expects a call to an address with the specified calldata.
 326 |     |     // Calldata can either be a strict or a partial match
 327 |     |     function expectCall(address callee, bytes calldata data) external;
 328 |     |     // Expects a call to an address with the specified msg.value and calldata
 329 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 330 |     |     // Sets block.coinbase
 331 |     |     function coinbase(address newCoinbase) external;
 332 |     |     // Snapshot the current state of the evm.
 333 |     |     // Returns the id of the snapshot that was created.
 334 |     |     // To revert a snapshot use `revertTo`
 335 |     |     function snapshot() external returns (uint256 snapshotId);
 336 |     |     // Revert the state of the EVM to a previous snapshot
 337 |     |     // Takes the snapshot id to revert to.
 338 |     |     // This deletes the snapshot and all snapshots taken after the given snapshot id.
 339 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 340 |     |     // Creates a new fork with the given endpoint and block and returns the identifier of the fork
 341 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 342 |     |     // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork
 343 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 344 |     |     // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,
 345 |     |     // and returns the identifier of the fork
 346 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 347 |     |     // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork
 348 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 349 |     |     // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before
 350 |     |     // the transaction, returns the identifier of the fork
 351 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 352 |     |     // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork
 353 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 354 |     |     // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 355 |     |     function selectFork(uint256 forkId) external;
 356 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 357 |     |     function activeFork() external view returns (uint256 forkId);
 358 |     |     // Updates the currently active fork to given block number
 359 |     |     // This is similar to `roll` but for the currently active fork
 360 |     |     function rollFork(uint256 blockNumber) external;
 361 |     |     // Updates the currently active fork to given transaction
 362 |     |     // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block
 363 |     |     function rollFork(bytes32 txHash) external;
 364 |     |     // Updates the given fork to given block number
 365 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 366 |     |     // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block
 367 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 368 |     |     // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 369 |     |     // Meaning, changes made to the state of this account will be kept when switching forks
 370 |     |     function makePersistent(address account) external;
 371 |     |     function makePersistent(address account0, address account1) external;
 372 |     |     function makePersistent(address account0, address account1, address account2) external;
 373 |     |     function makePersistent(address[] calldata accounts) external;
 374 |     |     // Revokes persistent status from the address, previously added via `makePersistent`
 375 |     |     function revokePersistent(address account) external;
 376 |     |     function revokePersistent(address[] calldata accounts) external;
 377 |     |     // Returns true if the account is marked as persistent
 378 |     |     function isPersistent(address account) external view returns (bool persistent);
 379 |     |     // In forking mode, explicitly grant the given address cheatcode access
 380 |     |     function allowCheatcodes(address account) external;
 381 |     |     // Fetches the given transaction from the active fork and executes it on the current state
 382 |     |     function transact(bytes32 txHash) external;
 383 |     |     // Fetches the given transaction from the given fork and executes it on the current state
 384 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 385 |     | }
 386 |     | 

/root/code/hyper/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _sendLogPayload(bytes memory payload) private view {
    8 |     |         uint256 payloadLength = payload.length;
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             let payloadStart := add(payload, 32)
   13 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   14 |     |         }
   15 |     |     }
   16 |     | 
   17 |     |     function log() internal view {
   18 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   19 |     |     }
   20 |     | 
   21 |     |     function logInt(int p0) internal view {
   22 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   23 |     |     }
   24 |     | 
   25 |     |     function logUint(uint p0) internal view {
   26 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   27 |     |     }
   28 |     | 
   29 |     |     function logString(string memory p0) internal view {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   31 |     |     }
   32 |     | 
   33 |     |     function logBool(bool p0) internal view {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logAddress(address p0) internal view {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logBytes(bytes memory p0) internal view {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBytes1(bytes1 p0) internal view {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logBytes2(bytes2 p0) internal view {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes3(bytes3 p0) internal view {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes4(bytes4 p0) internal view {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes5(bytes5 p0) internal view {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes6(bytes6 p0) internal view {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes7(bytes7 p0) internal view {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes8(bytes8 p0) internal view {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes9(bytes9 p0) internal view {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes10(bytes10 p0) internal view {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes11(bytes11 p0) internal view {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes12(bytes12 p0) internal view {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes13(bytes13 p0) internal view {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes14(bytes14 p0) internal view {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes15(bytes15 p0) internal view {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes16(bytes16 p0) internal view {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes17(bytes17 p0) internal view {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes18(bytes18 p0) internal view {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes19(bytes19 p0) internal view {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes20(bytes20 p0) internal view {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes21(bytes21 p0) internal view {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes22(bytes22 p0) internal view {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes23(bytes23 p0) internal view {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes24(bytes24 p0) internal view {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes25(bytes25 p0) internal view {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes26(bytes26 p0) internal view {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes27(bytes27 p0) internal view {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes28(bytes28 p0) internal view {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes29(bytes29 p0) internal view {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes30(bytes30 p0) internal view {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes31(bytes31 p0) internal view {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes32(bytes32 p0) internal view {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function log(uint p0) internal view {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function log(string memory p0) internal view {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function log(bool p0) internal view {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(address p0) internal view {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(uint p0, uint p1) internal view {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint p0, string memory p1) internal view {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  195 |     |     }
  196 |     | 
  197 |     |     function log(uint p0, bool p1) internal view {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, address p1) internal view {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(string memory p0, uint p1) internal view {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(string memory p0, string memory p1) internal view {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(string memory p0, bool p1) internal view {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, address p1) internal view {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(bool p0, uint p1) internal view {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(bool p0, string memory p1) internal view {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(bool p0, bool p1) internal view {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, address p1) internal view {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(address p0, uint p1) internal view {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(address p0, string memory p1) internal view {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(address p0, bool p1) internal view {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, address p1) internal view {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(uint p0, uint p1, uint p2) internal view {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  255 |     |     }
  256 |     | 
  257 |     |     function log(uint p0, uint p1, string memory p2) internal view {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  259 |     |     }
  260 |     | 
  261 |     |     function log(uint p0, uint p1, bool p2) internal view {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, address p2) internal view {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, string memory p1, uint p2) internal view {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, string memory p1, string memory p2) internal view {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, string memory p1, bool p2) internal view {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, address p2) internal view {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, bool p1, uint p2) internal view {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, bool p1, string memory p2) internal view {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, bool p1, bool p2) internal view {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, address p2) internal view {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, address p1, uint p2) internal view {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, address p1, string memory p2) internal view {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, address p1, bool p2) internal view {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, address p2) internal view {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(string memory p0, uint p1, uint p2) internal view {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(string memory p0, uint p1, string memory p2) internal view {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(string memory p0, uint p1, bool p2) internal view {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, address p2) internal view {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, string memory p1, uint p2) internal view {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, bool p1, uint p2) internal view {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, address p2) internal view {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, address p1, uint p2) internal view {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, address p1, bool p2) internal view {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, address p2) internal view {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(bool p0, uint p1, uint p2) internal view {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(bool p0, uint p1, string memory p2) internal view {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(bool p0, uint p1, bool p2) internal view {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, address p2) internal view {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, string memory p1, uint p2) internal view {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, address p2) internal view {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, bool p1, uint p2) internal view {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, bool p1, bool p2) internal view {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, address p2) internal view {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, address p1, uint p2) internal view {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, address p1, string memory p2) internal view {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, address p1, bool p2) internal view {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, address p2) internal view {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(address p0, uint p1, uint p2) internal view {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(address p0, uint p1, string memory p2) internal view {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(address p0, uint p1, bool p2) internal view {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, address p2) internal view {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, string memory p1, uint p2) internal view {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, string memory p1, bool p2) internal view {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, address p2) internal view {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, bool p1, uint p2) internal view {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, bool p1, string memory p2) internal view {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, bool p1, bool p2) internal view {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, address p2) internal view {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, address p1, uint p2) internal view {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, address p1, string memory p2) internal view {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, address p1, bool p2) internal view {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, address p2) internal view {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  511 |     |     }
  512 |     | 
  513 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  515 |     |     }
  516 |     | 
  517 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, address p3) internal view {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, address p3) internal view {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, address p2, uint p3) internal view {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, address p2, bool p3) internal view {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, address p3) internal view {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, address p3) internal view {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, address p3) internal view {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, address p3) internal view {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, address p2, uint p3) internal view {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, address p2, bool p3) internal view {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, address p3) internal view {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, address p1, uint p2, uint p3) internal view {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, address p1, uint p2, bool p3) internal view {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, address p3) internal view {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, address p3) internal view {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, bool p2, uint p3) internal view {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, bool p2, bool p3) internal view {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, address p3) internal view {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, address p2, uint p3) internal view {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, address p2, string memory p3) internal view {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, address p2, bool p3) internal view {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, address p3) internal view {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, address p3) internal view {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, address p3) internal view {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, address p2, uint p3) internal view {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, address p3) internal view {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, address p3) internal view {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, address p2, uint p3) internal view {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, address p2, bool p3) internal view {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, address p3) internal view {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, address p3) internal view {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, address p2, uint p3) internal view {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, address p1, uint p2, uint p3) internal view {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, address p1, uint p2, bool p3) internal view {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, address p3) internal view {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, bool p2, uint p3) internal view {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, address p2, uint p3) internal view {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(address p0, uint p1, uint p2, uint p3) internal view {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(address p0, uint p1, uint p2, bool p3) internal view {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, address p3) internal view {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, address p3) internal view {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, bool p2, uint p3) internal view {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, bool p2, bool p3) internal view {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, address p3) internal view {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, address p2, uint p3) internal view {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, address p2, string memory p3) internal view {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, address p2, bool p3) internal view {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, address p3) internal view {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, address p3) internal view {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, address p2, uint p3) internal view {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, bool p1, uint p2, uint p3) internal view {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, bool p1, uint p2, bool p3) internal view {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, address p3) internal view {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, bool p2, uint p3) internal view {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, address p2, uint p3) internal view {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, address p1, uint p2, uint p3) internal view {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, address p1, uint p2, string memory p3) internal view {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, address p1, uint p2, bool p3) internal view {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, address p3) internal view {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, string memory p2, uint p3) internal view {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, bool p2, uint p3) internal view {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, address p2, uint p3) internal view {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     | }

/root/code/hyper/lib/forge-std/src/console2.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | /// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should
    5 |     | /// use `int256` and `uint256`. This modified version fixes that. This version is recommended
    6 |     | /// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
    7 |     | /// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
    8 |     | /// Reference: https://github.com/NomicFoundation/hardhat/issues/2178
    9 |     | library console2 {
   10 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
   11 |     | 
   12 |     |     function _sendLogPayload(bytes memory payload) private view {
   13 |     |         uint256 payloadLength = payload.length;
   14 |     |         address consoleAddress = CONSOLE_ADDRESS;
   15 |     |         /// @solidity memory-safe-assembly
   16 |     |         assembly {
   17 |     |             let payloadStart := add(payload, 32)
   18 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   19 |     |         }
   20 |     |     }
   21 |     | 
   22 |     |     function log() internal view {
   23 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   24 |     |     }
   25 |     | 
   26 |     |     function logInt(int256 p0) internal view {
   27 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   28 |     |     }
   29 |     | 
   30 |     |     function logUint(uint256 p0) internal view {
   31 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   32 |     |     }
   33 |     | 
   34 |     |     function logString(string memory p0) internal view {
   35 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   36 |     |     }
   37 |     | 
   38 |     |     function logBool(bool p0) internal view {
   39 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   40 |     |     }
   41 |     | 
   42 |     |     function logAddress(address p0) internal view {
   43 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   44 |     |     }
   45 |     | 
   46 |     |     function logBytes(bytes memory p0) internal view {
   47 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   48 |     |     }
   49 |     | 
   50 |     |     function logBytes1(bytes1 p0) internal view {
   51 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   52 |     |     }
   53 |     | 
   54 |     |     function logBytes2(bytes2 p0) internal view {
   55 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   56 |     |     }
   57 |     | 
   58 |     |     function logBytes3(bytes3 p0) internal view {
   59 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   60 |     |     }
   61 |     | 
   62 |     |     function logBytes4(bytes4 p0) internal view {
   63 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   64 |     |     }
   65 |     | 
   66 |     |     function logBytes5(bytes5 p0) internal view {
   67 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   68 |     |     }
   69 |     | 
   70 |     |     function logBytes6(bytes6 p0) internal view {
   71 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   72 |     |     }
   73 |     | 
   74 |     |     function logBytes7(bytes7 p0) internal view {
   75 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   76 |     |     }
   77 |     | 
   78 |     |     function logBytes8(bytes8 p0) internal view {
   79 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   80 |     |     }
   81 |     | 
   82 |     |     function logBytes9(bytes9 p0) internal view {
   83 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   84 |     |     }
   85 |     | 
   86 |     |     function logBytes10(bytes10 p0) internal view {
   87 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   88 |     |     }
   89 |     | 
   90 |     |     function logBytes11(bytes11 p0) internal view {
   91 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   92 |     |     }
   93 |     | 
   94 |     |     function logBytes12(bytes12 p0) internal view {
   95 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   96 |     |     }
   97 |     | 
   98 |     |     function logBytes13(bytes13 p0) internal view {
   99 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  100 |     |     }
  101 |     | 
  102 |     |     function logBytes14(bytes14 p0) internal view {
  103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  104 |     |     }
  105 |     | 
  106 |     |     function logBytes15(bytes15 p0) internal view {
  107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  108 |     |     }
  109 |     | 
  110 |     |     function logBytes16(bytes16 p0) internal view {
  111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  112 |     |     }
  113 |     | 
  114 |     |     function logBytes17(bytes17 p0) internal view {
  115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  116 |     |     }
  117 |     | 
  118 |     |     function logBytes18(bytes18 p0) internal view {
  119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  120 |     |     }
  121 |     | 
  122 |     |     function logBytes19(bytes19 p0) internal view {
  123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  124 |     |     }
  125 |     | 
  126 |     |     function logBytes20(bytes20 p0) internal view {
  127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  128 |     |     }
  129 |     | 
  130 |     |     function logBytes21(bytes21 p0) internal view {
  131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  132 |     |     }
  133 |     | 
  134 |     |     function logBytes22(bytes22 p0) internal view {
  135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  136 |     |     }
  137 |     | 
  138 |     |     function logBytes23(bytes23 p0) internal view {
  139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  140 |     |     }
  141 |     | 
  142 |     |     function logBytes24(bytes24 p0) internal view {
  143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  144 |     |     }
  145 |     | 
  146 |     |     function logBytes25(bytes25 p0) internal view {
  147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  148 |     |     }
  149 |     | 
  150 |     |     function logBytes26(bytes26 p0) internal view {
  151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  152 |     |     }
  153 |     | 
  154 |     |     function logBytes27(bytes27 p0) internal view {
  155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  156 |     |     }
  157 |     | 
  158 |     |     function logBytes28(bytes28 p0) internal view {
  159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  160 |     |     }
  161 |     | 
  162 |     |     function logBytes29(bytes29 p0) internal view {
  163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  164 |     |     }
  165 |     | 
  166 |     |     function logBytes30(bytes30 p0) internal view {
  167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  168 |     |     }
  169 |     | 
  170 |     |     function logBytes31(bytes31 p0) internal view {
  171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  172 |     |     }
  173 |     | 
  174 |     |     function logBytes32(bytes32 p0) internal view {
  175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  176 |     |     }
  177 |     | 
  178 |     |     function log(uint256 p0) internal view {
  179 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  180 |     |     }
  181 |     | 
  182 |     |     function log(int256 p0) internal view {
  183 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  184 |     |     }
  185 |     | 
  186 |     |     function log(string memory p0) internal view {
  187 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  188 |     |     }
  189 |     | 
  190 |     |     function log(bool p0) internal view {
  191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  192 |     |     }
  193 |     | 
  194 |     |     function log(address p0) internal view {
  195 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  196 |     |     }
  197 |     | 
  198 |     |     function log(uint256 p0, uint256 p1) internal view {
  199 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  200 |     |     }
  201 |     | 
  202 |     |     function log(uint256 p0, string memory p1) internal view {
  203 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  204 |     |     }
  205 |     | 
  206 |     |     function log(uint256 p0, bool p1) internal view {
  207 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  208 |     |     }
  209 |     | 
  210 |     |     function log(uint256 p0, address p1) internal view {
  211 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  212 |     |     }
  213 |     | 
  214 |     |     function log(string memory p0, uint256 p1) internal view {
  215 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  216 |     |     }
  217 |     | 
  218 |     |     function log(string memory p0, int256 p1) internal view {
  219 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  220 |     |     }
  221 |     | 
  222 |     |     function log(string memory p0, string memory p1) internal view {
  223 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  224 |     |     }
  225 |     | 
  226 |     |     function log(string memory p0, bool p1) internal view {
  227 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  228 |     |     }
  229 |     | 
  230 |     |     function log(string memory p0, address p1) internal view {
  231 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  232 |     |     }
  233 |     | 
  234 |     |     function log(bool p0, uint256 p1) internal view {
  235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  236 |     |     }
  237 |     | 
  238 |     |     function log(bool p0, string memory p1) internal view {
  239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  240 |     |     }
  241 |     | 
  242 |     |     function log(bool p0, bool p1) internal view {
  243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  244 |     |     }
  245 |     | 
  246 |     |     function log(bool p0, address p1) internal view {
  247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  248 |     |     }
  249 |     | 
  250 |     |     function log(address p0, uint256 p1) internal view {
  251 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  252 |     |     }
  253 |     | 
  254 |     |     function log(address p0, string memory p1) internal view {
  255 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  256 |     |     }
  257 |     | 
  258 |     |     function log(address p0, bool p1) internal view {
  259 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  260 |     |     }
  261 |     | 
  262 |     |     function log(address p0, address p1) internal view {
  263 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  264 |     |     }
  265 |     | 
  266 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal view {
  267 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  268 |     |     }
  269 |     | 
  270 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal view {
  271 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  272 |     |     }
  273 |     | 
  274 |     |     function log(uint256 p0, uint256 p1, bool p2) internal view {
  275 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  276 |     |     }
  277 |     | 
  278 |     |     function log(uint256 p0, uint256 p1, address p2) internal view {
  279 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  280 |     |     }
  281 |     | 
  282 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal view {
  283 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  284 |     |     }
  285 |     | 
  286 |     |     function log(uint256 p0, string memory p1, string memory p2) internal view {
  287 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  288 |     |     }
  289 |     | 
  290 |     |     function log(uint256 p0, string memory p1, bool p2) internal view {
  291 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  292 |     |     }
  293 |     | 
  294 |     |     function log(uint256 p0, string memory p1, address p2) internal view {
  295 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  296 |     |     }
  297 |     | 
  298 |     |     function log(uint256 p0, bool p1, uint256 p2) internal view {
  299 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  300 |     |     }
  301 |     | 
  302 |     |     function log(uint256 p0, bool p1, string memory p2) internal view {
  303 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  304 |     |     }
  305 |     | 
  306 |     |     function log(uint256 p0, bool p1, bool p2) internal view {
  307 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  308 |     |     }
  309 |     | 
  310 |     |     function log(uint256 p0, bool p1, address p2) internal view {
  311 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  312 |     |     }
  313 |     | 
  314 |     |     function log(uint256 p0, address p1, uint256 p2) internal view {
  315 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  316 |     |     }
  317 |     | 
  318 |     |     function log(uint256 p0, address p1, string memory p2) internal view {
  319 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  320 |     |     }
  321 |     | 
  322 |     |     function log(uint256 p0, address p1, bool p2) internal view {
  323 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  324 |     |     }
  325 |     | 
  326 |     |     function log(uint256 p0, address p1, address p2) internal view {
  327 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  328 |     |     }
  329 |     | 
  330 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal view {
  331 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  332 |     |     }
  333 |     | 
  334 |     |     function log(string memory p0, uint256 p1, string memory p2) internal view {
  335 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  336 |     |     }
  337 |     | 
  338 |     |     function log(string memory p0, uint256 p1, bool p2) internal view {
  339 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  340 |     |     }
  341 |     | 
  342 |     |     function log(string memory p0, uint256 p1, address p2) internal view {
  343 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  344 |     |     }
  345 |     | 
  346 |     |     function log(string memory p0, string memory p1, uint256 p2) internal view {
  347 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  348 |     |     }
  349 |     | 
  350 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  351 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  352 |     |     }
  353 |     | 
  354 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  355 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  356 |     |     }
  357 |     | 
  358 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  359 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  360 |     |     }
  361 |     | 
  362 |     |     function log(string memory p0, bool p1, uint256 p2) internal view {
  363 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  364 |     |     }
  365 |     | 
  366 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  367 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  368 |     |     }
  369 |     | 
  370 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  371 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  372 |     |     }
  373 |     | 
  374 |     |     function log(string memory p0, bool p1, address p2) internal view {
  375 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  376 |     |     }
  377 |     | 
  378 |     |     function log(string memory p0, address p1, uint256 p2) internal view {
  379 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  380 |     |     }
  381 |     | 
  382 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  383 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  384 |     |     }
  385 |     | 
  386 |     |     function log(string memory p0, address p1, bool p2) internal view {
  387 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  388 |     |     }
  389 |     | 
  390 |     |     function log(string memory p0, address p1, address p2) internal view {
  391 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  392 |     |     }
  393 |     | 
  394 |     |     function log(bool p0, uint256 p1, uint256 p2) internal view {
  395 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  396 |     |     }
  397 |     | 
  398 |     |     function log(bool p0, uint256 p1, string memory p2) internal view {
  399 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  400 |     |     }
  401 |     | 
  402 |     |     function log(bool p0, uint256 p1, bool p2) internal view {
  403 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  404 |     |     }
  405 |     | 
  406 |     |     function log(bool p0, uint256 p1, address p2) internal view {
  407 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  408 |     |     }
  409 |     | 
  410 |     |     function log(bool p0, string memory p1, uint256 p2) internal view {
  411 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  412 |     |     }
  413 |     | 
  414 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  415 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  416 |     |     }
  417 |     | 
  418 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  419 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  420 |     |     }
  421 |     | 
  422 |     |     function log(bool p0, string memory p1, address p2) internal view {
  423 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  424 |     |     }
  425 |     | 
  426 |     |     function log(bool p0, bool p1, uint256 p2) internal view {
  427 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  428 |     |     }
  429 |     | 
  430 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  431 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  432 |     |     }
  433 |     | 
  434 |     |     function log(bool p0, bool p1, bool p2) internal view {
  435 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  436 |     |     }
  437 |     | 
  438 |     |     function log(bool p0, bool p1, address p2) internal view {
  439 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  440 |     |     }
  441 |     | 
  442 |     |     function log(bool p0, address p1, uint256 p2) internal view {
  443 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  444 |     |     }
  445 |     | 
  446 |     |     function log(bool p0, address p1, string memory p2) internal view {
  447 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  448 |     |     }
  449 |     | 
  450 |     |     function log(bool p0, address p1, bool p2) internal view {
  451 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  452 |     |     }
  453 |     | 
  454 |     |     function log(bool p0, address p1, address p2) internal view {
  455 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  456 |     |     }
  457 |     | 
  458 |     |     function log(address p0, uint256 p1, uint256 p2) internal view {
  459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  460 |     |     }
  461 |     | 
  462 |     |     function log(address p0, uint256 p1, string memory p2) internal view {
  463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  464 |     |     }
  465 |     | 
  466 |     |     function log(address p0, uint256 p1, bool p2) internal view {
  467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  468 |     |     }
  469 |     | 
  470 |     |     function log(address p0, uint256 p1, address p2) internal view {
  471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  472 |     |     }
  473 |     | 
  474 |     |     function log(address p0, string memory p1, uint256 p2) internal view {
  475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  476 |     |     }
  477 |     | 
  478 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  480 |     |     }
  481 |     | 
  482 |     |     function log(address p0, string memory p1, bool p2) internal view {
  483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  484 |     |     }
  485 |     | 
  486 |     |     function log(address p0, string memory p1, address p2) internal view {
  487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  488 |     |     }
  489 |     | 
  490 |     |     function log(address p0, bool p1, uint256 p2) internal view {
  491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  492 |     |     }
  493 |     | 
  494 |     |     function log(address p0, bool p1, string memory p2) internal view {
  495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  496 |     |     }
  497 |     | 
  498 |     |     function log(address p0, bool p1, bool p2) internal view {
  499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  500 |     |     }
  501 |     | 
  502 |     |     function log(address p0, bool p1, address p2) internal view {
  503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  504 |     |     }
  505 |     | 
  506 |     |     function log(address p0, address p1, uint256 p2) internal view {
  507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  508 |     |     }
  509 |     | 
  510 |     |     function log(address p0, address p1, string memory p2) internal view {
  511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  512 |     |     }
  513 |     | 
  514 |     |     function log(address p0, address p1, bool p2) internal view {
  515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  516 |     |     }
  517 |     | 
  518 |     |     function log(address p0, address p1, address p2) internal view {
  519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  520 |     |     }
  521 |     | 
  522 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  523 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  524 |     |     }
  525 |     | 
  526 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
  527 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  528 |     |     }
  529 |     | 
  530 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
  531 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  532 |     |     }
  533 |     | 
  534 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
  535 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  536 |     |     }
  537 |     | 
  538 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
  539 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  540 |     |     }
  541 |     | 
  542 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
  543 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  544 |     |     }
  545 |     | 
  546 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
  547 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  548 |     |     }
  549 |     | 
  550 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
  551 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  552 |     |     }
  553 |     | 
  554 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
  555 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  556 |     |     }
  557 |     | 
  558 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
  559 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  560 |     |     }
  561 |     | 
  562 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
  563 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  564 |     |     }
  565 |     | 
  566 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
  567 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  568 |     |     }
  569 |     | 
  570 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
  571 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  572 |     |     }
  573 |     | 
  574 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
  575 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  576 |     |     }
  577 |     | 
  578 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
  579 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  580 |     |     }
  581 |     | 
  582 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
  583 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  584 |     |     }
  585 |     | 
  586 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
  587 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  588 |     |     }
  589 |     | 
  590 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
  591 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  592 |     |     }
  593 |     | 
  594 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
  595 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  596 |     |     }
  597 |     | 
  598 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
  599 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  600 |     |     }
  601 |     | 
  602 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
  603 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  604 |     |     }
  605 |     | 
  606 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
  607 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  608 |     |     }
  609 |     | 
  610 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
  611 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  612 |     |     }
  613 |     | 
  614 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
  615 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  616 |     |     }
  617 |     | 
  618 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
  619 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  620 |     |     }
  621 |     | 
  622 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
  623 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  624 |     |     }
  625 |     | 
  626 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
  627 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  628 |     |     }
  629 |     | 
  630 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
  631 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  632 |     |     }
  633 |     | 
  634 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
  635 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  636 |     |     }
  637 |     | 
  638 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
  639 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  640 |     |     }
  641 |     | 
  642 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
  643 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  644 |     |     }
  645 |     | 
  646 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal view {
  647 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  648 |     |     }
  649 |     | 
  650 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
  651 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  652 |     |     }
  653 |     | 
  654 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
  655 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  656 |     |     }
  657 |     | 
  658 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
  659 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  660 |     |     }
  661 |     | 
  662 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
  663 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  664 |     |     }
  665 |     | 
  666 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
  667 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  668 |     |     }
  669 |     | 
  670 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
  671 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  672 |     |     }
  673 |     | 
  674 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
  675 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  676 |     |     }
  677 |     | 
  678 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
  679 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  680 |     |     }
  681 |     | 
  682 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
  683 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  684 |     |     }
  685 |     | 
  686 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
  687 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  688 |     |     }
  689 |     | 
  690 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
  691 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  692 |     |     }
  693 |     | 
  694 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal view {
  695 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  696 |     |     }
  697 |     | 
  698 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
  699 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  700 |     |     }
  701 |     | 
  702 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
  703 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  704 |     |     }
  705 |     | 
  706 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal view {
  707 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  708 |     |     }
  709 |     | 
  710 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal view {
  711 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  712 |     |     }
  713 |     | 
  714 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
  715 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  716 |     |     }
  717 |     | 
  718 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
  719 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  720 |     |     }
  721 |     | 
  722 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
  723 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  724 |     |     }
  725 |     | 
  726 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
  727 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  728 |     |     }
  729 |     | 
  730 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
  731 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  732 |     |     }
  733 |     | 
  734 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
  735 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  736 |     |     }
  737 |     | 
  738 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
  739 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  740 |     |     }
  741 |     | 
  742 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal view {
  743 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  744 |     |     }
  745 |     | 
  746 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
  747 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  748 |     |     }
  749 |     | 
  750 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
  751 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  752 |     |     }
  753 |     | 
  754 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal view {
  755 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  756 |     |     }
  757 |     | 
  758 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal view {
  759 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  760 |     |     }
  761 |     | 
  762 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
  763 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  764 |     |     }
  765 |     | 
  766 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal view {
  767 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  768 |     |     }
  769 |     | 
  770 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal view {
  771 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  772 |     |     }
  773 |     | 
  774 |     |     function log(uint256 p0, address p1, address p2, address p3) internal view {
  775 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  776 |     |     }
  777 |     | 
  778 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  779 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  780 |     |     }
  781 |     | 
  782 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
  783 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  784 |     |     }
  785 |     | 
  786 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
  787 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  788 |     |     }
  789 |     | 
  790 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
  791 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  792 |     |     }
  793 |     | 
  794 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
  795 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  796 |     |     }
  797 |     | 
  798 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
  799 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  800 |     |     }
  801 |     | 
  802 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
  803 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  804 |     |     }
  805 |     | 
  806 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
  807 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  808 |     |     }
  809 |     | 
  810 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
  811 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  812 |     |     }
  813 |     | 
  814 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
  815 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  816 |     |     }
  817 |     | 
  818 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
  819 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  820 |     |     }
  821 |     | 
  822 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
  823 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  824 |     |     }
  825 |     | 
  826 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
  827 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  828 |     |     }
  829 |     | 
  830 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
  831 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  832 |     |     }
  833 |     | 
  834 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
  835 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  836 |     |     }
  837 |     | 
  838 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal view {
  839 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  840 |     |     }
  841 |     | 
  842 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
  843 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  844 |     |     }
  845 |     | 
  846 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
  847 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  848 |     |     }
  849 |     | 
  850 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
  851 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  852 |     |     }
  853 |     | 
  854 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
  855 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  856 |     |     }
  857 |     | 
  858 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
  859 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  860 |     |     }
  861 |     | 
  862 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  863 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  864 |     |     }
  865 |     | 
  866 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  867 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  868 |     |     }
  869 |     | 
  870 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  871 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  872 |     |     }
  873 |     | 
  874 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
  875 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  876 |     |     }
  877 |     | 
  878 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  879 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  880 |     |     }
  881 |     | 
  882 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  883 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  884 |     |     }
  885 |     | 
  886 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  887 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  888 |     |     }
  889 |     | 
  890 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
  891 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  892 |     |     }
  893 |     | 
  894 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  895 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  896 |     |     }
  897 |     | 
  898 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  899 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  900 |     |     }
  901 |     | 
  902 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  903 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  904 |     |     }
  905 |     | 
  906 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
  907 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  908 |     |     }
  909 |     | 
  910 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
  911 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  912 |     |     }
  913 |     | 
  914 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
  915 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  916 |     |     }
  917 |     | 
  918 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
  919 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  920 |     |     }
  921 |     | 
  922 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
  923 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  924 |     |     }
  925 |     | 
  926 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  927 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  928 |     |     }
  929 |     | 
  930 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  931 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  932 |     |     }
  933 |     | 
  934 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  935 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  936 |     |     }
  937 |     | 
  938 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
  939 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  940 |     |     }
  941 |     | 
  942 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  943 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  944 |     |     }
  945 |     | 
  946 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  947 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  948 |     |     }
  949 |     | 
  950 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  951 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  952 |     |     }
  953 |     | 
  954 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
  955 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  956 |     |     }
  957 |     | 
  958 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  959 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  960 |     |     }
  961 |     | 
  962 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  963 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  964 |     |     }
  965 |     | 
  966 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  967 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  968 |     |     }
  969 |     | 
  970 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
  971 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  972 |     |     }
  973 |     | 
  974 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
  975 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  976 |     |     }
  977 |     | 
  978 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
  979 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  980 |     |     }
  981 |     | 
  982 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal view {
  983 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  984 |     |     }
  985 |     | 
  986 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
  987 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  988 |     |     }
  989 |     | 
  990 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  991 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  992 |     |     }
  993 |     | 
  994 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  995 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  996 |     |     }
  997 |     | 
  998 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  999 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1000 |     |     }
 1001 |     | 
 1002 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
 1003 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1004 |     |     }
 1005 |     | 
 1006 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
 1007 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1008 |     |     }
 1009 |     | 
 1010 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
 1011 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1012 |     |     }
 1013 |     | 
 1014 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1015 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1016 |     |     }
 1017 |     | 
 1018 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal view {
 1019 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1020 |     |     }
 1021 |     | 
 1022 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1023 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1024 |     |     }
 1025 |     | 
 1026 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1027 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1028 |     |     }
 1029 |     | 
 1030 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1031 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1032 |     |     }
 1033 |     | 
 1034 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1035 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1036 |     |     }
 1037 |     | 
 1038 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1039 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1040 |     |     }
 1041 |     | 
 1042 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
 1043 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1044 |     |     }
 1045 |     | 
 1046 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
 1047 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1048 |     |     }
 1049 |     | 
 1050 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1051 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1052 |     |     }
 1053 |     | 
 1054 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
 1055 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1056 |     |     }
 1057 |     | 
 1058 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
 1059 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1060 |     |     }
 1061 |     | 
 1062 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
 1063 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1064 |     |     }
 1065 |     | 
 1066 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
 1067 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1068 |     |     }
 1069 |     | 
 1070 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
 1071 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1072 |     |     }
 1073 |     | 
 1074 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
 1075 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1076 |     |     }
 1077 |     | 
 1078 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal view {
 1079 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1080 |     |     }
 1081 |     | 
 1082 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
 1083 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1084 |     |     }
 1085 |     | 
 1086 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
 1087 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1088 |     |     }
 1089 |     | 
 1090 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal view {
 1091 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1092 |     |     }
 1093 |     | 
 1094 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal view {
 1095 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1096 |     |     }
 1097 |     | 
 1098 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1099 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1100 |     |     }
 1101 |     | 
 1102 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
 1103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1104 |     |     }
 1105 |     | 
 1106 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
 1107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1108 |     |     }
 1109 |     | 
 1110 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
 1111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1112 |     |     }
 1113 |     | 
 1114 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
 1115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1116 |     |     }
 1117 |     | 
 1118 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1120 |     |     }
 1121 |     | 
 1122 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1124 |     |     }
 1125 |     | 
 1126 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1128 |     |     }
 1129 |     | 
 1130 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
 1131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1132 |     |     }
 1133 |     | 
 1134 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1136 |     |     }
 1137 |     | 
 1138 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1140 |     |     }
 1141 |     | 
 1142 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1144 |     |     }
 1145 |     | 
 1146 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
 1147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1148 |     |     }
 1149 |     | 
 1150 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1152 |     |     }
 1153 |     | 
 1154 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1156 |     |     }
 1157 |     | 
 1158 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1160 |     |     }
 1161 |     | 
 1162 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
 1163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1164 |     |     }
 1165 |     | 
 1166 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
 1167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1168 |     |     }
 1169 |     | 
 1170 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
 1171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1172 |     |     }
 1173 |     | 
 1174 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal view {
 1175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1176 |     |     }
 1177 |     | 
 1178 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
 1179 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1180 |     |     }
 1181 |     | 
 1182 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1183 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1184 |     |     }
 1185 |     | 
 1186 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1188 |     |     }
 1189 |     | 
 1190 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1192 |     |     }
 1193 |     | 
 1194 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
 1195 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1196 |     |     }
 1197 |     | 
 1198 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1199 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1200 |     |     }
 1201 |     | 
 1202 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1203 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1204 |     |     }
 1205 |     | 
 1206 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1207 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1208 |     |     }
 1209 |     | 
 1210 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal view {
 1211 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1212 |     |     }
 1213 |     | 
 1214 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1215 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1216 |     |     }
 1217 |     | 
 1218 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1219 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1220 |     |     }
 1221 |     | 
 1222 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1223 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1224 |     |     }
 1225 |     | 
 1226 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
 1227 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1228 |     |     }
 1229 |     | 
 1230 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
 1231 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1232 |     |     }
 1233 |     | 
 1234 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal view {
 1235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1236 |     |     }
 1237 |     | 
 1238 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal view {
 1239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1240 |     |     }
 1241 |     | 
 1242 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
 1243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1244 |     |     }
 1245 |     | 
 1246 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1248 |     |     }
 1249 |     | 
 1250 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1251 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1252 |     |     }
 1253 |     | 
 1254 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1255 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1256 |     |     }
 1257 |     | 
 1258 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal view {
 1259 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1260 |     |     }
 1261 |     | 
 1262 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1263 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1264 |     |     }
 1265 |     | 
 1266 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1267 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1268 |     |     }
 1269 |     | 
 1270 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1271 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1272 |     |     }
 1273 |     | 
 1274 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal view {
 1275 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1276 |     |     }
 1277 |     | 
 1278 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1279 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1280 |     |     }
 1281 |     | 
 1282 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1283 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1284 |     |     }
 1285 |     | 
 1286 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1287 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1288 |     |     }
 1289 |     | 
 1290 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1291 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1292 |     |     }
 1293 |     | 
 1294 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1295 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1296 |     |     }
 1297 |     | 
 1298 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
 1299 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1300 |     |     }
 1301 |     | 
 1302 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
 1303 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1304 |     |     }
 1305 |     | 
 1306 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1307 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1308 |     |     }
 1309 |     | 
 1310 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
 1311 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1312 |     |     }
 1313 |     | 
 1314 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
 1315 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1316 |     |     }
 1317 |     | 
 1318 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal view {
 1319 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1320 |     |     }
 1321 |     | 
 1322 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
 1323 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1324 |     |     }
 1325 |     | 
 1326 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
 1327 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1328 |     |     }
 1329 |     | 
 1330 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal view {
 1331 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1332 |     |     }
 1333 |     | 
 1334 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal view {
 1335 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1336 |     |     }
 1337 |     | 
 1338 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
 1339 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1340 |     |     }
 1341 |     | 
 1342 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal view {
 1343 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1344 |     |     }
 1345 |     | 
 1346 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal view {
 1347 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1348 |     |     }
 1349 |     | 
 1350 |     |     function log(address p0, uint256 p1, address p2, address p3) internal view {
 1351 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1352 |     |     }
 1353 |     | 
 1354 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1355 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1356 |     |     }
 1357 |     | 
 1358 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
 1359 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1360 |     |     }
 1361 |     | 
 1362 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
 1363 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1364 |     |     }
 1365 |     | 
 1366 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal view {
 1367 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1368 |     |     }
 1369 |     | 
 1370 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
 1371 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1372 |     |     }
 1373 |     | 
 1374 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1375 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1376 |     |     }
 1377 |     | 
 1378 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1379 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1380 |     |     }
 1381 |     | 
 1382 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1383 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1384 |     |     }
 1385 |     | 
 1386 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
 1387 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1388 |     |     }
 1389 |     | 
 1390 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1391 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1392 |     |     }
 1393 |     | 
 1394 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1395 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1396 |     |     }
 1397 |     | 
 1398 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1399 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1400 |     |     }
 1401 |     | 
 1402 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal view {
 1403 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1404 |     |     }
 1405 |     | 
 1406 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1407 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1408 |     |     }
 1409 |     | 
 1410 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1411 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1412 |     |     }
 1413 |     | 
 1414 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1415 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1416 |     |     }
 1417 |     | 
 1418 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
 1419 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1420 |     |     }
 1421 |     | 
 1422 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
 1423 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1424 |     |     }
 1425 |     | 
 1426 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal view {
 1427 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1428 |     |     }
 1429 |     | 
 1430 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal view {
 1431 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1432 |     |     }
 1433 |     | 
 1434 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
 1435 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1436 |     |     }
 1437 |     | 
 1438 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1439 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1440 |     |     }
 1441 |     | 
 1442 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1443 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1444 |     |     }
 1445 |     | 
 1446 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1447 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1448 |     |     }
 1449 |     | 
 1450 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal view {
 1451 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1452 |     |     }
 1453 |     | 
 1454 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1455 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1456 |     |     }
 1457 |     | 
 1458 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1460 |     |     }
 1461 |     | 
 1462 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1464 |     |     }
 1465 |     | 
 1466 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal view {
 1467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1468 |     |     }
 1469 |     | 
 1470 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1472 |     |     }
 1473 |     | 
 1474 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1476 |     |     }
 1477 |     | 
 1478 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1480 |     |     }
 1481 |     | 
 1482 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
 1483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1484 |     |     }
 1485 |     | 
 1486 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal view {
 1487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1488 |     |     }
 1489 |     | 
 1490 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal view {
 1491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1492 |     |     }
 1493 |     | 
 1494 |     |     function log(address p0, address p1, uint256 p2, address p3) internal view {
 1495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1496 |     |     }
 1497 |     | 
 1498 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal view {
 1499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1500 |     |     }
 1501 |     | 
 1502 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1504 |     |     }
 1505 |     | 
 1506 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1508 |     |     }
 1509 |     | 
 1510 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1512 |     |     }
 1513 |     | 
 1514 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal view {
 1515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1516 |     |     }
 1517 |     | 
 1518 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1520 |     |     }
 1521 |     | 
 1522 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1523 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1524 |     |     }
 1525 |     | 
 1526 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1527 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1528 |     |     }
 1529 |     | 
 1530 |     |     function log(address p0, address p1, address p2, uint256 p3) internal view {
 1531 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1532 |     |     }
 1533 |     | 
 1534 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1535 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1536 |     |     }
 1537 |     | 
 1538 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1539 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1540 |     |     }
 1541 |     | 
 1542 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1543 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1544 |     |     }
 1545 |     | 
 1546 |     | }

/root/code/hyper/lib/solmate/lib/ds-test/src/test.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | 
   3 |     | // This program is free software: you can redistribute it and/or modify
   4 |     | // it under the terms of the GNU General Public License as published by
   5 |     | // the Free Software Foundation, either version 3 of the License, or
   6 |     | // (at your option) any later version.
   7 |     | 
   8 |     | // This program is distributed in the hope that it will be useful,
   9 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  10 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11 |     | // GNU General Public License for more details.
  12 |     | 
  13 |     | // You should have received a copy of the GNU General Public License
  14 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15 |     | 
  16 |     | pragma solidity >=0.5.0;
  17 |     | 
  18 |     | contract DSTest {
  19 |     |     event log                    (string);
  20 |     |     event logs                   (bytes);
  21 |     | 
  22 |     |     event log_address            (address);
  23 |     |     event log_bytes32            (bytes32);
  24 |     |     event log_int                (int);
  25 |     |     event log_uint               (uint);
  26 |     |     event log_bytes              (bytes);
  27 |     |     event log_string             (string);
  28 |     | 
  29 |     |     event log_named_address      (string key, address val);
  30 |     |     event log_named_bytes32      (string key, bytes32 val);
  31 |     |     event log_named_decimal_int  (string key, int val, uint decimals);
  32 |     |     event log_named_decimal_uint (string key, uint val, uint decimals);
  33 |     |     event log_named_int          (string key, int val);
  34 |     |     event log_named_uint         (string key, uint val);
  35 |     |     event log_named_bytes        (string key, bytes val);
  36 |     |     event log_named_string       (string key, string val);
  37 |     | 
  38 |     |     bool public IS_TEST = true;
  39 |     |     bool private _failed;
  40 |     | 
  41 |     |     address constant HEVM_ADDRESS =
  42 |     |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
  43 |     | 
  44 |     |     modifier mayRevert() { _; }
  45 |     |     modifier testopts(string memory) { _; }
  46 |     | 
  47 |     |     function failed() public returns (bool) {
  48 |     |         if (_failed) {
  49 |     |             return _failed;
  50 |     |         } else {
  51 |     |             bool globalFailed = false;
  52 |     |             if (hasHEVMContext()) {
  53 |     |                 (, bytes memory retdata) = HEVM_ADDRESS.call(
  54 |     |                     abi.encodePacked(
  55 |     |                         bytes4(keccak256("load(address,bytes32)")),
  56 |     |                         abi.encode(HEVM_ADDRESS, bytes32("failed"))
  57 |     |                     )
  58 |     |                 );
  59 |     |                 globalFailed = abi.decode(retdata, (bool));
  60 |     |             }
  61 |     |             return globalFailed;
  62 |     |         }
  63 |     |     } 
  64 |     | 
  65 |     |     function fail() internal {
  66 |     |         if (hasHEVMContext()) {
  67 |     |             (bool status, ) = HEVM_ADDRESS.call(
  68 |     |                 abi.encodePacked(
  69 |     |                     bytes4(keccak256("store(address,bytes32,bytes32)")),
  70 |     |                     abi.encode(HEVM_ADDRESS, bytes32("failed"), bytes32(uint256(0x01)))
  71 |     |                 )
  72 |     |             );
  73 |     |             status; // Silence compiler warnings
  74 |     |         }
  75 |     |         _failed = true;
  76 |     |     }
  77 |     | 
  78 |     |     function hasHEVMContext() internal view returns (bool) {
  79 |     |         uint256 hevmCodeSize = 0;
  80 |     |         assembly {
  81 |     |             hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
  82 |     |         }
  83 |     |         return hevmCodeSize > 0;
  84 |     |     }
  85 |     | 
  86 |     |     modifier logs_gas() {
  87 |     |         uint startGas = gasleft();
  88 |     |         _;
  89 |     |         uint endGas = gasleft();
  90 |     |         emit log_named_uint("gas", startGas - endGas);
  91 |     |     }
  92 |     | 
  93 |     |     function assertTrue(bool condition) internal {
  94 |     |         if (!condition) {
  95 |     |             emit log("Error: Assertion Failed");
  96 |     |             fail();
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     function assertTrue(bool condition, string memory err) internal {
 101 |     |         if (!condition) {
 102 |     |             emit log_named_string("Error", err);
 103 |     |             assertTrue(condition);
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address a, address b) internal {
 108 |     |         if (a != b) {
 109 |     |             emit log("Error: a == b not satisfied [address]");
 110 |     |             emit log_named_address("  Expected", b);
 111 |     |             emit log_named_address("    Actual", a);
 112 |     |             fail();
 113 |     |         }
 114 |     |     }
 115 |     |     function assertEq(address a, address b, string memory err) internal {
 116 |     |         if (a != b) {
 117 |     |             emit log_named_string ("Error", err);
 118 |     |             assertEq(a, b);
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     function assertEq(bytes32 a, bytes32 b) internal {
 123 |     |         if (a != b) {
 124 |     |             emit log("Error: a == b not satisfied [bytes32]");
 125 |     |             emit log_named_bytes32("  Expected", b);
 126 |     |             emit log_named_bytes32("    Actual", a);
 127 |     |             fail();
 128 |     |         }
 129 |     |     }
 130 |     |     function assertEq(bytes32 a, bytes32 b, string memory err) internal {
 131 |     |         if (a != b) {
 132 |     |             emit log_named_string ("Error", err);
 133 |     |             assertEq(a, b);
 134 |     |         }
 135 |     |     }
 136 |     |     function assertEq32(bytes32 a, bytes32 b) internal {
 137 |     |         assertEq(a, b);
 138 |     |     }
 139 |     |     function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
 140 |     |         assertEq(a, b, err);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(int a, int b) internal {
 144 |     |         if (a != b) {
 145 |     |             emit log("Error: a == b not satisfied [int]");
 146 |     |             emit log_named_int("  Expected", b);
 147 |     |             emit log_named_int("    Actual", a);
 148 |     |             fail();
 149 |     |         }
 150 |     |     }
 151 |     |     function assertEq(int a, int b, string memory err) internal {
 152 |     |         if (a != b) {
 153 |     |             emit log_named_string("Error", err);
 154 |     |             assertEq(a, b);
 155 |     |         }
 156 |     |     }
 157 |     |     function assertEq(uint a, uint b) internal {
 158 |     |         if (a != b) {
 159 |     |             emit log("Error: a == b not satisfied [uint]");
 160 |     |             emit log_named_uint("  Expected", b);
 161 |     |             emit log_named_uint("    Actual", a);
 162 |     |             fail();
 163 |     |         }
 164 |     |     }
 165 |     |     function assertEq(uint a, uint b, string memory err) internal {
 166 |     |         if (a != b) {
 167 |     |             emit log_named_string("Error", err);
 168 |     |             assertEq(a, b);
 169 |     |         }
 170 |     |     }
 171 |     |     function assertEqDecimal(int a, int b, uint decimals) internal {
 172 |     |         if (a != b) {
 173 |     |             emit log("Error: a == b not satisfied [decimal int]");
 174 |     |             emit log_named_decimal_int("  Expected", b, decimals);
 175 |     |             emit log_named_decimal_int("    Actual", a, decimals);
 176 |     |             fail();
 177 |     |         }
 178 |     |     }
 179 |     |     function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
 180 |     |         if (a != b) {
 181 |     |             emit log_named_string("Error", err);
 182 |     |             assertEqDecimal(a, b, decimals);
 183 |     |         }
 184 |     |     }
 185 |     |     function assertEqDecimal(uint a, uint b, uint decimals) internal {
 186 |     |         if (a != b) {
 187 |     |             emit log("Error: a == b not satisfied [decimal uint]");
 188 |     |             emit log_named_decimal_uint("  Expected", b, decimals);
 189 |     |             emit log_named_decimal_uint("    Actual", a, decimals);
 190 |     |             fail();
 191 |     |         }
 192 |     |     }
 193 |     |     function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
 194 |     |         if (a != b) {
 195 |     |             emit log_named_string("Error", err);
 196 |     |             assertEqDecimal(a, b, decimals);
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     function assertGt(uint a, uint b) internal {
 201 |     |         if (a <= b) {
 202 |     |             emit log("Error: a > b not satisfied [uint]");
 203 |     |             emit log_named_uint("  Value a", a);
 204 |     |             emit log_named_uint("  Value b", b);
 205 |     |             fail();
 206 |     |         }
 207 |     |     }
 208 |     |     function assertGt(uint a, uint b, string memory err) internal {
 209 |     |         if (a <= b) {
 210 |     |             emit log_named_string("Error", err);
 211 |     |             assertGt(a, b);
 212 |     |         }
 213 |     |     }
 214 |     |     function assertGt(int a, int b) internal {
 215 |     |         if (a <= b) {
 216 |     |             emit log("Error: a > b not satisfied [int]");
 217 |     |             emit log_named_int("  Value a", a);
 218 |     |             emit log_named_int("  Value b", b);
 219 |     |             fail();
 220 |     |         }
 221 |     |     }
 222 |     |     function assertGt(int a, int b, string memory err) internal {
 223 |     |         if (a <= b) {
 224 |     |             emit log_named_string("Error", err);
 225 |     |             assertGt(a, b);
 226 |     |         }
 227 |     |     }
 228 |     |     function assertGtDecimal(int a, int b, uint decimals) internal {
 229 |     |         if (a <= b) {
 230 |     |             emit log("Error: a > b not satisfied [decimal int]");
 231 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 232 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 233 |     |             fail();
 234 |     |         }
 235 |     |     }
 236 |     |     function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
 237 |     |         if (a <= b) {
 238 |     |             emit log_named_string("Error", err);
 239 |     |             assertGtDecimal(a, b, decimals);
 240 |     |         }
 241 |     |     }
 242 |     |     function assertGtDecimal(uint a, uint b, uint decimals) internal {
 243 |     |         if (a <= b) {
 244 |     |             emit log("Error: a > b not satisfied [decimal uint]");
 245 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 246 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 247 |     |             fail();
 248 |     |         }
 249 |     |     }
 250 |     |     function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 251 |     |         if (a <= b) {
 252 |     |             emit log_named_string("Error", err);
 253 |     |             assertGtDecimal(a, b, decimals);
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     function assertGe(uint a, uint b) internal {
 258 |     |         if (a < b) {
 259 |     |             emit log("Error: a >= b not satisfied [uint]");
 260 |     |             emit log_named_uint("  Value a", a);
 261 |     |             emit log_named_uint("  Value b", b);
 262 |     |             fail();
 263 |     |         }
 264 |     |     }
 265 |     |     function assertGe(uint a, uint b, string memory err) internal {
 266 |     |         if (a < b) {
 267 |     |             emit log_named_string("Error", err);
 268 |     |             assertGe(a, b);
 269 |     |         }
 270 |     |     }
 271 |     |     function assertGe(int a, int b) internal {
 272 |     |         if (a < b) {
 273 |     |             emit log("Error: a >= b not satisfied [int]");
 274 |     |             emit log_named_int("  Value a", a);
 275 |     |             emit log_named_int("  Value b", b);
 276 |     |             fail();
 277 |     |         }
 278 |     |     }
 279 |     |     function assertGe(int a, int b, string memory err) internal {
 280 |     |         if (a < b) {
 281 |     |             emit log_named_string("Error", err);
 282 |     |             assertGe(a, b);
 283 |     |         }
 284 |     |     }
 285 |     |     function assertGeDecimal(int a, int b, uint decimals) internal {
 286 |     |         if (a < b) {
 287 |     |             emit log("Error: a >= b not satisfied [decimal int]");
 288 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 289 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 290 |     |             fail();
 291 |     |         }
 292 |     |     }
 293 |     |     function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
 294 |     |         if (a < b) {
 295 |     |             emit log_named_string("Error", err);
 296 |     |             assertGeDecimal(a, b, decimals);
 297 |     |         }
 298 |     |     }
 299 |     |     function assertGeDecimal(uint a, uint b, uint decimals) internal {
 300 |     |         if (a < b) {
 301 |     |             emit log("Error: a >= b not satisfied [decimal uint]");
 302 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 303 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 304 |     |             fail();
 305 |     |         }
 306 |     |     }
 307 |     |     function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 308 |     |         if (a < b) {
 309 |     |             emit log_named_string("Error", err);
 310 |     |             assertGeDecimal(a, b, decimals);
 311 |     |         }
 312 |     |     }
 313 |     | 
 314 |     |     function assertLt(uint a, uint b) internal {
 315 |     |         if (a >= b) {
 316 |     |             emit log("Error: a < b not satisfied [uint]");
 317 |     |             emit log_named_uint("  Value a", a);
 318 |     |             emit log_named_uint("  Value b", b);
 319 |     |             fail();
 320 |     |         }
 321 |     |     }
 322 |     |     function assertLt(uint a, uint b, string memory err) internal {
 323 |     |         if (a >= b) {
 324 |     |             emit log_named_string("Error", err);
 325 |     |             assertLt(a, b);
 326 |     |         }
 327 |     |     }
 328 |     |     function assertLt(int a, int b) internal {
 329 |     |         if (a >= b) {
 330 |     |             emit log("Error: a < b not satisfied [int]");
 331 |     |             emit log_named_int("  Value a", a);
 332 |     |             emit log_named_int("  Value b", b);
 333 |     |             fail();
 334 |     |         }
 335 |     |     }
 336 |     |     function assertLt(int a, int b, string memory err) internal {
 337 |     |         if (a >= b) {
 338 |     |             emit log_named_string("Error", err);
 339 |     |             assertLt(a, b);
 340 |     |         }
 341 |     |     }
 342 |     |     function assertLtDecimal(int a, int b, uint decimals) internal {
 343 |     |         if (a >= b) {
 344 |     |             emit log("Error: a < b not satisfied [decimal int]");
 345 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 346 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 347 |     |             fail();
 348 |     |         }
 349 |     |     }
 350 |     |     function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
 351 |     |         if (a >= b) {
 352 |     |             emit log_named_string("Error", err);
 353 |     |             assertLtDecimal(a, b, decimals);
 354 |     |         }
 355 |     |     }
 356 |     |     function assertLtDecimal(uint a, uint b, uint decimals) internal {
 357 |     |         if (a >= b) {
 358 |     |             emit log("Error: a < b not satisfied [decimal uint]");
 359 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 360 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 361 |     |             fail();
 362 |     |         }
 363 |     |     }
 364 |     |     function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 365 |     |         if (a >= b) {
 366 |     |             emit log_named_string("Error", err);
 367 |     |             assertLtDecimal(a, b, decimals);
 368 |     |         }
 369 |     |     }
 370 |     | 
 371 |     |     function assertLe(uint a, uint b) internal {
 372 |     |         if (a > b) {
 373 |     |             emit log("Error: a <= b not satisfied [uint]");
 374 |     |             emit log_named_uint("  Value a", a);
 375 |     |             emit log_named_uint("  Value b", b);
 376 |     |             fail();
 377 |     |         }
 378 |     |     }
 379 |     |     function assertLe(uint a, uint b, string memory err) internal {
 380 |     |         if (a > b) {
 381 |     |             emit log_named_string("Error", err);
 382 |     |             assertLe(a, b);
 383 |     |         }
 384 |     |     }
 385 |     |     function assertLe(int a, int b) internal {
 386 |     |         if (a > b) {
 387 |     |             emit log("Error: a <= b not satisfied [int]");
 388 |     |             emit log_named_int("  Value a", a);
 389 |     |             emit log_named_int("  Value b", b);
 390 |     |             fail();
 391 |     |         }
 392 |     |     }
 393 |     |     function assertLe(int a, int b, string memory err) internal {
 394 |     |         if (a > b) {
 395 |     |             emit log_named_string("Error", err);
 396 |     |             assertLe(a, b);
 397 |     |         }
 398 |     |     }
 399 |     |     function assertLeDecimal(int a, int b, uint decimals) internal {
 400 |     |         if (a > b) {
 401 |     |             emit log("Error: a <= b not satisfied [decimal int]");
 402 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 403 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 404 |     |             fail();
 405 |     |         }
 406 |     |     }
 407 |     |     function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
 408 |     |         if (a > b) {
 409 |     |             emit log_named_string("Error", err);
 410 |     |             assertLeDecimal(a, b, decimals);
 411 |     |         }
 412 |     |     }
 413 |     |     function assertLeDecimal(uint a, uint b, uint decimals) internal {
 414 |     |         if (a > b) {
 415 |     |             emit log("Error: a <= b not satisfied [decimal uint]");
 416 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 417 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 418 |     |             fail();
 419 |     |         }
 420 |     |     }
 421 |     |     function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 422 |     |         if (a > b) {
 423 |     |             emit log_named_string("Error", err);
 424 |     |             assertGeDecimal(a, b, decimals);
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     function assertEq(string memory a, string memory b) internal {
 429 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 430 |     |             emit log("Error: a == b not satisfied [string]");
 431 |     |             emit log_named_string("  Expected", b);
 432 |     |             emit log_named_string("    Actual", a);
 433 |     |             fail();
 434 |     |         }
 435 |     |     }
 436 |     |     function assertEq(string memory a, string memory b, string memory err) internal {
 437 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 438 |     |             emit log_named_string("Error", err);
 439 |     |             assertEq(a, b);
 440 |     |         }
 441 |     |     }
 442 |     | 
 443 |     |     function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
 444 |     |         ok = true;
 445 |     |         if (a.length == b.length) {
 446 |     |             for (uint i = 0; i < a.length; i++) {
 447 |     |                 if (a[i] != b[i]) {
 448 |     |                     ok = false;
 449 |     |                 }
 450 |     |             }
 451 |     |         } else {
 452 |     |             ok = false;
 453 |     |         }
 454 |     |     }
 455 |     |     function assertEq0(bytes memory a, bytes memory b) internal {
 456 |     |         if (!checkEq0(a, b)) {
 457 |     |             emit log("Error: a == b not satisfied [bytes]");
 458 |     |             emit log_named_bytes("  Expected", b);
 459 |     |             emit log_named_bytes("    Actual", a);
 460 |     |             fail();
 461 |     |         }
 462 |     |     }
 463 |     |     function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
 464 |     |         if (!checkEq0(a, b)) {
 465 |     |             emit log_named_string("Error", err);
 466 |     |             assertEq0(a, b);
 467 |     |         }
 468 |     |     }
 469 |     | }
 470 |     | 

/root/code/hyper/lib/solmate/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
   7 |     | /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
   8 |     | abstract contract ERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                                  EVENTS
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  14 |     | 
  15 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  16 |     | 
  17 |     |     /*//////////////////////////////////////////////////////////////
  18 |     |                             METADATA STORAGE
  19 |     |     //////////////////////////////////////////////////////////////*/
  20 |     | 
  21 | *r  |     string public name;
  22 |     | 
  23 | *r  |     string public symbol;
  24 |     | 
  25 | *r  |     uint8 public immutable decimals;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                               ERC20 STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 | *r  |     uint256 public totalSupply;
  32 |     | 
  33 | *r  |     mapping(address => uint256) public balanceOf;
  34 |     | 
  35 | *r  |     mapping(address => mapping(address => uint256)) public allowance;
  36 |     | 
  37 |     |     /*//////////////////////////////////////////////////////////////
  38 |     |                             EIP-2612 STORAGE
  39 |     |     //////////////////////////////////////////////////////////////*/
  40 |     | 
  41 |     |     uint256 internal immutable INITIAL_CHAIN_ID;
  42 |     | 
  43 |     |     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
  44 |     | 
  45 | *r  |     mapping(address => uint256) public nonces;
  46 |     | 
  47 |     |     /*//////////////////////////////////////////////////////////////
  48 |     |                                CONSTRUCTOR
  49 |     |     //////////////////////////////////////////////////////////////*/
  50 |     | 
  51 |     |     constructor(
  52 |     |         string memory _name,
  53 |     |         string memory _symbol,
  54 |     |         uint8 _decimals
  55 |     |     ) {
  56 |     |         name = _name;
  57 |     |         symbol = _symbol;
  58 |     |         decimals = _decimals;
  59 |     | 
  60 |     |         INITIAL_CHAIN_ID = block.chainid;
  61 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  62 |     |     }
  63 |     | 
  64 |     |     /*//////////////////////////////////////////////////////////////
  65 |     |                                ERC20 LOGIC
  66 |     |     //////////////////////////////////////////////////////////////*/
  67 |     | 
  68 | *r  |     function approve(address spender, uint256 amount) public virtual returns (bool) {
  69 | *   |         allowance[msg.sender][spender] = amount;
  70 |     | 
  71 | *   |         emit Approval(msg.sender, spender, amount);
  72 |     | 
  73 | *   |         return true;
  74 |     |     }
  75 |     | 
  76 | *r  |     function transfer(address to, uint256 amount) public virtual returns (bool) {
  77 | *r  |         balanceOf[msg.sender] -= amount;
  78 |     | 
  79 |     |         // Cannot overflow because the sum of all user
  80 |     |         // balances can't exceed the max uint256 value.
  81 |     |         unchecked {
  82 | *   |             balanceOf[to] += amount;
  83 |     |         }
  84 |     | 
  85 | *   |         emit Transfer(msg.sender, to, amount);
  86 |     | 
  87 |     |         return true;
  88 |     |     }
  89 |     | 
  90 | *r  |     function transferFrom(
  91 |     |         address from,
  92 |     |         address to,
  93 |     |         uint256 amount
  94 | *r  |     ) public virtual returns (bool) {
  95 | *r  |         uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
  96 |     | 
  97 | *r  |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
  98 |     | 
  99 | *r  |         balanceOf[from] -= amount;
 100 |     | 
 101 |     |         // Cannot overflow because the sum of all user
 102 |     |         // balances can't exceed the max uint256 value.
 103 |     |         unchecked {
 104 | *   |             balanceOf[to] += amount;
 105 |     |         }
 106 |     | 
 107 | *   |         emit Transfer(from, to, amount);
 108 |     | 
 109 | *   |         return true;
 110 |     |     }
 111 |     | 
 112 |     |     /*//////////////////////////////////////////////////////////////
 113 |     |                              EIP-2612 LOGIC
 114 |     |     //////////////////////////////////////////////////////////////*/
 115 |     | 
 116 | r   |     function permit(
 117 |     |         address owner,
 118 |     |         address spender,
 119 |     |         uint256 value,
 120 |     |         uint256 deadline,
 121 |     |         uint8 v,
 122 |     |         bytes32 r,
 123 |     |         bytes32 s
 124 |     |     ) public virtual {
 125 | r   |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 126 |     | 
 127 |     |         // Unchecked because the only math done is incrementing
 128 |     |         // the owner's nonce which cannot realistically overflow.
 129 |     |         unchecked {
 130 | r   |             address recoveredAddress = ecrecover(
 131 | r   |                 keccak256(
 132 | r   |                     abi.encodePacked(
 133 |     |                         "\x19\x01",
 134 | r   |                         DOMAIN_SEPARATOR(),
 135 | r   |                         keccak256(
 136 | r   |                             abi.encode(
 137 | r   |                                 keccak256(
 138 |     |                                     "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 139 |     |                                 ),
 140 |     |                                 owner,
 141 |     |                                 spender,
 142 |     |                                 value,
 143 | r   |                                 nonces[owner]++,
 144 |     |                                 deadline
 145 |     |                             )
 146 |     |                         )
 147 |     |                     )
 148 |     |                 ),
 149 |     |                 v,
 150 |     |                 r,
 151 |     |                 s
 152 |     |             );
 153 |     | 
 154 | r   |             require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 155 |     | 
 156 |     |             allowance[recoveredAddress][spender] = value;
 157 |     |         }
 158 |     | 
 159 |     |         emit Approval(owner, spender, value);
 160 |     |     }
 161 |     | 
 162 | *r  |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 163 | *r  |         return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 164 |     |     }
 165 |     | 
 166 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 167 |     |         return
 168 |     |             keccak256(
 169 |     |                 abi.encode(
 170 |     |                     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 171 |     |                     keccak256(bytes(name)),
 172 |     |                     keccak256("1"),
 173 |     |                     block.chainid,
 174 |     |                     address(this)
 175 |     |                 )
 176 |     |             );
 177 |     |     }
 178 |     | 
 179 |     |     /*//////////////////////////////////////////////////////////////
 180 |     |                         INTERNAL MINT/BURN LOGIC
 181 |     |     //////////////////////////////////////////////////////////////*/
 182 |     | 
 183 | *r  |     function _mint(address to, uint256 amount) internal virtual {
 184 | *r  |         totalSupply += amount;
 185 |     | 
 186 |     |         // Cannot overflow because the sum of all user
 187 |     |         // balances can't exceed the max uint256 value.
 188 |     |         unchecked {
 189 | *r  |             balanceOf[to] += amount;
 190 |     |         }
 191 |     | 
 192 | *r  |         emit Transfer(address(0), to, amount);
 193 |     |     }
 194 |     | 
 195 | *r  |     function _burn(address from, uint256 amount) internal virtual {
 196 | *r  |         balanceOf[from] -= amount;
 197 |     | 
 198 |     |         // Cannot underflow because a user's balance
 199 |     |         // will never be larger than the total supply.
 200 |     |         unchecked {
 201 | *r  |             totalSupply -= amount;
 202 |     |         }
 203 |     | 
 204 | *r  |         emit Transfer(from, address(0), amount);
 205 |     |     }
 206 |     | }
 207 |     | 

/root/code/hyper/lib/solmate/src/tokens/WETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "./ERC20.sol";
  5 |     | 
  6 |     | import {SafeTransferLib} from "../utils/SafeTransferLib.sol";
  7 |     | 
  8 |     | /// @notice Minimalist and modern Wrapped Ether implementation.
  9 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)
 10 | *r  | /// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)
 11 |     | contract WETH is ERC20("Wrapped Ether", "WETH", 18) {
 12 |     |     using SafeTransferLib for address;
 13 |     | 
 14 |     |     event Deposit(address indexed from, uint256 amount);
 15 |     | 
 16 |     |     event Withdrawal(address indexed to, uint256 amount);
 17 |     | 
 18 | *r  |     function deposit() public payable virtual {
 19 | *r  |         _mint(msg.sender, msg.value);
 20 |     | 
 21 | *r  |         emit Deposit(msg.sender, msg.value);
 22 |     |     }
 23 |     | 
 24 | *r  |     function withdraw(uint256 amount) public virtual {
 25 | *r  |         _burn(msg.sender, amount);
 26 |     | 
 27 | *r  |         emit Withdrawal(msg.sender, amount);
 28 |     | 
 29 | *r  |         msg.sender.safeTransferETH(amount);
 30 |     |     }
 31 |     | 
 32 |     |     receive() external payable virtual {
 33 | *r  |         deposit();
 34 |     |     }
 35 |     | }
 36 |     | 

/root/code/hyper/lib/solmate/src/utils/FixedPointMathLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Arithmetic library with operations for fixed-point numbers.
   5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)
   6 |     | library FixedPointMathLib {
   7 |     |     /*//////////////////////////////////////////////////////////////
   8 |     |                     SIMPLIFIED FIXED POINT OPERATIONS
   9 |     |     //////////////////////////////////////////////////////////////*/
  10 |     | 
  11 | *r  |     uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.
  12 |     | 
  13 | *r  |     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  14 | *r  |         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
  15 |     |     }
  16 |     | 
  17 | *r  |     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  18 | *r  |         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
  19 |     |     }
  20 |     | 
  21 | *r  |     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  22 | *r  |         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
  23 |     |     }
  24 |     | 
  25 | *r  |     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  26 | *r  |         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
  27 |     |     }
  28 |     | 
  29 | *r  |     function powWad(int256 x, int256 y) internal pure returns (int256) {
  30 |     |         // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)
  31 | *r  |         return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.
  32 |     |     }
  33 |     | 
  34 | *r  |     function expWad(int256 x) internal pure returns (int256 r) {
  35 |     |         unchecked {
  36 |     |             // When the result is < 0.5 we return zero. This happens when
  37 |     |             // x <= floor(log(0.5e18) * 1e18) ~ -42e18
  38 | *r  |             if (x <= -42139678854452767551) return 0;
  39 |     | 
  40 |     |             // When the result is > (2**255 - 1) / 1e18 we can not represent it as an
  41 |     |             // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.
  42 | *r  |             if (x >= 135305999368893231589) revert("EXP_OVERFLOW");
  43 |     | 
  44 |     |             // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96
  45 |     |             // for more intermediate precision and a binary basis. This base conversion
  46 |     |             // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
  47 | *r  |             x = (x << 78) / 5**18;
  48 |     | 
  49 |     |             // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers
  50 |     |             // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
  51 |     |             // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
  52 | *r  |             int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;
  53 | *r  |             x = x - k * 54916777467707473351141471128;
  54 |     | 
  55 |     |             // k is in the range [-61, 195].
  56 |     | 
  57 |     |             // Evaluate using a (6, 7)-term rational approximation.
  58 |     |             // p is made monic, we'll multiply by a scale factor later.
  59 | *r  |             int256 y = x + 1346386616545796478920950773328;
  60 | *r  |             y = ((y * x) >> 96) + 57155421227552351082224309758442;
  61 | *r  |             int256 p = y + x - 94201549194550492254356042504812;
  62 | *r  |             p = ((p * y) >> 96) + 28719021644029726153956944680412240;
  63 | *r  |             p = p * x + (4385272521454847904659076985693276 << 96);
  64 |     | 
  65 |     |             // We leave p in 2**192 basis so we don't need to scale it back up for the division.
  66 | *r  |             int256 q = x - 2855989394907223263936484059900;
  67 | *r  |             q = ((q * x) >> 96) + 50020603652535783019961831881945;
  68 | *r  |             q = ((q * x) >> 96) - 533845033583426703283633433725380;
  69 | *r  |             q = ((q * x) >> 96) + 3604857256930695427073651918091429;
  70 | *r  |             q = ((q * x) >> 96) - 14423608567350463180887372962807573;
  71 | *r  |             q = ((q * x) >> 96) + 26449188498355588339934803723976023;
  72 |     | 
  73 |     |             assembly {
  74 |     |                 // Div in assembly because solidity adds a zero check despite the unchecked.
  75 |     |                 // The q polynomial won't have zeros in the domain as all its roots are complex.
  76 |     |                 // No scaling is necessary because p is already 2**96 too large.
  77 | *r  |                 r := sdiv(p, q)
  78 |     |             }
  79 |     | 
  80 |     |             // r should be in the range (0.09, 0.25) * 2**96.
  81 |     | 
  82 |     |             // We now need to multiply r by:
  83 |     |             // * the scale factor s = ~6.031367120.
  84 |     |             // * the 2**k factor from the range reduction.
  85 |     |             // * the 1e18 / 2**96 factor for base conversion.
  86 |     |             // We do this all at once, with an intermediate result in 2**213
  87 |     |             // basis, so the final right shift is always by a positive amount.
  88 | *r  |             r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 | *r  |     function lnWad(int256 x) internal pure returns (int256 r) {
  93 |     |         unchecked {
  94 | *r  |             require(x > 0, "UNDEFINED");
  95 |     | 
  96 |     |             // We want to convert x from 10**18 fixed point to 2**96 fixed point.
  97 |     |             // We do this by multiplying by 2**96 / 10**18. But since
  98 |     |             // ln(x * C) = ln(x) + ln(C), we can simply do nothing here
  99 |     |             // and add ln(2**96 / 10**18) at the end.
 100 |     | 
 101 |     |             // Reduce range of x to (1, 2) * 2**96
 102 |     |             // ln(2^k * x) = k * ln(2) + ln(x)
 103 | *r  |             int256 k = int256(log2(uint256(x))) - 96;
 104 | *r  |             x <<= uint256(159 - k);
 105 | *r  |             x = int256(uint256(x) >> 159);
 106 |     | 
 107 |     |             // Evaluate using a (8, 8)-term rational approximation.
 108 |     |             // p is made monic, we will multiply by a scale factor later.
 109 | *r  |             int256 p = x + 3273285459638523848632254066296;
 110 | *r  |             p = ((p * x) >> 96) + 24828157081833163892658089445524;
 111 | *r  |             p = ((p * x) >> 96) + 43456485725739037958740375743393;
 112 | *r  |             p = ((p * x) >> 96) - 11111509109440967052023855526967;
 113 | *r  |             p = ((p * x) >> 96) - 45023709667254063763336534515857;
 114 | *r  |             p = ((p * x) >> 96) - 14706773417378608786704636184526;
 115 | *r  |             p = p * x - (795164235651350426258249787498 << 96);
 116 |     | 
 117 |     |             // We leave p in 2**192 basis so we don't need to scale it back up for the division.
 118 |     |             // q is monic by convention.
 119 | *r  |             int256 q = x + 5573035233440673466300451813936;
 120 | *r  |             q = ((q * x) >> 96) + 71694874799317883764090561454958;
 121 | *r  |             q = ((q * x) >> 96) + 283447036172924575727196451306956;
 122 | *r  |             q = ((q * x) >> 96) + 401686690394027663651624208769553;
 123 | *r  |             q = ((q * x) >> 96) + 204048457590392012362485061816622;
 124 | *r  |             q = ((q * x) >> 96) + 31853899698501571402653359427138;
 125 | *r  |             q = ((q * x) >> 96) + 909429971244387300277376558375;
 126 |     |             assembly {
 127 |     |                 // Div in assembly because solidity adds a zero check despite the unchecked.
 128 |     |                 // The q polynomial is known not to have zeros in the domain.
 129 |     |                 // No scaling required because p is already 2**96 too large.
 130 | *r  |                 r := sdiv(p, q)
 131 |     |             }
 132 |     | 
 133 |     |             // r is in the range (0, 0.125) * 2**96
 134 |     | 
 135 |     |             // Finalization, we need to:
 136 |     |             // * multiply by the scale factor s = 5.549…
 137 |     |             // * add ln(2**96 / 10**18)
 138 |     |             // * add k * ln(2)
 139 |     |             // * multiply by 10**18 / 2**96 = 5**18 >> 78
 140 |     | 
 141 |     |             // mul s * 5e18 * 2**96, base is now 5**18 * 2**192
 142 | *r  |             r *= 1677202110996718588342820967067443963516166;
 143 |     |             // add ln(2) * k * 5e18 * 2**192
 144 | *r  |             r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;
 145 |     |             // add ln(2**96 / 10**18) * 5e18 * 2**192
 146 | *r  |             r += 600920179829731861736702779321621459595472258049074101567377883020018308;
 147 |     |             // base conversion: mul 2**18 / 2**192
 148 | *r  |             r >>= 174;
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /*//////////////////////////////////////////////////////////////
 153 |     |                     LOW LEVEL FIXED POINT OPERATIONS
 154 |     |     //////////////////////////////////////////////////////////////*/
 155 |     | 
 156 | *r  |     function mulDivDown(
 157 |     |         uint256 x,
 158 |     |         uint256 y,
 159 |     |         uint256 denominator
 160 |     |     ) internal pure returns (uint256 z) {
 161 |     |         assembly {
 162 |     |             // Store x * y in z for now.
 163 | *r  |             z := mul(x, y)
 164 |     | 
 165 |     |             // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
 166 | *r  |             if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {
 167 | *r  |                 revert(0, 0)
 168 |     |             }
 169 |     | 
 170 |     |             // Divide z by the denominator.
 171 | *r  |             z := div(z, denominator)
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 | *r  |     function mulDivUp(
 176 |     |         uint256 x,
 177 |     |         uint256 y,
 178 |     |         uint256 denominator
 179 |     |     ) internal pure returns (uint256 z) {
 180 |     |         assembly {
 181 |     |             // Store x * y in z for now.
 182 | *r  |             z := mul(x, y)
 183 |     | 
 184 |     |             // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
 185 | *r  |             if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {
 186 |     |                 revert(0, 0)
 187 |     |             }
 188 |     | 
 189 |     |             // First, divide z - 1 by the denominator and add 1.
 190 |     |             // We allow z - 1 to underflow if z is 0, because we multiply the
 191 |     |             // end result by 0 if z is zero, ensuring we return 0 if z is zero.
 192 | *r  |             z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))
 193 |     |         }
 194 |     |     }
 195 |     | 
 196 |     |     function rpow(
 197 |     |         uint256 x,
 198 |     |         uint256 n,
 199 |     |         uint256 scalar
 200 |     |     ) internal pure returns (uint256 z) {
 201 |     |         assembly {
 202 |     |             switch x
 203 |     |             case 0 {
 204 |     |                 switch n
 205 |     |                 case 0 {
 206 |     |                     // 0 ** 0 = 1
 207 |     |                     z := scalar
 208 |     |                 }
 209 |     |                 default {
 210 |     |                     // 0 ** n = 0
 211 |     |                     z := 0
 212 |     |                 }
 213 |     |             }
 214 |     |             default {
 215 |     |                 switch mod(n, 2)
 216 |     |                 case 0 {
 217 |     |                     // If n is even, store scalar in z for now.
 218 |     |                     z := scalar
 219 |     |                 }
 220 |     |                 default {
 221 |     |                     // If n is odd, store x in z for now.
 222 |     |                     z := x
 223 |     |                 }
 224 |     | 
 225 |     |                 // Shifting right by 1 is like dividing by 2.
 226 |     |                 let half := shr(1, scalar)
 227 |     | 
 228 |     |                 for {
 229 |     |                     // Shift n right by 1 before looping to halve it.
 230 |     |                     n := shr(1, n)
 231 |     |                 } n {
 232 |     |                     // Shift n right by 1 each iteration to halve it.
 233 |     |                     n := shr(1, n)
 234 |     |                 } {
 235 |     |                     // Revert immediately if x ** 2 would overflow.
 236 |     |                     // Equivalent to iszero(eq(div(xx, x), x)) here.
 237 |     |                     if shr(128, x) {
 238 |     |                         revert(0, 0)
 239 |     |                     }
 240 |     | 
 241 |     |                     // Store x squared.
 242 |     |                     let xx := mul(x, x)
 243 |     | 
 244 |     |                     // Round to the nearest number.
 245 |     |                     let xxRound := add(xx, half)
 246 |     | 
 247 |     |                     // Revert if xx + half overflowed.
 248 |     |                     if lt(xxRound, xx) {
 249 |     |                         revert(0, 0)
 250 |     |                     }
 251 |     | 
 252 |     |                     // Set x to scaled xxRound.
 253 |     |                     x := div(xxRound, scalar)
 254 |     | 
 255 |     |                     // If n is even:
 256 |     |                     if mod(n, 2) {
 257 |     |                         // Compute z * x.
 258 |     |                         let zx := mul(z, x)
 259 |     | 
 260 |     |                         // If z * x overflowed:
 261 |     |                         if iszero(eq(div(zx, x), z)) {
 262 |     |                             // Revert if x is non-zero.
 263 |     |                             if iszero(iszero(x)) {
 264 |     |                                 revert(0, 0)
 265 |     |                             }
 266 |     |                         }
 267 |     | 
 268 |     |                         // Round to the nearest number.
 269 |     |                         let zxRound := add(zx, half)
 270 |     | 
 271 |     |                         // Revert if zx + half overflowed.
 272 |     |                         if lt(zxRound, zx) {
 273 |     |                             revert(0, 0)
 274 |     |                         }
 275 |     | 
 276 |     |                         // Return properly scaled zxRound.
 277 |     |                         z := div(zxRound, scalar)
 278 |     |                     }
 279 |     |                 }
 280 |     |             }
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     /*//////////////////////////////////////////////////////////////
 285 |     |                         GENERAL NUMBER UTILITIES
 286 |     |     //////////////////////////////////////////////////////////////*/
 287 |     | 
 288 | *r  |     function sqrt(uint256 x) internal pure returns (uint256 z) {
 289 |     |         assembly {
 290 | *r  |             let y := x // We start y at x, which will help us make our initial estimate.
 291 |     | 
 292 | *r  |             z := 181 // The "correct" value is 1, but this saves a multiplication later.
 293 |     | 
 294 |     |             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
 295 |     |             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
 296 |     | 
 297 |     |             // We check y >= 2^(k + 8) but shift right by k bits
 298 |     |             // each branch to ensure that if x >= 256, then y >= 256.
 299 | *r  |             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
 300 |     |                 y := shr(128, y)
 301 |     |                 z := shl(64, z)
 302 |     |             }
 303 | *r  |             if iszero(lt(y, 0x1000000000000000000)) {
 304 |     |                 y := shr(64, y)
 305 |     |                 z := shl(32, z)
 306 |     |             }
 307 | *r  |             if iszero(lt(y, 0x10000000000)) {
 308 | *r  |                 y := shr(32, y)
 309 | *r  |                 z := shl(16, z)
 310 |     |             }
 311 | *r  |             if iszero(lt(y, 0x1000000)) {
 312 | *r  |                 y := shr(16, y)
 313 | *r  |                 z := shl(8, z)
 314 |     |             }
 315 |     | 
 316 |     |             // Goal was to get z*z*y within a small factor of x. More iterations could
 317 |     |             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
 318 |     |             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
 319 |     |             // That's not possible if x < 256 but we can just verify those cases exhaustively.
 320 |     | 
 321 |     |             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
 322 |     |             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
 323 |     |             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
 324 |     | 
 325 |     |             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
 326 |     |             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
 327 |     | 
 328 |     |             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
 329 |     |             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
 330 |     | 
 331 |     |             // There is no overflow risk here since y < 2^136 after the first branch above.
 332 | *r  |             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
 333 |     | 
 334 |     |             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
 335 | *r  |             z := shr(1, add(z, div(x, z)))
 336 | *r  |             z := shr(1, add(z, div(x, z)))
 337 | *r  |             z := shr(1, add(z, div(x, z)))
 338 | *r  |             z := shr(1, add(z, div(x, z)))
 339 | *r  |             z := shr(1, add(z, div(x, z)))
 340 | *r  |             z := shr(1, add(z, div(x, z)))
 341 | *r  |             z := shr(1, add(z, div(x, z)))
 342 |     | 
 343 |     |             // If x+1 is a perfect square, the Babylonian method cycles between
 344 |     |             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
 345 |     |             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
 346 |     |             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
 347 |     |             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
 348 | *r  |             z := sub(z, lt(div(x, z), z))
 349 |     |         }
 350 |     |     }
 351 |     | 
 352 | *r  |     function log2(uint256 x) internal pure returns (uint256 r) {
 353 | *r  |         require(x > 0, "UNDEFINED");
 354 |     | 
 355 |     |         assembly {
 356 | *r  |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
 357 | *r  |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
 358 | *r  |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
 359 | *r  |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
 360 | *r  |             r := or(r, shl(3, lt(0xff, shr(r, x))))
 361 | *r  |             r := or(r, shl(2, lt(0xf, shr(r, x))))
 362 | *r  |             r := or(r, shl(1, lt(0x3, shr(r, x))))
 363 | *r  |             r := or(r, lt(0x1, shr(r, x)))
 364 |     |         }
 365 |     |     }
 366 |     | 
 367 |     |     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
 368 |     |         assembly {
 369 |     |             // z will equal 0 if y is 0, unlike in Solidity where it will revert.
 370 |     |             z := mod(x, y)
 371 |     |         }
 372 |     |     }
 373 |     | 
 374 |     |     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
 375 |     |         assembly {
 376 |     |             // z will equal 0 if y is 0, unlike in Solidity where it will revert.
 377 |     |             z := div(x, y)
 378 |     |         }
 379 |     |     }
 380 |     | 
 381 |     |     /// @dev Will return 0 instead of reverting if y is zero.
 382 |     |     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 383 |     |         assembly {
 384 |     |             // Add 1 to x * y if x % y > 0.
 385 |     |             z := add(gt(mod(x, y), 0), div(x, y))
 386 |     |         }
 387 |     |     }
 388 |     | }
 389 |     | 

/root/code/hyper/lib/solmate/src/utils/SafeCastLib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @notice Safe unsigned integer casting library that reverts on overflow.
  5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)
  6 |     | library SafeCastLib {
  7 |     |     function safeCastTo248(uint256 x) internal pure returns (uint248 y) {
  8 |     |         require(x < 1 << 248);
  9 |     | 
 10 |     |         y = uint248(x);
 11 |     |     }
 12 |     | 
 13 |     |     function safeCastTo224(uint256 x) internal pure returns (uint224 y) {
 14 |     |         require(x < 1 << 224);
 15 |     | 
 16 |     |         y = uint224(x);
 17 |     |     }
 18 |     | 
 19 |     |     function safeCastTo192(uint256 x) internal pure returns (uint192 y) {
 20 |     |         require(x < 1 << 192);
 21 |     | 
 22 |     |         y = uint192(x);
 23 |     |     }
 24 |     | 
 25 |     |     function safeCastTo160(uint256 x) internal pure returns (uint160 y) {
 26 |     |         require(x < 1 << 160);
 27 |     | 
 28 |     |         y = uint160(x);
 29 |     |     }
 30 |     | 
 31 | *r  |     function safeCastTo128(uint256 x) internal pure returns (uint128 y) {
 32 | *r  |         require(x < 1 << 128);
 33 |     | 
 34 | *r  |         y = uint128(x);
 35 |     |     }
 36 |     | 
 37 |     |     function safeCastTo96(uint256 x) internal pure returns (uint96 y) {
 38 |     |         require(x < 1 << 96);
 39 |     | 
 40 |     |         y = uint96(x);
 41 |     |     }
 42 |     | 
 43 |     |     function safeCastTo64(uint256 x) internal pure returns (uint64 y) {
 44 |     |         require(x < 1 << 64);
 45 |     | 
 46 |     |         y = uint64(x);
 47 |     |     }
 48 |     | 
 49 | *r  |     function safeCastTo32(uint256 x) internal pure returns (uint32 y) {
 50 | *r  |         require(x < 1 << 32);
 51 |     | 
 52 |     |         y = uint32(x);
 53 |     |     }
 54 |     | 
 55 |     |     function safeCastTo8(uint256 x) internal pure returns (uint8 y) {
 56 |     |         require(x < 1 << 8);
 57 |     | 
 58 |     |         y = uint8(x);
 59 |     |     }
 60 |     | }
 61 |     | 

/root/code/hyper/lib/solmate/src/utils/SafeTransferLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ERC20} from "../tokens/ERC20.sol";
   5 |     | 
   6 |     | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
   7 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)
   8 |     | /// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.
   9 |     | library SafeTransferLib {
  10 |     |     /*//////////////////////////////////////////////////////////////
  11 |     |                              ETH OPERATIONS
  12 |     |     //////////////////////////////////////////////////////////////*/
  13 |     | 
  14 | *r  |     function safeTransferETH(address to, uint256 amount) internal {
  15 | *r  |         bool success;
  16 |     | 
  17 |     |         assembly {
  18 |     |             // Transfer the ETH and store if it succeeded or not.
  19 | *r  |             success := call(gas(), to, amount, 0, 0, 0, 0)
  20 |     |         }
  21 |     | 
  22 | *r  |         require(success, "ETH_TRANSFER_FAILED");
  23 |     |     }
  24 |     | 
  25 |     |     /*//////////////////////////////////////////////////////////////
  26 |     |                             ERC20 OPERATIONS
  27 |     |     //////////////////////////////////////////////////////////////*/
  28 |     | 
  29 | *r  |     function safeTransferFrom(
  30 |     |         ERC20 token,
  31 |     |         address from,
  32 |     |         address to,
  33 |     |         uint256 amount
  34 |     |     ) internal {
  35 | *r  |         bool success;
  36 |     | 
  37 |     |         assembly {
  38 |     |             // We'll write our calldata to this slot below, but restore it later.
  39 | *r  |             let memPointer := mload(0x40)
  40 |     | 
  41 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  42 | *r  |             mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)
  43 | *r  |             mstore(4, from) // Append the "from" argument.
  44 | *r  |             mstore(36, to) // Append the "to" argument.
  45 | *r  |             mstore(68, amount) // Append the "amount" argument.
  46 |     | 
  47 | *r  |             success := and(
  48 |     |                 // Set success to whether the call reverted, if not we check it either
  49 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
  50 | *r  |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
  51 |     |                 // We use 100 because that's the total length of our calldata (4 + 32 * 3)
  52 |     |                 // Counterintuitively, this call() must be positioned after the or() in the
  53 |     |                 // surrounding and() because and() evaluates its arguments from right to left.
  54 | *r  |                 call(gas(), token, 0, 0, 100, 0, 32)
  55 |     |             )
  56 |     | 
  57 | *r  |             mstore(0x60, 0) // Restore the zero slot to zero.
  58 | *r  |             mstore(0x40, memPointer) // Restore the memPointer.
  59 |     |         }
  60 |     | 
  61 | *r  |         require(success, "TRANSFER_FROM_FAILED");
  62 |     |     }
  63 |     | 
  64 | *r  |     function safeTransfer(
  65 |     |         ERC20 token,
  66 |     |         address to,
  67 |     |         uint256 amount
  68 |     |     ) internal {
  69 | *r  |         bool success;
  70 |     | 
  71 |     |         assembly {
  72 |     |             // We'll write our calldata to this slot below, but restore it later.
  73 | *r  |             let memPointer := mload(0x40)
  74 |     | 
  75 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  76 | *r  |             mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
  77 | *r  |             mstore(4, to) // Append the "to" argument.
  78 | *r  |             mstore(36, amount) // Append the "amount" argument.
  79 |     | 
  80 | *r  |             success := and(
  81 |     |                 // Set success to whether the call reverted, if not we check it either
  82 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
  83 | *r  |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
  84 |     |                 // We use 68 because that's the total length of our calldata (4 + 32 * 2)
  85 |     |                 // Counterintuitively, this call() must be positioned after the or() in the
  86 |     |                 // surrounding and() because and() evaluates its arguments from right to left.
  87 | *r  |                 call(gas(), token, 0, 0, 68, 0, 32)
  88 |     |             )
  89 |     | 
  90 | *r  |             mstore(0x60, 0) // Restore the zero slot to zero.
  91 | *r  |             mstore(0x40, memPointer) // Restore the memPointer.
  92 |     |         }
  93 |     | 
  94 | *r  |         require(success, "TRANSFER_FAILED");
  95 |     |     }
  96 |     | 
  97 |     |     function safeApprove(
  98 |     |         ERC20 token,
  99 |     |         address to,
 100 |     |         uint256 amount
 101 |     |     ) internal {
 102 |     |         bool success;
 103 |     | 
 104 |     |         assembly {
 105 |     |             // We'll write our calldata to this slot below, but restore it later.
 106 |     |             let memPointer := mload(0x40)
 107 |     | 
 108 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
 109 |     |             mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
 110 |     |             mstore(4, to) // Append the "to" argument.
 111 |     |             mstore(36, amount) // Append the "amount" argument.
 112 |     | 
 113 |     |             success := and(
 114 |     |                 // Set success to whether the call reverted, if not we check it either
 115 |     |                 // returned exactly 1 (can't just be non-zero data), or had no return data.
 116 |     |                 or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
 117 |     |                 // We use 68 because that's the total length of our calldata (4 + 32 * 2)
 118 |     |                 // Counterintuitively, this call() must be positioned after the or() in the
 119 |     |                 // surrounding and() because and() evaluates its arguments from right to left.
 120 |     |                 call(gas(), token, 0, 0, 68, 0, 32)
 121 |     |             )
 122 |     | 
 123 |     |             mstore(0x60, 0) // Restore the zero slot to zero.
 124 |     |             mstore(0x40, memPointer) // Restore the memPointer.
 125 |     |         }
 126 |     | 
 127 |     |         require(success, "APPROVE_FAILED");
 128 |     |     }
 129 |     | }
 130 |     | 

/root/code/hyper/lib/solstat/src/Gaussian.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import "../../solmate/src/utils/FixedPointMathLib.sol";
   5 |     | import "./Units.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Gaussian Math Library.
   9 |     |  * @author @alexangelj
  10 |     |  *
  11 |     |  * @notice Models the normal distribution using the special Complimentary Error Function.
  12 |     |  *
  13 |     |  * @dev Only implements a distribution with mean (µ) = 0 and variance (σ) = 1.
  14 |     |  * Uses Numerical Recipes as a framework and reference C implemenation.
  15 |     |  * Numerical Recipes cites the original textbook written by Abramowitz and Stegun,
  16 |     |  * "Handbook of Mathematical Functions", which should be read to understand these
  17 |     |  * special functions and the implications of their numerical approximations.
  18 |     |  *
  19 |     |  * @custom:source Handbook of Mathematical Functions https://personal.math.ubc.ca/~cbm/aands/abramowitz_and_stegun.pdf.
  20 |     |  * @custom:source Numerical Recipes https://e-maxx.ru/bookz/files/numerical_recipes.pdf.
  21 |     |  * @custom:source Inspired by https://github.com/errcw/gaussian.
  22 |     |  */
  23 |     | library Gaussian {
  24 |     |     using FixedPointMathLib for int256;
  25 |     |     using FixedPointMathLib for uint256;
  26 |     | 
  27 |     |     error Infinity();
  28 |     |     error NegativeInfinity();
  29 |     | 
  30 | *r  |     uint256 internal constant HALF_WAD = 0.5 ether;
  31 |     |     uint256 internal constant PI = 3_141592653589793238;
  32 |     |     int256 internal constant SQRT_2PI = 2_506628274631000502;
  33 |     |     int256 internal constant SIGN = -1;
  34 |     |     int256 internal constant SCALAR = 1e18;
  35 |     |     int256 internal constant HALF_SCALAR = 1e9;
  36 |     |     int256 internal constant SCALAR_SQRD = 1e36;
  37 |     |     int256 internal constant HALF = 5e17;
  38 | *r  |     int256 internal constant ONE = 1e18;
  39 | *r  |     int256 internal constant TWO = 2e18;
  40 |     |     int256 internal constant NEGATIVE_TWO = -2e18;
  41 |     |     int256 internal constant SQRT2 = 1_414213562373095048; // √2 with 18 decimals of precision.
  42 |     |     int256 internal constant ERFC_A = 1_265512230000000000;
  43 |     |     int256 internal constant ERFC_B = 1_000023680000000000;
  44 |     |     int256 internal constant ERFC_C = 374091960000000000; // 1e-1
  45 |     |     int256 internal constant ERFC_D = 96784180000000000; // 1e-2
  46 |     |     int256 internal constant ERFC_E = -186288060000000000; // 1e-1
  47 |     |     int256 internal constant ERFC_F = 278868070000000000; // 1e-1
  48 |     |     int256 internal constant ERFC_G = -1_135203980000000000;
  49 |     |     int256 internal constant ERFC_H = 1_488515870000000000;
  50 |     |     int256 internal constant ERFC_I = -822152230000000000; // 1e-1
  51 |     |     int256 internal constant ERFC_J = 170872770000000000; // 1e-1
  52 |     |     int256 internal constant IERFC_A = -707110000000000000; // 1e-1
  53 |     |     int256 internal constant IERFC_B = 2_307530000000000000;
  54 |     |     int256 internal constant IERFC_C = 270610000000000000; // 1e-1
  55 |     |     int256 internal constant IERFC_D = 992290000000000000; // 1e-1
  56 |     |     int256 internal constant IERFC_E = 44810000000000000; // 1e-2
  57 |     |     int256 internal constant IERFC_F = 1_128379167095512570;
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Approximation of the Complimentary Error Function.
  61 |     |      * Related to the Error Function: `erfc(x) = 1 - erf(x)`.
  62 |     |      * Both cumulative distribution and error functions are integrals
  63 |     |      * which cannot be expressed in elementary terms. They are called special functions.
  64 |     |      * The error and complimentary error functions have numerical approximations
  65 |     |      * which is what is used in this library to compute the cumulative distribution function.
  66 |     |      *
  67 |     |      * @dev This is a special function with its own identities.
  68 |     |      * Identity: `erfc(-x) = 2 - erfc(x)`.
  69 |     |      * Special Values:
  70 |     |      * erfc(-infinity)	=	2
  71 |     |      * erfc(0)      	=	1
  72 |     |      * erfc(infinity)	=	0
  73 |     |      *
  74 |     |      * @custom:epsilon Fractional error less than 1.2e-7.
  75 |     |      * @custom:source Numerical Recipes in C 2e p221.
  76 |     |      * @custom:source https://mathworld.wolfram.com/Erfc.html.
  77 |     |      */
  78 | *r  |     function erfc(int256 input) internal pure returns (int256 output) {
  79 | *r  |         uint256 z = abs(input);
  80 | *r  |         int256 t;
  81 |     |         int256 step;
  82 |     |         int256 k;
  83 |     |         assembly {
  84 | *r  |             let quo := sdiv(mul(z, ONE), TWO) // 1 / (1 + z / 2).
  85 | *r  |             let den := add(ONE, quo)
  86 | *r  |             t := sdiv(SCALAR_SQRD, den)
  87 |     | 
  88 | *r  |             function muli(pxn, pxd) -> res {
  89 | *r  |                 res := sdiv(mul(pxn, pxd), ONE)
  90 |     |             }
  91 |     | 
  92 |     |             {
  93 | *r  |                 step := add(
  94 | *r  |                     ERFC_F,
  95 | *r  |                     muli(
  96 | *r  |                         t,
  97 | *r  |                         add(
  98 |     |                             ERFC_G,
  99 | *r  |                             muli(
 100 | *r  |                                 t,
 101 | *r  |                                 add(
 102 | *r  |                                     ERFC_H,
 103 | *r  |                                     muli(t, add(ERFC_I, muli(t, ERFC_J)))
 104 |     |                                 )
 105 |     |                             )
 106 |     |                         )
 107 |     |                     )
 108 |     |                 )
 109 |     |             }
 110 |     |             {
 111 | *r  |                 step := muli(
 112 |     |                     t,
 113 | *r  |                     add(
 114 | *r  |                         ERFC_B,
 115 |     |                         muli(
 116 |     |                             t,
 117 | *r  |                             add(
 118 | *r  |                                 ERFC_C,
 119 |     |                                 muli(
 120 |     |                                     t,
 121 | *r  |                                     add(
 122 | *r  |                                         ERFC_D,
 123 | *r  |                                         muli(t, add(ERFC_E, muli(t, step)))
 124 |     |                                     )
 125 |     |                                 )
 126 |     |                             )
 127 |     |                         )
 128 |     |                     )
 129 |     |                 )
 130 |     |             }
 131 |     | 
 132 | *r  |             k := add(sub(mul(SIGN, muli(z, z)), ERFC_A), step)
 133 |     |         }
 134 |     | 
 135 | *r  |         int256 expWad = FixedPointMathLib.expWad(k);
 136 | *r  |         int256 r;
 137 | *r  |         assembly {
 138 | *r  |             r := sdiv(mul(t, expWad), ONE)
 139 | *r  |             switch iszero(slt(input, 0))
 140 | *r  |             case 0 {
 141 | *r  |                 output := sub(TWO, r)
 142 |     |             }
 143 | *r  |             case 1 {
 144 | *r  |                 output := r
 145 |     |             }
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @notice Approximation of the Inverse Complimentary Error Function - erfc^(-1).
 151 |     |      *
 152 |     |      * @dev Equal to `ierfc(erfc(x)) = erfc(ierfc(x))` for 0 < x < 2.
 153 |     |      * Related to the Inverse Error Function: `ierfc(1 - x) = ierf(x)`.
 154 |     |      * This is a special function with its own identities.
 155 |     |      * Domain:      0 < x < 2
 156 |     |      * Special values:
 157 |     |      * ierfc(0)	=	infinity
 158 |     |      * ierfc(1)	=	0
 159 |     |      * ierfc(2)	=	-infinity
 160 |     |      *
 161 |     |      * @custom:source Numerical Recipes 3e p265.
 162 |     |      * @custom:source https://mathworld.wolfram.com/InverseErfc.html.
 163 |     |      */
 164 | *r  |     function ierfc(int256 x) internal pure returns (int256 z) {
 165 |     |         assembly {
 166 |     |             // x >= 2, iszero(x < 2 ? 1 : 0) ? 1 : 0.
 167 | *r  |             if iszero(slt(x, TWO)) {
 168 |     |                 z := mul(add(not(100), 1), SCALAR)
 169 |     |             }
 170 |     | 
 171 |     |             // x <= 0.
 172 | *r  |             if iszero(sgt(x, 0)) {
 173 |     |                 z := mul(100, SCALAR)
 174 |     |             }
 175 |     |         }
 176 |     | 
 177 | *r  |         if (z != 0) return z;
 178 |     | 
 179 | *r  |         int256 xx; // (x < ONE) ? x : TWO - x.
 180 |     |         assembly {
 181 | *r  |             switch iszero(slt(x, ONE))
 182 | *r  |             case 0 {
 183 |     |                 xx := x
 184 |     |             }
 185 | *r  |             case 1 {
 186 | *r  |                 xx := sub(TWO, x)
 187 |     |             }
 188 |     |         }
 189 |     | 
 190 | *r  |         int256 logInput = diviWad(xx, TWO);
 191 | *r  |         if (logInput == 0) revert Infinity();
 192 | *r  |         int256 ln = FixedPointMathLib.lnWad(logInput);
 193 | *r  |         uint256 t = uint256(muliWad(NEGATIVE_TWO, ln)).sqrt();
 194 |     |         assembly {
 195 | *r  |             t := mul(t, HALF_SCALAR)
 196 |     |         }
 197 |     | 
 198 | *r  |         int256 r;
 199 |     |         assembly {
 200 |     |             function muli(pxn, pxd) -> res {
 201 |     |                 res := sdiv(mul(pxn, pxd), ONE)
 202 |     |             }
 203 |     | 
 204 | *r  |             r := muli(
 205 |     |                 IERFC_A,
 206 | *r  |                 sub(
 207 | *r  |                     sdiv(
 208 | *r  |                         mul(add(IERFC_B, muli(t, IERFC_C)), ONE),
 209 | *r  |                         add(ONE, muli(t, add(IERFC_D, muli(t, IERFC_E))))
 210 |     |                     ),
 211 | *r  |                     t
 212 |     |                 )
 213 |     |             )
 214 |     |         }
 215 |     | 
 216 | *r  |         uint256 itr;
 217 | *r  |         while (itr < 2) {
 218 | *r  |             int256 err = erfc(r);
 219 |     |             assembly {
 220 | *r  |                 err := sub(err, xx)
 221 |     |             }
 222 |     | 
 223 | *r  |             int256 input;
 224 |     |             assembly {
 225 | *r  |                 input := add(not(sdiv(mul(r, r), ONE)), 1) // -(r * r).
 226 |     |             }
 227 |     | 
 228 | *r  |             int256 expWad = input.expWad();
 229 |     | 
 230 | *r  |             assembly {
 231 |     |                 function muli(pxn, pxd) -> res {
 232 |     |                     res := sdiv(mul(pxn, pxd), ONE)
 233 |     |                 }
 234 |     | 
 235 | *r  |                 r := add(
 236 | *r  |                     r,
 237 | *r  |                     sdiv(
 238 | *r  |                         mul(err, ONE),
 239 | *r  |                         sub(muli(IERFC_F, expWad), muli(r, err))
 240 |     |                     )
 241 |     |                 )
 242 |     | 
 243 | *r  |                 itr := add(itr, 1)
 244 |     |             }
 245 |     |         }
 246 |     | 
 247 |     |         assembly {
 248 | *r  |             switch iszero(slt(x, ONE)) // x < ONE ? r : -r.
 249 | *r  |             case 0 {
 250 |     |                 z := r
 251 |     |             }
 252 | *r  |             case 1 {
 253 | *r  |                 z := add(not(r), 1)
 254 |     |             }
 255 |     |         }
 256 |     |     }
 257 |     | 
 258 |     |     /**
 259 |     |      * @notice Approximation of the Cumulative Distribution Function.
 260 |     |      *
 261 |     |      * @dev Equal to `D(x) = 0.5[ 1 + erf((x - µ) / σ√2)]`.
 262 |     |      * Only computes cdf of a distribution with µ = 0 and σ = 1.
 263 |     |      *
 264 |     |      * @custom:error Maximum error of 1.2e-7.
 265 |     |      * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.
 266 |     |      */
 267 | *r  |     function cdf(int256 x) internal pure returns (int256 z) {
 268 |     |         int256 negated;
 269 |     |         assembly {
 270 | *r  |             let res := sdiv(mul(x, ONE), SQRT2)
 271 | *r  |             negated := add(not(res), 1)
 272 |     |         }
 273 |     | 
 274 | *r  |         int256 _erfc = erfc(negated);
 275 |     |         assembly {
 276 | *r  |             z := sdiv(mul(ONE, _erfc), TWO)
 277 |     |         }
 278 |     |     }
 279 |     | 
 280 |     |     /**
 281 |     |      * @notice Approximation of the Probability Density Function.
 282 |     |      *
 283 |     |      * @dev Equal to `Z(x) = (1 / σ√2π)e^( (-(x - µ)^2) / 2σ^2 )`.
 284 |     |      * Only computes pdf of a distribution with µ = 0 and σ = 1.
 285 |     |      *
 286 |     |      * @custom:error Maximum error of 1.2e-7.
 287 |     |      * @custom:source https://mathworld.wolfram.com/ProbabilityDensityFunction.html.
 288 |     |      */
 289 |     |     function pdf(int256 x) internal pure returns (int256 z) {
 290 |     |         int256 e;
 291 |     |         assembly {
 292 |     |             e := sdiv(mul(add(not(x), 1), x), TWO) // (-x * x) / 2.
 293 |     |         }
 294 |     |         e = FixedPointMathLib.expWad(e);
 295 |     | 
 296 |     |         assembly {
 297 |     |             z := sdiv(mul(e, ONE), SQRT_2PI)
 298 |     |         }
 299 |     |     }
 300 |     | 
 301 |     |     /**
 302 |     |      * @notice Approximation of the Percent Point Function.
 303 |     |      *
 304 |     |      * @dev Equal to `D(x)^(-1) = µ - σ√2(ierfc(2x))`.
 305 |     |      * Only computes ppf of a distribution with µ = 0 and σ = 1.
 306 |     |      *
 307 |     |      * @custom:error Maximum error of 1.2e-7.
 308 |     |      * @custom:source https://mathworld.wolfram.com/NormalDistribution.html.
 309 |     |      */
 310 | *r  |     function ppf(int256 x) internal pure returns (int256 z) {
 311 | *r  |         if (x == int256(HALF_WAD)) return int256(0); // returns 3.75e-8, but we know it's zero.
 312 | *r  |         if (x >= ONE) revert Infinity();
 313 | *r  |         if (x == 0) revert NegativeInfinity();
 314 |     |         assembly {
 315 | *r  |             x := mul(x, 2)
 316 |     |         }
 317 |     | 
 318 | *r  |         int256 _ierfc = ierfc(x);
 319 |     | 
 320 |     |         assembly {
 321 | *r  |             let res := sdiv(mul(SQRT2, _ierfc), ONE)
 322 | *r  |             z := add(not(res), 1) // -res.
 323 |     |         }
 324 |     |     }
 325 |     | }
 326 |     | 

/root/code/hyper/lib/solstat/src/Invariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | import "./Gaussian.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title Invariant of Primitive RMM.
   8 |     |  * @author @alexangelj
   9 |     |  * @notice Invariant is `k` with the trading function `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.
  10 |     |  *
  11 |     |  * @dev Terms which can potentially be ambiguous are given discrete names.
  12 |     |  * This makes it easier to search for terms and update terms.
  13 |     |  * Variables can sometimes not be trusted to be or act like their names.
  14 |     |  * This naming scheme avoids this problem using a glossary to define them.
  15 |     |  *
  16 |     |  * // -------------------- Glossary --------------------- //
  17 |     |  *
  18 |     |  * `R_x` - Amount of asset token reserves per single unit of liquidity.
  19 |     |  * `R_y` - Amount of quote token reserves per single unit of liquidity.
  20 |     |  * `stk` - Strike price of the pool. The terminal price of each asset token.
  21 |     |  * `vol` - Implied volatility of the pool. Higher vol = higher price impact on swaps.
  22 |     |  * `tau` - Time until the pool expires. Amount of seconds until the pool's curve becomes flat around `stk`.
  23 |     |  * `inv` - Invariant of the pool. Difference between theoretical $ value and actual $ value per liquidity.
  24 |     |  *
  25 |     |  * `WAD` - Signed or unsigned fixed point number with up to 18 decimals and up to 256 total bits wide.
  26 |     |  * `YEAR`- Equal to the amount of seconds in a year. Used in `invariant` function.
  27 |     |  *
  28 |     |  * // -------------------- Units ------------------------ //
  29 |     |  *
  30 |     |  * `R_x` - Units are unsigned WAD. Represents value of tokens, decimals matter.
  31 |     |  * `R_y` - Units are unsigned WAD. Represents value of tokens, decimals matter.
  32 |     |  * `stk` - Units are unsigned WAD. Represents value of tokens, decimals matter.
  33 |     |  * `vol` - Units are unsigned WAD. Represents a percentage in which 100% = WAD.
  34 |     |  * `tau` - Units are YEAR. Represents a time unit which `1.0` is equal to YEAR.
  35 |     |  * `inv` - Units are signed WAD. Initial value of zero and decreases over time.
  36 |     |  *
  37 |     |  * // -------------------- Denoted By ----------------- //
  38 |     |  *
  39 |     |  * `R_x` - Denoted by `x`.
  40 |     |  * `R_y` - Denoted by `y`.
  41 |     |  * `stk` - Denoted by `K`.
  42 |     |  * `vol` - Denoted by `σ`.
  43 |     |  * `tau` - Denoted by `τ`.
  44 |     |  * `inv` - Denoted by `k`.
  45 |     |  *
  46 |     |  * // -------------------- Error Bounds ----------------- //
  47 |     |  *
  48 |     |  * `inv` - Up to 1e-9.
  49 |     |  *
  50 |     |  * // ------------------------ ~ ------------------------ //
  51 |     |  */
  52 |     | library Invariant {
  53 |     |     using Gaussian for int256; // Uses the `cdf` and `pdf` functions.
  54 |     |     using FixedPointMathLib for uint256; // Uses the `sqrt` function.
  55 |     | 
  56 | *r  |     uint256 internal constant WAD = 1 ether;
  57 |     |     uint256 internal constant DOUBLE_WAD = 2 ether;
  58 |     |     int256 internal constant ONE = 1 ether;
  59 |     |     int256 internal constant YEAR = 31556952;
  60 |     |     int256 internal constant HALF_SCALAR = 1e9;
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Reverts when an input value is out of bounds of its acceptable range.
  64 |     |      */
  65 |     |     error OOB();
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Uses reserves `R_x` to compute reserves `R_y`.
  69 |     |      *
  70 |     |      * @dev Computes `y` in `y = KΦ(Φ⁻¹(1-x) - σ√τ) + k`.
  71 |     |      * Primary function use to compute the invariant.
  72 |     |      * Simplifies to `K(1 -x) + k` when time to expiry is zero.
  73 |     |      * Reverts if `R_x` is greater than one. Units are a fixed point number with 18 decimals.
  74 |     |      *
  75 |     |      * We handle some special cases, try this:
  76 |     |      * `normalcdlower(normalicdlower(1) - 0.1)` in https://keisan.casio.com/calculator
  77 |     |      * Gaussian.sol reverts for `ppf(1)` and `ppf(0)`, so we handle those cases.
  78 |     |      *
  79 |     |      * @param R_x Quantity of token reserve `x` within the bounds of [0, 1].
  80 |     |      * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.
  81 |     |      * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.
  82 |     |      * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.
  83 |     |      * @param inv Current invariant given the actual `R_x`. Zero if computing invariant itself.
  84 |     |      * @return R_y Quantity of token reserve `y` within the bounds of [0, stk].
  85 |     |      *
  86 |     |      * @custom:error Technically, none. This is the source of truth for the trading function.
  87 |     |      * @custom:source https://primitive.xyz/whitepaper
  88 |     |      */
  89 | *r  |     function getY(
  90 |     |         uint256 R_x,
  91 |     |         uint256 stk,
  92 |     |         uint256 vol,
  93 |     |         uint256 tau,
  94 |     |         int256 inv
  95 | *r  |     ) internal pure returns (uint256 R_y) {
  96 | *r  |         if (R_x > WAD) revert OOB(); // Negative input for `ppf` is invalid.
  97 | *r  |         if (R_x == WAD) return uint256(int256(stk) + inv); // For `ppf(0)` case, because 1 - R_x == 0, and `y = K * 1 + k` simplifies to `y = K + k`
  98 | *r  |         if (R_x == 0) return uint256(inv); // For `ppf(1)` case, because 1 - 0 == 1, and `y = K * 0 + k` simplifies to `y = k`.
  99 | *r  |         if (tau != 0) {
 100 |     |             // Short circuits because tau != 0 is more likely.
 101 | *r  |             uint256 sec;
 102 |     |             assembly {
 103 | *r  |                 sec := sdiv(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.
 104 |     |             }
 105 |     | 
 106 | *r  |             uint256 sdr = sec.sqrt(); // √τ.
 107 |     |             assembly {
 108 | *r  |                 sdr := mul(sdr, HALF_SCALAR) // Unit math: sdr * HALF_SCALAR = SCALAR.
 109 | *r  |                 sdr := sdiv(mul(vol, sdr), ONE) // σ√τ.
 110 |     |             }
 111 |     | 
 112 |     |             int256 phi;
 113 |     |             assembly {
 114 | *r  |                 phi := sub(ONE, R_x)
 115 |     |             }
 116 | *r  |             phi = phi.ppf(); // Φ⁻¹(1-x).
 117 |     | 
 118 |     |             int256 cdf;
 119 |     |             assembly {
 120 | *r  |                 cdf := sub(phi, sdr) // Φ⁻¹(1-x) - σ√τ.
 121 |     |             }
 122 | *r  |             cdf = cdf.cdf(); // Φ(Φ⁻¹(1-x) - σ√τ).
 123 |     | 
 124 |     |             assembly {
 125 | *r  |                 R_y := add(sdiv(mul(stk, cdf), ONE), inv)
 126 |     |             }
 127 |     |         } else {
 128 |     |             assembly {
 129 |     |                 R_y := add(sdiv(mul(stk, sub(ONE, R_x)), ONE), inv)
 130 |     |             }
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Uses reserves `R_y` to compute reserves `R_x`.
 136 |     |      *
 137 |     |      * @dev Computes `x` in `x = 1 - Φ(Φ⁻¹( (y + k) / K ) + σ√τ)`.
 138 |     |      * Not used in invariant function. Used for computing swap outputs.
 139 |     |      * Simplifies to `1 - ( (y + k) / K )` when time to expiry is zero.
 140 |     |      * Reverts if `R_y` is greater than one. Units are WAD.
 141 |     |      *
 142 |     |      * Dangerous! There are important bounds to using this function.
 143 |     |      *
 144 |     |      * @param R_y Quantity of token reserve `y` within the bounds of [0, stk].
 145 |     |      * @param stk Strike price of the pool. Terminal price of asset `x` in the pool denominated in asset `y`.
 146 |     |      * @param vol Implied volatility of the pool. Higher implied volatility = higher price impact on swaps.
 147 |     |      * @param tau Time until the pool expires. Once expired, no swaps can happen. Scaled to units of `Invariant.YEAR`.
 148 |     |      * @param inv Current invariant given the actual reserves `R_y`.
 149 |     |      * @return R_x Quantity of token reserve `x` within the bounds of [0, 1].
 150 |     |      *
 151 |     |      * @custom:error Up to 1e-6. This an **approximated** "inverse" of the `getY` function.
 152 |     |      * @custom:source https://primitive.xyz/whitepaper
 153 |     |      */
 154 |     |     function getX(
 155 |     |         uint256 R_y,
 156 |     |         uint256 stk,
 157 |     |         uint256 vol,
 158 |     |         uint256 tau,
 159 |     |         int256 inv
 160 |     |     ) internal pure returns (uint256 R_x) {
 161 |     |         // Short circuits because tau != 0 is more likely.
 162 |     |         if (tau != 0) {
 163 |     |             uint256 sec;
 164 |     |             assembly {
 165 |     |                 sec := div(mul(tau, ONE), YEAR) // Unit math: YEAR * SCALAR / YEAR = SCALAR.
 166 |     |             }
 167 |     | 
 168 |     |             uint256 sdr = sec.sqrt(); // √τ.
 169 |     |             assembly {
 170 |     |                 sdr := mul(sdr, HALF_SCALAR) // Unit math: HALF_SCALAR * HALF_SCALAR = SCALAR.
 171 |     |                 sdr := div(mul(vol, sdr), ONE) // σ√τ.
 172 |     |             }
 173 |     | 
 174 |     |             int256 phi;
 175 |     |             assembly {
 176 |     |                 phi := sdiv(mul(add(R_y, inv), ONE), stk) // (y + k) / K.
 177 |     |             }
 178 |     | 
 179 |     |             if (phi < 0) revert OOB(); // Negative input for `ppf` is invalid.
 180 |     |             if (phi > ONE) revert OOB();
 181 |     |             if (phi == ONE) return 0; // `x = 1 - Φ(Φ⁻¹( 1 ) + σ√τ)` simplifies to  `x = 0`.
 182 |     |             if (phi == 0) return WAD; // `x = 1 - Φ(Φ⁻¹( 0 ) + σ√τ)` simplifies to `x = 1`.
 183 |     | 
 184 |     |             phi = phi.ppf(); // Φ⁻¹( (y + k) / K ).
 185 |     | 
 186 |     |             int256 cdf;
 187 |     |             assembly {
 188 |     |                 cdf := add(phi, sdr) // Φ⁻¹( (y + k) / K ) + σ√τ.
 189 |     |             }
 190 |     |             cdf = cdf.cdf(); // Φ(Φ⁻¹( (y + k) / K ) + σ√τ).
 191 |     | 
 192 |     |             assembly {
 193 |     |                 R_x := sub(ONE, cdf)
 194 |     |             }
 195 |     |         } else {
 196 |     |             assembly {
 197 |     |                 R_x := sub(ONE, sdiv(mul(add(R_y, inv), ONE), stk))
 198 |     |             }
 199 |     |         }
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @notice Computes the invariant of the RMM trading function.
 204 |     |      *
 205 |     |      * @dev Computes `k` in `k = y - KΦ(Φ⁻¹(1-x) - σ√τ)`.
 206 |     |      * Used to validate swaps, the most critical function.
 207 |     |      *
 208 |     |      * @custom:source https://rmm.eth.xyz
 209 |     |      */
 210 |     |     function invariant(
 211 |     |         uint256 R_y,
 212 |     |         uint256 R_x,
 213 |     |         uint256 stk,
 214 |     |         uint256 vol,
 215 |     |         uint256 tau
 216 |     |     ) internal pure returns (int256 inv) {
 217 |     |         uint256 y = getY(R_x, stk, vol, tau, inv); // `inv` is 0 because we are solving `inv`, aka `k`.
 218 |     |         assembly {
 219 |     |             inv := sub(R_y, y)
 220 |     |         }
 221 |     |     }
 222 |     | }
 223 |     | 

/root/code/hyper/lib/solstat/src/Units.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | error Min();
  5 | *r  | 
  6 | *r  | function abs(int256 input) pure returns (uint256 output) {
  7 | *r  |     if (input == type(int256).min) revert Min();
  8 | *r  |     if (input < 0) {
  9 |     |         assembly {
 10 | *r  |             output := add(not(input), 1)
 11 |     |         }
 12 |     |     } else {
 13 |     |         assembly {
 14 |     |             output := input
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 
 19 | *r  | /// @dev From solmate@v7, changes last `div` to `sdiv`.
 20 |     | function muli(
 21 |     |     int256 x,
 22 |     |     int256 y,
 23 |     |     int256 denominator
 24 |     | ) pure returns (int256 z) {
 25 |     |     assembly {
 26 |     |         // Store x * y in z for now.
 27 | *r  |         z := mul(x, y)
 28 |     | 
 29 |     |         // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
 30 | *r  |         if iszero(
 31 | *r  |             and(iszero(iszero(denominator)), or(iszero(x), eq(sdiv(z, x), y)))
 32 |     |         ) {
 33 |     |             revert(0, 0)
 34 |     |         }
 35 |     | 
 36 |     |         // Divide z by the denominator.
 37 | *r  |         z := sdiv(z, denominator)
 38 |     |     }
 39 |     | }
 40 | *r  | 
 41 | *r  | function muliWad(int256 x, int256 y) pure returns (int256 z) {
 42 | *r  |     z = muli(x, y, 1 ether);
 43 |     | }
 44 | *r  | 
 45 | *r  | function diviWad(int256 x, int256 y) pure returns (int256 z) {
 46 | *r  |     z = muli(x, 1 ether, y);
 47 |     | }
 48 |     | 

/root/code/hyper/test/E2E/InvariantAllocateUnallocate.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./setup/InvariantTargetContract.sol";
   5 |     | 
   6 |     | contract InvariantAllocateUnallocate is InvariantTargetContract {
   7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
   8 |     | 
   9 |     |     function allocate(uint deltaLiquidity, uint index) public {
  10 |     |         deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);
  11 |     | 
  12 |     |         // Allocate to a random pool.
  13 |     |         // VERY IMPORTANT
  14 |     |         setPoolId(ctx.getRandomPoolId(index));
  15 |     | 
  16 |     |         _assertAllocate(deltaLiquidity);
  17 |     |     }
  18 |     | 
  19 |     |     // avoid stack too deep
  20 |     |     uint expectedDeltaAsset;
  21 |     |     uint expectedDeltaQuote;
  22 |     |     bool transferAssetIn;
  23 |     |     bool transferQuoteIn;
  24 |     |     int assetCredit;
  25 |     |     int quoteCredit;
  26 |     |     uint deltaAsset;
  27 |     |     uint deltaQuote;
  28 |     |     uint userAssetBalance;
  29 |     |     uint userQuoteBalance;
  30 |     |     uint physicalAssetPayment;
  31 |     |     uint physicalQuotePayment;
  32 |     | 
  33 |     |     HyperState prev;
  34 |     |     HyperState post;
  35 |     | 
  36 |     |     function _assertAllocate(uint deltaLiquidity) internal {
  37 |     |         // TODO: cleanup reset of these
  38 |     |         transferAssetIn = true;
  39 |     |         transferQuoteIn = true;
  40 |     | 
  41 |     |         // Preconditions
  42 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
  43 |     |         assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
  44 |     |         assertTrue(pool.lastPrice != 0, "Pool not created with a price");
  45 |     | 
  46 |     |         // Amounts of tokens that will be allocated to pool.
  47 |     |         (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(
  48 |     |             __poolId__,
  49 |     |             int128(uint128(deltaLiquidity))
  50 |     |         );
  51 |     | 
  52 |     |         // If net balance > 0, there are tokens in the contract which are not in a pool or balance.
  53 |     |         // They will be credited to the msg.sender of the next call.
  54 |     |         assetCredit = __hyper__.getNetBalance(address(__asset__));
  55 |     |         quoteCredit = __hyper__.getNetBalance(address(__quote__));
  56 |     | 
  57 |     |         // Net balances should always be positive outside of execution.
  58 |     |         assertTrue(assetCredit >= 0, "negative-net-asset-tokens");
  59 |     |         assertTrue(quoteCredit >= 0, "negative-net-quote-tokens");
  60 |     | 
  61 |     |         // Internal balance of tokens spendable by user.
  62 |     |         userAssetBalance = getBalance(address(__hyper__), address(this), address(__asset__));
  63 |     |         userQuoteBalance = getBalance(address(__hyper__), address(this), address(__quote__));
  64 |     | 
  65 |     |         // If there is a net balance, user can use it to pay their cost.
  66 |     |         // Total payment the user must make.
  67 |     |         physicalAssetPayment = uint(assetCredit) > expectedDeltaAsset ? 0 : expectedDeltaAsset - uint(assetCredit);
  68 |     |         physicalQuotePayment = uint(quoteCredit) > expectedDeltaQuote ? 0 : expectedDeltaQuote - uint(quoteCredit);
  69 |     | 
  70 |     |         physicalAssetPayment = uint(userAssetBalance) > physicalAssetPayment
  71 |     |             ? 0
  72 |     |             : physicalAssetPayment - uint(userAssetBalance);
  73 |     |         physicalQuotePayment = uint(userQuoteBalance) > physicalQuotePayment
  74 |     |             ? 0
  75 |     |             : physicalQuotePayment - uint(userQuoteBalance);
  76 |     | 
  77 |     |         // If user can pay for the allocate using their internal balance of tokens, don't need to transfer tokens in.
  78 |     |         // Won't need to transfer in tokens if user payment is zero.
  79 |     |         if (physicalAssetPayment == 0) transferAssetIn = false;
  80 |     |         if (physicalQuotePayment == 0) transferQuoteIn = false;
  81 |     | 
  82 |     |         // If the user has to pay externally, give them tokens.
  83 |     |         if (transferAssetIn) __asset__.mint(address(this), physicalAssetPayment);
  84 |     |         if (transferQuoteIn) __quote__.mint(address(this), physicalQuotePayment);
  85 |     | 
  86 |     |         // Execution
  87 |     |         prev = getState();
  88 |     |         (deltaAsset, deltaQuote) = __hyper__.allocate(__poolId__, deltaLiquidity);
  89 |     |         post = getState();
  90 |     | 
  91 |     |         // Postconditions
  92 |     | 
  93 |     |         assertEq(deltaAsset, expectedDeltaAsset, "pool-delta-asset");
  94 |     |         assertEq(deltaQuote, expectedDeltaQuote, "pool-delta-quote");
  95 |     |         assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, "pool-total-liquidity");
  96 |     |         assertTrue(post.totalPoolLiquidity > prev.totalPoolLiquidity, "pool-liquidity-increases");
  97 |     |         assertEq(
  98 |     |             post.callerPositionLiquidity,
  99 |     |             prev.callerPositionLiquidity + deltaLiquidity,
 100 |     |             "position-liquidity-increases"
 101 |     |         );
 102 |     | 
 103 |     |         assertEq(post.reserveAsset, prev.reserveAsset + physicalAssetPayment + uint(assetCredit), "reserve-asset");
 104 |     |         assertEq(post.reserveQuote, prev.reserveQuote + physicalQuotePayment + uint(quoteCredit), "reserve-quote");
 105 |     |         assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + physicalAssetPayment, "physical-asset");
 106 |     |         assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + physicalQuotePayment, "physical-quote");
 107 |     | 
 108 |     |         uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;
 109 |     |         uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;
 110 |     |         assertTrue(feeDelta0 == feeDelta1, "asset-growth");
 111 |     | 
 112 |     |         uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;
 113 |     |         uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;
 114 |     |         assertTrue(feeDelta2 == feeDelta3, "quote-growth");
 115 |     | 
 116 |     |         emit FinishedCall("Allocate");
 117 |     | 
 118 |     |         checkVirtualInvariant();
 119 |     |     }
 120 |     | 
 121 |     |     event FinishedCall(string);
 122 |     | 
 123 |     |     function unallocate(uint deltaLiquidity, uint index) external {
 124 |     |         deltaLiquidity = bound(deltaLiquidity, 1, 2 ** 126);
 125 |     | 
 126 |     |         // Unallocate from a random pool.
 127 |     |         // VERY IMPORTANT
 128 |     |         setPoolId(ctx.getRandomPoolId(index));
 129 |     | 
 130 |     |         _assertUnallocate(deltaLiquidity);
 131 |     |     }
 132 |     | 
 133 |     |     function _assertUnallocate(uint deltaLiquidity) internal {
 134 |     |         // TODO: Add use max flag support.
 135 |     | 
 136 |     |         // Get some liquidity.
 137 |     |         HyperPosition memory pos = getPosition(address(__hyper__), address(this), __poolId__);
 138 |     |         require(pos.freeLiquidity >= deltaLiquidity, "Not enough liquidity");
 139 |     | 
 140 |     |         if (pos.freeLiquidity >= deltaLiquidity) {
 141 |     |             // Preconditions
 142 |     |             HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 143 |     |             assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
 144 |     |             assertTrue(pool.lastPrice != 0, "Pool not created with a price");
 145 |     | 
 146 |     |             // Unallocate
 147 |     |             uint timestamp = block.timestamp + 4; // todo: fix default jit policy
 148 |     |             vm.warp(timestamp);
 149 |     |             __hyper__.setTimestamp(uint128(timestamp));
 150 |     | 
 151 |     |             (expectedDeltaAsset, expectedDeltaQuote) = __hyper__.getLiquidityDeltas(
 152 |     |                 __poolId__,
 153 |     |                 -int128(uint128(deltaLiquidity))
 154 |     |             );
 155 |     |             prev = getState();
 156 |     |             (uint unallocatedAsset, uint unallocatedQuote) = __hyper__.unallocate(__poolId__, deltaLiquidity);
 157 |     |             HyperState memory end = getState();
 158 |     | 
 159 |     |             assertEq(unallocatedAsset, expectedDeltaAsset, "asset-delta");
 160 |     |             assertEq(unallocatedQuote, expectedDeltaQuote, "quote-delta");
 161 |     |             assertEq(end.reserveAsset, prev.reserveAsset - unallocatedAsset, "reserve-asset");
 162 |     |             assertEq(end.reserveQuote, prev.reserveQuote - unallocatedQuote, "reserve-quote");
 163 |     |             assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity - deltaLiquidity, "total-liquidity");
 164 |     |             assertTrue(prev.totalPositionLiquidity >= deltaLiquidity, "total-pos-liq-underflow");
 165 |     |             assertTrue(prev.callerPositionLiquidity >= deltaLiquidity, "caller-pos-liq-underflow");
 166 |     |             assertEq(
 167 |     |                 end.totalPositionLiquidity,
 168 |     |                 prev.totalPositionLiquidity - deltaLiquidity,
 169 |     |                 "total-position-liquidity"
 170 |     |             );
 171 |     |             assertEq(
 172 |     |                 end.callerPositionLiquidity,
 173 |     |                 prev.callerPositionLiquidity - deltaLiquidity,
 174 |     |                 "caller-position-liquidity"
 175 |     |             );
 176 |     |         }
 177 |     |         emit FinishedCall("Unallocate");
 178 |     | 
 179 |     |         checkVirtualInvariant();
 180 |     |     }
 181 |     | 
 182 |     |     function checkVirtualInvariant() internal {
 183 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 184 |     |         // TODO: Breaks when we call this function on a pool with zero liquidity...
 185 |     |         (uint dAsset, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);
 186 |     |         emit log("dAsset", dAsset);
 187 |     |         emit log("dQuote", dQuote);
 188 |     | 
 189 |     |         uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));
 190 |     |         uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));
 191 |     | 
 192 |     |         emit log("bAsset", bAsset);
 193 |     |         emit log("bQuote", bQuote);
 194 |     | 
 195 |     |         int diffAsset = int(bAsset) - int(dAsset);
 196 |     |         int diffQuote = int(bQuote) - int(dQuote);
 197 |     |         emit log("diffAsset", diffAsset);
 198 |     |         emit log("diffQuote", diffQuote);
 199 |     | 
 200 |     |         assertTrue(bAsset >= dAsset, "invariant-virtual-reserves-asset");
 201 |     |         assertTrue(bQuote >= dQuote, "invariant-virtual-reserves-quote");
 202 |     | 
 203 |     |         emit FinishedCall("Check Virtual Invariant");
 204 |     |     }
 205 |     | 
 206 |     |     event log(string, uint);
 207 |     |     event log(string, int);
 208 |     | }
 209 |     | 

/root/code/hyper/test/E2E/InvariantCreatePool.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/HyperLib.sol" as HyperTypes;
   5 |     | import "contracts/Enigma.sol" as Enigma;
   6 |     | import "./setup/InvariantTargetContract.sol";
   7 |     | 
   8 |     | contract InvariantCreatePool is InvariantTargetContract {
   9 |     |     Forwarder forwarder;
  10 |     | 
  11 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {
  12 |     |         forwarder = new Forwarder();
  13 |     |     }
  14 |     | 
  15 |     |     function create_pool(
  16 |     |         uint index,
  17 |     |         uint128 price,
  18 |     |         uint128 strike,
  19 |     |         uint24 sigma,
  20 |     |         uint32 maturity,
  21 |     |         uint32 gamma,
  22 |     |         uint32 priorityGamma
  23 |     |     ) external {
  24 |     |         vm.assume(strike != 0);
  25 |     |         vm.assume(sigma != 0);
  26 |     | 
  27 |     |         maturity = uint32(block.timestamp + bound(maturity, 1, 365 days));
  28 |     |         price = uint128(bound(price, 1, 1e36));
  29 |     |         gamma = uint32(bound(sigma, 1e4 - HyperTypes.MAX_FEE, 1e4 - HyperTypes.MIN_FEE));
  30 |     |         priorityGamma = uint32(bound(sigma, gamma, 1e4 - HyperTypes.MIN_FEE));
  31 |     | 
  32 |     |         // Random user
  33 |     |         address caller = ctx.getRandomUser(index);
  34 |     |         address[] memory tokens = new address[](3);
  35 |     |         tokens[0] = address(ctx.__asset__());
  36 |     |         tokens[1] = address(ctx.__quote__());
  37 |     |         //tokens[0] = address(ctx.__weth__());
  38 |     | 
  39 |     |         address[] memory shuffled = shuffle(index, tokens);
  40 |     |         address token0 = shuffled[0];
  41 |     |         address token1 = shuffled[1];
  42 |     |         assertTrue(token0 != token1, "same-token");
  43 |     | 
  44 |     |         CreateArgs memory args = CreateArgs(
  45 |     |             caller,
  46 |     |             token0,
  47 |     |             token1,
  48 |     |             price,
  49 |     |             strike,
  50 |     |             sigma,
  51 |     |             maturity,
  52 |     |             gamma,
  53 |     |             priorityGamma
  54 |     |         );
  55 |     |         _assertCreatePool(args);
  56 |     |     }
  57 |     | 
  58 |     |     function shuffle(uint random, address[] memory array) internal view returns (address[] memory output) {
  59 |     |         for (uint256 i = 0; i < array.length; i++) {
  60 |     |             uint256 n = i + (random % (array.length - i));
  61 |     |             address temp = array[n];
  62 |     |             array[n] = array[i];
  63 |     |             array[i] = temp;
  64 |     |         }
  65 |     | 
  66 |     |         output = array;
  67 |     |     }
  68 |     | 
  69 |     |     struct CreateArgs {
  70 |     |         address caller;
  71 |     |         address token0;
  72 |     |         address token1;
  73 |     |         uint128 price;
  74 |     |         uint128 strike;
  75 |     |         uint24 sigma;
  76 |     |         uint32 maturity;
  77 |     |         uint32 gamma;
  78 |     |         uint32 priorityGamma;
  79 |     |     }
  80 |     | 
  81 |     |     bytes[] instructions;
  82 |     | 
  83 |     |     function _assertCreatePool(CreateArgs memory args) internal {
  84 |     |         bool isMutable = true;
  85 |     |         uint24 pairId = __hyper__.getPairId(args.token0, args.token1);
  86 |     |         {
  87 |     |             // HyperPair not created? Push a create pair call to the stack.
  88 |     |             if (pairId == 0) instructions.push(Enigma.encodeCreatePair(args.token0, args.token1));
  89 |     | 
  90 |     |             // Push create pool to stack
  91 |     |             instructions.push(
  92 |     |                 Enigma.encodeCreatePool(
  93 |     |                     pairId,
  94 |     |                     address(this),
  95 |     |                     1, // priorityFee
  96 |     |                     1, // fee
  97 |     |                     1, // vol
  98 |     |                     1, // dur
  99 |     |                     5,
 100 |     |                     int24(20_000),
 101 |     |                     args.price
 102 |     |                 )
 103 |     |             ); // temp
 104 |     |         }
 105 |     |         bytes memory payload = Enigma.encodeJumpInstruction(instructions);
 106 |     |         vm.prank(args.caller);
 107 |     |         console.logBytes(payload);
 108 |     |         (bool success, bytes memory reason) = address(__hyper__).call(payload);
 109 |     |         assembly {
 110 |     |             log0(add(32, reason), mload(reason))
 111 |     |         }
 112 |     | 
 113 |     |         //bool success = forwarder.forward(address(__hyper__), payload); // TODO: Fallback function does not bubble up custom errors.
 114 |     |         assertTrue(success, "hyper-call-failed");
 115 |     | 
 116 |     |         // Refetch the poolId. Current poolId could be "magic" zero variable.
 117 |     |         pairId = __hyper__.getPairId(args.token0, args.token1);
 118 |     |         assertTrue(pairId != 0, "pair-not-created");
 119 |     | 
 120 |     |         // todo: make sure we create the last pool...
 121 |     |         uint64 poolId = Enigma.encodePoolId(pairId, isMutable, uint32(__hyper__.getPoolNonce()));
 122 |     | 
 123 |     |         // Add the created pool to the list of pools.
 124 |     |         assertTrue(getPool(address(__hyper__), poolId).lastPrice != 0, "pool-price-zero");
 125 |     |         ctx.addPoolId(poolId);
 126 |     | 
 127 |     |         // Reset instructions so we don't use some old payload data...
 128 |     |         delete instructions;
 129 |     |     }
 130 |     | }
 131 |     | 
 132 |     | interface DoJump {
 133 |     |     function doJumpProcess(bytes calldata data) external payable;
 134 |     | }
 135 |     | 
 136 |     | contract Forwarder {
 137 |     |     function forward(address hyper, bytes calldata data) external payable returns (bool) {
 138 |     |         try DoJump(hyper).doJumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {
 139 |     |             assembly {
 140 |     |                 revert(add(32, reason), mload(reason))
 141 |     |             }
 142 |     |         }
 143 |     |         return true;
 144 |     |     }
 145 |     | }
 146 |     | 

/root/code/hyper/test/E2E/InvariantDeposit.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantDeposit is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     function deposit(uint amount, uint index) external {
 10 |     |         amount = bound(amount, 1, 1e36);
 11 |     | 
 12 |     |         address target = ctx.getRandomUser(index);
 13 |     | 
 14 |     |         vm.deal(target, amount);
 15 |     | 
 16 |     |         address weth = __hyper__.WETH();
 17 |     | 
 18 |     |         uint preBal = getBalance(address(__hyper__), target, weth);
 19 |     |         uint preRes = getReserve(address(__hyper__), weth);
 20 |     |         vm.prank(target);
 21 |     |         __hyper__.deposit{value: amount}();
 22 |     |         uint postRes = getReserve(address(__hyper__), weth);
 23 |     |         uint postBal = getBalance(address(__hyper__), target, weth);
 24 |     | 
 25 |     |         assertEq(postRes, preRes + amount, "weth-reserve");
 26 |     |         assertEq(postBal, preBal + amount, "weth-balance");
 27 |     |         assertEq(address(__hyper__).balance, 0, "eth-balance");
 28 |     |         assertEq(getPhysicalBalance(address(__hyper__), weth), postRes, "weth-physical");
 29 |     |     }
 30 |     | }
 31 |     | 

/root/code/hyper/test/E2E/InvariantFundDraw.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantFundDraw is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     function fund_asset(uint amount, uint index) public {
 10 |     |         amount = bound(amount, 1, 1e36);
 11 |     | 
 12 |     |         address target = ctx.getRandomUser(index);
 13 |     | 
 14 |     |         // If net balance > 0, there are tokens in the contract which are not in a pool or balance.
 15 |     |         // They will be credited to the msg.sender of the next call.
 16 |     |         int netAssetBalance = __hyper__.getNetBalance(address(__asset__));
 17 |     |         int netQuoteBalance = __hyper__.getNetBalance(address(__quote__));
 18 |     |         assertTrue(netAssetBalance >= 0, "negative-net-asset-tokens");
 19 |     |         assertTrue(netQuoteBalance >= 0, "negative-net-quote-tokens");
 20 |     | 
 21 |     |         vm.prank(target);
 22 |     |         __asset__.approve(address(__hyper__), amount);
 23 |     |         deal(address(__asset__), target, amount);
 24 |     | 
 25 |     |         uint preRes = getReserve(address(__hyper__), address(__asset__));
 26 |     |         uint preBal = getBalance(address(__hyper__), target, address(__asset__));
 27 |     |         vm.prank(target);
 28 |     |         __hyper__.fund(address(__asset__), amount);
 29 |     |         uint postRes = getReserve(address(__hyper__), address(__asset__));
 30 |     |         uint postBal = getBalance(address(__hyper__), target, address(__asset__));
 31 |     | 
 32 |     |         assertEq(postBal, preBal + amount + uint(netAssetBalance), "fund-delta-asset-balance");
 33 |     |         assertEq(postRes, preRes + amount + uint(netQuoteBalance), "fund-delta-asset-reserve");
 34 |     |     }
 35 |     | 
 36 |     |     function fund_quote(uint amount, uint index) public {
 37 |     |         amount = bound(amount, 1, 1e36);
 38 |     | 
 39 |     |         address target = ctx.getRandomUser(index);
 40 |     | 
 41 |     |         vm.prank(target);
 42 |     |         __quote__.approve(address(__hyper__), amount);
 43 |     |         deal(address(__quote__), target, amount);
 44 |     | 
 45 |     |         uint preRes = getReserve(address(__hyper__), address(__quote__));
 46 |     |         uint preBal = getBalance(address(__hyper__), target, address(__quote__));
 47 |     |         vm.prank(target);
 48 |     |         __hyper__.fund(address(__quote__), amount);
 49 |     |         uint postRes = getReserve(address(__hyper__), address(__quote__));
 50 |     |         uint postBal = getBalance(address(__hyper__), target, address(__quote__));
 51 |     | 
 52 |     |         assertEq(postBal, preBal + amount, "fund-delta-quote-balance");
 53 |     |         assertEq(postRes, preRes + amount, "fund-delta-quote-reserve");
 54 |     |     }
 55 |     | }
 56 |     | 

/root/code/hyper/test/E2E/InvariantSendTokens.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantSendTokens is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     event SentTokens(address indexed token, uint amount);
 10 |     | 
 11 |     |     function sendAssetTokens(uint amount) external {
 12 |     |         amount = bound(amount, 1, 2 ** 127);
 13 |     |         transfer(__asset__, amount);
 14 |     |     }
 15 |     | 
 16 |     |     function sendQuoteTokens(uint amount) external {
 17 |     |         amount = bound(amount, 1, 2 ** 127);
 18 |     |         transfer(__quote__, amount);
 19 |     |     }
 20 |     | 
 21 |     |     function transfer(TestERC20 token, uint amount) internal {
 22 |     |         token.mint(address(__hyper__), amount);
 23 |     |         emit SentTokens(address(token), amount);
 24 |     |     }
 25 |     | }
 26 |     | 

/root/code/hyper/test/E2E/InvariantWarper.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/InvariantTargetContract.sol";
  5 |     | 
  6 |     | contract InvariantWarper is InvariantTargetContract {
  7 |     |     constructor(address hyper_, address asset_, address quote_) InvariantTargetContract(hyper_, asset_, quote_) {}
  8 |     | 
  9 |     |     function warper(uint amount) external {
 10 |     |         ctx.customWarp(block.timestamp + bound(amount, 1, 365 days));
 11 |     |     }
 12 |     | 
 13 |     |     function warpAfterMaturity(uint amount) external {
 14 |     |         amount = bound(amount, 1 days, 700 days);
 15 |     |         uint tau = HyperTau(address(__hyper__)).computeCurrentTau(__poolId__);
 16 |     |         ctx.customWarp(block.timestamp + tau + amount);
 17 |     |     }
 18 |     | }
 19 |     | 
 20 |     | interface HyperTau {
 21 |     |     function computeCurrentTau(uint64 poolId) external view returns (uint);
 22 |     | }
 23 |     | 

/root/code/hyper/test/E2E/TestE2EInvariant.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./setup/TestE2ESetup.sol";
   5 |     | import "./setup/TestInvariantSetup.sol";
   6 |     | 
   7 |     | import {InvariantAllocateUnallocate} from "./InvariantAllocateUnallocate.sol";
   8 |     | import {InvariantFundDraw} from "./InvariantFundDraw.sol";
   9 |     | import {InvariantDeposit} from "./InvariantDeposit.sol";
  10 |     | import {InvariantSendTokens} from "./InvariantSendTokens.sol";
  11 |     | import {InvariantWarper} from "./InvariantWarper.sol";
  12 |     | import {InvariantCreatePool} from "./InvariantCreatePool.sol";
  13 |     | 
  14 |     | bytes32 constant SLOT_LOCKED = bytes32(uint(10));
  15 |     | 
  16 |     | /**
  17 |     |  * @dev Most important test suite, verifies the critical invariants of Hyper.
  18 |     |  *
  19 |     |  * Invariant 1. balanceOf >= getReserve for all tokens.
  20 |     |  * Invariant 2. AccountSystem.settled == true.
  21 |     |  * Invariant 3. AccountSystem.prepared == false.
  22 |     |  * Invariant 4. (balanceOf(asset), balanceOf(quote)) >= hyper.getVirtualReserves, for all pools.
  23 |     |  * Invariant 5. ∑ hyper.positions(owner, poolId).freeLiquidity == hyper.pools(poolId).liquidity, for all pools.
  24 |     |  */
  25 |     | contract TestE2EInvariant is TestInvariantSetup, TestE2ESetup {
  26 |     |     InvariantAllocateUnallocate internal _allocateUnallocate;
  27 |     |     InvariantFundDraw internal _fundDraw;
  28 |     |     InvariantDeposit internal _deposit;
  29 |     |     InvariantSendTokens internal _sendTokens;
  30 |     |     InvariantWarper internal _warper;
  31 |     |     InvariantCreatePool internal _createPool;
  32 |     | 
  33 |     |     uint64[] public __poolIds__;
  34 |     | 
  35 |     |     function setUp() public override {
  36 |     |         super.setUp();
  37 |     | 
  38 |     |         (address hyper, address asset, address quote) = (address(__hyper__), address(__asset__), address(__quote__));
  39 |     | 
  40 |     |         _allocateUnallocate = new InvariantAllocateUnallocate(hyper, asset, quote);
  41 |     |         _fundDraw = new InvariantFundDraw(hyper, asset, quote);
  42 |     |         _deposit = new InvariantDeposit(hyper, asset, quote);
  43 |     |         _sendTokens = new InvariantSendTokens(hyper, asset, quote);
  44 |     |         _warper = new InvariantWarper(hyper, asset, quote);
  45 |     |         _createPool = new InvariantCreatePool(hyper, asset, quote);
  46 |     | 
  47 |     |         addTargetContract(address(_allocateUnallocate));
  48 |     |         addTargetContract(address(_fundDraw));
  49 |     |         addTargetContract(address(_deposit));
  50 |     |         addTargetContract(address(_sendTokens));
  51 |     |         addTargetContract(address(_warper));
  52 |     |         addTargetContract(address(_createPool));
  53 |     | 
  54 |     |         __users__.push(address(_allocateUnallocate));
  55 |     |         __users__.push(address(_fundDraw));
  56 |     |         __users__.push(address(_deposit));
  57 |     |         __users__.push(address(_sendTokens));
  58 |     |         __users__.push(address(_warper));
  59 |     |         __users__.push(address(_createPool));
  60 |     | 
  61 |     |         addPoolId(__poolId__);
  62 |     |     }
  63 |     | 
  64 |     |     function invariant_assert_pools_created() public {
  65 |     |         assertTrue(__poolIds__.length > 0);
  66 |     |     }
  67 |     | 
  68 |     |     function invariant_asset_balance_gte_reserves() public {
  69 |     |         (uint reserve, uint physical, ) = getBalances(address(__asset__));
  70 |     |         assertTrue(physical >= reserve, "invariant-asset-physical-balance");
  71 |     |     }
  72 |     | 
  73 |     |     function invariant_quote_balance_gte_reserves() public {
  74 |     |         (uint reserve, uint physical, ) = getBalances(address(__quote__));
  75 |     |         assertTrue(physical >= reserve, "invariant-quote-physical-balance");
  76 |     |     }
  77 |     | 
  78 |     |     function invariant_account_settled() public {
  79 |     |         (, bool settled) = __hyper__.__account__();
  80 |     |         assertTrue(settled, "invariant-settled");
  81 |     |     }
  82 |     | 
  83 |     |     function invariant_account_prepared() public {
  84 |     |         (bool prepared, ) = __hyper__.__account__();
  85 |     |         assertTrue(!prepared, "invariant-prepared");
  86 |     |     }
  87 |     | 
  88 |     |     function invariant_virtual_pool_asset_reserves() public {
  89 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
  90 |     | 
  91 |     |         if (pool.liquidity > 0) {
  92 |     |             (uint dAsset, ) = __hyper__.getVirtualReserves(__poolId__);
  93 |     |             uint bAsset = getPhysicalBalance(address(__hyper__), address(__asset__));
  94 |     |             assertTrue(bAsset >= dAsset, "invariant-virtual-reserves-asset");
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     function invariant_virtual_pool_quote_reserves() public {
  99 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 100 |     | 
 101 |     |         if (pool.liquidity > 0) {
 102 |     |             (, uint dQuote) = __hyper__.getVirtualReserves(__poolId__);
 103 |     |             uint bQuote = getPhysicalBalance(address(__hyper__), address(__quote__));
 104 |     |             assertTrue(bQuote >= dQuote, "invariant-virtual-reserves-quote");
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     function invariant_liquidity_sum() public {
 109 |     |         HyperPool memory pool = getPool(address(__hyper__), __poolId__);
 110 |     | 
 111 |     |         uint sum;
 112 |     |         for (uint i; i != __users__.length; ++i) {
 113 |     |             HyperPosition memory pos = getPosition(address(__hyper__), __users__[i], __poolId__);
 114 |     |             sum += pos.freeLiquidity;
 115 |     |         }
 116 |     | 
 117 |     |         assertTrue(sum == pool.liquidity, "invariant-liquidity-sum");
 118 |     |     }
 119 |     | 
 120 |     |     function invariant_reentrancy() public {
 121 |     |         bytes32 locked = vm.load(address(__hyper__), SLOT_LOCKED);
 122 |     |         assertEq(uint(locked), 1, "invariant-locked");
 123 |     | 
 124 |     |         uint balance = address(__hyper__).balance;
 125 |     |         assertEq(balance, 0, "invariant-ether");
 126 |     |     }
 127 |     | 
 128 |     |     function getBalances(address token) internal view returns (uint reserve, uint physical, uint balances) {
 129 |     |         reserve = getReserve(address(__hyper__), token);
 130 |     |         physical = getPhysicalBalance(address(__hyper__), token);
 131 |     |         balances = getBalanceSum(address(__hyper__), token, __users__);
 132 |     |     }
 133 |     | 
 134 |     |     function addPoolId(uint64 poolId) public {
 135 |     |         assertTrue(poolId != 0, "zero poolId");
 136 |     |         __poolIds__.push(poolId);
 137 |     |     }
 138 |     | 
 139 |     |     function getRandomUser(uint id) public returns (address) {
 140 |     |         assertTrue(__users__.length > 0);
 141 |     |         uint index = id % __users__.length;
 142 |     |         address user = __users__[index];
 143 |     |         return user;
 144 |     |     }
 145 |     | 
 146 |     |     function getRandomPoolId(uint id) public returns (uint64) {
 147 |     |         assertTrue(__poolIds__.length > 0);
 148 |     |         uint index = id % __poolIds__.length;
 149 |     |         uint64 poolId = __poolIds__[index];
 150 |     |         return poolId;
 151 |     |     }
 152 |     | }
 153 |     | 

/root/code/hyper/test/E2E/TestInvariantBasic.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "./setup/TestInvariantSetup.sol";
  6 |     | 
  7 |     | /** @dev Example invariant testing contract, for reference only. https://github.com/foundry-rs/foundry/pull/1572#discussion_r869737535 */
  8 |     | contract InvariantBreaker is Test {
  9 |     |     bool public flag0 = true;
 10 |     |     bool public flag1 = true;
 11 |     | 
 12 |     |     function set0(int val) public returns (bool) {
 13 |     |         if (val % 100 == 0) flag0 = false;
 14 |     |         return flag0;
 15 |     |     }
 16 |     | 
 17 |     |     function set1(int val) public returns (bool) {
 18 |     |         if (val % 10 == 0 && !flag0) flag1 = false;
 19 |     |         return flag1;
 20 |     |     }
 21 |     | }
 22 |     | 
 23 |     | /** @dev Example invariant test. Always fails! */
 24 |     | contract TestInvariantBasic is TestInvariantSetup, Test {
 25 |     |     InvariantBreaker inv;
 26 |     | 
 27 |     |     function setUp() public {
 28 |     |         inv = new InvariantBreaker();
 29 |     |         addTargetContract(address(inv));
 30 |     |     }
 31 |     | 
 32 |     |     function invariant_neverFalse() public view {
 33 |     |         // note: uncomment to test invariant testing
 34 |     |         // require(inv.flag1());
 35 |     |     }
 36 |     | }
 37 |     | 

/root/code/hyper/test/E2E/setup/InvariantTargetContract.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "test/helpers/HelperHyperView.sol";
  6 |     | import {HyperPool, HyperPosition, HyperTimeOverride, TestERC20} from "test/helpers/HyperTestOverrides.sol";
  7 |     | 
  8 |     | interface Context {
  9 |     |     function users() external view returns (address[] memory);
 10 |     | 
 11 |     |     function getRandomPoolId(uint id) external view returns (uint64);
 12 |     | 
 13 |     |     function setPoolId(uint64 poolId) external;
 14 |     | 
 15 |     |     function addPoolId(uint64 poolId) external;
 16 |     | 
 17 |     |     function customWarp(uint time) external;
 18 |     | 
 19 |     |     function getRandomUser(uint id) external view returns (address);
 20 |     | 
 21 |     |     function __weth__() external view returns (TestERC20);
 22 |     | 
 23 |     |     function __asset__() external view returns (TestERC20);
 24 |     | 
 25 |     |     function __quote__() external view returns (TestERC20);
 26 |     | }
 27 |     | 
 28 |     | /** @dev Target contract must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */
 29 |     | contract InvariantTargetContract is HelperHyperView, Test {
 30 |     |     Context ctx;
 31 |     | 
 32 |     |     uint64 public __poolId__ = 0x0000010000000001;
 33 |     |     HyperTimeOverride public __hyper__; // Actual contract
 34 |     |     TestERC20 public __quote__;
 35 |     |     TestERC20 public __asset__;
 36 |     | 
 37 |     |     constructor(address hyper_, address asset_, address quote_) {
 38 |     |         ctx = Context(msg.sender);
 39 |     |         __hyper__ = HyperTimeOverride(payable(hyper_));
 40 |     |         __asset__ = TestERC20(asset_);
 41 |     |         __quote__ = TestERC20(quote_);
 42 |     | 
 43 |     |         __asset__.approve(hyper_, type(uint).max);
 44 |     |         __quote__.approve(hyper_, type(uint).max);
 45 |     |     }
 46 |     | 
 47 |     |     /** @dev Uses the initialized context for the getState function. */
 48 |     |     function getState() internal view returns (HyperState memory) {
 49 |     |         return getState(address(__hyper__), __poolId__, address(this), ctx.users());
 50 |     |     }
 51 |     | 
 52 |     |     function setPoolId(uint64 poolId) internal {
 53 |     |         ctx.setPoolId(poolId); // TODO: duplicating for now...
 54 |     | 
 55 |     |         HyperPair memory pair = getPair(address(__hyper__), Processor.decodePairIdFromPoolId(poolId));
 56 |     |         __asset__ = TestERC20(pair.tokenAsset);
 57 |     |         __quote__ = TestERC20(pair.tokenQuote);
 58 |     |     }
 59 |     | }
 60 |     | 

/root/code/hyper/test/E2E/setup/TestE2ESetup.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "solmate/tokens/WETH.sol";
   5 |     | import "contracts/HyperLib.sol";
   6 |     | import "contracts/libraries/Price.sol";
   7 |     | 
   8 |     | import "forge-std/Test.sol";
   9 |     | import {TestERC20, HyperTimeOverride, FixedPointMathLib} from "test/helpers/HyperTestOverrides.sol";
  10 |     | 
  11 |     | import "test/helpers/HelperHyperActions.sol";
  12 |     | import "test/helpers/HelperHyperInvariants.sol";
  13 |     | import "test/helpers/HelperHyperProfiles.sol";
  14 |     | import "test/helpers/HelperHyperView.sol";
  15 |     | 
  16 |     | uint constant STARTING_BALANCE = 0;
  17 |     | 
  18 |     | contract Helpers is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView {}
  19 |     | 
  20 |     | /** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */
  21 |     | contract TestE2ESetup is Helpers, Test {
  22 |     |     using FixedPointMathLib for uint256;
  23 |     |     using FixedPointMathLib for int256;
  24 |     | 
  25 |     |     // ===== Global Variables ===== //
  26 |     |     uint64 public __poolId__ = 0x0000010000000001;
  27 |     |     address[] public __users__;
  28 |     | 
  29 |     |     WETH public __weth__;
  30 |     |     TestERC20 public __quote__;
  31 |     |     TestERC20 public __asset__;
  32 |     |     HyperTimeOverride public __hyper__; // Actual contract
  33 |     | 
  34 |     |     // ===== Set up ===== //
  35 |     | 
  36 |     |     function setUp() public virtual {
  37 |     |         initContracts();
  38 |     |         initUsers();
  39 |     |         initScenarios();
  40 |     |         initPrerequisites();
  41 |     |         afterSetUp();
  42 |     |     }
  43 |     | 
  44 |     |     /** @dev Requires tokens to be spent and spenders to be approved. */
  45 |     |     function initPrerequisites() internal {
  46 |     |         approveTokens();
  47 |     |     }
  48 |     | 
  49 |     |     /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */
  50 |     |     receive() external payable {
  51 |     |         receiveOverride();
  52 |     |     }
  53 |     | 
  54 |     |     /** @dev Uses the initialized context for the getState function. */
  55 |     |     function getState() internal view virtual returns (HyperState memory) {
  56 |     |         return getState(address(__hyper__), __poolId__, address(this), __users__);
  57 |     |     }
  58 |     | 
  59 |     |     /** @dev Hook to run after test setup. */
  60 |     |     function afterSetUp() public virtual {}
  61 |     | 
  62 |     |     /** @dev Replace receive ether logic. */
  63 |     |     function receiveOverride() public virtual {}
  64 |     | 
  65 |     |     // ===== Contracts Context ===== //
  66 |     |     function initContracts() internal {
  67 |     |         __weth__ = new WETH();
  68 |     |         __hyper__ = new HyperTimeOverride(address(__weth__));
  69 |     |         __quote__ = new TestERC20("USD Coin", "USDC", 6);
  70 |     |         __asset__ = new TestERC20("18 Decimals", "18DEC", 18);
  71 |     | 
  72 |     |         setLabels();
  73 |     |     }
  74 |     | 
  75 |     |     function setLabels() internal {
  76 |     |         vm.label(address(this), "Self");
  77 |     |         vm.label(address(__weth__), "Weth");
  78 |     |         vm.label(address(__hyper__), "HyperTimeOverride");
  79 |     |         vm.label(address(__quote__), "QuoteToken");
  80 |     |         vm.label(address(__asset__), "AssetToken");
  81 |     |     }
  82 |     | 
  83 |     |     // ===== Users ===== //
  84 |     | 
  85 |     |     function users() public view virtual returns (address[] memory) {
  86 |     |         return __users__;
  87 |     |     }
  88 |     | 
  89 |     |     function initUsers() internal {
  90 |     |         address self = address(this);
  91 |     |         address alicent = address(0x0001);
  92 |     |         address boba = address(0x0002);
  93 |     | 
  94 |     |         addUser(self, "Self");
  95 |     |         addUser(alicent, "Alicent");
  96 |     |         addUser(boba, "Boba");
  97 |     |     }
  98 |     | 
  99 |     |     function addUser(address user, string memory label) public {
 100 |     |         vm.label(user, label);
 101 |     |         __users__.push(user);
 102 |     |     }
 103 |     | 
 104 |     |     // ===== Test Scenarios ===== //
 105 |     | 
 106 |     |     function initScenarios() internal {
 107 |     |         __hyper__.setTimestamp(uint128(block.timestamp)); // Important
 108 |     |         // Create default pool
 109 |     |         bytes memory data = createPool(
 110 |     |             address(__asset__),
 111 |     |             address(__quote__),
 112 |     |             address(0),
 113 |     |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
 114 |     |             uint16(1e4 - DEFAULT_GAMMA),
 115 |     |             uint16(DEFAULT_SIGMA),
 116 |     |             uint16(DEFAULT_DURATION_DAYS),
 117 |     |             DEFAULT_JIT,
 118 |     |             DEFAULT_TICK,
 119 |     |             DEFAULT_PRICE
 120 |     |         );
 121 |     | 
 122 |     |         (bool success, ) = address(__hyper__).call(data);
 123 |     |         assertTrue(success, "create pool call failed");
 124 |     |     }
 125 |     | 
 126 |     |     // ===== Utils ===== //
 127 |     | 
 128 |     |     /** @dev Does not include weth. */
 129 |     |     function approveTokens() internal {
 130 |     |         for (uint z; z != __users__.length; ++z) {
 131 |     |             vm.prank(__users__[z]); // Sets caller
 132 |     |             __asset__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 133 |     |             __quote__.approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /** @dev Does not include weth. */
 138 |     |     function fundUsers(uint deltaAsset, uint deltaQuote) internal {
 139 |     |         for (uint i; i != __users__.length; ++i) {
 140 |     |             deal(address(__asset__), __users__[i], deltaAsset); // TODO: Use regular ERC20, since we can deal.
 141 |     |             deal(address(__quote__), __users__[i], deltaQuote); // TODO: Use regular ERC20, since we can deal.
 142 |     |         }
 143 |     |     }
 144 |     | 
 145 |     |     function customWarp(uint time) public virtual {
 146 |     |         vm.warp(time);
 147 |     |         __hyper__.setTimestamp(uint128(time));
 148 |     |     }
 149 |     | 
 150 |     |     event SetNewPoolId(uint64);
 151 |     | 
 152 |     |     /** @dev Sets the pool id and assets in TestE2ESetup state. Affects all tests! */
 153 |     |     function setPoolId(uint64 poolId) public {
 154 |     |         __poolId__ = poolId;
 155 |     | 
 156 |     |         HyperPair memory pair = getPair(address(__hyper__), Enigma.decodePairIdFromPoolId(poolId));
 157 |     |         __asset__ = TestERC20(pair.tokenAsset);
 158 |     |         __quote__ = TestERC20(pair.tokenQuote);
 159 |     | 
 160 |     |         emit SetNewPoolId(poolId);
 161 |     |     }
 162 |     | }
 163 |     | 

/root/code/hyper/test/E2E/setup/TestInvariantSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /** @dev Invariant tests must inherit. Read: https://github.com/dapphub/dapptools/blob/master/src/dapp/README.md#invariant-testing */
  5 |     | contract TestInvariantSetup {
  6 |     |     address[] private _targetContracts;
  7 |     | 
  8 |     |     function addTargetContract(address target) internal {
  9 |     |         _targetContracts.push(target);
 10 |     |     }
 11 |     | 
 12 |     |     function targetContracts() public view returns (address[] memory) {
 13 |     |         require(_targetContracts.length != uint(0), "no-target-contracts");
 14 |     |         return _targetContracts;
 15 |     |     }
 16 |     | }
 17 |     | 

/root/code/hyper/test/analysis/TestAnalysisSwap.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../contracts/Hyper.sol";
   6 |     | import "../helpers/HelperHyperActions.sol";
   7 |     | 
   8 |     | interface Quoter {
   9 |     |     function quoteExactInputSingle(address, address, uint24, uint256, uint160) external returns (uint256);
  10 |     | }
  11 |     | 
  12 |     | interface Factory {
  13 |     |     function getPool(address, address, uint24) external view returns (address);
  14 |     | }
  15 |     | 
  16 |     | struct Slot0 {
  17 |     |     // the current price
  18 |     |     uint160 sqrtPriceX96;
  19 |     |     // the current tick
  20 |     |     int24 tick;
  21 |     |     // the most-recently updated index of the observations array
  22 |     |     uint16 observationIndex;
  23 |     |     // the current maximum number of observations that are being stored
  24 |     |     uint16 observationCardinality;
  25 |     |     // the next maximum number of observations to store, triggered in observations.write
  26 |     |     uint16 observationCardinalityNext;
  27 |     |     // the current protocol fee as a percentage of the swap fee taken on withdrawal
  28 |     |     // represented as an integer denominator (1/x)%
  29 |     |     uint8 feeProtocol;
  30 |     |     // whether the pool is locked
  31 |     |     bool unlocked;
  32 |     | }
  33 |     | 
  34 |     | interface Uni {
  35 |     |     function slot0() external view returns (Slot0 memory);
  36 |     | }
  37 |     | 
  38 |     | interface ERC20 {
  39 |     |     function approve(address, uint) external;
  40 |     | 
  41 |     |     function decimals() external view returns (uint8);
  42 |     | 
  43 |     |     function balanceOf(address) external view returns (uint);
  44 |     | }
  45 |     | 
  46 |     | contract Addresses {
  47 |     |     address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
  48 |     |     address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
  49 |     |     Quoter quoter = Quoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);
  50 |     |     Factory factory = Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);
  51 |     | }
  52 |     | 
  53 |     | // must --fork-url
  54 |     | contract TestAnalysisSwap is Test, Addresses, HelperHyperActions {
  55 |     |     Hyper hyper;
  56 |     |     Uni pool;
  57 |     |     uint24 fee = 3000;
  58 |     |     uint64 poolId = 0x0000010100000001;
  59 |     |     int24 tick;
  60 |     |     uint stk;
  61 |     |     uint price;
  62 |     | 
  63 |     |     function setUp() public {
  64 |     |         hyper = new Hyper(WETH);
  65 |     |         pool = Uni(factory.getPool(WETH, USDC, fee));
  66 |     |         console.log("Got pool: ", address(pool));
  67 |     |         price = pool.slot0().sqrtPriceX96;
  68 |     |         price = 1e36 / (((price * price * 10 ** ERC20(USDC).decimals())) >> (96 * 2));
  69 |     |         stk = (price * 5) / 4;
  70 |     |         console.log("stk", stk);
  71 |     |         tick = Price.computeTickWithPrice(stk);
  72 |     |         console.log("Got price of WETH-USDC 30bps", price);
  73 |     |         console.log("Got tick at price", uint24(tick));
  74 |     | 
  75 |     |         vm.deal(address(this), 1_000 ether);
  76 |     |         (bool success, bytes memory revertData) = address(hyper).call{value: 1_000 ether}(
  77 |     |             createPool(WETH, USDC, address(this), 1, 30, 5_500, 365, 1, tick, uint128(price))
  78 |     |         );
  79 |     |         assertTrue(success, "create pool failed");
  80 |     | 
  81 |     |         deal(USDC, address(this), 1_000 ether);
  82 |     |         ERC20(USDC).approve(address(hyper), type(uint256).max);
  83 |     |         hyper.allocate(poolId, 1_000 ether);
  84 |     |     }
  85 |     | 
  86 |     |     function __testAnalysisSwapQuote() public {
  87 |     |         (uint uWeth, uint uUsdc) = (ERC20(WETH).balanceOf(address(pool)), ERC20(USDC).balanceOf(address(pool)));
  88 |     |         console.log("WETH in Uniswap: ", uWeth);
  89 |     |         console.log("USDC in Uniswap: ", uUsdc);
  90 |     | 
  91 |     |         (uint bWeth, uint bUsdc) = hyper.getVirtualReserves(poolId);
  92 |     |         console.log("WETH in Hyper: ", bWeth);
  93 |     |         console.log("USDC in Hyper: ", bUsdc);
  94 |     | 
  95 |     |         console.log("Diff in WETH, uni - hyper: ");
  96 |     |         console.logInt(int(uWeth) - int(bWeth));
  97 |     |         console.log("Diff in USDC, uni - hyper: ");
  98 |     |         console.logInt(int(uUsdc) - int(bUsdc));
  99 |     | 
 100 |     |         bytes memory quote = abi.encodeWithSelector(Quoter.quoteExactInputSingle.selector, WETH, USDC, fee, 1 ether, 0);
 101 |     |         //(bool success, bytes memory quoteData) = address(quoter).staticcall(quote);
 102 |     |         //uint uQuote = abi.decode(quoteData, (uint));
 103 |     |         uint uQuote = quoter.quoteExactInputSingle(WETH, USDC, fee, 1 ether, 0);
 104 |     |         console.log("Got uniswap quote: ", uQuote);
 105 |     | 
 106 |     |         uint hQuote = hyper.getAmountOut(poolId, true, 1 ether);
 107 |     |         //(uint hQuote, ) = hyper.swap(poolId, true, 1 ether, 0);
 108 |     |         console.log("Got hyper quote: ", hQuote);
 109 |     | 
 110 |     |         console.log("Diff in quote, uni - hyper: ");
 111 |     |         console.logInt(int(uQuote) - int(hQuote));
 112 |     | 
 113 |     |         uint optimized;
 114 |     |         uint i;
 115 |     |         int24 startTick = tick;
 116 |     |         int24 endTick = startTick;
 117 |     |         uint16 vol = 2_000;
 118 |     |         uint16 dur = 365;
 119 |     | 
 120 |     |         while (optimized < uQuote && i != 25) {
 121 |     |             uint strike = Price.computePriceWithTick(endTick);
 122 |     |             if (dur > 20) {
 123 |     |                 // optimize duration first
 124 |     |                 hyper.changeParameters(poolId, 0, 0, 0, dur, 0, 0);
 125 |     |                 console.log("dur: ", dur);
 126 |     |                 dur -= 35;
 127 |     |             } else if (strike < price) {
 128 |     |                 // optimize vol
 129 |     |                 hyper.changeParameters(poolId, 0, 0, vol, 0, 0, 0);
 130 |     |                 console.log("vol: ", vol);
 131 |     |                 vol -= 100;
 132 |     |             } else {
 133 |     |                 // optimize strike
 134 |     |                 hyper.changeParameters(poolId, 0, 0, 0, 0, 0, endTick);
 135 |     |                 console.log("strike price: ", strike);
 136 |     |                 endTick -= 250;
 137 |     |             }
 138 |     |             optimized = hyper.getAmountOut(poolId, true, 1 ether);
 139 |     |             console.log("target - optimized", uQuote - optimized);
 140 |     | 
 141 |     |             ++i;
 142 |     |         }
 143 |     | 
 144 |     |         console.log("DONE");
 145 |     |     }
 146 |     | 
 147 |     |     function __testFuzzSwapOutput(uint16 vol, uint16 dur, uint128 strike) public {
 148 |     |         vol = uint16(bound(vol, 500, 2_000));
 149 |     |         dur = uint16(bound(dur, 10, 100));
 150 |     |         strike = uint128(bound(strike, stk, price * 2)); // between strike and twice the price
 151 |     | 
 152 |     |         hyper.changeParameters(poolId, 0, 0, vol, dur, 0, Price.computeTickWithPrice(strike));
 153 |     | 
 154 |     |         uint target = 1261714834;
 155 |     |         uint actual = hyper.getAmountOut(poolId, true, 1 ether);
 156 |     |         assertTrue(actual < target, "Found a value!");
 157 |     |         console.log("Actual", actual);
 158 |     |     }
 159 |     | }
 160 |     | 

/root/code/hyper/test/crytic/TestE2EHyper.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /* import "./setup/TestEchidnaSetup.sol"; */
  5 |     | 
  6 |     | contract TestE2EHyper {
  7 |     |     event AssertionFailed();
  8 |     | 
  9 |     |     function echidna_jit_policy() public returns (bool) {
 10 |     |         if (5 != 4) emit AssertionFailed();
 11 |     |     }
 12 |     | }
 13 |     | 

/root/code/hyper/test/crytic/setup/TestEchidnaSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "solmate/tokens/WETH.sol";
  5 |     | import "contracts/libraries/Price.sol";
  6 |     | import "contracts/HyperLib.sol";
  7 |     | import "test/helpers/HelperHyperActions.sol";
  8 |     | import "test/helpers/HelperHyperInvariants.sol";
  9 |     | import "test/helpers/HelperHyperProfiles.sol";
 10 |     | import "test/helpers/HelperHyperView.sol";
 11 |     | 
 12 |     | import {TestERC20, HyperTimeOverride} from "test/helpers/HyperTestOverrides.sol";
 13 |     | 
 14 |     | uint constant STARTING_BALANCE = 4000e18;
 15 |     | 
 16 |     | contract TestEchidnaEvents {
 17 |     |     event AssertionFailed();
 18 |     |     event AssertionFailed(uint);
 19 |     |     event AssertionFailed(uint, uint);
 20 |     |     event AssertionFailed(uint, uint, uint);
 21 |     |     event AssertionFailed(string, uint);
 22 |     |     event AssertionFailed(bytes);
 23 |     |     event AssertionFailed(int);
 24 |     | }
 25 |     | 
 26 |     | contract Addresses {
 27 |     |     User public __user__;
 28 |     |     WETH public __weth__;
 29 |     |     HyperTimeOverride public __hyper__;
 30 |     |     TestERC20 public __usdc__;
 31 |     |     TestERC20 public __token_18__;
 32 |     | }
 33 |     | 
 34 |     | contract User {}
 35 |     | 
 36 |     | contract TestEchidnaSetup is
 37 |     |     TestEchidnaEvents,
 38 |     |     HelperHyperActions,
 39 |     |     HelperHyperInvariants,
 40 |     |     HelperHyperProfiles,
 41 |     |     HelperHyperView,
 42 |     |     Addresses
 43 |     | {
 44 |     |     using FixedPointMathLib for uint256;
 45 |     |     using FixedPointMathLib for int256;
 46 |     | 
 47 |     |     constructor() {
 48 |     |         initContracts();
 49 |     |         fundUsers();
 50 |     |         approveSpenders();
 51 |     | 
 52 |     |         afterSetUp();
 53 |     |     }
 54 |     | 
 55 |     |     function initContracts() internal {
 56 |     |         __user__ = new User();
 57 |     |         __weth__ = new WETH();
 58 |     | 
 59 |     |         // --- Hyper Contracts --- //
 60 |     |         __hyper__ = new HyperTimeOverride(address(__weth__));
 61 |     | 
 62 |     |         // --- Tokens --- //
 63 |     |         __usdc__ = new TestERC20("USD Coin", "USDC", 6);
 64 |     |         __token_18__ = new TestERC20("18 Decimals", "18DEC", 18);
 65 |     |     }
 66 |     | 
 67 |     |     /** @dev Hook to override receive. Defaults to just accepting ether sent to this test contract. */
 68 |     |     receive() external payable {
 69 |     |         receiveOverride();
 70 |     |     }
 71 |     | 
 72 |     |     /** @dev Hook to run after test setup. */
 73 |     |     function afterSetUp() public virtual {}
 74 |     | 
 75 |     |     /** @dev Hook to implement to handle receive differently. */
 76 |     |     function receiveOverride() public virtual {}
 77 |     | 
 78 |     |     function deal(TestERC20 token, address to, uint amount) internal {
 79 |     |         token.mint(to, amount);
 80 |     |     }
 81 |     | 
 82 |     |     /** @dev Does not include weth. */
 83 |     |     function fundUsers() internal {
 84 |     |         deal(__token_18__, address(__user__), STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.
 85 |     |         deal(__usdc__, address(__user__), STARTING_BALANCE);
 86 |     |     }
 87 |     | 
 88 |     |     /** @dev Does not include weth. */
 89 |     |     function approveSpenders() internal {
 90 |     |         TestERC20(__token_18__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 91 |     |         TestERC20(__usdc__).approve(address(__hyper__), type(uint256).max); // Approves test contracts to spend tokens.
 92 |     |     }
 93 |     | }
 94 |     | 

/root/code/hyper/test/foundry/TestAssembly.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../contracts/Assembly.sol";
  5 |     | import "forge-std/Test.sol";
  6 |     | 
  7 |     | contract AddSignedDelta {
  8 |     |     function addSignedDelta(uint128 input, int128 delta) public pure returns (uint128 output) {
  9 |     |         bytes memory revertData = abi.encodeWithSelector(InvalidLiquidity.selector);
 10 |     |         assembly {
 11 |     |             output := add(input, delta)
 12 |     | 
 13 |     |             if gt(output, 0xffffffffffffffffffffffffffffffff) {
 14 |     |                 revert(add(32, revertData), mload(revertData)) // 0x1fff9681
 15 |     |             }
 16 |     |         }
 17 |     |     }
 18 |     | 
 19 |     |     function addSignedDelta_ref(uint128 input, int128 delta) external pure returns (uint128 output) {
 20 |     |         if (delta < 0) {
 21 |     |             output = input - uint128(-delta);
 22 |     |             if (output >= input) revert InvalidLiquidity();
 23 |     |         } else {
 24 |     |             output = input + uint128(delta);
 25 |     |             if (output < input) revert InvalidLiquidity();
 26 |     |         }
 27 |     |     }
 28 |     | }
 29 |     | 
 30 |     | contract TestAssembly is Test {
 31 |     |     AddSignedDelta public target;
 32 |     | 
 33 |     |     function setUp() public {
 34 |     |         target = new AddSignedDelta();
 35 |     |     }
 36 |     | 
 37 |     |     function test_addSignedDelta_positive_delta(uint128 input, int128 delta) public {
 38 |     |         vm.assume(delta >= 0);
 39 |     | 
 40 |     |         if (uint256(input) + uint256(uint128(delta)) <= type(uint128).max) {
 41 |     |             uint128 output = target.addSignedDelta(input, delta);
 42 |     |             assertEq(output, input + uint128(delta));
 43 |     |         } else {
 44 |     |             vm.expectRevert();
 45 |     |             target.addSignedDelta(input, delta);
 46 |     |         }
 47 |     |     }
 48 |     | 
 49 |     |     function test_addSignedDelta_negative_delta(uint128 input, int128 delta) public {
 50 |     |         vm.assume(delta < 0);
 51 |     |         vm.assume(uint256(-int256(delta)) < 170141183460469231731687303715884105728);
 52 |     | 
 53 |     |         if (uint256(-int256(delta)) > uint256(input)) {
 54 |     |             vm.expectRevert();
 55 |     |             target.addSignedDelta(input, delta);
 56 |     |         } else {
 57 |     |             uint128 output = target.addSignedDelta(input, delta);
 58 |     |             assertEq(uint256(output), uint256(input) - uint256(int256(-delta)));
 59 |     |         }
 60 |     |     }
 61 |     | 
 62 |     |     function test_addSignedDelta_should_match(uint128 input, int128 delta) public {
 63 |     |         vm.assume(input > 0);
 64 |     |         vm.assume(delta > 0);
 65 |     |         vm.assume(input >= uint128(delta));
 66 |     |         vm.assume(uint256(input) + uint256(uint128(delta)) <= type(uint128).max);
 67 |     | 
 68 |     |         assertEq(
 69 |     |             target.addSignedDelta(input, delta),
 70 |     |             target.addSignedDelta_ref(input, delta)
 71 |     |         );
 72 |     |     }
 73 |     | }
 74 |     | 

/root/code/hyper/test/foundry/TestGas.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | import "forge-std/Test.sol";
  6 |     | 
  7 |     | contract TestGas is TestHyperSetup {
  8 |     |     function testGasAllocateExternal() public {
  9 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
 10 |     |     }
 11 |     | 
 12 |     |     function testGasAllocateInternalBalance() public {
 13 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), 10 ether);
 14 |     |         __hyperTestingContract__.fund(address(defaultScenario.quote), 10 ether);
 15 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
 16 |     |     }
 17 |     | 
 18 |     |     function testGasAllocateProcess() public {
 19 |     |         bytes memory data = Enigma.encodeAllocate(uint8(0), defaultScenario.poolId, 0x12, 0x01); // 1 ether
 20 |     |         bool success = __revertCatcher__.process(data);
 21 |     |         assertTrue(success, "call failed");
 22 |     |     }
 23 |     | 
 24 |     |     function testGasAllocateProcessInternalBalance() public {
 25 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), 10 ether);
 26 |     |         __hyperTestingContract__.fund(address(defaultScenario.quote), 10 ether);
 27 |     |         bytes memory data = Enigma.encodeAllocate(uint8(0), defaultScenario.poolId, 0x12, 0x01); // 1 ether
 28 |     |         bool success = __revertCatcher__.process(data);
 29 |     |         assertTrue(success, "call failed");
 30 |     |     }
 31 |     | }
 32 |     | 

/root/code/hyper/test/foundry/TestHyperAllocate.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {HyperPool, JUST_IN_TIME_LIQUIDITY_POLICY, HyperPair} from "contracts/HyperLib.sol";
   5 |     | import "./setup/TestHyperSetup.sol";
   6 |     | 
   7 |     | struct Amounts {
   8 |     |     uint expectedDelta0;
   9 |     |     uint expectedDelta1;
  10 |     |     uint computedDelta0;
  11 |     |     uint computedDelta1;
  12 |     |     uint prevReserve0;
  13 |     |     uint prevReserve1;
  14 |     |     uint postReserve0;
  15 |     |     uint postReserve1;
  16 |     | }
  17 |     | 
  18 |     | contract TestHyperAllocate is TestHyperSetup {
  19 |     |     using SafeCastLib for uint;
  20 |     | 
  21 |     |     Amounts _amounts;
  22 |     | 
  23 |     |     modifier afterTest() {
  24 |     |         _;
  25 |     |         delete _amounts;
  26 |     |     }
  27 |     | 
  28 |     |     function testAllocateNonStandardDecimals() public postTestInvariantChecks afterTest {
  29 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  30 |     |         assertTrue(pool.lastTimestamp != 0, "pool-created");
  31 |     | 
  32 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40));
  33 |     | 
  34 |     |         address hyper = address(__hyperTestingContract__);
  35 |     |         uint64 poolId = defaultScenario.poolId;
  36 |     | 
  37 |     |         uint128 liquidity = DEFAULT_LIQUIDITY;
  38 |     |         (_amounts.computedDelta0, _amounts.computedDelta1) = pool.getAmountsWad(); // one liquidity wad
  39 |     | 
  40 |     |         (_amounts.expectedDelta0, _amounts.expectedDelta1) = (
  41 |     |             Assembly.scaleFromWadDown(_amounts.computedDelta0, pair.decimalsAsset),
  42 |     |             Assembly.scaleFromWadDown(_amounts.computedDelta1, pair.decimalsQuote)
  43 |     |         );
  44 |     | 
  45 |     |         (_amounts.prevReserve0, _amounts.prevReserve1) = (
  46 |     |             getReserve(hyper, pair.tokenAsset),
  47 |     |             getReserve(hyper, pair.tokenQuote)
  48 |     |         );
  49 |     | 
  50 |     |         __hyperTestingContract__.allocate(poolId, liquidity);
  51 |     | 
  52 |     |         (_amounts.postReserve0, _amounts.postReserve1) = (
  53 |     |             getReserve(hyper, pair.tokenAsset),
  54 |     |             getReserve(hyper, pair.tokenQuote)
  55 |     |         );
  56 |     | 
  57 |     |         assertEq(_amounts.postReserve0, _amounts.prevReserve0 + _amounts.expectedDelta0, "asset-reserves");
  58 |     |         assertEq(_amounts.postReserve1, _amounts.prevReserve1 + _amounts.expectedDelta1, "quote-reserves");
  59 |     |     }
  60 |     | 
  61 |     |     function testAllocateFull() public postTestInvariantChecks {
  62 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  63 |     |         assertTrue(pool.lastTimestamp != 0, "pool-created");
  64 |     | 
  65 |     |         uint256 price = pool.lastPrice;
  66 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId));
  67 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), uint24(defaultScenario.poolId >> 40));
  68 |     | 
  69 |     |         uint tau = pool.lastTau(); // seconds
  70 |     | 
  71 |     |         uint256 theoreticalR2 = Price.getXWithPrice(
  72 |     |             price,
  73 |     |             Price.computePriceWithTick(pool.params.maxTick),
  74 |     |             pool.params.volatility,
  75 |     |             tau
  76 |     |         );
  77 |     | 
  78 |     |         uint delLiquidity = 4_000_000;
  79 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, delLiquidity);
  80 |     | 
  81 |     |         uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  82 |     |         uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  83 |     |         assertTrue(globalR1 > 0);
  84 |     |         assertTrue(globalR2 > 0);
  85 |     |         assertApproxEqAbs(globalR2, (theoreticalR2 * delLiquidity) / 1e18, 1, "asset-reserve-theoretic");
  86 |     |     }
  87 |     | 
  88 |     |     function testAllocateUseMax() public postTestInvariantChecks {
  89 |     |         uint assetBalance = defaultScenario.asset.balanceOf(address(this));
  90 |     |         uint quoteBalance = defaultScenario.quote.balanceOf(address(this));
  91 |     |         uint maxLiquidity = __hyperTestingContract__.getMaxLiquidity(
  92 |     |             defaultScenario.poolId,
  93 |     |             assetBalance,
  94 |     |             quoteBalance
  95 |     |         );
  96 |     | 
  97 |     |         (address asset, address quote) = (address(defaultScenario.asset), address(defaultScenario.quote));
  98 |     | 
  99 |     |         __hyperTestingContract__.fund(asset, assetBalance);
 100 |     |         __hyperTestingContract__.fund(quote, quoteBalance);
 101 |     | 
 102 |     |         assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);
 103 |     |         quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);
 104 |     |         maxLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, assetBalance, quoteBalance);
 105 |     | 
 106 |     |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getLiquidityDeltas(
 107 |     |             defaultScenario.poolId,
 108 |     |             -int128(maxLiquidity.safeCastTo128()) // negative delta rounds output amounts down
 109 |     |         );
 110 |     | 
 111 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, type(uint256).max);
 112 |     | 
 113 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 114 |     |         assetBalance = getBalance(address(__hyperTestingContract__), address(this), asset);
 115 |     |         quoteBalance = getBalance(address(__hyperTestingContract__), address(this), quote);
 116 |     |         (uint128 reserveAsset, uint128 reserveQuote) = pool.getVirtualReserves();
 117 |     | 
 118 |     |         assertEq(deltaAsset, reserveAsset, "delta-asset");
 119 |     |         assertEq(deltaQuote, reserveQuote, "delta-quote");
 120 |     |         assertEq(maxLiquidity, pool.liquidity, "delta-liquidity");
 121 |     |         assertEq(
 122 |     |             assetBalance,
 123 |     |             getReserve(address(__hyperTestingContract__), asset) - (deltaAsset + 1), // round up
 124 |     |             "asset-balance"
 125 |     |         );
 126 |     |         assertEq(
 127 |     |             quoteBalance,
 128 |     |             getReserve(address(__hyperTestingContract__), quote) - (deltaQuote + 1), // round up
 129 |     |             "quote-balance"
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * note: Found an interesting overflow bug!
 135 |     |      * 170141183460469231731687303715884105728 is equal to 2^127.
 136 |     |      * Values between 2^127 and 2^128 will break allocate, because of the implicit conversion
 137 |     |      * from uint128 to int128 causing an overflow.
 138 |     |      */
 139 |     |     function testFuzzAllocateUnallocateSuccessful(uint128 deltaLiquidity) public postTestInvariantChecks {
 140 |     |         vm.assume(deltaLiquidity != 0);
 141 |     |         vm.assume(deltaLiquidity < (2 ** 126 - 1e36)); // note: if its 2^127, it could still overflow since liquidity is multiplied against token amounts in getLiquidityDeltas.
 142 |     |         // TODO: Add use max flag support.
 143 |     |         _assertAllocate(deltaLiquidity);
 144 |     |     }
 145 |     | 
 146 |     |     /** @dev ALlocates then asserts the invariants. */
 147 |     |     function _assertAllocate(uint128 deltaLiquidity) internal {
 148 |     |         // Preconditions
 149 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 150 |     |         assertTrue(pool.lastTimestamp != 0, "Pool not initialized");
 151 |     |         assertTrue(pool.lastPrice != 0, "Pool not created with a price");
 152 |     | 
 153 |     |         (uint expectedDeltaAsset, uint expectedDeltaQuote) = __hyperTestingContract__.getLiquidityDeltas(
 154 |     |             defaultScenario.poolId,
 155 |     |             int128(deltaLiquidity)
 156 |     |         );
 157 |     |         defaultScenario.asset.mint(address(this), expectedDeltaAsset);
 158 |     |         defaultScenario.quote.mint(address(this), expectedDeltaQuote);
 159 |     | 
 160 |     |         // Execution
 161 |     |         HyperState memory prev = getState();
 162 |     |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.allocate(defaultScenario.poolId, deltaLiquidity);
 163 |     |         HyperState memory post = getState();
 164 |     | 
 165 |     |         // Postconditions
 166 |     |         {
 167 |     |             assertEq(deltaAsset, expectedDeltaAsset, "pool-delta-asset");
 168 |     |             assertEq(deltaQuote, expectedDeltaQuote, "pool-delta-quote");
 169 |     |             assertEq(post.totalPoolLiquidity, prev.totalPoolLiquidity + deltaLiquidity, "pool-total-liquidity");
 170 |     |             assertTrue(post.totalPoolLiquidity > prev.totalPoolLiquidity, "pool-liquidity-increases");
 171 |     |             assertEq(
 172 |     |                 post.callerPositionLiquidity,
 173 |     |                 prev.callerPositionLiquidity + deltaLiquidity,
 174 |     |                 "position-liquidity-increases"
 175 |     |             );
 176 |     | 
 177 |     |             assertEq(post.reserveAsset, prev.reserveAsset + expectedDeltaAsset, "reserve-asset");
 178 |     |             assertEq(post.reserveQuote, prev.reserveQuote + expectedDeltaQuote, "reserve-quote");
 179 |     |             assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + expectedDeltaAsset, "physical-asset");
 180 |     |             assertEq(post.physicalBalanceQuote, prev.physicalBalanceQuote + expectedDeltaQuote, "physical-quote");
 181 |     | 
 182 |     |             uint feeDelta0 = post.feeGrowthAssetPosition - prev.feeGrowthAssetPosition;
 183 |     |             uint feeDelta1 = post.feeGrowthAssetPool - prev.feeGrowthAssetPool;
 184 |     |             assertTrue(feeDelta0 == feeDelta1, "asset-growth");
 185 |     | 
 186 |     |             uint feeDelta2 = post.feeGrowthQuotePosition - prev.feeGrowthQuotePosition;
 187 |     |             uint feeDelta3 = post.feeGrowthQuotePool - prev.feeGrowthQuotePool;
 188 |     |             assertTrue(feeDelta2 == feeDelta3, "quote-growth");
 189 |     |         }
 190 |     | 
 191 |     |         // Unallocate
 192 |     |         customWarp(block.timestamp + JUST_IN_TIME_LIQUIDITY_POLICY); // TODO: make this public function.
 193 |     |         (uint unallocatedAsset, uint unallocatedQuote) = __hyperTestingContract__.unallocate(
 194 |     |             defaultScenario.poolId,
 195 |     |             deltaLiquidity
 196 |     |         );
 197 |     | 
 198 |     |         // remove all credits, since unallocate will increase this amount.
 199 |     |         __hyperTestingContract__.draw(
 200 |     |             address(defaultScenario.asset),
 201 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),
 202 |     |             address(this)
 203 |     |         );
 204 |     |         __hyperTestingContract__.draw(
 205 |     |             address(defaultScenario.quote),
 206 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),
 207 |     |             address(this)
 208 |     |         );
 209 |     | 
 210 |     |         {
 211 |     |             HyperState memory end = getState();
 212 |     |             assertApproxEqAbs(unallocatedAsset, deltaAsset, 1, "unallocate-delta-asset");
 213 |     |             assertApproxEqAbs(unallocatedQuote, deltaQuote, 1, "unallocate-delta-quote");
 214 |     |             assertApproxEqAbs(end.reserveAsset, prev.reserveAsset, 1, "unallocate-reserve-asset");
 215 |     |             assertApproxEqAbs(end.reserveQuote, prev.reserveQuote, 1, "unallocate-reserve-quote");
 216 |     |             assertEq(end.totalPoolLiquidity, prev.totalPoolLiquidity, "unallocate-pool-liquidity");
 217 |     |             assertEq(end.totalPositionLiquidity, prev.totalPositionLiquidity, "unallocate-sum-position-liquidity");
 218 |     |             assertEq(end.callerPositionLiquidity, prev.callerPositionLiquidity, "unallocate-caller-position-liquidity");
 219 |     |         }
 220 |     |     }
 221 |     | }
 222 |     | 

/root/code/hyper/test/foundry/TestHyperClaim.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./setup/TestHyperSetup.sol";
   5 |     | 
   6 |     | /**
   7 |     |  @custom:docs 
   8 |     |  
   9 |     |  Fee Buckets and Claiming
  10 |     |     - Users allocate tokens to pools which issue liquidity represent their proportion of deposit.
  11 |     |     - Users swap against the pool and pay the swap fee. Absolute fees per liquidity unit is tracked in the `feeGrowth` variables.
  12 |     |     - Users can stake liquidity. Staking liquidity will increment their position's staked liquidity and decrement their "free liquidity".
  13 |     |     - Staking liquidity does not alter pool liquidity. The `liquidity` variable of each pool is the total supply of liquidity, including staked.
  14 |     |     - Fee growth is always based on `liquidity`, which is `freeLiquidity + stakedLiquidity`. 
  15 |     |     - Positions liquidity is just split into `free` and `staked`. 
  16 |     |     - The sum of all position's sums of free and staked liquidity is equal to the pool liquidity. 
  17 |     |     - Fees accrue both to free and staked liquidity, because the pool treats it all as global liquidity.
  18 |     |     - Positions sync their fees by computing the sum of their free and staked liquidity multiplied by the fee per liquidity growth variable.
  19 |     |  */
  20 |     | contract TestHyperClaim is TestHyperSetup {
  21 |     |     using FixedPointMathLib for uint;
  22 |     |     using Price for Price.RMM;
  23 |     | 
  24 |     |     function testClaimNoPosition_reverts() public {
  25 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPosition.selector, address(this), defaultScenario.poolId));
  26 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, 0, 0);
  27 |     |     }
  28 |     | 
  29 |     |     function testClaim_successful_PositionOwedAmountsReturnsZero() public {
  30 |     |         basicAllocate();
  31 |     |         basicSwap();
  32 |     | 
  33 |     |         // Has asset tokens owed
  34 |     | 
  35 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  36 |     |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
  37 |     |         uint tokensOwed = Assembly
  38 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)
  39 |     |             .mulWadDown(pool.liquidity);
  40 |     | 
  41 |     |         uint pre = _getBalance(hx(), address(this), (defaultScenario.asset));
  42 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);
  43 |     |         uint post = _getBalance(hx(), address(this), (defaultScenario.asset));
  44 |     | 
  45 |     |         pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  46 |     | 
  47 |     |         assertEq(post, pre + tokensOwed, "delta");
  48 |     |         assertEq(post, tokensOwed, "claimed-bal");
  49 |     |         assertEq(pos.tokensOwedAsset, 0, "zero-claim");
  50 |     |     }
  51 |     | 
  52 |     |     function testClaimGetBalanceReturnsFeeAmount_asset() public {
  53 |     |         basicAllocate();
  54 |     |         basicSwap();
  55 |     | 
  56 |     |         // Has asset tokens owed
  57 |     | 
  58 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  59 |     |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
  60 |     |         uint tokensOwed = Assembly
  61 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalAsset, pos.feeGrowthAssetLast)
  62 |     |             .mulWadDown(pool.liquidity);
  63 |     | 
  64 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, tokensOwed, 0);
  65 |     |         uint post = _getBalance(hx(), address(this), (defaultScenario.asset));
  66 |     |         assertEq(post, tokensOwed, "claimed-bal");
  67 |     |     }
  68 |     | 
  69 |     |     function testClaimGetBalanceReturnsFeeAmount_quote() public {
  70 |     |         basicAllocate();
  71 |     |         basicSwapQuoteIn();
  72 |     | 
  73 |     |         // Has asset tokens owed
  74 |     | 
  75 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), defaultScenario.poolId);
  76 |     |         HyperPool memory pool = _getPool(hs(), defaultScenario.poolId);
  77 |     |         uint tokensOwed = Assembly
  78 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalQuote, pos.feeGrowthQuoteLast)
  79 |     |             .mulWadDown(pool.liquidity);
  80 |     | 
  81 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, 0, tokensOwed);
  82 |     |         uint post = _getBalance(hx(), address(this), defaultScenario.quote);
  83 |     |         assertEq(post, tokensOwed, "claimed-bal");
  84 |     |     }
  85 |     | 
  86 |     |     function testClaimGetBalanceReturnsFeeAmount_reward() public {
  87 |     |         // Rewards only accrue to controlled pools
  88 |     |         createControlledPool();
  89 |     | 
  90 |     |         TestScenario memory scenario = _scenario_controlled;
  91 |     |         assertTrue(
  92 |     |             keccak256(abi.encodePacked(scenario.label)) == keccak256(abi.encodePacked("Controlled")),
  93 |     |             "not controlled?"
  94 |     |         );
  95 |     | 
  96 |     |         __weth__.deposit{value: 0.01 ether}();
  97 |     |         __weth__.approve(address(__hyperTestingContract__), type(uint256).max);
  98 |     | 
  99 |     |         _alloc(scenario.poolId);
 100 |     |         __hyperTestingContract__.stake(scenario.poolId, 1 ether);
 101 |     | 
 102 |     |         // pass some time for staking
 103 |     |         customWarp(__hyperTestingContract__.timestamp() + 1);
 104 |     | 
 105 |     |         _swap(scenario.poolId); // swapping in controlled pool should increment reward token (weth)
 106 |     | 
 107 |     |         // Has asset tokens owed
 108 |     | 
 109 |     |         HyperPosition memory pos = _getPosition(hs(), address(this), scenario.poolId);
 110 |     |         HyperPool memory pool = _getPool(hs(), scenario.poolId);
 111 |     |         uint tokensOwed = Assembly
 112 |     |             .computeCheckpointDistance(pool.feeGrowthGlobalReward, pos.feeGrowthRewardLast)
 113 |     |             .mulWadDown(pool.liquidity);
 114 |     | 
 115 |     |         __hyperTestingContract__.claim(scenario.poolId, 0, 0);
 116 |     |         uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 117 |     |         assertEq(post, tokensOwed, "claimed-bal");
 118 |     |     }
 119 |     | 
 120 |     |     function testClaimCreditsAssetBalance() public postTestInvariantChecks {
 121 |     |         basicAllocate();
 122 |     |         basicSwap(); // swaps __asset__ in, so pays fees in asset.
 123 |     | 
 124 |     |         HyperPool memory pool = defaultPool();
 125 |     |         uint real0 = _getReserve(hx(), defaultScenario.asset);
 126 |     |         uint real1 = _getReserve(hx(), defaultScenario.quote);
 127 |     |         (uint res0, uint res1) = pool.getVirtualReserves();
 128 |     |         uint liquidity = pool.liquidity;
 129 |     | 
 130 |     |         basicUnallocate();
 131 |     |         maxDraw(); // zero balance to ensure we aren't paying ourself.
 132 |     | 
 133 |     |         HyperPosition memory pos = defaultPosition();
 134 |     |         pool = defaultPool();
 135 |     |         (uint fee0, uint fee1) = (pos.tokensOwedAsset, pos.tokensOwedQuote);
 136 |     |         assertTrue(fee0 > 0, "fee0-zero");
 137 |     |         assertTrue(pool.liquidity == 0, "non-zero-liquidity");
 138 |     | 
 139 |     |         uint entitledAssetAmount = real0 - fee0;
 140 |     | 
 141 |     |         Price.RMM memory rmm = pool.getRMM();
 142 |     |         uint adjustedAmt = entitledAssetAmount.divWadDown(liquidity);
 143 |     |         uint expectedPrice = rmm.getPriceWithX(adjustedAmt);
 144 |     | 
 145 |     |         // Claim
 146 |     |         uint prevReserve = _getReserve(hx(), defaultScenario.asset);
 147 |     |         uint prevBalance = _getBalance(hx(), address(this), defaultScenario.asset);
 148 |     |         __hyperTestingContract__.claim(defaultScenario.poolId, fee0, fee1);
 149 |     |         uint nextBalance = _getBalance(hx(), address(this), defaultScenario.asset);
 150 |     | 
 151 |     |         maxDraw(); // clear reserve
 152 |     | 
 153 |     |         pos = defaultPosition();
 154 |     |         (fee0, ) = (pos.tokensOwedAsset, pos.tokensOwedQuote);
 155 |     |         assertEq(fee0, 0, "unclaimed-fees");
 156 |     | 
 157 |     |         uint nextReserve = _getReserve(hx(), defaultScenario.asset);
 158 |     |         // todo: fix. Price deviation trick leaves dust, there should be no dust! assertEq(nextReserve, 0, "reserve-not-zero");
 159 |     |         assertTrue(nextBalance > prevBalance, "no fee claimed");
 160 |     |         assertTrue(nextReserve < prevReserve, "no fee removed");
 161 |     |     }
 162 |     | 
 163 |     |     /// @custom:tob TOB-HYPR-7, Exploit Scenario 1
 164 |     |     function testClaim_small_liquidity_does_not_steal_fees() public {
 165 |     |         uint startLiquidity = 10_000;
 166 |     |         __hyperTestingContract__.allocate(_scenario_18_18.poolId, startLiquidity);
 167 |     | 
 168 |     |         address eve = address(0x4215);
 169 |     |         deal(address(_scenario_18_18.asset), eve, 10000);
 170 |     |         deal(address(_scenario_18_18.quote), eve, 100000);
 171 |     |         vm.prank(eve);
 172 |     |         _scenario_18_18.asset.approve(address(__hyperTestingContract__), 10000);
 173 |     |         vm.prank(eve);
 174 |     |         _scenario_18_18.quote.approve(address(__hyperTestingContract__), 100000);
 175 |     | 
 176 |     |         // eve provides minimal liquidity to the pool
 177 |     |         vm.prank(eve);
 178 |     |         __hyperTestingContract__.allocate(_scenario_18_18.poolId, startLiquidity / 5); // 20% of pool, eve = 2000, total = 2000 + 10000
 179 |     | 
 180 |     |         // eve waits for some swaps to happen. basicSwap will sell assets and increment asset fee growth.
 181 |     |         __hyperTestingContract__.swap(_scenario_18_18.poolId, true, 1500, 1); // trade in 1500 * 1% fee = 15 / 12_000 = 0.00125 fee growth per liquidity
 182 |     | 
 183 |     |         // save the total fee growth for the asset per liquidity.
 184 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), _scenario_18_18.poolId);
 185 |     |         uint totalLiquidity = pool.liquidity; // 12_000
 186 |     |         uint totalFeeAssetPerLiquidity = pool.feeGrowthGlobalAsset; // 0.00125
 187 |     | 
 188 |     |         // eve claims earned fees, which should be proportional to her share of the liquidity
 189 |     |         vm.prank(eve);
 190 |     |         __hyperTestingContract__.claim(_scenario_18_18.poolId, type(uint256).max, type(uint256).max);
 191 |     | 
 192 |     |         uint evesShare = startLiquidity / 5; // 2000
 193 |     |         uint evesClaimedFees = _getBalance(hx(), eve, _scenario_18_18.asset); // 2_000 / 12_000 = ~16% of 0.00125 fee growth = 0.0002 in fees
 194 |     | 
 195 |     |         // check to make sure eve did not receive more than they were entitled to
 196 |     |         assertTrue(evesClaimedFees != 0, "eve-zero-fees");
 197 |     |         assertEq(evesClaimedFees, 2, "unexpected-fees"); // 2_000 * 0.00125 = 2.5, rounded down to integer of 2
 198 |     |         assertEq((evesShare * totalFeeAssetPerLiquidity) / 1 ether, evesClaimedFees, "incorrect-fee");
 199 |     |     }
 200 |     | }
 201 |     | 

/root/code/hyper/test/foundry/TestHyperCreate.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "forge-std/Vm.sol";
   5 |     | import "./setup/TestHyperSetup.sol";
   6 |     | 
   7 |     | contract TestHyperCreate is TestHyperSetup {
   8 |     |     function testFuzzCreatePol(
   9 |     |         uint16 priorityFee,
  10 |     |         uint16 fee,
  11 |     |         uint16 jit,
  12 |     |         uint16 duration,
  13 |     |         uint16 volatility,
  14 |     |         int24 maxTick,
  15 |     |         uint128 price
  16 |     |     ) public {
  17 |     |         fee = uint16(bound(fee, MIN_FEE, MAX_FEE));
  18 |     |         priorityFee = uint16(bound(priorityFee, 1, fee));
  19 |     |         jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));
  20 |     |         duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));
  21 |     |         volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
  22 |     |         maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));
  23 |     |         vm.assume(price > 0);
  24 |     |         vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.
  25 |     |         bytes memory data = Enigma.encodeCreatePool(
  26 |     |             uint24(1),
  27 |     |             address(this),
  28 |     |             priorityFee,
  29 |     |             fee,
  30 |     |             volatility,
  31 |     |             duration,
  32 |     |             jit,
  33 |     |             maxTick,
  34 |     |             price
  35 |     |         );
  36 |     |         bool success = __revertCatcher__.process(data);
  37 |     |         uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(__hyperTestingContract__.getPoolNonce()));
  38 |     | 
  39 |     |         HyperPool memory pool = _getPool(hs(), poolId);
  40 |     |         HyperCurve memory actual = pool.params;
  41 |     | 
  42 |     |         assertTrue(success, "fuzz create pool failed");
  43 |     |         assertEq(pool.controller, address(this), "controller");
  44 |     |         assertEq(actual.priorityFee, priorityFee, "priorityFee");
  45 |     |         assertEq(actual.fee, fee, "fee");
  46 |     |         assertEq(actual.volatility, volatility, "volatility");
  47 |     |         assertEq(actual.duration, duration, "duration");
  48 |     |         assertEq(actual.jit, jit, "jit");
  49 |     |         assertEq(actual.maxTick, maxTick, "maxTick");
  50 |     |     }
  51 |     | 
  52 |     |     function testCreatePoolNonControlledHasDefaultJit() public {
  53 |     |         __hyperTestingContract__.setJitPolicy(JUST_IN_TIME_LIQUIDITY_POLICY); // for assertion below.
  54 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(0), 1, 100, 100, 100, 100, 100, 100);
  55 |     |         bool success = __revertCatcher__.process(data);
  56 |     |         assertTrue(success, "create failed");
  57 |     |         uint64 poolId = Enigma.encodePoolId(uint24(1), false, uint32(__hyperTestingContract__.getPoolNonce()));
  58 |     |         assertEq(_getPool(hs(), poolId).params.jit, JUST_IN_TIME_LIQUIDITY_POLICY);
  59 |     |     }
  60 |     | 
  61 |     |     function testCreatePoolZeroPriceReverts() public {
  62 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 1, 1, 1, 1, 1, 1, 0);
  63 |     |         vm.expectRevert(ZeroPrice.selector);
  64 |     |         bool success = __revertCatcher__.process(data);
  65 |     |         assertTrue(!success);
  66 |     |     }
  67 |     | 
  68 |     |     function testCreatePoolPriorityFeeInvalidFeeReverts() public {
  69 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(this), 0, 1, 1, 1, 1, 1, 1);
  70 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, 0));
  71 |     |         bool success = __revertCatcher__.process(data);
  72 |     |         assertTrue(!success);
  73 |     |     }
  74 |     | 
  75 |     |     function testFuzzChangeParameters(
  76 |     |         uint16 priorityFee,
  77 |     |         uint16 fee,
  78 |     |         uint16 jit,
  79 |     |         uint16 duration,
  80 |     |         uint16 volatility,
  81 |     |         int24 maxTick
  82 |     |     ) public {
  83 |     |         uint64 poolId = _createDefaultPool();
  84 |     |         fee = uint16(bound(fee, MIN_FEE, MAX_FEE));
  85 |     |         priorityFee = uint16(bound(priorityFee, 1, fee));
  86 |     |         jit = uint16(bound(jit, 1, JUST_IN_TIME_MAX));
  87 |     |         duration = uint16(bound(duration, MIN_DURATION, MAX_DURATION));
  88 |     |         volatility = uint16(bound(volatility, MIN_VOLATILITY, MAX_VOLATILITY));
  89 |     |         maxTick = int24(bound(maxTick, -MAX_TICK, MAX_TICK));
  90 |     |         vm.assume(maxTick != 0); // todo: fix once maxTick fixes check for 0 tick.
  91 |     | 
  92 |     |         __hyperTestingContract__.changeParameters(poolId, priorityFee, fee, volatility, duration, jit, maxTick);
  93 |     |         HyperCurve memory actual = _getPool(hs(), poolId).params;
  94 |     |         assertEq(actual.priorityFee, priorityFee, "priorityFee");
  95 |     |         assertEq(actual.fee, fee, "fee");
  96 |     |         assertEq(actual.volatility, volatility, "volatility");
  97 |     |         assertEq(actual.duration, duration, "duration");
  98 |     |         assertEq(actual.jit, jit, "jit");
  99 |     |         assertEq(actual.maxTick, maxTick, "maxTick");
 100 |     |     }
 101 |     | 
 102 |     |     function testChangeParametersPriorityFeeSuccess() public {
 103 |     |         uint64 poolId = _createDefaultPool();
 104 |     |         uint16 prev = _getPool(hs(), poolId).params.priorityFee;
 105 |     |         __hyperTestingContract__.changeParameters(poolId, DEFAULT_FEE + 10, DEFAULT_FEE + 20, 0, 0, 0, 0);
 106 |     |         uint16 post = _getPool(hs(), poolId).params.priorityFee;
 107 |     |         assertEq(post, prev + 10, "priority-fee-change");
 108 |     |     }
 109 |     | 
 110 |     |     function testChangeParametersSuccessKeepsPoolSolvency() public {
 111 |     |         uint64 poolId = _createDefaultPool();
 112 |     |         (uint prev0, uint prev1) = __hyperTestingContract__.getVirtualReserves(poolId);
 113 |     |         __hyperTestingContract__.changeParameters(
 114 |     |             poolId,
 115 |     |             0,
 116 |     |             0,
 117 |     |             DEFAULT_VOLATILITY * 2,
 118 |     |             DEFAULT_DURATION + 30,
 119 |     |             0,
 120 |     |             DEFAULT_TICK + 500
 121 |     |         );
 122 |     |         (uint post0, uint post1) = __hyperTestingContract__.getVirtualReserves(poolId);
 123 |     |         assertEq(post0, prev0, "virtual-asset-balance-altered");
 124 |     |         assertEq(post1, prev1, "virtual-quote-balance-altered");
 125 |     |     }
 126 |     | 
 127 |     |     function testChangeParametersNotControllerReverts() public {
 128 |     |         uint64 poolId = _createDefaultPool();
 129 |     |         uint16 failureArg = 1;
 130 |     |         vm.expectRevert(NotController.selector);
 131 |     |         vm.prank(address(0x0006));
 132 |     |         __hyperTestingContract__.changeParameters(
 133 |     |             poolId,
 134 |     |             DEFAULT_FEE,
 135 |     |             DEFAULT_FEE,
 136 |     |             DEFAULT_VOLATILITY,
 137 |     |             DEFAULT_DURATION,
 138 |     |             DEFAULT_JIT,
 139 |     |             DEFAULT_TICK
 140 |     |         );
 141 |     |     }
 142 |     | 
 143 |     |     function testChangeParametersInvalidVolatilityReverts() public {
 144 |     |         uint64 poolId = _createDefaultPool();
 145 |     |         uint16 failureArg = 1;
 146 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));
 147 |     |         __hyperTestingContract__.changeParameters(
 148 |     |             poolId,
 149 |     |             DEFAULT_FEE,
 150 |     |             DEFAULT_FEE,
 151 |     |             1,
 152 |     |             DEFAULT_DURATION,
 153 |     |             DEFAULT_JIT,
 154 |     |             DEFAULT_TICK
 155 |     |         );
 156 |     |     }
 157 |     | 
 158 |     |     function testChangeParametersInvalidDurationReverts() public {
 159 |     |         uint64 poolId = _createDefaultPool();
 160 |     |         uint16 failureArg = 5000;
 161 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDuration.selector, failureArg));
 162 |     |         __hyperTestingContract__.changeParameters(
 163 |     |             poolId,
 164 |     |             DEFAULT_FEE,
 165 |     |             DEFAULT_FEE,
 166 |     |             DEFAULT_VOLATILITY,
 167 |     |             5000,
 168 |     |             DEFAULT_JIT,
 169 |     |             DEFAULT_TICK
 170 |     |         );
 171 |     |     }
 172 |     | 
 173 |     |     function testChangeParametersInvalidTickReverts() public {
 174 |     |         uint64 poolId = _createDefaultPool();
 175 |     |         int24 failureArg = 1000000;
 176 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidTick.selector, uint24(failureArg)));
 177 |     |         __hyperTestingContract__.changeParameters(
 178 |     |             poolId,
 179 |     |             DEFAULT_FEE,
 180 |     |             DEFAULT_FEE,
 181 |     |             DEFAULT_VOLATILITY,
 182 |     |             DEFAULT_DURATION,
 183 |     |             DEFAULT_JIT,
 184 |     |             failureArg
 185 |     |         );
 186 |     |     }
 187 |     | 
 188 |     |     function testChangeParametersInvalidJitReverts() public {
 189 |     |         uint64 poolId = _createDefaultPool();
 190 |     |         uint16 failureArg = 10000;
 191 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidJit.selector, failureArg));
 192 |     |         __hyperTestingContract__.changeParameters(
 193 |     |             poolId,
 194 |     |             DEFAULT_FEE,
 195 |     |             DEFAULT_FEE,
 196 |     |             DEFAULT_VOLATILITY,
 197 |     |             DEFAULT_DURATION,
 198 |     |             failureArg,
 199 |     |             DEFAULT_TICK
 200 |     |         );
 201 |     |     }
 202 |     | 
 203 |     |     function testChangeParametersPriorityFeeAboveFeeReverts() public {
 204 |     |         uint64 poolId = _createDefaultPool();
 205 |     |         HyperCurve memory curve = HyperCurve({
 206 |     |             maxTick: DEFAULT_TICK,
 207 |     |             jit: DEFAULT_JIT,
 208 |     |             fee: 55,
 209 |     |             duration: DEFAULT_DURATION,
 210 |     |             volatility: DEFAULT_VOLATILITY,
 211 |     |             priorityFee: 56,
 212 |     |             createdAt: 100000000
 213 |     |         });
 214 |     |         (, bytes memory revertData) = curve.checkParameters();
 215 |     |         assertEq(revertData, abi.encodeWithSelector(InvalidFee.selector, curve.priorityFee));
 216 |     |         vm.expectRevert(revertData);
 217 |     |         __hyperTestingContract__.changeParameters(
 218 |     |             poolId,
 219 |     |             curve.priorityFee,
 220 |     |             curve.fee,
 221 |     |             curve.volatility,
 222 |     |             curve.duration,
 223 |     |             curve.jit,
 224 |     |             curve.maxTick
 225 |     |         );
 226 |     |     }
 227 |     | 
 228 |     |     function testChangeParametersInvalidFeeReverts() public {
 229 |     |         uint16 failureArg = 2 ** 16 - 10;
 230 |     |         uint64 poolId = _createDefaultPool();
 231 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
 232 |     |         __hyperTestingContract__.changeParameters(
 233 |     |             poolId,
 234 |     |             DEFAULT_FEE,
 235 |     |             failureArg,
 236 |     |             DEFAULT_VOLATILITY,
 237 |     |             DEFAULT_DURATION,
 238 |     |             DEFAULT_JIT,
 239 |     |             DEFAULT_TICK
 240 |     |         );
 241 |     |     }
 242 |     | 
 243 |     |     function _createDefaultPool() internal returns (uint64 poolId) {
 244 |     |         uint24 pairId = uint24(1);
 245 |     |         bytes memory createData = Enigma.encodeCreatePool(
 246 |     |             pairId, // assumes first pair is created
 247 |     |             address(this),
 248 |     |             DEFAULT_FEE,
 249 |     |             DEFAULT_FEE,
 250 |     |             DEFAULT_VOLATILITY,
 251 |     |             DEFAULT_DURATION,
 252 |     |             DEFAULT_JIT,
 253 |     |             DEFAULT_TICK,
 254 |     |             DEFAULT_PRICE
 255 |     |         );
 256 |     |         bool success = __revertCatcher__.process(createData);
 257 |     |         assertTrue(success, "did not create pool");
 258 |     | 
 259 |     |         poolId = Enigma.encodePoolId(pairId, true, uint32(__hyperTestingContract__.getPoolNonce()));
 260 |     |     }
 261 |     | 
 262 |     |     bytes arithmeticError = abi.encodeWithSelector(0x4e487b71, 0x11); // 0x4e487b71 is Panic(uint256), and 0x11 is the panic code for arithmetic overflow.
 263 |     | 
 264 |     |     function testCreateAboveMaxPairs_Reverts() public {
 265 |     |         bytes32 slot = bytes32(uint(5)); // slot is packed so has the pair + pool nonces.
 266 |     |         vm.store(address(__hyperTestingContract__), slot, bytes32(type(uint256).max)); // just set the whole slot of 0xf...
 267 |     |         assertEq(__hyperTestingContract__.getPairNonce(), type(uint24).max, "not set to max value");
 268 |     |         address token = address(new TestERC20("t", "t", 18));
 269 |     |         bytes memory payload = Enigma.encodeCreatePair(address(defaultScenario.asset), token);
 270 |     |         vm.expectRevert(arithmeticError);
 271 |     |         bool success = __revertCatcher__.process(payload);
 272 |     |         assertTrue(!success, "created a pair at max pairId");
 273 |     |     }
 274 |     | 
 275 |     |     function testCreateAboveMaxPools_Reverts() public {
 276 |     |         bytes32 slot = bytes32(uint(5)); // slot is packed so has the pair + pool nonces.
 277 |     |         vm.store(address(__hyperTestingContract__), slot, bytes32(type(uint256).max)); // just set the whole slot of 0xf...
 278 |     |         assertEq(__hyperTestingContract__.getPoolNonce(), type(uint32).max, "not set to max value");
 279 |     | 
 280 |     |         address token = address(new TestERC20("t", "t", 18));
 281 |     |         bytes memory data = Enigma.encodeCreatePool(uint24(1), address(0), 1, 100, 100, 100, 100, 100, 100);
 282 |     | 
 283 |     |         vm.expectRevert(arithmeticError);
 284 |     |         bool success = __revertCatcher__.process(data);
 285 |     |         assertTrue(!success, "created a pool at max poolId");
 286 |     |     }
 287 |     | }
 288 |     | 

/root/code/hyper/test/foundry/TestHyperDeploy.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Vm.sol";
  5 |     | import "./setup/TestHyperSetup.sol";
  6 |     | 
  7 |     | contract TestHyperDeploy is TestHyperSetup {
  8 |     |     event Deployed(string, address);
  9 |     | 
 10 |     |     function testDeploy() public {
 11 |     |         address weth = address(new WETH());
 12 |     |         address usdc = address(new TestERC20("USDC", "USD Coin", 6));
 13 |     |         Hyper hyper = new Hyper(weth);
 14 |     | 
 15 |     |         emit Deployed("Deployed weth at: ", weth);
 16 |     |         emit Deployed("Deployed hyper at: ", address(hyper));
 17 |     |         emit Deployed("Deployed usdc at: ", usdc);
 18 |     | 
 19 |     |         assertEq(hyper.WETH(), weth, "weth address");
 20 |     |         (, bool settled) = hyper.__account__();
 21 |     |         assertTrue(settled, "settled");
 22 |     | 
 23 |     |         assertTrue(bytes32(abi.encodePacked(hyper.VERSION())) == bytes32(abi.encodePacked("beta-v0.1.0")));
 24 |     |     }
 25 |     | }
 26 |     | 

/root/code/hyper/test/foundry/TestHyperDeposit.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Vm.sol";
  5 |     | import "./setup/TestHyperSetup.sol";
  6 |     | 
  7 |     | contract TestHyperDeposit is TestHyperSetup {
  8 |     |     function testDepositMsgValueZero_reverts() public {
  9 |     |         vm.expectRevert(ZeroValue.selector);
 10 |     |         __hyperTestingContract__.deposit{value: 0}();
 11 |     |     }
 12 |     | 
 13 |     |     function testDepositWethTotalSupplyReturnsMsgValue() public {
 14 |     |         uint pre = __weth__.totalSupply();
 15 |     |         __hyperTestingContract__.deposit{value: 100}();
 16 |     |         uint post = __weth__.totalSupply();
 17 |     |         uint delta = post - pre;
 18 |     |         assertEq(post, 100, "ts");
 19 |     |         assertEq(delta, 100, "del");
 20 |     |     }
 21 |     | 
 22 |     |     function testDepositCallersBalanceReturnsMsgValue() public {
 23 |     |         uint pre = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 24 |     |         __hyperTestingContract__.deposit{value: 100}();
 25 |     |         uint post = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 26 |     |         uint delta = post - pre;
 27 |     |         assertEq(post, 100, "ts");
 28 |     |         assertEq(delta, 100, "del");
 29 |     |     }
 30 |     | 
 31 |     |     function testDepositEtherBalanceReturnsZero() public {
 32 |     |         __hyperTestingContract__.deposit{value: 100}();
 33 |     |         uint actual = address(__hyperTestingContract__).balance;
 34 |     |         assertEq(actual, 0, "balance");
 35 |     |     }
 36 |     | 
 37 |     |     function testDepositWethReservesReturnsMsgValue() public {
 38 |     |         uint pre = getReserve(address(__hyperTestingContract__), address(__weth__));
 39 |     |         __hyperTestingContract__.deposit{value: 100}();
 40 |     |         uint post = getReserve(address(__hyperTestingContract__), address(__weth__));
 41 |     |         uint delta = post - pre;
 42 |     |         assertEq(post, 100, "ts");
 43 |     |         assertEq(delta, 100, "del");
 44 |     |     }
 45 |     | 
 46 |     |     function testDepositBalanceOfWethReturnsMsgValue() public {
 47 |     |         __hyperTestingContract__.deposit{value: 100}();
 48 |     |         uint actual = __weth__.balanceOf(address(__hyperTestingContract__));
 49 |     |         assertEq(actual, 100, "balance");
 50 |     |     }
 51 |     | 
 52 |     |     function testDepositWrapsEther() public postTestInvariantChecks {
 53 |     |         uint prevWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));
 54 |     |         uint prevBalance = address(this).balance;
 55 |     |         __hyperTestingContract__.deposit{value: 4000}();
 56 |     |         uint nextBalance = address(this).balance;
 57 |     |         uint nextWethBalance = __weth__.balanceOf(address(__hyperTestingContract__));
 58 |     | 
 59 |     |         assertTrue(nextBalance < prevBalance);
 60 |     |         assertTrue(nextWethBalance > prevWethBalance);
 61 |     |     }
 62 |     | 
 63 |     |     function testDepositIncreasesUserBalance() public postTestInvariantChecks {
 64 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 65 |     |         __hyperTestingContract__.deposit{value: 4000}();
 66 |     |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(__weth__));
 67 |     | 
 68 |     |         assertTrue(nextBalance > prevBalance, "balance-not-increased");
 69 |     |     }
 70 |     | 
 71 |     |     event Deposit(address indexed account, uint amount);
 72 |     | 
 73 |     |     function testDepositWrapsEther_emit_Deposit() public {
 74 |     |         vm.expectEmit(true, true, false, true, address(__hyperTestingContract__));
 75 |     |         emit Deposit(address(this), 4000);
 76 |     |         __hyperTestingContract__.deposit{value: 4000}();
 77 |     |     }
 78 |     | 
 79 |     |     event IncreaseUserBalance(address indexed account, address indexed token, uint256 amount);
 80 |     | 
 81 |     |     function testDepositWrapsEther_emit_IncreaseUserBalance() public {
 82 |     |         vm.expectEmit(true, true, true, true, address(__hyperTestingContract__));
 83 |     |         emit IncreaseUserBalance(address(this), address(__weth__), 4000);
 84 |     |         __hyperTestingContract__.deposit{value: 4000}();
 85 |     |     }
 86 |     | }
 87 |     | 

/root/code/hyper/test/foundry/TestHyperDraw.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | 
  6 |     | contract TestHyperDraw is TestHyperSetup {
  7 |     |     function testDrawReducesBalance() public postTestInvariantChecks {
  8 |     |         // Fund the account
  9 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);
 10 |     | 
 11 |     |         // Draw
 12 |     |         uint prevReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
 13 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 14 |     |         __hyperTestingContract__.draw(address(defaultScenario.asset), 4000, address(this));
 15 |     |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 16 |     |         uint nextReserve = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
 17 |     | 
 18 |     |         assertTrue(nextBalance == 0);
 19 |     |         assertTrue(nextBalance < prevBalance);
 20 |     |         assertTrue(nextReserve < prevReserve);
 21 |     |     }
 22 |     | 
 23 |     |     function testDrawRevertsWithDrawBalance() public {
 24 |     |         vm.expectRevert(DrawBalance.selector);
 25 |     |         __hyperTestingContract__.draw(address(defaultScenario.asset), 1e18, address(this));
 26 |     |     }
 27 |     | 
 28 |     |     function testDrawFromWethTransfersEther() public postTestInvariantChecks {
 29 |     |         // First fund the account
 30 |     |         __hyperTestingContract__.deposit{value: 4000}();
 31 |     | 
 32 |     |         // Draw
 33 |     |         uint prevBalance = address(this).balance;
 34 |     |         __hyperTestingContract__.draw(address(__weth__), 4000, address(this));
 35 |     |         uint nextBalance = address(this).balance;
 36 |     | 
 37 |     |         assertTrue(nextBalance > prevBalance);
 38 |     |     }
 39 |     | }
 40 |     | 

/root/code/hyper/test/foundry/TestHyperFund.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | 
  6 |     | contract TestHyperFund is TestHyperSetup {
  7 |     |     function testFundIncreasesBalance() public postTestInvariantChecks {
  8 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  9 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), 4000);
 10 |     |         uint nextBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 11 |     | 
 12 |     |         assertTrue(nextBalance > prevBalance, "increase-internal-bal");
 13 |     |     }
 14 |     | 
 15 |     |     function testFuzzFundDrawSuccessful(uint128 amount) public {
 16 |     |         vm.assume(amount > 0);
 17 |     |         _assertFundDraw(amount);
 18 |     |     }
 19 |     | 
 20 |     |     function _assertFundDraw(uint amount) internal {
 21 |     |         // Preconditions
 22 |     |         defaultScenario.asset.approve(address(__hyperTestingContract__), amount);
 23 |     |         deal(address(defaultScenario.asset), address(this), amount);
 24 |     | 
 25 |     |         // Execution
 26 |     |         uint preBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 27 |     |         HyperState memory prev = getState();
 28 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), amount);
 29 |     |         HyperState memory post = getState();
 30 |     |         uint postBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 31 |     | 
 32 |     |         // Post conditions
 33 |     |         assertTrue(postBal > preBal, "bal-increase");
 34 |     |         assertEq(postBal, preBal + amount, "bal-increase-exact");
 35 |     |         assertEq(post.reserveAsset, prev.reserveAsset + amount, "reserve-increase");
 36 |     |         assertEq(post.physicalBalanceAsset, prev.physicalBalanceAsset + amount, "physical-increase");
 37 |     |         assertEq(post.totalBalanceAsset, prev.totalBalanceAsset + amount, "total-bal-increase");
 38 |     | 
 39 |     |         __hyperTestingContract__.draw(address(defaultScenario.asset), amount, address(this));
 40 |     |         HyperState memory end = getState();
 41 |     |         uint endBal = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
 42 |     | 
 43 |     |         assertEq(endBal, preBal, "reverse-exact-bal");
 44 |     |         assertEq(end.reserveAsset, prev.reserveAsset, "reverse-exact-reserve");
 45 |     |         assertEq(end.physicalBalanceAsset, prev.physicalBalanceAsset, "reverse-exact-physical");
 46 |     |     }
 47 |     | }
 48 |     | 

/root/code/hyper/test/foundry/TestHyperProcessing.t.sol
    1 |     | // SPDX-License-Identifier: UNLICENSED
    2 |     | pragma solidity 0.8.13;
    3 |     | 
    4 |     | import "contracts/HyperLib.sol" as HyperTypes;
    5 |     | import "./setup/TestHyperSetup.sol";
    6 |     | 
    7 |     | contract TestHyperProcessing is TestHyperSetup {
    8 |     |     using SafeCastLib for uint;
    9 |     | 
   10 |     |     function afterSetUp() public override {
   11 |     |         assertTrue(
   12 |     |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp != 0,
   13 |     |             "Pool not created"
   14 |     |         );
   15 |     |         assertTrue(
   16 |     |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick != 0,
   17 |     |             "Pool not initialized with price"
   18 |     |         );
   19 |     |         assertTrue(
   20 |     |             getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity == 0,
   21 |     |             "Pool initialized with liquidity"
   22 |     |         );
   23 |     |     }
   24 |     | 
   25 |     |     // ===== Getters ===== //
   26 |     | 
   27 |     |     function testGetAmounts() public {
   28 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
   29 |     |         HyperCurve memory curve = pool.params;
   30 |     |         (uint deltaAsset, uint deltaQuote) = __hyperTestingContract__.getAmounts(defaultScenario.poolId);
   31 |     |         uint maxDelta = 0.001 ether; // 1ether = 100%, 0.001 ether = 0.10%
   32 |     |         assertApproxEqRel(
   33 |     |             deltaAsset,
   34 |     |             Assembly.scaleFromWadDown(DEFAULT_ASSET_RESERVE, pool.pair.decimalsAsset),
   35 |     |             maxDelta,
   36 |     |             "asset-reserve"
   37 |     |         ); // todo: fix default amounts
   38 |     |         assertApproxEqRel(
   39 |     |             deltaQuote,
   40 |     |             Assembly.scaleFromWadDown(DEFAULT_QUOTE_RESERVE, pool.pair.decimalsQuote),
   41 |     |             maxDelta,
   42 |     |             "quote-reserve"
   43 |     |         );
   44 |     |     }
   45 |     | 
   46 |     |     function testGetLiquidityMinted() public {
   47 |     |         uint deltaLiquidity = __hyperTestingContract__.getMaxLiquidity(defaultScenario.poolId, 1, 1e19);
   48 |     |     }
   49 |     | 
   50 |     |     // ===== Enigma ===== //
   51 |     | 
   52 |     |     function testJumpProcessCreatesPair() public {
   53 |     |         bytes[] memory instructions = new bytes[](1);
   54 |     |         instructions[0] = (Enigma.encodeCreatePair(address(__token_8__), address(defaultScenario.quote)));
   55 |     |         bytes memory data = Enigma.encodeJumpInstruction(instructions);
   56 |     |         bool success = __revertCatcher__.jumpProcess(data);
   57 |     |         assertTrue(success);
   58 |     | 
   59 |     |         uint24 pairId = uint16(__hyperTestingContract__.getPairNonce());
   60 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);
   61 |     |         assertTrue(pair.tokenAsset != address(0));
   62 |     |         assertTrue(pair.tokenQuote != address(0));
   63 |     |     }
   64 |     | 
   65 |     |     function testProcessRevertsWithInvalidInstructionZeroOpcode() public {
   66 |     |         vm.expectRevert(InvalidInstruction.selector);
   67 |     |         __revertCatcher__.process(hex"00");
   68 |     |     }
   69 |     | 
   70 |     |     function testProcessRevertsWithInvalidInstruction() public {
   71 |     |         vm.expectRevert(InvalidInstruction.selector);
   72 |     |         __revertCatcher__.process(hex"44");
   73 |     |     }
   74 |     | 
   75 |     |     // ===== Effects ===== //
   76 |     | 
   77 |     |     // --- Swap --- //
   78 |     | 
   79 |     |     function testSwapExactInNonExistentPoolIdReverts() public {
   80 |     |         uint64 failureArg = uint64(0x01);
   81 |     |         bytes memory data = Enigma.encodeSwap(0, failureArg, 0x01, 0x01, 0x01, 0x01, 0);
   82 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
   83 |     |         bool success = __revertCatcher__.process(data);
   84 |     |         assertTrue(!success);
   85 |     |     }
   86 |     | 
   87 |     |     function testSwapExactInZeroSwapAmountReverts() public {
   88 |     |         uint128 failureArg = 0;
   89 |     |         bytes memory data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, failureArg, 0x01, 0x01, 0);
   90 |     |         vm.expectRevert(ZeroInput.selector);
   91 |     |         bool success = __revertCatcher__.process(data);
   92 |     |         assertTrue(!success);
   93 |     |     }
   94 |     | 
   95 |     |     function testSwapExactInPoolPriceUpdated() public postTestInvariantChecks {
   96 |     |         // Add liquidity first
   97 |     |         bytes memory data = Enigma.encodeAllocate(
   98 |     |             0,
   99 |     |             defaultScenario.poolId,
  100 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  101 |     |             0x01
  102 |     |         );
  103 |     |         bool success = __revertCatcher__.process(data);
  104 |     |         assertTrue(success);
  105 |     |         // move some time
  106 |     |         customWarp(block.timestamp + 1);
  107 |     | 
  108 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
  109 |     | 
  110 |     |         uint8 useMax = 0;
  111 |     |         uint8 direction = 0;
  112 |     |         uint128 input = 2e18;
  113 |     |         uint128 output = helperGetAmountOut(
  114 |     |             address(__hyperTestingContract__),
  115 |     |             defaultScenario.poolId,
  116 |     |             direction == 0,
  117 |     |             input
  118 |     |         ).safeCastTo128();
  119 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  120 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, output, direction);
  121 |     |         success = __revertCatcher__.process(data);
  122 |     |         assertTrue(success);
  123 |     | 
  124 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
  125 |     |         assertTrue(next != prev);
  126 |     |     }
  127 |     | 
  128 |     |     /* function testSwapExactInPoolSlotIndexUpdated() public {
  129 |     |         // Add liquidity first
  130 |     |         bytes memory data = Enigma.encodeAllocate(
  131 |     |             0,
  132 |     |             defaultScenario.poolId,
  133 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  134 |     |             0x01
  135 |     |         );
  136 |     |         bool success = __revertCatcher__.process(data);
  137 |     |         assertTrue(success);
  138 |     |         // move some time
  139 |     |         customWarp(block.timestamp + 1);
  140 |     | 
  141 |     |         int256 prev = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;
  142 |     | 
  143 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  144 |     |         data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x12, 0x02, 0x1f, 0x01, 0);
  145 |     |         success = __revertCatcher__.process(data);
  146 |     |         assertTrue(success);
  147 |     | 
  148 |     |         int256 next = getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick;
  149 |     |         assertTrue(next != prev);
  150 |     |     } */
  151 |     | 
  152 |     |     function testSwapUseMax() public postTestInvariantChecks {
  153 |     |         uint amount = type(uint256).max;
  154 |     |         uint limit = amount;
  155 |     |         // Add liquidity first
  156 |     |         bytes memory data = Enigma.encodeAllocate(
  157 |     |             0,
  158 |     |             defaultScenario.poolId,
  159 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  160 |     |             0x01
  161 |     |         );
  162 |     |         bool success = __revertCatcher__.process(data);
  163 |     |         assertTrue(success);
  164 |     | 
  165 |     |         // move some time
  166 |     |         customWarp(block.timestamp + 1);
  167 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  168 |     |         bool direction = true;
  169 |     |         uint internalBalance = 0.5 ether;
  170 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), internalBalance);
  171 |     |         uint prevBalance = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  172 |     |         uint128 input = internalBalance.safeCastTo128();
  173 |     |         uint128 output = helperGetAmountOut(address(__hyperTestingContract__), defaultScenario.poolId, direction, input)
  174 |     |             .safeCastTo128();
  175 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, output);
  176 |     | 
  177 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  178 |     |         assertTrue(next == prev);
  179 |     |     }
  180 |     | 
  181 |     |     function testSwapInQuote() public postTestInvariantChecks {
  182 |     |         uint limit = type(uint256).max;
  183 |     |         uint amount = 2222;
  184 |     |         // Add liquidity first
  185 |     |         bytes memory data = Enigma.encodeAllocate(
  186 |     |             0,
  187 |     |             defaultScenario.poolId,
  188 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  189 |     |             0x01
  190 |     |         );
  191 |     |         bool success = __revertCatcher__.process(data);
  192 |     |         assertTrue(success);
  193 |     | 
  194 |     |         // move some time
  195 |     |         customWarp(block.timestamp + 1);
  196 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  197 |     |         bool direction = false;
  198 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, direction, amount, getMaxSwapLimit(direction));
  199 |     | 
  200 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  201 |     |         assertTrue(next == prev);
  202 |     |     }
  203 |     | 
  204 |     |     function testSwapReverse() public {
  205 |     |         bool direction = true;
  206 |     |         uint limit = type(uint256).max;
  207 |     |         uint amount = 17e16;
  208 |     |         // Add liquidity first
  209 |     |         /* bytes memory data = Enigma.encodeAllocate(
  210 |     |             0,
  211 |     |             defaultScenario.poolId,
  212 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  213 |     |             0x01
  214 |     |         );
  215 |     |         bool success = __revertCatcher__.process(data);
  216 |     |         assertTrue(success); */
  217 |     |         allocatePool(address(__hyperTestingContract__), defaultScenario.poolId, 10e19);
  218 |     | 
  219 |     |         // deposit first
  220 |     |         __hyperTestingContract__.fund(address(defaultScenario.asset), amount);
  221 |     |         uint256 prev = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  222 |     | 
  223 |     |         (uint output, ) = __hyperTestingContract__.swap(
  224 |     |             defaultScenario.poolId,
  225 |     |             direction,
  226 |     |             amount,
  227 |     |             getMaxSwapLimit(direction)
  228 |     |         );
  229 |     |         direction = false;
  230 |     |         (uint input, ) = __hyperTestingContract__.swap(
  231 |     |             defaultScenario.poolId,
  232 |     |             direction,
  233 |     |             output,
  234 |     |             getMaxSwapLimit(direction)
  235 |     |         );
  236 |     | 
  237 |     |         uint256 next = getBalance(address(__hyperTestingContract__), address(this), address(defaultScenario.asset));
  238 |     |         assertTrue(next <= prev, "invalid-user-gained-balance");
  239 |     |         assertTrue(input < amount, "invalid-invariant-got-more-out");
  240 |     |     }
  241 |     | 
  242 |     |     function testSwapExpiredPoolReverts() public {
  243 |     |         uint limit = type(uint256).max;
  244 |     |         uint amount = 2222;
  245 |     |         // Add liquidity first
  246 |     |         bytes memory data = Enigma.encodeAllocate(
  247 |     |             0,
  248 |     |             defaultScenario.poolId,
  249 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  250 |     |             0x01
  251 |     |         );
  252 |     |         bool success = __revertCatcher__.process(data);
  253 |     |         assertTrue(success);
  254 |     | 
  255 |     |         // move some time beyond maturity
  256 |     |         customWarp(
  257 |     |             block.timestamp +
  258 |     |                 getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(
  259 |     |                     __hyperTestingContract__.timestamp()
  260 |     |                 ) +
  261 |     |                 1
  262 |     |         );
  263 |     | 
  264 |     |         vm.expectRevert(PoolExpired.selector);
  265 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, false, amount, limit);
  266 |     |     }
  267 |     | 
  268 |     |     function testSwapExactInPoolLiquidityUnchanged() public postTestInvariantChecks {
  269 |     |         // Add liquidity first
  270 |     |         bytes memory data = Enigma.encodeAllocate(
  271 |     |             0,
  272 |     |             defaultScenario.poolId,
  273 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  274 |     |             0x01
  275 |     |         );
  276 |     |         bool success = __revertCatcher__.process(data);
  277 |     |         assertTrue(success);
  278 |     |         // move some time
  279 |     |         customWarp(block.timestamp + 1);
  280 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  281 |     | 
  282 |     |         uint8 useMax = 0;
  283 |     |         uint8 direction = 0;
  284 |     |         uint128 input = 2e18;
  285 |     |         uint128 output = helperGetAmountOut(
  286 |     |             address(__hyperTestingContract__),
  287 |     |             defaultScenario.poolId,
  288 |     |             direction == 0,
  289 |     |             input
  290 |     |         ).safeCastTo128();
  291 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  292 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, output, direction);
  293 |     |         success = __revertCatcher__.process(data);
  294 |     |         assertTrue(success);
  295 |     | 
  296 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity;
  297 |     |         assertTrue(next == prev);
  298 |     |     }
  299 |     | 
  300 |     |     function testSwapExactInPoolTimestampUpdated() public postTestInvariantChecks {
  301 |     |         // Add liquidity first
  302 |     |         bytes memory data = Enigma.encodeAllocate(
  303 |     |             0,
  304 |     |             defaultScenario.poolId,
  305 |     |             0x13, // 19 zeroes, so 10e19 liquidity, note: 0x0a amount breaks test? todo: handle case where insufficient liquidity
  306 |     |             0x01
  307 |     |         );
  308 |     |         bool success = __revertCatcher__.process(data);
  309 |     |         assertTrue(success);
  310 |     |         // move some time
  311 |     |         customWarp(block.timestamp + 1);
  312 |     | 
  313 |     |         uint256 prev = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;
  314 |     |         uint8 useMax = 0;
  315 |     |         uint8 direction = 0;
  316 |     |         uint128 input = 2e18;
  317 |     |         uint128 output = helperGetAmountOut(
  318 |     |             address(__hyperTestingContract__),
  319 |     |             defaultScenario.poolId,
  320 |     |             direction == 0,
  321 |     |             input
  322 |     |         ).safeCastTo128();
  323 |     | 
  324 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  325 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, output, direction);
  326 |     |         success = __revertCatcher__.process(data);
  327 |     |         assertTrue(success);
  328 |     | 
  329 |     |         uint256 next = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTimestamp;
  330 |     |         assertTrue(next != prev);
  331 |     |     }
  332 |     | 
  333 |     |     function testSwapExactInGlobalAssetBalanceIncreases() public postTestInvariantChecks {
  334 |     |         // Add liquidity first
  335 |     |         bytes memory data = Enigma.encodeAllocate(
  336 |     |             0,
  337 |     |             defaultScenario.poolId,
  338 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  339 |     |             0x01
  340 |     |         );
  341 |     |         bool success = __revertCatcher__.process(data);
  342 |     |         assertTrue(success);
  343 |     |         // move some time
  344 |     |         customWarp(block.timestamp + 1);
  345 |     | 
  346 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  347 |     | 
  348 |     |         uint8 useMax = 0;
  349 |     |         uint8 direction = 0;
  350 |     |         uint128 input = 2e18;
  351 |     |         uint128 output = helperGetAmountOut(
  352 |     |             address(__hyperTestingContract__),
  353 |     |             defaultScenario.poolId,
  354 |     |             direction == 0,
  355 |     |             input
  356 |     |         ).safeCastTo128();
  357 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  358 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, output, direction);
  359 |     |         success = __revertCatcher__.process(data);
  360 |     |         assertTrue(success);
  361 |     | 
  362 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  363 |     |         assertTrue(next > prev);
  364 |     |     }
  365 |     | 
  366 |     |     function testSwapExactInGlobalQuoteBalanceDecreases() public postTestInvariantChecks {
  367 |     |         // Add liquidity first
  368 |     |         bytes memory data = Enigma.encodeAllocate(
  369 |     |             0,
  370 |     |             defaultScenario.poolId,
  371 |     |             0x13, // 19 zeroes, so 10e19 liquidity
  372 |     |             0x01
  373 |     |         );
  374 |     |         bool success = __revertCatcher__.process(data);
  375 |     |         assertTrue(success);
  376 |     |         // move some time
  377 |     |         customWarp(block.timestamp + 1);
  378 |     | 
  379 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  380 |     | 
  381 |     |         uint8 useMax = 0;
  382 |     |         uint8 direction = 0;
  383 |     |         uint128 input = 2e18;
  384 |     |         uint128 output = helperGetAmountOut(
  385 |     |             address(__hyperTestingContract__),
  386 |     |             defaultScenario.poolId,
  387 |     |             direction == 0,
  388 |     |             input
  389 |     |         ).safeCastTo128();
  390 |     |         // need to swap a large amount so we cross slots. This is 2e18. 0x12 = 18 10s, 0x02 = 2
  391 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x12, 0x02, 0x0, output, direction);
  392 |     |         success = __revertCatcher__.process(data);
  393 |     |         assertTrue(success, "swap failed");
  394 |     | 
  395 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  396 |     |         assertTrue(next == prev, "reserves-changed");
  397 |     |     }
  398 |     | 
  399 |     |     // --- Allocate --- //
  400 |     | 
  401 |     |     function testAllocateNonExistentPoolIdReverts() public {
  402 |     |         uint64 failureArg = uint64(48);
  403 |     |         bytes memory data = Enigma.encodeAllocate(0, failureArg, 0x01, 0x01);
  404 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  405 |     |         bool success = __revertCatcher__.process(data);
  406 |     |         assertTrue(!success, "forwarder call failed");
  407 |     |     }
  408 |     | 
  409 |     |     function testAllocateZeroLiquidityReverts() public {
  410 |     |         uint8 failureArg = 0;
  411 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, 0x00, failureArg);
  412 |     |         vm.expectRevert(ZeroLiquidity.selector);
  413 |     |         bool success = __revertCatcher__.process(data);
  414 |     |         assertTrue(!success, "forwarder call failed");
  415 |     |     }
  416 |     | 
  417 |     |     function testProcessAllocateFull() public postTestInvariantChecks {
  418 |     |         uint256 price = getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastPrice;
  419 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), (defaultScenario.poolId));
  420 |     |         uint tau = getPool(address(__hyperTestingContract__), defaultScenario.poolId).tau(
  421 |     |             __hyperTestingContract__.timestamp()
  422 |     |         );
  423 |     |         uint strike = Price.computePriceWithTick(curve.maxTick);
  424 |     |         console.log(tau, strike, curve.volatility);
  425 |     |         uint256 theoreticalR2 = Price.getXWithPrice(price, strike, curve.volatility, tau);
  426 |     | 
  427 |     |         uint8 power = uint8(0x06); // 6 zeroes
  428 |     |         uint8 amount = uint8(0x04); // 4 with 6 zeroes = 4_000_000 wei
  429 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  430 |     | 
  431 |     |         __revertCatcher__.process(data);
  432 |     | 
  433 |     |         uint delLiquidity = 4_000_000;
  434 |     |         uint256 globalR1 = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  435 |     |         uint256 globalR2 = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  436 |     |         assertTrue(globalR1 > 0);
  437 |     |         assertTrue(globalR2 > 0);
  438 |     |         uint expected = (theoreticalR2 * delLiquidity) / 1e18;
  439 |     |         console.log("expected", expected);
  440 |     |         console.log("globalR2", globalR2);
  441 |     |         // todo: fix this test
  442 |     |         assertApproxEqAbs(globalR2, expected, 1e2, "asset-reserve-theoretic"); // todo: fix, should it be this far?
  443 |     |     }
  444 |     | 
  445 |     |     function testAllocatePositionTimestampUpdated() public postTestInvariantChecks {
  446 |     |         uint64 positionId = defaultScenario.poolId;
  447 |     | 
  448 |     |         uint256 prevPositionTimestamp = getPosition(
  449 |     |             address(__hyperTestingContract__),
  450 |     |             address(__revertCatcher__),
  451 |     |             positionId
  452 |     |         ).lastTimestamp;
  453 |     | 
  454 |     |         uint8 amount = 0x01;
  455 |     |         uint8 power = 0x01;
  456 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  457 |     |         bool success = __revertCatcher__.process(data);
  458 |     |         assertTrue(success, "forwarder call failed");
  459 |     | 
  460 |     |         uint256 nextPositionTimestamp = getPosition(
  461 |     |             address(__hyperTestingContract__),
  462 |     |             address(__revertCatcher__),
  463 |     |             positionId
  464 |     |         ).lastTimestamp;
  465 |     | 
  466 |     |         assertTrue(prevPositionTimestamp == 0);
  467 |     |         assertTrue(nextPositionTimestamp > prevPositionTimestamp && nextPositionTimestamp == block.timestamp);
  468 |     |     }
  469 |     | 
  470 |     |     function testAllocatePositionfreeLiquidityIncreases() public postTestInvariantChecks {
  471 |     |         uint64 positionId = defaultScenario.poolId;
  472 |     | 
  473 |     |         uint256 prevPositionfreeLiquidity = getPosition(
  474 |     |             address(__hyperTestingContract__),
  475 |     |             address(__revertCatcher__),
  476 |     |             positionId
  477 |     |         ).freeLiquidity;
  478 |     | 
  479 |     |         uint8 amount = 0x01;
  480 |     |         uint8 power = 0x01;
  481 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  482 |     |         bool success = __revertCatcher__.process(data);
  483 |     |         assertTrue(success, "forwarder call failed");
  484 |     | 
  485 |     |         uint256 nextPositionfreeLiquidity = getPosition(
  486 |     |             address(__hyperTestingContract__),
  487 |     |             address(__revertCatcher__),
  488 |     |             positionId
  489 |     |         ).freeLiquidity;
  490 |     | 
  491 |     |         assertTrue(prevPositionfreeLiquidity == 0);
  492 |     |         assertTrue(nextPositionfreeLiquidity > prevPositionfreeLiquidity);
  493 |     |     }
  494 |     | 
  495 |     |     function testAllocateGlobalAssetIncreases() public postTestInvariantChecks {
  496 |     |         uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  497 |     | 
  498 |     |         uint8 amount = 0x01;
  499 |     |         uint8 power = 0x01;
  500 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  501 |     |         bool success = __revertCatcher__.process(data);
  502 |     |         assertTrue(success, "forwarder call failed");
  503 |     | 
  504 |     |         uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  505 |     |         assertTrue(nextGlobal != 0, "next globalReserves is zero");
  506 |     |         assertTrue(nextGlobal > prevGlobal, "globalReserves did not change");
  507 |     |     }
  508 |     | 
  509 |     |     function testAllocateGlobalQuoteIncreases() public postTestInvariantChecks {
  510 |     |         uint256 prevGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  511 |     | 
  512 |     |         uint8 amount = 0x01;
  513 |     |         uint8 power = 0x01;
  514 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  515 |     |         bool success = __revertCatcher__.process(data);
  516 |     |         assertTrue(success, "forwarder call failed");
  517 |     | 
  518 |     |         uint256 nextGlobal = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  519 |     |         assertTrue(nextGlobal != 0, "next globalReserves is zero");
  520 |     |         assertTrue(nextGlobal > prevGlobal, "globalReserves did not change");
  521 |     |     }
  522 |     | 
  523 |     |     // --- Remove Liquidity --- //
  524 |     | 
  525 |     |     function testUnallocateZeroLiquidityReverts() public {
  526 |     |         bytes memory data = Enigma.encodeUnallocate(0, defaultScenario.poolId, 0x00, 0x00);
  527 |     |         vm.expectRevert(ZeroLiquidity.selector);
  528 |     |         bool success = __revertCatcher__.process(data);
  529 |     |         assertTrue(!success);
  530 |     |     }
  531 |     | 
  532 |     |     function testUnallocateNonExistentPoolReverts() public {
  533 |     |         uint64 failureArg = 42;
  534 |     |         bytes memory data = Enigma.encodeUnallocate(0, 42, 0x01, 0x01);
  535 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  536 |     |         bool success = __revertCatcher__.process(data);
  537 |     |         assertTrue(!success);
  538 |     |     }
  539 |     | 
  540 |     |     // needs a mutable pool, or a pool with a non-zero jit policy
  541 |     |     function testUnallocatePositionJitPolicyReverts() public postTestInvariantChecks {
  542 |     |         uint16 jit = 99;
  543 |     |         bytes memory createData = Enigma.encodeCreatePool(
  544 |     |             uint24(1), // pairId
  545 |     |             address(this), // controller
  546 |     |             DEFAULT_FEE,
  547 |     |             DEFAULT_FEE,
  548 |     |             uint16(DEFAULT_SIGMA),
  549 |     |             DEFAULT_DURATION_DAYS,
  550 |     |             jit,
  551 |     |             DEFAULT_TICK,
  552 |     |             DEFAULT_PRICE
  553 |     |         );
  554 |     | 
  555 |     |         bool success = __revertCatcher__.process(createData);
  556 |     |         assertTrue(success, "forwarder call failed");
  557 |     | 
  558 |     |         uint64 poolId = Enigma.encodePoolId(uint24(0x01), true, uint32(__hyperTestingContract__.getPoolNonce()));
  559 |     | 
  560 |     |         uint8 amount = 0x01;
  561 |     |         uint8 power = 0x01;
  562 |     |         bytes memory data = Enigma.encodeAllocate(0, poolId, power, amount);
  563 |     |         success = __revertCatcher__.process(data);
  564 |     |         assertTrue(success, "forwarder call failed");
  565 |     | 
  566 |     |         // Set the distance for the position by warping in time.
  567 |     |         uint256 distance = 22;
  568 |     |         uint256 warpTimestamp = block.timestamp + distance;
  569 |     |         customWarp(warpTimestamp);
  570 |     | 
  571 |     |         data = Enigma.encodeUnallocate(0, poolId, power, amount);
  572 |     | 
  573 |     |         vm.expectRevert(abi.encodeWithSelector(JitLiquidity.selector, distance));
  574 |     |         success = __revertCatcher__.process(data);
  575 |     |         assertTrue(!success, "Should not suceed in testUnllocatePositionJit");
  576 |     |     }
  577 |     | 
  578 |     |     function testUnallocatePositionTimestampUpdated() public postTestInvariantChecks {
  579 |     |         int24 hiTick = DEFAULT_TICK;
  580 |     |         int24 loTick = DEFAULT_TICK - 256;
  581 |     |         uint8 amount = 0x01;
  582 |     |         uint8 power = 0x01;
  583 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  584 |     |         bool success = __revertCatcher__.process(data);
  585 |     |         assertTrue(success, "forwarder call failed");
  586 |     | 
  587 |     |         uint64 positionId = defaultScenario.poolId;
  588 |     |         uint256 prevPositionTimestamp = getPosition(
  589 |     |             address(__hyperTestingContract__),
  590 |     |             address(__revertCatcher__),
  591 |     |             positionId
  592 |     |         ).lastTimestamp;
  593 |     | 
  594 |     |         uint256 warpTimestamp = block.timestamp + 1;
  595 |     |         customWarp(warpTimestamp);
  596 |     | 
  597 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  598 |     |         success = __revertCatcher__.process(data);
  599 |     | 
  600 |     |         uint256 nextPositionTimestamp = getPosition(
  601 |     |             address(__hyperTestingContract__),
  602 |     |             address(__revertCatcher__),
  603 |     |             positionId
  604 |     |         ).lastTimestamp;
  605 |     | 
  606 |     |         assertTrue(nextPositionTimestamp > prevPositionTimestamp && nextPositionTimestamp == warpTimestamp);
  607 |     |     }
  608 |     | 
  609 |     |     function testUnallocatePositionfreeLiquidityDecreases() public postTestInvariantChecks {
  610 |     |         int24 hiTick = DEFAULT_TICK;
  611 |     |         int24 loTick = DEFAULT_TICK - 256;
  612 |     |         uint8 amount = 0x01;
  613 |     |         uint8 power = 0x01;
  614 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  615 |     |         bool success = __revertCatcher__.process(data);
  616 |     |         assertTrue(success, "forwarder call failed");
  617 |     | 
  618 |     |         uint64 positionId = defaultScenario.poolId;
  619 |     |         uint256 prevPositionLiquidity = getPosition(
  620 |     |             address(__hyperTestingContract__),
  621 |     |             address(__revertCatcher__),
  622 |     |             positionId
  623 |     |         ).freeLiquidity;
  624 |     | 
  625 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  626 |     |         success = __revertCatcher__.process(data);
  627 |     | 
  628 |     |         uint256 nextPositionLiquidity = getPosition(
  629 |     |             address(__hyperTestingContract__),
  630 |     |             address(__revertCatcher__),
  631 |     |             positionId
  632 |     |         ).freeLiquidity;
  633 |     | 
  634 |     |         assertTrue(nextPositionLiquidity < prevPositionLiquidity);
  635 |     |     }
  636 |     | 
  637 |     |     function testUnallocateGlobalAssetDecreases() public postTestInvariantChecks {
  638 |     |         uint8 amount = 0x01;
  639 |     |         uint8 power = 0x05; // if this is low enough, it will revert because token amounts rounded down to zero.
  640 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  641 |     |         bool success = __revertCatcher__.process(data);
  642 |     |         assertTrue(success);
  643 |     | 
  644 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  645 |     | 
  646 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  647 |     |         success = __revertCatcher__.process(data);
  648 |     | 
  649 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.asset));
  650 |     |         assertTrue(next == prev, "reserves-changed"); // unallocated amounts are credited to user
  651 |     |     }
  652 |     | 
  653 |     |     /// @dev IMPORTANT TEST. For low token decimals, be very aware of the amount of liquidity involved in each tx.
  654 |     |     function testUnallocateGlobalQuoteDecreases() public postTestInvariantChecks {
  655 |     |         uint8 amount = 0x01;
  656 |     |         uint8 power = 0x0c; // 1e12 liquidity
  657 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  658 |     |         bool success = __revertCatcher__.process(data);
  659 |     |         assertTrue(success);
  660 |     | 
  661 |     |         uint256 prev = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  662 |     | 
  663 |     |         data = Enigma.encodeUnallocate(0, defaultScenario.poolId, power, amount);
  664 |     |         success = __revertCatcher__.process(data);
  665 |     | 
  666 |     |         uint256 next = getReserve(address(__hyperTestingContract__), address(defaultScenario.quote));
  667 |     |         assertTrue(next == prev, "reserves-changed"); // unallocated amounts are credited to user
  668 |     |     }
  669 |     | 
  670 |     |     // --- Stake Position --- //
  671 |     | 
  672 |     |     function testStakeExternalEpochIncrements() public {
  673 |     |         uint8 amount = 0x05;
  674 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, amount);
  675 |     | 
  676 |     |         uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  677 |     |             .stakeTimestamp;
  678 |     |         __hyperTestingContract__.stake(defaultScenario.poolId, amount);
  679 |     |         uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  680 |     |             .stakeTimestamp;
  681 |     | 
  682 |     |         assertTrue(nextId != prevId);
  683 |     |     }
  684 |     | 
  685 |     |     function testStakePositionStakedUpdated() public postTestInvariantChecks {
  686 |     |         int24 lo = DEFAULT_TICK - 256;
  687 |     |         int24 hi = DEFAULT_TICK;
  688 |     |         uint8 amount = 0x01;
  689 |     |         uint8 power = 0x01;
  690 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  691 |     |         bool success = __revertCatcher__.process(data);
  692 |     |         assertTrue(success);
  693 |     | 
  694 |     |         uint64 positionId = defaultScenario.poolId;
  695 |     | 
  696 |     |         bool prevPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
  697 |     |             .stakeTimestamp != 0;
  698 |     | 
  699 |     |         data = Enigma.encodeStakePosition(positionId, amount);
  700 |     |         success = __revertCatcher__.process(data);
  701 |     | 
  702 |     |         bool nextPositionStaked = getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
  703 |     |             .stakeTimestamp != 0;
  704 |     | 
  705 |     |         assertTrue(nextPositionStaked != prevPositionStaked, "Position staked did not update.");
  706 |     |         assertTrue(nextPositionStaked, "Position staked is not true.");
  707 |     |     }
  708 |     | 
  709 |     |     function testStakePoolStakedLiquidityUpdated() public postTestInvariantChecks {
  710 |     |         int24 lo = DEFAULT_TICK - 256;
  711 |     |         int24 hi = DEFAULT_TICK;
  712 |     |         uint8 amount = 0x01;
  713 |     |         uint8 power = 0x01;
  714 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  715 |     |         bool success = __revertCatcher__.process(data);
  716 |     |         assertTrue(success);
  717 |     | 
  718 |     |         uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)
  719 |     |             .stakedLiquidity;
  720 |     | 
  721 |     |         uint64 positionId = defaultScenario.poolId;
  722 |     |         data = Enigma.encodeStakePosition(positionId, amount);
  723 |     |         success = __revertCatcher__.process(data);
  724 |     | 
  725 |     |         uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__), defaultScenario.poolId)
  726 |     |             .stakedLiquidity;
  727 |     | 
  728 |     |         if (
  729 |     |             lo <= getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick &&
  730 |     |             hi > getPool(address(__hyperTestingContract__), defaultScenario.poolId).lastTick
  731 |     |         ) {
  732 |     |             assertTrue(nextPoolStakedLiquidity > prevPoolStakedLiquidity, "Pool staked liquidity did not increase.");
  733 |     |             assertTrue(
  734 |     |                 nextPoolStakedLiquidity ==
  735 |     |                     getPosition(address(__hyperTestingContract__), address(__revertCatcher__), positionId)
  736 |     |                         .freeLiquidity,
  737 |     |                 "Pool staked liquidity not equal to liquidity of staked position."
  738 |     |             );
  739 |     |         } else {
  740 |     |             assertTrue(
  741 |     |                 nextPoolStakedLiquidity == prevPoolStakedLiquidity,
  742 |     |                 "Pool staked liquidity changed even though position staked out of range."
  743 |     |             );
  744 |     |         }
  745 |     |     }
  746 |     | 
  747 |     |     function testStakeNonExistentPoolIdReverts() public {
  748 |     |         uint64 failureArg = uint64(3214);
  749 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  750 |     |         __hyperTestingContract__.stake(failureArg, 100);
  751 |     |     }
  752 |     | 
  753 |     |     function testStakeZeroLiquidityRevertsWithInsufficientPosition() public {
  754 |     |         vm.expectRevert(abi.encodeWithSelector(InsufficientPosition.selector, defaultScenario.poolId));
  755 |     |         __hyperTestingContract__.stake(defaultScenario.poolId, 100);
  756 |     |     }
  757 |     | 
  758 |     |     // --- Unstake Position --- //
  759 |     | 
  760 |     |     function testUnstakeExternalEpochIncrements() public {
  761 |     |         uint8 amount = 0x05;
  762 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, amount);
  763 |     |         __hyperTestingContract__.stake(defaultScenario.poolId, amount);
  764 |     | 
  765 |     |         uint prevId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  766 |     |             .unstakeTimestamp;
  767 |     | 
  768 |     |         customWarp(prevId + 1);
  769 |     |         __hyperTestingContract__.unstake(defaultScenario.poolId, amount);
  770 |     |         uint nextId = getPosition(address(__hyperTestingContract__), address(this), defaultScenario.poolId)
  771 |     |             .unstakeTimestamp;
  772 |     | 
  773 |     |         // todo: add better tests
  774 |     |         //assertTrue(nextId != prevId);
  775 |     |     }
  776 |     | 
  777 |     |     function testUnstakePositionStakedUpdated() public postTestInvariantChecks {
  778 |     |         uint8 amount = 0x01;
  779 |     |         uint8 power = 0x0f;
  780 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  781 |     |         bool success = __revertCatcher__.process(data);
  782 |     |         assertTrue(success);
  783 |     | 
  784 |     |         uint128 stakeAmount = uint128(amount * 10 ** power);
  785 |     | 
  786 |     |         uint64 positionId = defaultScenario.poolId;
  787 |     |         data = Enigma.encodeStakePosition(positionId, stakeAmount);
  788 |     |         success = __revertCatcher__.process(data);
  789 |     | 
  790 |     |         HyperPosition memory pos = getPosition(
  791 |     |             address(__hyperTestingContract__),
  792 |     |             address(this),
  793 |     |             defaultScenario.poolId
  794 |     |         );
  795 |     | 
  796 |     |         // touch pool to update it so we know how much staked liquidity the position has
  797 |     |         uint8 useMax = 0;
  798 |     |         uint8 direction = 0;
  799 |     |         uint128 input = 0x01 * (10 ** 0x0d);
  800 |     |         uint128 output = helperGetAmountOut(
  801 |     |             address(__hyperTestingContract__),
  802 |     |             defaultScenario.poolId,
  803 |     |             direction == 0,
  804 |     |             input
  805 |     |         ).safeCastTo128();
  806 |     |         data = Enigma.encodeSwap(useMax, defaultScenario.poolId, 0x0d, 0x01, 0x0, output, direction);
  807 |     |         success = __revertCatcher__.process(data);
  808 |     | 
  809 |     |         HyperPosition memory revertCatcherPos = defaultRevertCatcherPosition();
  810 |     | 
  811 |     |         uint256 prevPositionStaked = getPosition(
  812 |     |             address(__hyperTestingContract__),
  813 |     |             address(__revertCatcher__),
  814 |     |             positionId
  815 |     |         ).unstakeTimestamp;
  816 |     | 
  817 |     |         uint prevStaked = revertCatcherPos.stakedLiquidity;
  818 |     | 
  819 |     |         data = Enigma.encodeUnstakePosition(positionId, stakeAmount);
  820 |     |         customWarp(prevPositionStaked + 1);
  821 |     |         success = __revertCatcher__.process(data);
  822 |     |         revertCatcherPos = defaultRevertCatcherPosition();
  823 |     | 
  824 |     |         uint256 nextPositionStaked = getPosition(
  825 |     |             address(__hyperTestingContract__),
  826 |     |             address(__revertCatcher__),
  827 |     |             positionId
  828 |     |         ).unstakeTimestamp;
  829 |     | 
  830 |     |         uint postStaked = revertCatcherPos.stakedLiquidity;
  831 |     |         assertEq(postStaked, prevStaked - stakeAmount, "stake-liquidity-decreases");
  832 |     |         assertTrue(postStaked < prevStaked, "stake-did-not-decrease");
  833 |     |         //assertTrue(nextPositionStaked != prevPositionStaked, "Position staked did not update.");
  834 |     |         //assertTrue(nextPositionStaked != 0, "Position staked is true.");
  835 |     |     }
  836 |     | 
  837 |     |     // note: some unintended side effects most likely from update/sync pool messing with price
  838 |     |     // it creates a discrepency in the contract where the contract holds more tokens than the sum
  839 |     |     // of all claims is entitled to.
  840 |     |     function testUnstakePoolStakedLiquidityUpdated() public postTestInvariantChecks {
  841 |     |         uint8 amount = 0x01;
  842 |     |         uint8 power = 0x0f;
  843 |     |         bytes memory data = Enigma.encodeAllocate(0, defaultScenario.poolId, power, amount);
  844 |     |         bool success = __revertCatcher__.process(data);
  845 |     |         assertTrue(success);
  846 |     | 
  847 |     |         uint64 positionId = defaultScenario.poolId;
  848 |     |         data = Enigma.encodeStakePosition(positionId, amount);
  849 |     |         success = __revertCatcher__.process(data);
  850 |     | 
  851 |     |         // touch pool to update it so we know how much staked liquidity the position has
  852 |     |         uint8 useMax = 0;
  853 |     |         uint8 direction = 0;
  854 |     |         uint128 input = 0x01 * (10 ** 0x0c);
  855 |     |         uint128 output = helperGetAmountOut(
  856 |     |             address(__hyperTestingContract__),
  857 |     |             defaultScenario.poolId,
  858 |     |             direction == 0,
  859 |     |             input
  860 |     |         ).safeCastTo128();
  861 |     |         data = Enigma.encodeSwap(useMax, positionId, 0x0c, 0x01, 0x0, output, direction);
  862 |     |         success = __revertCatcher__.process(data);
  863 |     | 
  864 |     |         uint256 prevPoolStakedLiquidity = getPool(address(__hyperTestingContract__), positionId).stakedLiquidity;
  865 |     | 
  866 |     |         HyperPosition memory pos = defaultRevertCatcherPosition();
  867 |     |         customWarp(pos.unstakeTimestamp + 1);
  868 |     |         data = Enigma.encodeUnstakePosition(positionId, amount);
  869 |     |         success = __revertCatcher__.process(data);
  870 |     | 
  871 |     |         pos = defaultRevertCatcherPosition();
  872 |     |         customWarp((pos.unstakeTimestamp + 1) * 2);
  873 |     | 
  874 |     |         // TODO: FIX FAILING TEST
  875 |     | 
  876 |     |         // touch pool to update it so we know how much staked liquidity the position has
  877 |     |         // data = Enigma.encodeSwap(0, defaultScenario.poolId, 0x01, 0x01, 0x15, 0x01, 0);
  878 |     |         // success = __revertCatcher__.process(data);
  879 |     |         //
  880 |     |         // // todo: currently fails because unstaking does not change staked liquidity.
  881 |     |         // uint256 nextPoolStakedLiquidity = getPool(address(__hyperTestingContract__),defaultScenario.poolId).stakedLiquidity;
  882 |     |         //
  883 |     |         // if (lo <= getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick && hi > getPool(address(__hyperTestingContract__),defaultScenario.poolId).lastTick) {
  884 |     |         //     assertTrue(nextPoolStakedLiquidity < prevPoolStakedLiquidity, "Pool staked liquidity did not increase.");
  885 |     |         //     assertTrue(nextPoolStakedLiquidity == 0, "Pool staked liquidity does not equal 0 after unstake.");
  886 |     |         // } else {
  887 |     |         //     assertTrue(
  888 |     |         //         nextPoolStakedLiquidity == prevPoolStakedLiquidity,
  889 |     |         //         "Pool staked liquidity changed even though position staked out of range."
  890 |     |         //     );
  891 |     |         // }
  892 |     |     }
  893 |     | 
  894 |     |     function testUnstakeNonExistentPoolIdReverts() public {
  895 |     |         uint64 failureArg = 1224;
  896 |     |         vm.expectRevert(abi.encodeWithSelector(NonExistentPool.selector, failureArg));
  897 |     |         __hyperTestingContract__.unstake(failureArg, 555);
  898 |     |     }
  899 |     | 
  900 |     |     function testUnstakeNotStakedReverts() public {
  901 |     |         vm.expectRevert(abi.encodeWithSelector(PositionNotStaked.selector, defaultScenario.poolId));
  902 |     |         __hyperTestingContract__.unstake(defaultScenario.poolId, 555);
  903 |     |     }
  904 |     | 
  905 |     |     // --- Create HyperPair --- //
  906 |     | 
  907 |     |     function testCreatePairSameTokensReverts() public {
  908 |     |         address token = address(new TestERC20("t", "t", 18));
  909 |     |         bytes memory data = Enigma.encodeCreatePair(token, token);
  910 |     |         vm.expectRevert(SameTokenError.selector);
  911 |     |         bool success = __revertCatcher__.process(data);
  912 |     |         assertTrue(!success, "forwarder call failed");
  913 |     |     }
  914 |     | 
  915 |     |     function testCreatePairPairExistsReverts() public {
  916 |     |         bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.asset), address(defaultScenario.quote));
  917 |     |         vm.expectRevert(abi.encodeWithSelector(PairExists.selector, 1));
  918 |     |         bool success = __revertCatcher__.process(data);
  919 |     |     }
  920 |     | 
  921 |     |     function testCreatePairLowerDecimalBoundsAssetReverts() public {
  922 |     |         address token0 = address(new TestERC20("t", "t", 5));
  923 |     |         address token1 = address(new TestERC20("t", "t", 18));
  924 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  925 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));
  926 |     |         bool success = __revertCatcher__.process(data);
  927 |     |     }
  928 |     | 
  929 |     |     function testCreatePairLowerDecimalBoundsQuoteReverts() public {
  930 |     |         address token0 = address(new TestERC20("t", "t", 18));
  931 |     |         address token1 = address(new TestERC20("t", "t", 5));
  932 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  933 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 5));
  934 |     |         bool success = __revertCatcher__.process(data);
  935 |     |     }
  936 |     | 
  937 |     |     function testCreatePairUpperDecimalBoundsAssetReverts() public {
  938 |     |         address token0 = address(new TestERC20("t", "t", 24));
  939 |     |         address token1 = address(new TestERC20("t", "t", 18));
  940 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  941 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));
  942 |     |         bool success = __revertCatcher__.process(data);
  943 |     |     }
  944 |     | 
  945 |     |     function testCreatePairUpperDecimalBoundsQuoteReverts() public {
  946 |     |         address token0 = address(new TestERC20("t", "t", 18));
  947 |     |         address token1 = address(new TestERC20("t", "t", 24));
  948 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  949 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidDecimals.selector, 24));
  950 |     |         bool success = __revertCatcher__.process(data);
  951 |     |     }
  952 |     | 
  953 |     |     function testCreatePairPairNonceIncrementedReturnsOneAdded() public {
  954 |     |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
  955 |     |         address token0 = address(new TestERC20("t", "t", 18));
  956 |     |         address token1 = address(new TestERC20("t", "t", 18));
  957 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  958 |     |         bool success = __revertCatcher__.process(data);
  959 |     |         uint256 nonce = __hyperTestingContract__.getPairNonce();
  960 |     |         assertEq(nonce, prevNonce + 1);
  961 |     |     }
  962 |     | 
  963 |     |     function testCreatePairFetchesPairIdReturnsNonZero() public {
  964 |     |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
  965 |     |         address token0 = address(new TestERC20("t", "t", 18));
  966 |     |         address token1 = address(new TestERC20("t", "t", 18));
  967 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  968 |     |         bool success = __revertCatcher__.process(data);
  969 |     |         uint256 pairId = __hyperTestingContract__.getPairId(token0, token1);
  970 |     |         assertTrue(pairId != 0);
  971 |     |     }
  972 |     | 
  973 |     |     function testCreatePairFetchesPairDataReturnsAddresses() public {
  974 |     |         uint256 prevNonce = __hyperTestingContract__.getPairNonce();
  975 |     |         address token0 = address(new TestERC20("t", "t", 18));
  976 |     |         address token1 = address(new TestERC20("t", "t", 18));
  977 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
  978 |     |         bool success = __revertCatcher__.process(data);
  979 |     |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
  980 |     |         HyperPair memory pair = getPair(address(__hyperTestingContract__), pairId);
  981 |     |         assertEq(pair.tokenAsset, token0);
  982 |     |         assertEq(pair.tokenQuote, token1);
  983 |     |         assertEq(pair.decimalsAsset, 18);
  984 |     |         assertEq(pair.decimalsQuote, 18);
  985 |     |     }
  986 |     | 
  987 |     |     /* // --- Create Curve --- //
  988 |     | 
  989 |     |     function testCreateCurveCurveExistsReverts() public {
  990 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
  991 |     |         bytes memory data = Enigma.encodeCreateCurve(
  992 |     |             curve.sigma,
  993 |     |             curve.maturity,
  994 |     |             uint16(1e4 - curve.gamma),
  995 |     |             uint16(1e4 - curve.priorityGamma),
  996 |     |             curve.strike
  997 |     |         );
  998 |     |         vm.expectRevert(abi.encodeWithSelector(CurveExists.selector, 1));
  999 |     |         bool success = __revertCatcher__.process(data);
 1000 |     |     }
 1001 |     | 
 1002 |     |     function testCreateCurveFeeParameterOutsideBoundsReverts() public {
 1003 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1004 |     |         uint16 failureArg = 5e4;
 1005 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1006 |     |             curve.sigma,
 1007 |     |             curve.maturity,
 1008 |     |             failureArg,
 1009 |     |             uint16(1e4 - curve.priorityGamma),
 1010 |     |             curve.strike
 1011 |     |         );
 1012 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
 1013 |     |         bool success = __revertCatcher__.process(data);
 1014 |     |     }
 1015 |     | 
 1016 |     |     function testCreateCurvePriorityFeeParameterOutsideBoundsReverts() public {
 1017 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1018 |     |         uint16 failureArg = 5e4;
 1019 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1020 |     |             curve.sigma,
 1021 |     |             curve.maturity,
 1022 |     |             uint16(1e4 - curve.gamma),
 1023 |     |             failureArg,
 1024 |     |             curve.strike
 1025 |     |         );
 1026 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidFee.selector, failureArg));
 1027 |     |         bool success = __revertCatcher__.process(data);
 1028 |     |     }
 1029 |     | 
 1030 |     |     function testCreateCurveRMMPoolZeroSigmaReverts() public {
 1031 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1032 |     |         uint24 failureArg = 0;
 1033 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1034 |     |             failureArg,
 1035 |     |             curve.maturity,
 1036 |     |             uint16(1e4 - curve.gamma),
 1037 |     |             uint16(1e4 - curve.priorityGamma),
 1038 |     |             curve.strike
 1039 |     |         );
 1040 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidVolatility.selector, failureArg));
 1041 |     |         bool success = __revertCatcher__.process(data);
 1042 |     |     }
 1043 |     | 
 1044 |     |     function testCreateCurveRMMPoolZeroStrikeReverts() public {
 1045 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1046 |     |         uint128 failureArg = 0;
 1047 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1048 |     |             curve.sigma,
 1049 |     |             curve.maturity,
 1050 |     |             uint16(1e4 - curve.gamma),
 1051 |     |             uint16(1e4 - curve.priorityGamma),
 1052 |     |             failureArg
 1053 |     |         );
 1054 |     |         vm.expectRevert(abi.encodeWithSelector(InvalidStrike.selector, failureArg));
 1055 |     |         bool success = __revertCatcher__.process(data);
 1056 |     |     }
 1057 |     | 
 1058 |     |     function testCreateCurveCurveNonceIncrementReturnsOne() public {
 1059 |     |         uint256 prevNonce = __hyperTestingContract__.getCurveNonce();
 1060 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1061 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1062 |     |             curve.sigma + 1,
 1063 |     |             curve.maturity,
 1064 |     |             uint16(1e4 - curve.gamma),
 1065 |     |             uint16(1e4 - curve.priorityGamma),
 1066 |     |             curve.strike
 1067 |     |         );
 1068 |     |         bool success = __revertCatcher__.process(data);
 1069 |     |         uint256 nextNonce = __hyperTestingContract__.getCurveNonce();
 1070 |     |         assertEq(prevNonce, nextNonce - 1);
 1071 |     |     }
 1072 |     | 
 1073 |     |     function testCreateCurveFetchesCurveIdReturnsNonZero() public {
 1074 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1075 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1076 |     |             curve.sigma + 1,
 1077 |     |             curve.maturity,
 1078 |     |             uint16(1e4 - curve.gamma),
 1079 |     |             uint16(1e4 - curve.priorityGamma),
 1080 |     |             curve.strike
 1081 |     |         );
 1082 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1083 |     |             abi.encodePacked(
 1084 |     |                 curve.sigma + 1,
 1085 |     |                 curve.maturity,
 1086 |     |                 uint16(1e4 - curve.gamma),
 1087 |     |                 uint16(1e4 - curve.priorityGamma),
 1088 |     |                 curve.strike
 1089 |     |             )
 1090 |     |         );
 1091 |     |         bool success = __revertCatcher__.process(data);
 1092 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1093 |     |         assertTrue(curveId != 0);
 1094 |     |     }
 1095 |     | 
 1096 |     |     function testCreateCurveFetchesCurveDataReturnsParametersSet() public {
 1097 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1098 |     |         bytes memory data = Enigma.encodeCreateCurve(
 1099 |     |             curve.sigma + 1,
 1100 |     |             curve.maturity,
 1101 |     |             uint16(1e4 - curve.gamma),
 1102 |     |             uint16(1e4 - curve.priorityGamma),
 1103 |     |             curve.strike
 1104 |     |         );
 1105 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1106 |     |             abi.encodePacked(
 1107 |     |                 curve.sigma + 1,
 1108 |     |                 curve.maturity,
 1109 |     |                 uint16(1e4 - curve.gamma),
 1110 |     |                 uint16(1e4 - curve.priorityGamma),
 1111 |     |                 curve.strike
 1112 |     |             )
 1113 |     |         );
 1114 |     |         bool success = __revertCatcher__.process(data);
 1115 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1116 |     |         HyperCurve memory newCurve = getCurve(address(__hyperTestingContract__), curveId);
 1117 |     |         assertEq(newCurve.sigma, curve.sigma + 1);
 1118 |     |         assertEq(newCurve.maturity, curve.maturity);
 1119 |     |         assertEq(newCurve.gamma, curve.gamma);
 1120 |     |         assertEq(newCurve.priorityGamma, curve.priorityGamma);
 1121 |     |         assertEq(newCurve.strike, curve.strike);
 1122 |     |     } */
 1123 |     | 
 1124 |     |     // --- Create Pool --- //
 1125 |     |     // todo: fix
 1126 |     | 
 1127 |     |     /* function testCreatePoolZeroPriceParameterReverts() public {
 1128 |     |         uint128 failureArg = 0;
 1129 |     |         bytes memory data = Enigma.encodeCreatePool(1, failureArg);
 1130 |     |         vm.expectRevert(ZeroPrice.selector);
 1131 |     |         bool success = __revertCatcher__.process(data);
 1132 |     |     } */
 1133 |     | 
 1134 |     |     // todo: fix
 1135 |     |     /* function testCreatePoolExistentPoolReverts() public {
 1136 |     |         uint64 failureArg = defaultScenario.poolId;
 1137 |     |         bytes memory data = Enigma.encodeCreatePool(failureArg, 1);
 1138 |     |         vm.expectRevert(PoolExists.selector);
 1139 |     |         bool success = __revertCatcher__.process(data);
 1140 |     |     } */
 1141 |     | 
 1142 |     |     // todo: fix
 1143 |     |     /* function testCreatePoolMagicPairId() public {
 1144 |     |         // Create a new curve to increment the nonce to 2
 1145 |     |         bytes memory data = Enigma.encodeCreateCurve(4, type(uint32).max - 1, 4, 4, 4);
 1146 |     |         __revertCatcher__.process(data);
 1147 |     | 
 1148 |     |         uint64 magicVariable = 0x000000000002;
 1149 |     |         data = Enigma.encodeCreatePool(magicVariable, 1);
 1150 |     |         bool success = __revertCatcher__.process(data);
 1151 |     |         assertTrue(success);
 1152 |     |     } */
 1153 |     |     /* 
 1154 |     |     function testCreatePoolMagicCurveId() public {
 1155 |     |         // Create a new pair to increment the nonce to 2
 1156 |     |         bytes memory data = Enigma.encodeCreatePair(address(defaultScenario.quote), address(__weth__));
 1157 |     |         __revertCatcher__.process(data);
 1158 |     | 
 1159 |     |         uint64 magicVariable = 0x000200000000;
 1160 |     |         data = Enigma.encodeCreatePool(magicVariable, 1);
 1161 |     |         bool success = __revertCatcher__.process(data);
 1162 |     |         assertTrue(success);
 1163 |     |     }
 1164 |     | 
 1165 |     |     function testCreatePoolRMMPoolExpiredReverts() public {
 1166 |     |         address token0 = address(new TestERC20("t", "t", 18));
 1167 |     |         address token1 = address(new TestERC20("t", "t", 18));
 1168 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
 1169 |     |         bool success = __revertCatcher__.process(data);
 1170 |     |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
 1171 |     | 
 1172 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1173 |     |         data = Enigma.encodeCreateCurve(
 1174 |     |             curve.sigma + 1,
 1175 |     |             uint32(0),
 1176 |     |             uint16(1e4 - curve.gamma),
 1177 |     |             uint16(1e4 - curve.priorityGamma),
 1178 |     |             curve.strike
 1179 |     |         );
 1180 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1181 |     |             abi.encodePacked(curve.sigma + 1, uint32(0), uint16(1e4 - curve.gamma), curve.strike)
 1182 |     |         );
 1183 |     |         success = __revertCatcher__.process(data);
 1184 |     | 
 1185 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1186 |     |         uint64 id = Enigma.encodePoolId(pairId, curveId);
 1187 |     |         data = Enigma.encodeCreatePool(id, 1_000);
 1188 |     |         vm.expectRevert(PoolExpired.selector);
 1189 |     |         success = __revertCatcher__.process(data);
 1190 |     |     }
 1191 |     | 
 1192 |     |     function testCreatePoolFetchesPoolDataReturnsNonZeroBlockTimestamp() public {
 1193 |     |         address token0 = address(new TestERC20("t", "t", 18));
 1194 |     |         address token1 = address(new TestERC20("t", "t", 18));
 1195 |     |         bytes memory data = Enigma.encodeCreatePair(address(token0), address(token1));
 1196 |     |         bool success = __revertCatcher__.process(data);
 1197 |     |         uint24 pairId = __hyperTestingContract__.getPairId(token0, token1);
 1198 |     | 
 1199 |     |         HyperCurve memory curve = getCurve(address(__hyperTestingContract__), uint32(defaultScenario.poolId)); // Existing curve from helper setup
 1200 |     |         data = Enigma.encodeCreateCurve(
 1201 |     |             curve.sigma + 1,
 1202 |     |             curve.maturity,
 1203 |     |             uint16(1e4 - curve.gamma),
 1204 |     |             uint16(1e4 - curve.priorityGamma),
 1205 |     |             curve.strike
 1206 |     |         );
 1207 |     |         bytes32 rawCurveId = Enigma.toBytes32(
 1208 |     |             abi.encodePacked(
 1209 |     |                 curve.sigma + 1,
 1210 |     |                 curve.maturity,
 1211 |     |                 uint16(1e4 - curve.gamma),
 1212 |     |                 uint16(1e4 - curve.priorityGamma),
 1213 |     |                 curve.strike
 1214 |     |             )
 1215 |     |         );
 1216 |     |         success = __revertCatcher__.process(data);
 1217 |     | 
 1218 |     |         uint32 curveId = __hyperTestingContract__.getCurveId(rawCurveId);
 1219 |     |         uint64 id = Enigma.encodePoolId(pairId, curveId);
 1220 |     |         data = Enigma.encodeCreatePool(id, 1_000);
 1221 |     |         success = __revertCatcher__.process(data);
 1222 |     | 
 1223 |     |         uint256 time = getPool(address(__hyperTestingContract__), id).lastTimestamp;
 1224 |     |         assertTrue(time != 0);
 1225 |     |     } */
 1226 |     | }
 1227 |     | 

/root/code/hyper/test/foundry/TestHyperSwap.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/HyperLib.sol" as HyperTypes;
   5 |     | import "./setup/TestHyperSetup.sol";
   6 |     | import "test/helpers/HelperHyperProfiles.sol";
   7 |     | 
   8 |     | contract TestHyperSwap is TestHyperSetup {
   9 |     |     modifier allocateFirst() {
  10 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 10 ether);
  11 |     |         _;
  12 |     |     }
  13 |     | 
  14 |     |     // todo: fake test
  15 |     |     function testSwap_should_succeed() public allocateFirst {
  16 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  17 |     | 
  18 |     |         uint input = DEFAULT_SWAP_INPUT;
  19 |     |         uint expected = DEFAULT_SWAP_OUTPUT; // 6 decimals
  20 |     |         (uint out, ) = pool.getAmountOut(true, input, 0);
  21 |     | 
  22 |     |         (uint output, uint remainder) = __hyperTestingContract__.swap(
  23 |     |             defaultScenario.poolId,
  24 |     |             true,
  25 |     |             input,
  26 |     |             0 // limit
  27 |     |         );
  28 |     | 
  29 |     |         assertEq(output, expected, "expected-output");
  30 |     | 
  31 |     |         (uint amount0, uint amount1) = pool.getAmounts();
  32 |     |         console.log("amounts", amount0, amount1);
  33 |     |         console.log("outputs, actual, expected", output, out);
  34 |     |     }
  35 |     | 
  36 |     |     function testSwap_back_and_forth_outputs_less() public allocateFirst {
  37 |     |         uint256 start = 10000;
  38 |     | 
  39 |     |         bool direction = false;
  40 |     |         (uint output, ) = __hyperTestingContract__.swap(
  41 |     |             defaultScenario.poolId,
  42 |     |             direction,
  43 |     |             start,
  44 |     |             direction ? 0 : type(uint128).max
  45 |     |         );
  46 |     | 
  47 |     |         direction = true;
  48 |     |         (uint finalOutput, ) = __hyperTestingContract__.swap(
  49 |     |             defaultScenario.poolId,
  50 |     |             direction,
  51 |     |             output,
  52 |     |             direction ? 0 : type(uint128).max
  53 |     |         );
  54 |     | 
  55 |     |         assertGt(start, finalOutput);
  56 |     |     }
  57 |     | 
  58 |     |     function testSwap_revert_PoolExpired() public allocateFirst {
  59 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  60 |     |         uint end = pool.params.createdAt + Assembly.convertDaysToSeconds(pool.params.duration);
  61 |     |         customWarp(end + 1);
  62 |     |         vm.expectRevert(PoolExpired.selector);
  63 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, false, 10000, type(uint128).max);
  64 |     |     }
  65 |     | 
  66 |     |     function testSwap_revert_ZeroInput() public {
  67 |     |         vm.expectRevert(ZeroInput.selector);
  68 |     |         __hyperTestingContract__.swap(defaultScenario.poolId, true, 0, 0);
  69 |     |     }
  70 |     | 
  71 |     |     /*
  72 |     |     function testSwap_revert_NonExistentPool() public {
  73 |     |         vm.expectRevert(NonExistentPool.selector);
  74 |     |         __hyperTestingContract__.swap(
  75 |     |             42,
  76 |     |             true,
  77 |     |             1,
  78 |     |             0
  79 |     |         );
  80 |     |     }
  81 |     |     */
  82 |     | 
  83 |     |     // maxInput case
  84 |     |     function testSwap_pays_fee_maxInput() public allocateFirst {
  85 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
  86 |     | 
  87 |     |         uint maxInput = getMaxSwapAssetInWad(pool);
  88 |     |         uint extra = 1;
  89 |     |         console.log(maxInput);
  90 |     |         (uint out, ) = pool.getAmountOut(true, maxInput + extra, 0);
  91 |     | 
  92 |     |         uint prevFeeGrowthAsset = pool.feeGrowthGlobalAsset;
  93 |     |         (uint output, uint remainder) = __hyperTestingContract__.swap(
  94 |     |             defaultScenario.poolId,
  95 |     |             true,
  96 |     |             maxInput + extra,
  97 |     |             0 // limit
  98 |     |         );
  99 |     | 
 100 |     |         pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 101 |     |         uint postFeeGrowthAsset = pool.feeGrowthGlobalAsset;
 102 |     | 
 103 |     |         assertEq(remainder, extra, "expected-output");
 104 |     |         assertTrue(postFeeGrowthAsset > prevFeeGrowthAsset, "fee-did-not-increase");
 105 |     |     }
 106 |     | 
 107 |     |     // not maxInput case
 108 |     |     function testSwap_pays_fee() public allocateFirst {
 109 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 110 |     | 
 111 |     |         uint maxInput = getMaxSwapAssetInWad(pool);
 112 |     |         (uint out, ) = pool.getAmountOut(true, maxInput - 1, 0);
 113 |     | 
 114 |     |         uint prevFeeGrowthAsset = pool.feeGrowthGlobalAsset;
 115 |     |         (uint output, uint remainder) = __hyperTestingContract__.swap(
 116 |     |             defaultScenario.poolId,
 117 |     |             true,
 118 |     |             maxInput - 1,
 119 |     |             0 // limit
 120 |     |         );
 121 |     | 
 122 |     |         pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 123 |     |         uint postFeeGrowthAsset = pool.feeGrowthGlobalAsset;
 124 |     | 
 125 |     |         assertEq(remainder, 0, "expected-output");
 126 |     |         assertTrue(postFeeGrowthAsset > prevFeeGrowthAsset, "fee-did-not-increase");
 127 |     |     }
 128 |     | 
 129 |     |     /// todo: Fix this test! view this plot: `yarn plot --strike 1 --vol 1 --tau 365 --price 1 --epsilon 180 --swapAssetIn 0.1`
 130 |     |     /* function testSwap_small_tau() public allocateFirst {
 131 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 132 |     | 
 133 |     |         customWarp(pool.params.maturity() - 100);
 134 |     | 
 135 |     |         pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 136 |     | 
 137 |     |         uint maxInput = getMaxSwapAssetInWad(pool);
 138 |     |         (uint out, ) = pool.getAmountOut(true, maxInput - 1, 0);
 139 |     | 
 140 |     |         uint prevFeeGrowthAsset = pool.feeGrowthGlobalAsset;
 141 |     |         (uint output, uint remainder) = __hyperTestingContract__.swap(
 142 |     |             defaultScenario.poolId,
 143 |     |             true,
 144 |     |             maxInput - 1,
 145 |     |             0 // limit
 146 |     |         );
 147 |     | 
 148 |     |         pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 149 |     |         uint postFeeGrowthAsset = pool.feeGrowthGlobalAsset;
 150 |     | 
 151 |     |         assertEq(remainder, 0, "expected-output");
 152 |     |         assertTrue(postFeeGrowthAsset > prevFeeGrowthAsset, "fee-did-not-increase");
 153 |     |     } */
 154 |     | }
 155 |     | 

/root/code/hyper/test/foundry/TestHyperUnallocate.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestHyperSetup.sol";
  5 |     | 
  6 |     | contract TestHyperUnallocate is TestHyperSetup {
  7 |     |     function testUnallocateUseMax() public postTestInvariantChecks {
  8 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
  9 |     | 
 10 |     |         uint maxLiquidity = getPosition(address(__hyperTestingContract__), msg.sender, defaultScenario.poolId)
 11 |     |             .freeLiquidity;
 12 |     | 
 13 |     |         __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint256).max);
 14 |     | 
 15 |     |         assertEq(0, getPool(address(__hyperTestingContract__), defaultScenario.poolId).liquidity);
 16 |     |     }
 17 |     | }
 18 |     | 

/root/code/hyper/test/foundry/TestPriceComputePrice.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceComputePrice is TestPriceSetup {
  7 |     |     using Price for Price.RMM;
  8 |     | 
  9 |     |     function testComputedPriceWithDefaultAssetReserve() public {
 10 |     |         uint actual = cases[0].getPriceWithX(DEFAULT_ASSET_RESERVE);
 11 |     |         uint err = 1e4; // TODO: Fix for error...
 12 |     |         assertTrue(actual <= DEFAULT_PRICE + err && actual >= DEFAULT_PRICE - err);
 13 |     |     }
 14 |     | 
 15 |     |     // ===== Raw ===== //
 16 |     | 
 17 |     |     function testComputePriceWithZeroChangeInTauReturnsPrice() public {
 18 |     |         uint price = DEFAULT_PRICE;
 19 |     |         uint actual = cases[0].computePriceWithChangeInTau(price, 0);
 20 |     |         assertEq(actual, price);
 21 |     |     }
 22 |     | 
 23 |     |     function testComputePriceWithEpsilonEqualsTauReturnsStrike() public {
 24 |     |         Price.RMM memory info = cases[0];
 25 |     |         uint price = DEFAULT_PRICE;
 26 |     |         uint epsilon = info.tau;
 27 |     |         uint actual = info.computePriceWithChangeInTau(price, epsilon);
 28 |     |         assertEq(actual, info.strike);
 29 |     |     }
 30 |     | 
 31 |     |     function testFuzzComputePriceWithChangeInTau(uint32 epsilon) public {
 32 |     |         Price.RMM memory info = cases[0];
 33 |     |         // Fuzzing Filters
 34 |     |         vm.assume(epsilon > 0); // Fuzzing non-zero test cases only.
 35 |     |         vm.assume(epsilon < info.tau); // Epsilon > tau is the same as epsilon == tau.
 36 |     | 
 37 |     |         // Behavior: as epsilon gets larger, tau gets smaller, price increases, reaches inflection, price tends to strike after inflection point.
 38 |     |         uint price = DEFAULT_PRICE;
 39 |     |         uint actual = info.computePriceWithChangeInTau(price, epsilon);
 40 |     |         uint actualDiff = actual - info.strike;
 41 |     |         uint expectedDiff = price - info.strike;
 42 |     |         assertTrue(actualDiff > expectedDiff); // maybe? As tau gets smaller, price should increase until epsilon >= tau.
 43 |     |     }
 44 |     | 
 45 |     |     function testComputePriceWithEpsilonChangeEqualToTauReturnsPrice() public {
 46 |     |         uint price = DEFAULT_PRICE;
 47 |     |         uint actual = cases[0].computePriceWithChangeInTau(price, cases[0].tau);
 48 |     |         assertEq(actual, price);
 49 |     |     }
 50 |     | }
 51 |     | 

/root/code/hyper/test/foundry/TestPriceComputeReserves.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceComputeReserves is TestPriceSetup {
  7 |     |     using Price for Price.RMM;
  8 |     | 
  9 |     |     function testComputedAssetReserveWithDefaultPrice() public {
 10 |     |         uint actual = cases[0].getXWithPrice(DEFAULT_PRICE);
 11 |     |         assertEq(actual, DEFAULT_ASSET_RESERVE);
 12 |     |     }
 13 |     | 
 14 |     |     function testComputedQuoteReserveWithDefaultAssetReserve() public {
 15 |     |         uint actual = cases[0].getYWithX(DEFAULT_ASSET_RESERVE);
 16 |     |         assertEq(actual, DEFAULT_QUOTE_RESERVE);
 17 |     |     }
 18 |     | 
 19 |     |     function testComputedAssetReserveWithDefaultQuoteReserve() public {
 20 |     |         uint actual = cases[0].getXWithY(DEFAULT_QUOTE_RESERVE);
 21 |     |         assertEq(actual, DEFAULT_ASSET_RESERVE);
 22 |     |     }
 23 |     | 
 24 |     |     function testComputedReservesWithDefaultPrice() public {
 25 |     |         (uint actualQuoteReserve, uint actualAssetReserve) = cases[0].computeReserves(DEFAULT_PRICE);
 26 |     |         assertEq(actualQuoteReserve, DEFAULT_QUOTE_RESERVE);
 27 |     |         assertEq(actualAssetReserve, DEFAULT_ASSET_RESERVE);
 28 |     |     }
 29 |     | }
 30 |     | 

/root/code/hyper/test/foundry/TestPriceInvariant.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceInvariant is TestPriceSetup {
  7 |     |     using Price for Price.RMM;
  8 |     | 
  9 |     |     function testInvariantReturnsZeroWithDefaultPool() public {
 10 |     |         int actual = cases[0].invariantOf(DEFAULT_QUOTE_RESERVE, DEFAULT_ASSET_RESERVE);
 11 |     |         assertEq(actual, 0);
 12 |     |     }
 13 |     | }
 14 |     | 

/root/code/hyper/test/foundry/TestPriceUtils.t.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./setup/TestPriceSetup.sol";
  5 |     | 
  6 |     | contract TestPriceUtils is TestPriceSetup {
  7 |     |     // ===== Utils ===== //
  8 |     | 
  9 |     |     function testConvertPercentageReturnsOne() public {
 10 |     |         uint percentage = Price.PERCENTAGE;
 11 |     |         uint expected = Price.WAD;
 12 |     |         uint converted = Price.convertPercentageToWad(percentage);
 13 |     |         assertEq(converted, expected);
 14 |     |     }
 15 |     | 
 16 |     |     function testFuzzConvertPercentageReturnsComputedValue(uint percentage) public {
 17 |     |         vm.assume(percentage < type(uint64).max);
 18 |     |         uint expected = (percentage * Price.WAD) / Price.PERCENTAGE;
 19 |     |         uint converted = Price.convertPercentageToWad(percentage);
 20 |     |         assertEq(converted, expected);
 21 |     |     }
 22 |     | }
 23 |     | 

/root/code/hyper/test/foundry/recipes/TestSwapMath.t.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../../../contracts/recipes/SwapMath.sol" as SwapMath;
   5 |     | import "forge-std/Test.sol";
   6 |     | 
   7 |     | contract TestSwapMath is Test {
   8 |     |     function testSwapMath_D_ppf() public {
   9 |     |         int256 input = int256(0.5 ether);
  10 |     |         int256 actual = SwapMath.d_ppf(input);
  11 |     |         console.logInt(actual);
  12 |     |     }
  13 |     | 
  14 |     |     /** @custom:invariant Swapping quote tokens in always increases the marginal price. */
  15 |     |     function testSwapMath_computeMarginalPriceQuoteIn_increases() public {
  16 |     |         SwapMath.Parameters memory params = SwapMath.Parameters({
  17 |     |             stk: 10 ether, // this means y will be between 10 >= y >= 0
  18 |     |             vol: 10_000, // 100%
  19 |     |             tau: 365 days,
  20 |     |             fee: 15, // 0.15%
  21 |     |             inv: 0 // note: initialized at zero always!
  22 |     |         });
  23 |     | 
  24 |     |         uint startPrice = 10 ether;
  25 |     |         uint R_x = SwapMath.Price.getXWithPrice(startPrice, params.stk, params.vol, params.tau);
  26 |     |         uint R_y = SwapMath.Price.getYWithX(R_x, params.stk, params.vol, params.tau, params.inv);
  27 |     |         uint d_y = (R_y * 0.02 ether) / 1 ether; // swap in 2% of the pool's y reserves
  28 |     |         uint actual = SwapMath.computeMarginalPriceQuoteIn(
  29 |     |             d_y,
  30 |     |             R_y,
  31 |     |             params.stk,
  32 |     |             params.vol,
  33 |     |             params.tau,
  34 |     |             params.fee,
  35 |     |             params.inv
  36 |     |         );
  37 |     | 
  38 |     |         uint d_percentage = 0.02 ether; // todo: fix with better assumption. note: assuming 2% swap has at most 0.2% of price impact. Depends on params!
  39 |     | 
  40 |     |         console.log(d_y, actual);
  41 |     |         // todo: fix assertTrue(actual > startPrice, "marginal-price-decreased");
  42 |     |         assertApproxEqRel(actual, startPrice, d_percentage, "marginal-price-error");
  43 |     |     }
  44 |     | 
  45 |     |     // desmos: https://www.desmos.com/calculator/v90nbj8pih
  46 |     |     function testSwapMath_computeMarginalPriceQuoteIn_increases_exact() public {
  47 |     |         SwapMath.Parameters memory params = SwapMath.Parameters({
  48 |     |             stk: 10 ether, // this means y will be between 10 >= y >= 0
  49 |     |             vol: 10_000, // 100%
  50 |     |             tau: 365 days,
  51 |     |             fee: 15, // 0.15%
  52 |     |             inv: 0 // note: initialized at zero always!
  53 |     |         });
  54 |     | 
  55 |     |         uint startPrice = 10 ether;
  56 |     |         uint R_x = SwapMath.Price.getXWithPrice(startPrice, params.stk, params.vol, params.tau);
  57 |     |         uint R_y = SwapMath.Price.getYWithX(R_x, params.stk, params.vol, params.tau, params.inv);
  58 |     |         uint d_y = 0.0617075077452 ether; // swap in 2% of the pool's y reserves
  59 |     |         uint actual = SwapMath.computeMarginalPriceQuoteIn(
  60 |     |             d_y,
  61 |     |             R_y,
  62 |     |             params.stk,
  63 |     |             params.vol,
  64 |     |             params.tau,
  65 |     |             params.fee,
  66 |     |             params.inv
  67 |     |         );
  68 |     | 
  69 |     |         uint d_percentage = 0.02 ether; // todo: fix with better assumption.  note: assuming 2% swap has at most 0.2% of price impact. Depends on params!
  70 |     | 
  71 |     |         uint expected = 9.84201501876 ether;
  72 |     | 
  73 |     |         // todo: fix assertTrue(actual > startPrice, "marginal-price-decreased");
  74 |     |         assertApproxEqRel(actual, expected, d_percentage, "marginal-price-error");
  75 |     |     }
  76 |     | 
  77 |     |     /** @custom:invariant Swapping assets tokens in always decreases the marginal price. */
  78 |     |     function testSwapMath_computeMarginalPriceAssetIn_decreases() public {
  79 |     |         SwapMath.Parameters memory params = SwapMath.Parameters({
  80 |     |             stk: 10 ether, // this means y will be between 10 >= y >= 0
  81 |     |             vol: 10_000, // 100%
  82 |     |             tau: 365 days,
  83 |     |             fee: 15, // 0.15%
  84 |     |             inv: 0 // note: initialized at zero always!
  85 |     |         });
  86 |     | 
  87 |     |         uint startPrice = 10 ether;
  88 |     |         uint R_x = SwapMath.Price.getXWithPrice(startPrice, params.stk, params.vol, params.tau);
  89 |     |         uint R_y = SwapMath.Price.getYWithX(R_x, params.stk, params.vol, params.tau, params.inv);
  90 |     |         uint d_x = (R_x * 0.02 ether) / 1 ether; // swap in 2% of the pool's y reserves
  91 |     |         uint actual = SwapMath.computeMarginalPriceAssetIn(
  92 |     |             d_x,
  93 |     |             R_x,
  94 |     |             params.stk,
  95 |     |             params.vol,
  96 |     |             params.tau,
  97 |     |             params.fee,
  98 |     |             params.inv
  99 |     |         );
 100 |     | 
 101 |     |         uint d_percentage = 0.02 ether; // todo: fix with better assumption. note: assuming 2% swap has at most 0.2% of price impact. Depends on params!
 102 |     | 
 103 |     |         // todo: fix assertTrue(actual < startPrice, "marginal-price-increased");
 104 |     |         assertApproxEqRel(actual, startPrice, d_percentage, "marginal-price-error");
 105 |     |     }
 106 |     | }
 107 |     | 

/root/code/hyper/test/foundry/setup/TestHyperSetup.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "solmate/tokens/WETH.sol";
   5 |     | import "solmate/utils/SafeCastLib.sol";
   6 |     | import "contracts/HyperLib.sol";
   7 |     | import "contracts/libraries/Price.sol";
   8 |     | 
   9 |     | import "forge-std/Test.sol";
  10 |     | import {TestERC20, Hyper, HyperTimeOverride, HyperCatchReverts, RevertCatcher, FixedPointMathLib} from "test/helpers/HyperTestOverrides.sol";
  11 |     | 
  12 |     | import "test/helpers/HelperHyperActions.sol";
  13 |     | import "test/helpers/HelperHyperInvariants.sol";
  14 |     | import "test/helpers/HelperHyperProfiles.sol";
  15 |     | import "test/helpers/HelperHyperView.sol";
  16 |     | 
  17 |     | uint constant STARTING_BALANCE = 4000e18;
  18 |     | 
  19 |     | struct TestScenario {
  20 |     |     TestERC20 asset;
  21 |     |     TestERC20 quote;
  22 |     |     uint64 poolId;
  23 |     |     string label;
  24 |     | }
  25 |     | 
  26 |     | /** @dev Deploys test contracts, test tokens, sets labels, funds users, and approves contracts to spend tokens. */
  27 |     | contract TestHyperSetup is HelperHyperActions, HelperHyperInvariants, HelperHyperProfiles, HelperHyperView, Test {
  28 |     |     using FixedPointMathLib for uint256;
  29 |     |     using FixedPointMathLib for int256;
  30 |     |     using SafeCastLib for uint;
  31 |     | 
  32 |     |     WETH public __weth__;
  33 |     |     Hyper public __hyper__; // Actual contract
  34 |     |     HyperTimeOverride public __hyperTimeOverride__; // Inherits Hyper, adds block.timestamp and jit policy overrides
  35 |     |     HyperCatchReverts public __hyperTestingContract__; // Inherits HyperTimeOverrides, adds endpoints to process functions.
  36 |     |     RevertCatcher public __revertCatcher__;
  37 |     | 
  38 |     |     TestERC20 public __usdc__;
  39 |     |     TestERC20 public __token_8__;
  40 |     |     TestERC20 public __token_18__;
  41 |     |     TestERC20 public __token_18__2;
  42 |     |     TestERC20 public __badToken__;
  43 |     | 
  44 |     |     address[] public __contracts__;
  45 |     |     address[] public __users__;
  46 |     |     address[] public __tokens__;
  47 |     | 
  48 |     |     TestScenario public defaultScenario;
  49 |     |     TestScenario public _scenario_18_18;
  50 |     |     TestScenario public _scenario_controlled;
  51 |     |     TestScenario[] public scenarios;
  52 |     | 
  53 |     |     modifier postTestInvariantChecks() virtual {
  54 |     |         _;
  55 |     |         assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.asset), __users__);
  56 |     |         assertSettlementInvariant(address(__hyperTestingContract__), address(defaultScenario.quote), __users__);
  57 |     |     }
  58 |     | 
  59 |     |     function setUp() public {
  60 |     |         initContracts();
  61 |     |         initUsers();
  62 |     |         initScenarios();
  63 |     |         initPrerequisites();
  64 |     |         afterSetUp();
  65 |     |     }
  66 |     | 
  67 |     |     function getState() public view returns (HyperState memory) {
  68 |     |         return getState(address(__hyperTestingContract__), defaultScenario.poolId, address(this), __users__);
  69 |     |     }
  70 |     | 
  71 |     |     /** Hook to override receive. Defaults to just accepting ether sent to this test contract. */
  72 |     |     receive() external payable {
  73 |     |         receiveOverride();
  74 |     |     }
  75 |     | 
  76 |     |     /** @dev Hook to run after test setup. */
  77 |     |     function afterSetUp() public virtual {}
  78 |     | 
  79 |     |     function receiveOverride() public virtual {}
  80 |     | 
  81 |     |     function initContracts() internal {
  82 |     |         __weth__ = new WETH();
  83 |     | 
  84 |     |         // --- Hyper Contracts --- //
  85 |     |         __hyper__ = new Hyper(address(__weth__));
  86 |     |         __hyperTimeOverride__ = new HyperTimeOverride(address(__weth__));
  87 |     |         __hyperTestingContract__ = new HyperCatchReverts(address(__weth__));
  88 |     |         __revertCatcher__ = new RevertCatcher(address(__hyperTestingContract__));
  89 |     |         __contracts__.push(address(__hyper__));
  90 |     |         __contracts__.push(address(__hyperTimeOverride__));
  91 |     |         __contracts__.push(address(__hyperTestingContract__));
  92 |     |         __contracts__.push(address(__revertCatcher__));
  93 |     | 
  94 |     |         __usdc__ = new TestERC20("USD Coin", "USDC", 6);
  95 |     |         __token_8__ = new TestERC20("8 Decimals", "8DEC", 8);
  96 |     |         __token_18__ = new TestERC20("18 Decimals", "18DEC", 18);
  97 |     |         __token_18__2 = new TestERC20("18 Decimals #2", "18DEC_2", 18);
  98 |     |         __badToken__ = new TestERC20("Non-standard ERC20", "BAD", 18); // TODO: Add proper bad token.
  99 |     |         __tokens__.push(address(__usdc__));
 100 |     |         __tokens__.push(address(__token_8__));
 101 |     |         __tokens__.push(address(__token_18__));
 102 |     |         __tokens__.push(address(__token_18__2));
 103 |     |         __tokens__.push(address(__badToken__));
 104 |     | 
 105 |     |         setLabels();
 106 |     |     }
 107 |     | 
 108 |     |     function initUsers() internal {
 109 |     |         address self = address(this);
 110 |     |         address alicent = address(0x0001);
 111 |     |         address boba = address(0x0002);
 112 |     |         address revertCatcher = address(__revertCatcher__);
 113 |     | 
 114 |     |         vm.label(self, "Self");
 115 |     |         vm.label(alicent, "Alicent");
 116 |     |         vm.label(boba, "Boba");
 117 |     | 
 118 |     |         __users__.push(self);
 119 |     |         __users__.push(alicent);
 120 |     |         __users__.push(boba);
 121 |     |         __users__.push(revertCatcher);
 122 |     |     }
 123 |     | 
 124 |     |     function initScenarios() internal {
 125 |     |         __hyperTestingContract__.setTimestamp(uint128(block.timestamp)); // Important
 126 |     |         // Create default pool
 127 |     |         bytes memory data = createPool(
 128 |     |             address(__token_18__),
 129 |     |             address(__usdc__),
 130 |     |             address(0),
 131 |     |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
 132 |     |             uint16(1e4 - DEFAULT_GAMMA),
 133 |     |             uint16(DEFAULT_SIGMA),
 134 |     |             uint16(DEFAULT_DURATION_DAYS),
 135 |     |             DEFAULT_JIT,
 136 |     |             DEFAULT_TICK,
 137 |     |             DEFAULT_PRICE
 138 |     |         );
 139 |     | 
 140 |     |         bool success = __revertCatcher__.jumpProcess(data);
 141 |     |         assertTrue(success, "__revertCatcher__ call failed");
 142 |     | 
 143 |     |         // Create default scenario and add to all scenarios.
 144 |     |         defaultScenario = TestScenario(__token_18__, __usdc__, FIRST_POOL, "Default");
 145 |     |         scenarios.push(defaultScenario);
 146 |     | 
 147 |     |         data = createPool(
 148 |     |             address(__token_18__),
 149 |     |             address(__token_18__2),
 150 |     |             address(0),
 151 |     |             uint16(1e4 - DEFAULT_PRIORITY_GAMMA),
 152 |     |             uint16(1e4 - DEFAULT_GAMMA),
 153 |     |             uint16(DEFAULT_SIGMA),
 154 |     |             uint16(DEFAULT_DURATION_DAYS),
 155 |     |             DEFAULT_JIT,
 156 |     |             DEFAULT_TICK,
 157 |     |             DEFAULT_PRICE
 158 |     |         );
 159 |     | 
 160 |     |         success = __revertCatcher__.jumpProcess(data);
 161 |     |         assertTrue(success, "__revertCatcher__ call failed");
 162 |     | 
 163 |     |         _scenario_18_18 = TestScenario(
 164 |     |             __token_18__,
 165 |     |             __token_18__2,
 166 |     |             Enigma.encodePoolId(
 167 |     |                 uint24(__hyperTestingContract__.getPairNonce()),
 168 |     |                 false,
 169 |     |                 uint32(__hyperTestingContract__.getPoolNonce())
 170 |     |             ),
 171 |     |             "18-18 decimal pair"
 172 |     |         );
 173 |     |         scenarios.push(_scenario_18_18);
 174 |     |     }
 175 |     | 
 176 |     |     uint64 public constant FIRST_POOL = 0x0000010000000001;
 177 |     |     uint64 public constant SECOND_POOL = 0x0000020000000002;
 178 |     |     uint64 public constant SECOND_POOL_FIRST_PAIR = 0x0000010000000002;
 179 |     | 
 180 |     |     /** @dev Requires tokens to be spent and spenders to be approved. */
 181 |     |     function initPrerequisites() internal {
 182 |     |         fundUsers();
 183 |     |         approveTokens();
 184 |     |     }
 185 |     | 
 186 |     |     /** @dev Does not include weth. */
 187 |     |     function approveTokens() internal {
 188 |     |         for (uint x; x != __tokens__.length; ++x) {
 189 |     |             for (uint y; y != __contracts__.length; ++y) {
 190 |     |                 for (uint z; z != __users__.length; ++z) {
 191 |     |                     vm.prank(__users__[z]); // Sets caller
 192 |     |                     TestERC20(__tokens__[x]).approve(__contracts__[y], type(uint256).max); // Approves test contracts to spend tokens.
 193 |     |                 }
 194 |     |             }
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     /** @dev Does not include weth. */
 199 |     |     function fundUsers() internal {
 200 |     |         for (uint i; i != __users__.length; ++i) {
 201 |     |             for (uint j; j != __tokens__.length; ++j) {
 202 |     |                 deal(__tokens__[j], __users__[i], STARTING_BALANCE); // TODO: Use regular ERC20, since we can deal.
 203 |     |             }
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     function setLabels() internal {
 208 |     |         vm.label(address(this), "Self");
 209 |     |         vm.label(address(__weth__), "Weth");
 210 |     |         vm.label(address(__revertCatcher__), "RevertCatcher");
 211 |     |         vm.label(address(__hyper__), "DefaultHyper");
 212 |     |         vm.label(address(__hyperTimeOverride__), "HyperTimeOverride");
 213 |     |         vm.label(address(__hyperTestingContract__), "HyperCatchReverts");
 214 |     |         vm.label(address(__usdc__), "USDC");
 215 |     |         vm.label(address(__token_8__), "Token8Decimals");
 216 |     |         vm.label(address(__token_18__), "Token18Decimals");
 217 |     |         vm.label(address(__badToken__), "BadToken");
 218 |     |     }
 219 |     | 
 220 |     |     function customWarp(uint time) internal {
 221 |     |         vm.warp(time);
 222 |     |         __hyperTestingContract__.setTimestamp(uint128(time));
 223 |     |     }
 224 |     | 
 225 |     |     function createControlledPool() internal {
 226 |     |         bytes memory data = Enigma.encodeCreatePool(
 227 |     |             uint24(1), // first pair, is it good in this test?
 228 |     |             address(this),
 229 |     |             100,
 230 |     |             DEFAULT_FEE,
 231 |     |             DEFAULT_VOLATILITY,
 232 |     |             DEFAULT_DURATION,
 233 |     |             DEFAULT_JIT,
 234 |     |             DEFAULT_MAX_TICK,
 235 |     |             DEFAULT_PRICE
 236 |     |         );
 237 |     | 
 238 |     |         bool success = __revertCatcher__.process(data);
 239 |     |         assertTrue(success, "controlled pool not created");
 240 |     | 
 241 |     |         // assumes second pool has not been created...
 242 |     |         // can be fixed by getting pool nonce and encoding pool id.
 243 |     |         uint64 poolId = Enigma.encodePoolId(uint24(1), true, uint32(__hyperTestingContract__.getPoolNonce()));
 244 |     |         _scenario_controlled = TestScenario(__token_18__, __usdc__, poolId, "Controlled");
 245 |     |         scenarios.push(_scenario_controlled);
 246 |     |     }
 247 |     | 
 248 |     |     function basicSwap() internal {
 249 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 250 |     |         (uint output, ) = __hyperTestingContract__.swap(
 251 |     |             defaultScenario.poolId,
 252 |     |             true,
 253 |     |             (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether,
 254 |     |             1
 255 |     |         );
 256 |     | 
 257 |     |         assertTrue(output > 0, "no swap happened!");
 258 |     |     }
 259 |     | 
 260 |     |     function _swap(uint64 id) internal {
 261 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), id);
 262 |     |         (uint output, ) = __hyperTestingContract__.swap(id, true, (pool.getMaxSwapAssetInWad() * 1 ether) / 2 ether, 1);
 263 |     |         assertTrue(output > 0, "no swap happened!");
 264 |     |     }
 265 |     | 
 266 |     |     function basicSwapQuoteIn() internal {
 267 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 268 |     |         (uint output, ) = __hyperTestingContract__.swap(
 269 |     |             defaultScenario.poolId,
 270 |     |             false,
 271 |     |             (pool.getMaxSwapQuoteInWad() * 1 ether) / 2 ether,
 272 |     |             type(uint256).max
 273 |     |         );
 274 |     | 
 275 |     |         assertTrue(output > 0, "no swap happened!");
 276 |     |     }
 277 |     | 
 278 |     |     function basicAllocate() internal {
 279 |     |         __hyperTestingContract__.allocate(defaultScenario.poolId, 1 ether);
 280 |     |     }
 281 |     | 
 282 |     |     function _alloc(uint64 id) internal {
 283 |     |         __hyperTestingContract__.allocate(id, 1 ether);
 284 |     |     }
 285 |     | 
 286 |     |     function basicUnallocate() internal {
 287 |     |         __hyperTestingContract__.unallocate(defaultScenario.poolId, type(uint).max); // max
 288 |     |     }
 289 |     | 
 290 |     |     function maxDraw() internal {
 291 |     |         __hyperTestingContract__.draw(
 292 |     |             address(defaultScenario.asset),
 293 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.asset)),
 294 |     |             address(this)
 295 |     |         );
 296 |     |         __hyperTestingContract__.draw(
 297 |     |             address(defaultScenario.quote),
 298 |     |             __hyperTestingContract__.getBalance(address(this), address(defaultScenario.quote)),
 299 |     |             address(this)
 300 |     |         );
 301 |     |     }
 302 |     | 
 303 |     |     function defaultPool() internal view returns (HyperPool memory) {
 304 |     |         HyperPool memory pool = getPool(address(__hyperTestingContract__), defaultScenario.poolId);
 305 |     |         return pool;
 306 |     |     }
 307 |     | 
 308 |     |     function defaultRevertCatcherPosition() internal view returns (HyperPosition memory) {
 309 |     |         HyperPosition memory pos = getPosition(
 310 |     |             address(__hyperTestingContract__),
 311 |     |             address(__revertCatcher__),
 312 |     |             defaultScenario.poolId
 313 |     |         );
 314 |     |         return pos;
 315 |     |     }
 316 |     | 
 317 |     |     function defaultPosition() internal view returns (HyperPosition memory) {
 318 |     |         HyperPosition memory pos = getPosition(
 319 |     |             address(__hyperTestingContract__),
 320 |     |             address(this),
 321 |     |             defaultScenario.poolId
 322 |     |         );
 323 |     |         return pos;
 324 |     |     }
 325 |     | 
 326 |     |     /** @dev Casted to returns structs as memory */
 327 |     |     function hs() internal view returns (IHyperStruct) {
 328 |     |         return IHyperStruct(address(__hyperTestingContract__));
 329 |     |     }
 330 |     | 
 331 |     |     function hx() internal view returns (HyperLike) {
 332 |     |         return HyperLike(address(__hyperTestingContract__));
 333 |     |     }
 334 |     | }
 335 |     | 

/root/code/hyper/test/foundry/setup/TestPriceSetup.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "contracts/libraries/Price.sol";
  6 |     | import "test/helpers/HelperHyperProfiles.sol";
  7 |     | 
  8 |     | contract TestPriceSetup is HelperHyperProfiles, Test {
  9 |     |     Price.RMM[] cases;
 10 |     | 
 11 |     |     function setUp() public {
 12 |     |         addTestCase(DEFAULT_STRIKE, DEFAULT_SIGMA, DEFAULT_MATURITY);
 13 |     |     }
 14 |     | 
 15 |     |     function addTestCase(uint strike, uint sigma, uint tau) internal returns (Price.RMM memory) {
 16 |     |         Price.RMM memory info = Price.RMM(strike, sigma, tau);
 17 |     |         cases.push(info);
 18 |     |         return info;
 19 |     |     }
 20 |     | }
 21 |     | 

/root/code/hyper/test/helpers/HelperHyperActions.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "contracts/Enigma.sol" as ProcessingLib;
  5 |     | import "./HelperHyperProfiles.sol";
  6 |     | 
  7 |     | contract HelperHyperActions {
  8 |     |     /** @dev Encodes jump process for creating a pair + curve + pool in one tx. */
  9 |     |     function createPool(
 10 |     |         address token0,
 11 |     |         address token1,
 12 |     |         address controller,
 13 |     |         uint16 priorityFee,
 14 |     |         uint16 fee,
 15 |     |         uint16 volatility,
 16 |     |         uint16 duration,
 17 |     |         uint16 jit,
 18 |     |         int24 maxTick,
 19 |     |         uint128 price
 20 |     |     ) internal pure returns (bytes memory data) {
 21 |     |         bytes[] memory instructions = new bytes[](2);
 22 |     |         uint24 magicPoolId = 0x000000;
 23 |     |         instructions[0] = (ProcessingLib.encodeCreatePair(token0, token1));
 24 |     |         instructions[1] = (
 25 |     |             ProcessingLib.encodeCreatePool(
 26 |     |                 magicPoolId, // magic variable
 27 |     |                 controller,
 28 |     |                 priorityFee,
 29 |     |                 fee,
 30 |     |                 volatility,
 31 |     |                 duration,
 32 |     |                 jit,
 33 |     |                 maxTick,
 34 |     |                 price
 35 |     |             )
 36 |     |         );
 37 |     |         data = ProcessingLib.encodeJumpInstruction(instructions);
 38 |     |     }
 39 |     | 
 40 |     |     function allocatePool(address hyper, uint64 poolId, uint amount) internal {
 41 |     |         bytes memory data = ProcessingLib.encodeAllocate(
 42 |     |             0, // useMax = false
 43 |     |             poolId,
 44 |     |             0x0, // amount multiplier = 10^0 = 1
 45 |     |             uint128(amount)
 46 |     |         );
 47 |     |         (bool success, ) = hyper.call{value: 0}(data);
 48 |     |         require(success, "failed to allocate");
 49 |     |     }
 50 |     | }
 51 |     | 

/root/code/hyper/test/helpers/HelperHyperInvariants.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {HyperLike} from "./HelperHyperView.sol";
  5 |     | 
  6 |     | interface ERC20Like {
  7 |     |     function balanceOf(address) external view returns (uint);
  8 |     | }
  9 |     | 
 10 |     | contract HelperHyperInvariants {
 11 |     |     error SettlementInvariantInvalid(uint, uint);
 12 |     | 
 13 |     |     function assertSettlementInvariant(
 14 |     |         address hyper,
 15 |     |         address token,
 16 |     |         address[] memory accounts
 17 |     |     ) internal view returns (bool) {
 18 |     |         uint reserve = HyperLike(hyper).getReserve(token);
 19 |     |         uint physical = ERC20Like(token).balanceOf(hyper);
 20 |     |         if (reserve > physical) revert SettlementInvariantInvalid(physical, reserve);
 21 |     |         return true;
 22 |     |     }
 23 |     | }
 24 |     | 

/root/code/hyper/test/helpers/HelperHyperProfiles.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-only
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | uint128 constant DEFAULT_STRIKE = 10e18;
  5 |     | uint24 constant DEFAULT_SIGMA = 1e4;
  6 |     | uint32 constant DEFAULT_MATURITY = 31556953; // adds 1
  7 |     | uint16 constant DEFAULT_FEE = 100; // 100 bps = 1%
  8 |     | uint32 constant DEFAULT_GAMMA = 9900;
  9 |     | uint32 constant DEFAULT_PRIORITY_GAMMA = 9950;
 10 |     | uint16 constant DEFAULT_DURATION_DAYS = 365;
 11 |     | uint128 constant DEFAULT_QUOTE_RESERVE = 3085375116376210650;
 12 |     | uint128 constant DEFAULT_ASSET_RESERVE = 308537516918601823; // 308596235182
 13 |     | uint128 constant DEFAULT_LIQUIDITY = 1e18;
 14 |     | uint128 constant DEFAULT_PRICE = 10e18;
 15 |     | int24 constant DEFAULT_TICK = int24(23027); // 10e18, rounded up! pay attention
 16 |     | uint constant DEFAULT_SWAP_INPUT = 0.1 ether;
 17 |     | uint constant DEFAULT_SWAP_OUTPUT = 976_278 wei;
 18 |     | uint16 constant DEFAULT_JIT = 4;
 19 |     | uint16 constant DEFAULT_VOLATILITY = 10_000;
 20 |     | uint16 constant DEFAULT_DURATION = 365;
 21 |     | int24 constant DEFAULT_MAX_TICK = int24(23027);
 22 |     | 
 23 |     | contract HelperHyperProfiles {}
 24 |     | 

/root/code/hyper/test/helpers/HelperHyperView.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/Enigma.sol" as Processor;
   5 |     | import "contracts/OS.sol" as Operating;
   6 |     | import {HyperPair, HyperCurve, HyperPool, HyperPosition} from "contracts/HyperLib.sol";
   7 |     | import {TestERC20} from "contracts/test/TestERC20.sol";
   8 |     | 
   9 |     | interface IHyperStruct {
  10 |     |     function pairs(uint24 pairId) external view returns (HyperPair memory);
  11 |     | 
  12 |     |     function positions(address owner, uint64 positionId) external view returns (HyperPosition memory);
  13 |     | 
  14 |     |     function pools(uint64 poolId) external view returns (HyperPool memory);
  15 |     | 
  16 |     |     function getTimePassed(uint64 poolId) external view returns (uint);
  17 |     | }
  18 |     | 
  19 |     | interface HyperLike {
  20 |     |     function getReserve(address) external view returns (uint);
  21 |     | 
  22 |     |     function getBalance(address, address) external view returns (uint);
  23 |     | 
  24 |     |     function getPairNonce() external view returns (uint16);
  25 |     | }
  26 |     | 
  27 |     | struct HyperState {
  28 |     |     uint reserveAsset; // getReserve
  29 |     |     uint reserveQuote; // getReserve
  30 |     |     uint physicalBalanceAsset; // balanceOf
  31 |     |     uint physicalBalanceQuote; // balanceOf
  32 |     |     uint totalBalanceAsset; // sum of all balances from getBalance
  33 |     |     uint totalBalanceQuote; // sum of all balances from getBalance
  34 |     |     uint totalPositionLiquidity; // sum of all position liquidity
  35 |     |     uint callerPositionLiquidity; // position.freeLiquidity
  36 |     |     uint totalPoolLiquidity; // pool.liquidity
  37 |     |     uint feeGrowthAssetPool; // getPool
  38 |     |     uint feeGrowthQuotePool; // getPool
  39 |     |     uint feeGrowthAssetPosition; // getPosition
  40 |     |     uint feeGrowthQuotePosition; // getPosition
  41 |     | }
  42 |     | 
  43 |     | interface TokenLike {
  44 |     |     function balanceOf(address) external view returns (uint);
  45 |     | }
  46 |     | 
  47 |     | contract HelperHyperView {
  48 | *r  |     function getPool(address hyper, uint64 poolId) internal view returns (HyperPool memory) {
  49 | *r  |         return IHyperStruct(hyper).pools(poolId);
  50 |     |     }
  51 |     | 
  52 |     |     function getCurve(address hyper, uint64 poolId) internal view returns (HyperCurve memory) {
  53 |     |         HyperPool memory pool = getPool(hyper, poolId);
  54 |     |         return pool.params;
  55 |     |     }
  56 |     | 
  57 | *r  |     function getPair(address hyper, uint24 pairId) internal view returns (HyperPair memory) {
  58 | *r  |         return IHyperStruct(hyper).pairs(pairId);
  59 |     |     }
  60 |     | 
  61 | *r  |     function getPosition(address hyper, address owner, uint64 positionId) internal view returns (HyperPosition memory) {
  62 | *r  |         return IHyperStruct(hyper).positions(owner, positionId);
  63 |     |     }
  64 |     | 
  65 | *r  |     function getReserve(address hyper, address token) internal view returns (uint) {
  66 | *r  |         return HyperLike(hyper).getReserve(token);
  67 |     |     }
  68 |     | 
  69 | *r  |     function getBalance(address hyper, address owner, address token) internal view returns (uint) {
  70 | *r  |         return HyperLike(hyper).getBalance(owner, token);
  71 |     |     }
  72 |     | 
  73 |     |     function _getPool(IHyperStruct hyper, uint64 poolId) internal view returns (HyperPool memory) {
  74 |     |         return (hyper).pools(poolId);
  75 |     |     }
  76 |     | 
  77 |     |     function _getPosition(
  78 |     |         IHyperStruct hyper,
  79 |     |         address owner,
  80 |     |         uint64 positionId
  81 |     |     ) internal view returns (HyperPosition memory) {
  82 |     |         return hyper.positions(owner, positionId);
  83 |     |     }
  84 |     | 
  85 |     |     function _getReserve(HyperLike hyper, TestERC20 token) internal view returns (uint) {
  86 |     |         return hyper.getReserve(address(token));
  87 |     |     }
  88 |     | 
  89 |     |     function _getBalance(HyperLike hyper, address owner, TestERC20 token) internal view returns (uint) {
  90 |     |         return hyper.getBalance(owner, address(token));
  91 |     |     }
  92 |     | 
  93 |     |     /** @dev Fetches pool state and account state for a single pool's tokens. */
  94 | *r  |     function getState(
  95 |     |         address hyper,
  96 |     |         uint64 poolId,
  97 |     |         address caller,
  98 |     |         address[] memory owners
  99 | *r  |     ) internal view returns (HyperState memory) {
 100 | *r  |         HyperPair memory pair = getPair(hyper, Processor.decodePairIdFromPoolId(poolId));
 101 | *r  |         address asset = pair.tokenAsset;
 102 | *r  |         address quote = pair.tokenQuote;
 103 |     | 
 104 | *r  |         HyperPool memory pool = getPool(hyper, poolId);
 105 | *r  |         HyperPosition memory position = getPosition(hyper, caller, poolId);
 106 |     | 
 107 | *r  |         HyperState memory state = HyperState(
 108 | *r  |             getReserve(hyper, asset),
 109 | *r  |             getReserve(hyper, quote),
 110 | *r  |             getPhysicalBalance(hyper, asset),
 111 | *r  |             getPhysicalBalance(hyper, quote),
 112 | *r  |             getBalanceSum(hyper, asset, owners),
 113 | *r  |             getBalanceSum(hyper, quote, owners),
 114 | *r  |             getPositionLiquiditySum(hyper, poolId, owners),
 115 | *r  |             position.freeLiquidity,
 116 | *r  |             pool.liquidity,
 117 | *r  |             pool.feeGrowthGlobalAsset,
 118 | *r  |             pool.feeGrowthGlobalQuote,
 119 | *r  |             position.feeGrowthAssetLast,
 120 | *r  |             position.feeGrowthQuoteLast
 121 |     |         );
 122 |     | 
 123 | *r  |         return state;
 124 |     |     }
 125 |     | 
 126 | *r  |     function getPhysicalBalance(address hyper, address token) internal view returns (uint) {
 127 | *r  |         return Operating.__balanceOf__(token, hyper);
 128 |     |     }
 129 |     | 
 130 |     |     function getVirtualBalance(address hyper, address token, address[] memory owners) internal view returns (uint) {
 131 |     |         uint sum = getReserve(hyper, token) + getBalanceSum(hyper, token, owners);
 132 |     |         return sum;
 133 |     |     }
 134 |     | 
 135 | *r  |     function getBalanceSum(address hyper, address token, address[] memory owners) internal view returns (uint) {
 136 | *r  |         uint sum;
 137 | *r  |         for (uint x; x != owners.length; ++x) {
 138 | *r  |             sum += getBalance(hyper, owners[x], token);
 139 |     |         }
 140 |     | 
 141 | *r  |         return sum;
 142 |     |     }
 143 |     | 
 144 | *r  |     function getPositionLiquiditySum(address hyper, uint64 poolId, address[] memory owners) internal view returns (uint) {
 145 | *r  |         uint sum;
 146 | *r  |         for (uint i; i != owners.length; ++i) {
 147 | *r  |             sum += getPosition(hyper, owners[i], poolId).freeLiquidity;
 148 |     |         }
 149 |     | 
 150 |     |         return sum;
 151 |     |     }
 152 |     | 
 153 |     |     function getMaxSwapLimit(bool sellAsset) internal pure returns (uint) {
 154 |     |         if (sellAsset) {
 155 |     |             // price goes down
 156 |     |             return 0;
 157 |     |         } else {
 158 |     |             // price goes up
 159 |     |             return type(uint).max;
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     function helperGetAmountOut(address hyper, uint64 poolId, bool sellAsset, uint input) internal view returns (uint) {
 164 |     |         HyperPool memory pool = getPool(hyper, poolId);
 165 |     |         uint256 passed = IHyperStruct(hyper).getTimePassed(poolId);
 166 |     |         (uint output, ) = pool.getAmountOut(sellAsset, input, passed);
 167 |     |         return output;
 168 |     |     }
 169 |     | }
 170 |     | 

/root/code/hyper/test/helpers/HyperTestOverrides.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-only
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "contracts/Hyper.sol";
   5 |     | import "contracts/HyperLib.sol";
   6 |     | import "contracts/test/TestERC20.sol";
   7 |     | 
   8 |     | contract HyperTimeOverride is Hyper {
   9 |     |     constructor(address weth) Hyper(weth) {}
  10 |     | 
  11 |     |     function _blockTimestamp() internal view override returns (uint128) {
  12 |     |         return uint128(timestamp);
  13 |     |     }
  14 |     | 
  15 |     |     function _liquidityPolicy() internal view override returns (uint) {
  16 |     |         return jitDelay;
  17 |     |     }
  18 |     | 
  19 |     |     // ===== Added ==== //
  20 |     | 
  21 |     |     uint public timestamp;
  22 |     |     uint public jitDelay;
  23 |     | 
  24 |     |     function setJitPolicy(uint delay) public {
  25 |     |         jitDelay = delay;
  26 |     |     }
  27 |     | 
  28 |     |     function setTimestamp(uint128 time) public {
  29 |     |         timestamp = time;
  30 |     |     }
  31 |     | 
  32 |     |     /** @dev Temp jump override for invariant tests. */
  33 |     |     function doJumpProcess(bytes calldata data) external payable lock interactions {
  34 |     |         Enigma._jumpProcess(data, super._process);
  35 |     |     }
  36 |     | }
  37 |     | 
  38 |     | /** @dev To catch reverts, external functions can be called by a contract that has a try-cactch. */
  39 |     | contract HyperCatchReverts is HyperTimeOverride {
  40 |     |     constructor(address weth) HyperTimeOverride(weth) {}
  41 |     | 
  42 |     |     // ===== Added ===== //
  43 |     | 
  44 |     |     /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */
  45 |     |     function jumpProcess(bytes calldata data) external payable lock interactions {
  46 |     |         Enigma._jumpProcess(data, super._process);
  47 |     |     }
  48 |     | 
  49 |     |     /** @dev This is an implemented function to test process, so it has to have settle and re-entrancy guard. */
  50 |     |     function process(bytes calldata data) external payable lock interactions {
  51 |     |         super._process(data);
  52 |     |     }
  53 |     | 
  54 |     |     /** @dev Solidity does not support error catching with the fallback function, so we use this external function. */
  55 |     |     function mockFallback(bytes calldata data) external payable lock interactions {
  56 |     |         if (data[0] != Enigma.INSTRUCTION_JUMP) super._process(data);
  57 |     |         else Enigma._jumpProcess(data, super._process);
  58 |     |     }
  59 |     | }
  60 |     | 
  61 |     | contract RevertCatcher {
  62 |     |     HyperCatchReverts public hyper;
  63 |     | 
  64 |     |     constructor(address hyper_) {
  65 |     |         hyper = HyperCatchReverts(payable(hyper_));
  66 |     |     }
  67 |     | 
  68 |     |     receive() external payable {}
  69 |     | 
  70 |     |     function approve(address token, address spender) external {
  71 |     |         TestERC20(token).approve(spender, type(uint256).max);
  72 |     |     }
  73 |     | 
  74 |     |     function mockFallback(bytes calldata data) external payable returns (bool) {
  75 |     |         try hyper.mockFallback{value: msg.value}(data) {} catch (bytes memory reason) {
  76 |     |             assembly {
  77 |     |                 revert(add(32, reason), mload(reason))
  78 |     |             }
  79 |     |         }
  80 |     |         return true;
  81 |     |     }
  82 |     | 
  83 |     |     /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */
  84 |     |     function process(bytes calldata data) external payable returns (bool) {
  85 |     |         try hyper.process{value: msg.value}(data) {} catch (bytes memory reason) {
  86 |     |             assembly {
  87 |     |                 revert(add(32, reason), mload(reason))
  88 |     |             }
  89 |     |         }
  90 |     |         return true;
  91 |     |     }
  92 |     | 
  93 |     |     /** @dev Assumes Hyper calls this, for testing only. Uses try catch to bubble up errors. */
  94 |     |     function jumpProcess(bytes calldata data) external payable returns (bool) {
  95 |     |         try hyper.jumpProcess{value: msg.value}(data) {} catch (bytes memory reason) {
  96 |     |             assembly {
  97 |     |                 revert(add(32, reason), mload(reason))
  98 |     |             }
  99 |     |         }
 100 |     |         return true;
 101 |     |     }
 102 |     | }
 103 |     | 

